<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Do you vs Are you íŒ¨í„´ ë§ˆìŠ¤í„°</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        h1 {
            color: #4338ca;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.2em;
        }
        .stage-selector {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
        }
        .stage-btn {
            padding: 15px 25px;
            border: 3px solid #ddd;
            border-radius: 10px;
            background: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .stage-btn.active {
            border-color: #4338ca;
            background: #4338ca;
            color: white;
        }
        .stage-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        .progress-bar {
            background: #f0f0f0;
            border-radius: 10px;
            height: 8px;
            margin-bottom: 30px;
            overflow: hidden;
        }
        .progress-fill {
            background: linear-gradient(90deg, #4338ca, #7c3aed);
            height: 100%;
            border-radius: 10px;
            transition: width 0.5s ease;
            width: 0%;
        }
        .question-area {
            text-align: center;
            margin: 40px 0;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .korean-text {
            font-size: 2.5em;
            font-weight: bold;
            color: #1f2937;
            margin-bottom: 20px;
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .english-answer {
            font-size: 2em;
            color: #059669;
            font-weight: 600;
            min-height: 50px;
            margin-bottom: 20px;
            opacity: 0;
            transition: opacity 0.5s;
        }
        .english-answer.show {
            opacity: 1;
        }
        .timer-circle {
            width: 80px;
            height: 80px;
            border: 4px solid #e5e7eb;
            border-top: 4px solid #4338ca;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            display: none;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
        }
        .control-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            color: white;
        }
        .start-btn {
            background: linear-gradient(135deg, #10b981, #059669);
        }
        .pause-btn {
            background: linear-gradient(135deg, #f59e0b, #d97706);
        }
        .reset-btn {
            background: linear-gradient(135deg, #ef4444, #dc2626);
        }
        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        .control-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        .stat-card {
            background: linear-gradient(135deg, #f8fafc, #e2e8f0);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }
        .stat-number {
            font-size: 2.5em;
            font-weight: bold;
            color: #4338ca;
        }
        .stat-label {
            color: #64748b;
            font-weight: 500;
        }
        .pattern-info {
            background: linear-gradient(135deg, #fef3c7, #fbbf24);
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        .pattern-info h3 {
            margin: 0 0 10px 0;
            color: #92400e;
        }
        .verb-selector {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .verb-btn {
            padding: 8px 15px;
            border: 2px solid #4338ca;
            border-radius: 20px;
            background: white;
            color: #4338ca;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        .verb-btn.active {
            background: #4338ca;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ë’¤ë¡œ ê°€ê¸° ë²„íŠ¼ (ë ˆë²¨ ì‹œìŠ¤í…œì—ì„œ ì˜¨ ê²½ìš°ë§Œ í‘œì‹œ) -->
        <div id="back-to-level" style="display: none; margin-bottom: 20px;">
            <button onclick="window.close()" style="background: #6b7280; color: white; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                â† ë ˆë²¨ ì„ íƒìœ¼ë¡œ ëŒì•„ê°€ê¸°
            </button>
        </div>

        <h1>ğŸ¯ Do you vs Are you</h1>
        <p class="subtitle">íŒ¨í„´ ë§ˆìŠ¤í„° - 3ë‹¨ê³„ ì§‘ì¤‘ í›ˆë ¨</p>
        
        <!-- íŒ¨í„´ ì„¤ëª… -->
        <div class="pattern-info">
            <h3>ğŸ“š í•™ìŠµ íŒ¨í„´</h3>
            <p><strong>ì¼ë°˜ë™ì‘:</strong> Do you go? / I don't go<br>
            <strong>ì§„í–‰ì¤‘:</strong> Are you going? / I'm not going</p>
        </div>

        <!-- ë™ì‚¬ ì„ íƒ -->
        <div class="verb-selector">
            <div class="verb-btn active" data-verb="go">Go</div>
            <div class="verb-btn" data-verb="sell">Sell</div>
            <div class="verb-btn" data-verb="study">Study</div>
            <div class="verb-btn" data-verb="write">Write</div>
            <div class="verb-btn" data-verb="call">Call</div>
        </div>

        <!-- ìŒì„± ì„¤ì • (ê°œë°œì ëª¨ë“œì—ì„œë§Œ í‘œì‹œ) -->
        <div id="voice-settings" style="display: none; justify-content: center; align-items: center; gap: 15px; margin-bottom: 20px; padding: 15px; background: #f1f5f9; border-radius: 10px; border: 2px dashed #cbd5e1; flex-wrap: wrap;">
            <div style="font-size: 12px; color: #6b7280; margin-right: 10px;">ğŸ› ï¸ ê°œë°œì ì„¤ì •:</div>
            <label style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="voice-korean" checked>
                <span>ğŸ‡°ğŸ‡· í•œêµ­ì–´ ìŒì„±</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px;">
                <input type="checkbox" id="voice-english" checked>
                <span>ğŸ‡ºğŸ‡¸ ì˜ì–´ ìŒì„±</span>
            </label>
            <label style="display: flex; align-items: center; gap: 8px;">
                <span>í•œêµ­ì–´:</span>
                <select id="korean-voice-select" style="padding: 4px; border-radius: 4px; border: 1px solid #cbd5e1;">
                    <option value="">ìë™ ì„ íƒ</option>
                </select>
            </label>
            <label style="display: flex; align-items: center; gap: 8px;">
                <span>English:</span>
                <select id="english-voice-select" style="padding: 4px; border-radius: 4px; border: 1px solid #cbd5e1;">
                    <option value="">ìë™ ì„ íƒ</option>
                </select>
            </label>
            <label style="display: flex; align-items: center; gap: 8px;">
                <span>ì†ë„:</span>
                <input type="range" id="voice-speed" min="0.5" max="1.5" step="0.1" value="0.8" style="width: 80px;">
                <span id="speed-value">0.8x</span>
            </label>
        </div>

        <!-- ë‹¨ê³„ ì„ íƒ -->
        <div class="stage-selector">
            <div class="stage-btn active" data-stage="1">
                1ë‹¨ê³„<br><small>ìˆœì„œëŒ€ë¡œ (3ì´ˆ)</small>
            </div>
            <div class="stage-btn" data-stage="2">
                2ë‹¨ê³„<br><small>ì¡°ê¸ˆ ì„ê¸° (2ì´ˆ)</small>
            </div>
            <div class="stage-btn" data-stage="3">
                3ë‹¨ê³„<br><small>ì™„ì „ ì„ê¸° (1ì´ˆ)</small>
            </div>
        </div>

        <!-- ì§„í–‰ë¥  -->
        <div class="progress-bar">
            <div class="progress-fill" id="progress-fill"></div>
        </div>

        <!-- ì§ˆë¬¸ ì˜ì—­ -->
        <div class="question-area">
            <div class="korean-text" id="korean-text">ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”</div>
            <div class="english-answer" id="english-answer"></div>
            <div class="timer-circle" id="timer"></div>
            
            <!-- ìŒì„± ì¸ì‹ í…ŒìŠ¤íŠ¸ ì˜ì—­ -->
            <div id="speech-test-area" style="display: none; margin-top: 20px; padding: 20px; background: #f0f8ff; border-radius: 10px;">
                <div style="text-align: center; margin-bottom: 15px;">
                    <div id="countdown-timer" style="font-size: 24px; font-weight: bold; color: #ef4444; margin-bottom: 10px;">
                        3ì´ˆ í›„ ìŒì„± ì¸ì‹ ì‹œì‘...
                    </div>
                    <div id="mic-status" style="background: #6b7280; color: white; padding: 10px 20px; border-radius: 10px; font-size: 16px;">
                        ğŸ¤ ì¤€ë¹„ ì¤‘...
                    </div>
                </div>
                <div id="speech-result" style="background: white; padding: 15px; border-radius: 8px; border: 2px dashed #ccc; min-height: 40px; text-align: center; color: #666;">
                    ì ì‹œ í›„ ìë™ìœ¼ë¡œ ìŒì„± ì¸ì‹ì´ ì‹œì‘ë©ë‹ˆë‹¤
                </div>
                <div id="answer-evaluation" style="margin-top: 15px; padding: 10px; border-radius: 8px; text-align: center; display: none;">
                </div>
            </div>
        </div>

        <!-- ì»¨íŠ¸ë¡¤ -->
        <div class="controls">
            <button class="control-btn start-btn" id="start-btn">ğŸš€ ì‹œì‘í•˜ê¸°</button>
            <button class="control-btn reset-btn" id="reset-btn">ğŸ”„ ë‹¤ì‹œí•˜ê¸°</button>
        </div>

        <!-- í†µê³„ -->
        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="current-question">0</div>
                <div class="stat-label">í˜„ì¬ ë¬¸ì œ</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="total-questions">0</div>
                <div class="stat-label">ì „ì²´ ë¬¸ì œ</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="completion-rate">0%</div>
                <div class="stat-label">ì™„ë£Œìœ¨</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="error-rate">0%</div>
                <div class="stat-label">ì˜¤ë‹µë¥ </div>
            </div>
        </div>
    </div>

    <script>
        // ë™ì‚¬ë³„ íŒ¨í„´ ë°ì´í„°
        const verbPatterns = {
            go: {
                korean: ['ë‚˜ëŠ” ê°„ë‹¤', 'ë‚˜ëŠ” ì•ˆ ê°„ë‹¤', 'ë„ˆ ê°€ë‹ˆ?', 'ë‚˜ëŠ” ê°€ëŠ” ì¤‘ì´ë‹¤', 'ë‚˜ëŠ” ê°€ëŠ” ì¤‘ì´ ì•„ë‹ˆë‹¤', 'ë„ˆ ê°€ëŠ” ì¤‘ì´ë‹ˆ?'],
                english: ['I go', 'I don\'t go', 'Do you go?', 'I\'m going', 'I\'m not going', 'Are you going?']
            },
            sell: {
                korean: ['ë‚˜ëŠ” íŒë‹¤', 'ë‚˜ëŠ” ì•ˆ íŒë‹¤', 'ë„ˆ íŒŒë‹ˆ?', 'ë‚˜ëŠ” íŒŒëŠ” ì¤‘ì´ë‹¤', 'ë‚˜ëŠ” íŒŒëŠ” ì¤‘ì´ ì•„ë‹ˆë‹¤', 'ë„ˆ íŒŒëŠ” ì¤‘ì´ë‹ˆ?'],
                english: ['I sell', 'I don\'t sell', 'Do you sell?', 'I\'m selling', 'I\'m not selling', 'Are you selling?']
            },
            study: {
                korean: ['ë‚˜ëŠ” ê³µë¶€í•œë‹¤', 'ë‚˜ëŠ” ê³µë¶€ ì•ˆí•œë‹¤', 'ë„ˆ ê³µë¶€í•˜ë‹ˆ?', 'ë‚˜ëŠ” ê³µë¶€í•˜ëŠ” ì¤‘ì´ë‹¤', 'ë‚˜ëŠ” ê³µë¶€í•˜ëŠ” ì¤‘ì´ ì•„ë‹ˆë‹¤', 'ë„ˆ ê³µë¶€í•˜ëŠ” ì¤‘ì´ë‹ˆ?'],
                english: ['I study', 'I don\'t study', 'Do you study?', 'I\'m studying', 'I\'m not studying', 'Are you studying?']
            },
            write: {
                korean: ['ë‚˜ëŠ” ì“´ë‹¤', 'ë‚˜ëŠ” ì•ˆ ì“´ë‹¤', 'ë„ˆ ì“°ë‹ˆ?', 'ë‚˜ëŠ” ì“°ëŠ” ì¤‘ì´ë‹¤', 'ë‚˜ëŠ” ì“°ëŠ” ì¤‘ì´ ì•„ë‹ˆë‹¤', 'ë„ˆ ì“°ëŠ” ì¤‘ì´ë‹ˆ?'],
                english: ['I write', 'I don\'t write', 'Do you write?', 'I\'m writing', 'I\'m not writing', 'Are you writing?']
            },
            call: {
                korean: ['ë‚˜ëŠ” ì „í™”í•œë‹¤', 'ë‚˜ëŠ” ì „í™” ì•ˆí•œë‹¤', 'ë„ˆ ì „í™”í•˜ë‹ˆ?', 'ë‚˜ëŠ” ì „í™”í•˜ëŠ” ì¤‘ì´ë‹¤', 'ë‚˜ëŠ” ì „í™”í•˜ëŠ” ì¤‘ì´ ì•„ë‹ˆë‹¤', 'ë„ˆ ì „í™”í•˜ëŠ” ì¤‘ì´ë‹ˆ?'],
                english: ['I call', 'I don\'t call', 'Do you call?', 'I\'m calling', 'I\'m not calling', 'Are you calling?']
            }
        };

        // ìƒíƒœ ë³€ìˆ˜
        let currentStage = 1;
        let currentVerb = 'go';
        let currentQuestions = [];
        let currentIndex = 0;
        let wrongAnswerCount = 0;
        let totalAttemptedQuestions = 0;
        let isRunning = false;
        let isPaused = false;
        let questionTimer = null;
        let currentCountdownInterval = null;
        let currentPhase = 'idle'; // 'tts', 'countdown', 'recognition', 'waiting', 'idle'
        let ttsTimeout = null;
        let speechDelayTimeout = null;
        let nextQuestionTimeout = null;
        let remainingCountdownTime = 0;
        let remainingRecognitionTime = 0;
        let remainingWaitTime = 0;
        let pausedAt = null;
        let currentRecognitionCountdown = null;
        let currentRecognitionTimeout = null;
        let currentWaitTimeout = null;
        
        // ë¶€ì •í–‰ìœ„ ë°©ì§€ - ìŒì„±ì¸ì‹ ì¤‘ ì¼ì‹œì •ì§€ ì‹œ ì¬ë‹µë³€ ë°©ì§€
        let recognitionAnswerSubmitted = false;
        let recognitionUserAnswer = '';
        
        // ìŒì„±ì¸ì‹ ì™„ë£Œ ìƒíƒœ ê´€ë¦¬
        let isCompleted = false;
        
        // URL íŒŒë¼ë¯¸í„° ì²˜ë¦¬
        let levelSystemData = null;
        let reviewModeData = null;
        
        function parseURLParams() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // ë³µìŠµ ëª¨ë“œ ì²´í¬
            if (urlParams.has('reviewMode')) {
                const reviewMode = urlParams.get('reviewMode');
                const reviewIds = urlParams.get('reviewIds')?.split(',') || [];
                const reviewId = urlParams.get('reviewId');
                const patternName = urlParams.get('patternName');
                
                reviewModeData = {
                    mode: reviewMode, // 'single', 'all', 'pattern', 'weak-patterns'
                    reviewIds: reviewIds,
                    reviewId: reviewId,
                    patternName: patternName
                };
                
                console.log('ë³µìŠµ ëª¨ë“œ í™œì„±í™”:', reviewModeData);
                return 'review';
            }
            
            // ì¼ë°˜ ë ˆë²¨ ì‹œìŠ¤í…œ ëª¨ë“œ
            if (urlParams.has('level')) {
                levelSystemData = {
                    level: parseInt(urlParams.get('level')),
                    stage: parseInt(urlParams.get('stage')),
                    verbs: urlParams.get('verbs')?.split(',') || ['go'],
                    targetAccuracy: parseInt(urlParams.get('targetAccuracy')),
                    developerMode: urlParams.get('developerMode') === 'true'
                };
                console.log('ë ˆë²¨ ì‹œìŠ¤í…œì—ì„œ ì „ë‹¬ë°›ì€ ë°ì´í„°:', levelSystemData);
                return 'level';
            }
            
            return 'normal';
        }

        // TTS ê´€ë ¨ ë³€ìˆ˜
        let tts = null;
        let voiceKorean = true;
        let voiceEnglish = true;
        let voiceSpeed = 0.8;
        let selectedKoreanVoice = null;
        let selectedEnglishVoice = null;
        
        // í‹€ë¦° ë¬¸ì œ ìˆ˜ì§‘ì„ ìœ„í•œ ë³€ìˆ˜
        let currentQuestionData = null;
        let mistakeCollector = {
            currentSession: {
                level: levelSystemData?.level || 1,
                stage: levelSystemData?.stage || 1,
                startTime: Date.now(),
                mistakes: [],
                totalQuestions: 0,
                correctAnswers: 0
            }
        };

        // localStorage í‚¤ ìƒìˆ˜
        const STORAGE_KEYS = {
            MISTAKES: 'dasi_mistakes',
            REVIEW_SCHEDULE: 'dasi_review_schedule',
            USER_STATS: 'dasi_user_stats'
        };

        // ë§ê°ê³¡ì„  ë³µìŠµ ê°„ê²© (ë°€ë¦¬ì´ˆ)
        const REVIEW_INTERVALS = {
            FIRST: 1 * 24 * 60 * 60 * 1000,    // 1ì¼
            SECOND: 3 * 24 * 60 * 60 * 1000,   // 3ì¼  
            THIRD: 7 * 24 * 60 * 60 * 1000,    // 7ì¼
            FOURTH: 14 * 24 * 60 * 60 * 1000   // 14ì¼
        };

        // localStorage ê´€ë¦¬ ê°ì²´
        const StorageManager = {
            // í‹€ë¦° ë¬¸ì œ ëª©ë¡ ë¶ˆëŸ¬ì˜¤ê¸°
            getMistakes() {
                try {
                    const data = localStorage.getItem(STORAGE_KEYS.MISTAKES);
                    return data ? JSON.parse(data) : [];
                } catch (error) {
                    console.error('í‹€ë¦° ë¬¸ì œ ë°ì´í„° ë¡œë“œ ì‹¤íŒ¨:', error);
                    return [];
                }
            },

            // í‹€ë¦° ë¬¸ì œ ì €ì¥
            saveMistake(mistake) {
                try {
                    const mistakes = this.getMistakes();
                    
                    // ë™ì¼í•œ ë¬¸ì œê°€ ì´ë¯¸ ìˆëŠ”ì§€ í™•ì¸
                    const existingIndex = mistakes.findIndex(m => 
                        m.korean === mistake.korean && 
                        m.english === mistake.english &&
                        m.pattern === mistake.pattern
                    );

                    const now = Date.now();
                    
                    if (existingIndex >= 0) {
                        // ê¸°ì¡´ í‹€ë¦° ë¬¸ì œ ì—…ë°ì´íŠ¸
                        mistakes[existingIndex].mistakeCount += 1;
                        mistakes[existingIndex].lastMistake = now;
                        mistakes[existingIndex].totalResponseTime += mistake.responseTime;
                        mistakes[existingIndex].averageResponseTime = 
                            mistakes[existingIndex].totalResponseTime / mistakes[existingIndex].mistakeCount;
                        
                        // ë³µìŠµ ìŠ¤ì¼€ì¤„ ì¬ì„¤ì • (ë‹¤ì‹œ í‹€ë ¸ìœ¼ë¯€ë¡œ 1ì¼ë¶€í„° ì‹œì‘)
                        mistakes[existingIndex].nextReview = now + REVIEW_INTERVALS.FIRST;
                        mistakes[existingIndex].reviewStage = 0;
                        mistakes[existingIndex].lastUserAnswer = mistake.userAnswer;
                        
                        console.log(`ê¸°ì¡´ í‹€ë¦° ë¬¸ì œ ì—…ë°ì´íŠ¸: ${mistake.korean} (ì´ ${mistakes[existingIndex].mistakeCount}ë²ˆ í‹€ë¦¼)`);
                    } else {
                        // ìƒˆë¡œìš´ í‹€ë¦° ë¬¸ì œ ì¶”ê°€
                        const newMistake = {
                            id: `mistake_${now}_${Math.random().toString(36).substr(2, 9)}`,
                            level: mistake.level,
                            stage: mistake.stage,
                            korean: mistake.korean,
                            english: mistake.english,
                            verb: mistake.verb,
                            pattern: mistake.pattern,
                            mistakeCount: 1,
                            firstMistake: now,
                            lastMistake: now,
                            nextReview: now + REVIEW_INTERVALS.FIRST,
                            reviewStage: 0, // 0: 1ì¼í›„, 1: 3ì¼í›„, 2: 7ì¼í›„, 3: 14ì¼í›„
                            reviewCount: 0,
                            difficulty: mistake.difficulty,
                            totalResponseTime: mistake.responseTime,
                            averageResponseTime: mistake.responseTime,
                            lastUserAnswer: mistake.userAnswer,
                            mastered: false
                        };
                        
                        mistakes.push(newMistake);
                        console.log(`ìƒˆ í‹€ë¦° ë¬¸ì œ ì¶”ê°€: ${mistake.korean}`);
                    }

                    localStorage.setItem(STORAGE_KEYS.MISTAKES, JSON.stringify(mistakes));
                    return true;
                } catch (error) {
                    console.error('í‹€ë¦° ë¬¸ì œ ì €ì¥ ì‹¤íŒ¨:', error);
                    return false;
                }
            },

            // ë³µìŠµ ëŒ€ìƒ ë¬¸ì œë“¤ ê°€ì ¸ì˜¤ê¸°
            getDueReviews() {
                const now = Date.now();
                const mistakes = this.getMistakes();
                return mistakes.filter(mistake => 
                    !mistake.mastered && mistake.nextReview <= now
                );
            },

            // ë³µìŠµ ì™„ë£Œ ì²˜ë¦¬
            completeReview(mistakeId, isCorrect) {
                try {
                    const mistakes = this.getMistakes();
                    const mistakeIndex = mistakes.findIndex(m => m.id === mistakeId);
                    
                    if (mistakeIndex >= 0) {
                        const mistake = mistakes[mistakeIndex];
                        mistake.reviewCount += 1;
                        mistake.lastReview = Date.now();

                        if (isCorrect) {
                            // ì •ë‹µ ì‹œ ë‹¤ìŒ ë³µìŠµ ë‹¨ê³„ë¡œ
                            mistake.reviewStage += 1;
                            
                            if (mistake.reviewStage >= 4) {
                                // 4ë‹¨ê³„ ëª¨ë‘ ì™„ë£Œ ì‹œ ë§ˆìŠ¤í„° ì²˜ë¦¬
                                mistake.mastered = true;
                                mistake.masteredDate = Date.now();
                                console.log(`ë§ˆìŠ¤í„° ì™„ë£Œ: ${mistake.korean}`);
                            } else {
                                // ë‹¤ìŒ ë‹¨ê³„ ë³µìŠµ ìŠ¤ì¼€ì¤„ ì„¤ì •
                                const intervals = [
                                    REVIEW_INTERVALS.FIRST,
                                    REVIEW_INTERVALS.SECOND, 
                                    REVIEW_INTERVALS.THIRD,
                                    REVIEW_INTERVALS.FOURTH
                                ];
                                mistake.nextReview = Date.now() + intervals[mistake.reviewStage];
                            }
                        } else {
                            // í‹€ë ¸ì„ ì‹œ 1ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ
                            mistake.reviewStage = 0;
                            mistake.nextReview = Date.now() + REVIEW_INTERVALS.FIRST;
                            mistake.mistakeCount += 1;
                        }

                        localStorage.setItem(STORAGE_KEYS.MISTAKES, JSON.stringify(mistakes));
                        return true;
                    }
                    return false;
                } catch (error) {
                    console.error('ë³µìŠµ ì™„ë£Œ ì²˜ë¦¬ ì‹¤íŒ¨:', error);
                    return false;
                }
            },

            // í†µê³„ ì •ë³´ ì €ì¥/ë¶ˆëŸ¬ì˜¤ê¸°
            saveUserStats(stats) {
                try {
                    localStorage.setItem(STORAGE_KEYS.USER_STATS, JSON.stringify({
                        ...stats,
                        lastUpdated: Date.now()
                    }));
                    return true;
                } catch (error) {
                    console.error('ì‚¬ìš©ì í†µê³„ ì €ì¥ ì‹¤íŒ¨:', error);
                    return false;
                }
            },

            getUserStats() {
                try {
                    const data = localStorage.getItem(STORAGE_KEYS.USER_STATS);
                    return data ? JSON.parse(data) : {
                        totalSessions: 0,
                        totalQuestions: 0,
                        totalCorrect: 0,
                        totalMistakes: 0,
                        averageAccuracy: 0,
                        totalStudyTime: 0
                    };
                } catch (error) {
                    console.error('ì‚¬ìš©ì í†µê³„ ë¡œë“œ ì‹¤íŒ¨:', error);
                    return {};
                }
            },

            // ë””ë²„ê·¸ìš© - ëª¨ë“  ë°ì´í„° ì¶œë ¥
            debugPrint() {
                console.log('=== localStorage ë°ì´í„° ===');
                console.log('í‹€ë¦° ë¬¸ì œ:', this.getMistakes());
                console.log('ë³µìŠµ ëŒ€ìƒ:', this.getDueReviews());
                console.log('ì‚¬ìš©ì í†µê³„:', this.getUserStats());
            },

            // ë°ì´í„° ì´ˆê¸°í™” (ê°œë°œìš©)
            clearAll() {
                localStorage.removeItem(STORAGE_KEYS.MISTAKES);
                localStorage.removeItem(STORAGE_KEYS.REVIEW_SCHEDULE);
                localStorage.removeItem(STORAGE_KEYS.USER_STATS);
                console.log('ëª¨ë“  ë°ì´í„°ê°€ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        };
        
        if ('speechSynthesis' in window) {
            tts = window.speechSynthesis;
        }

        // Web Speech API (ìŒì„± ì¸ì‹) ì´ˆê¸°í™”
        let speechRecognition = null;
        let isRecording = false;
        let recordingTimeout = null;
        let countdownInterval = null;
        let autoStartTimeout = null;

        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            speechRecognition = new SpeechRecognition();
            speechRecognition.continuous = false;
            speechRecognition.interimResults = false;
            speechRecognition.lang = 'en-US';
            speechRecognition.maxAlternatives = 5;
            
            // ìŒì„±ì¸ì‹ ì •í™•ë„ ê°œì„  ì„¤ì •
            if (speechRecognition.serviceURI) {
                speechRecognition.serviceURI = 'wss://www.google.com/speech-api/v2/recognize';
            }
        }

        // DOM ìš”ì†Œ
        const stageButtons = document.querySelectorAll('.stage-btn');
        const verbButtons = document.querySelectorAll('.verb-btn');
        const startBtn = document.getElementById('start-btn');
        // pauseBtn ì œê±°ë¨
        const resetBtn = document.getElementById('reset-btn');
        const koreanText = document.getElementById('korean-text');
        const englishAnswer = document.getElementById('english-answer');
        const timer = document.getElementById('timer');
        const progressFill = document.getElementById('progress-fill');
        const currentQuestionEl = document.getElementById('current-question');
        const totalQuestionsEl = document.getElementById('total-questions');
        const completionRateEl = document.getElementById('completion-rate');
        const errorRateEl = document.getElementById('error-rate');
        
        // ìŒì„± ì„¤ì • ìš”ì†Œ
        const voiceKoreanCheck = document.getElementById('voice-korean');
        const voiceEnglishCheck = document.getElementById('voice-english');
        const voiceSpeedSlider = document.getElementById('voice-speed');
        const speedValue = document.getElementById('speed-value');
        const koreanVoiceSelect = document.getElementById('korean-voice-select');
        const englishVoiceSelect = document.getElementById('english-voice-select');
        
        // ìŒì„± ì¸ì‹ í…ŒìŠ¤íŠ¸ ìš”ì†Œ
        const speechTestArea = document.getElementById('speech-test-area');
        const countdownTimer = document.getElementById('countdown-timer');
        const micStatus = document.getElementById('mic-status');
        const speechResult = document.getElementById('speech-result');
        const answerEvaluation = document.getElementById('answer-evaluation');

        // TTS ìŒì„± ì¬ìƒ í•¨ìˆ˜
        function speakText(text, lang = 'ko', onEnd = null) {
            console.log(`TTS ì‹œë„: "${text}" (ì–¸ì–´: ${lang})`);
            
            if (!tts) {
                console.log('TTS ì‚¬ìš© ë¶ˆê°€');
                if (onEnd) onEnd();
                return;
            }
            
            tts.cancel();
            
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = voiceSpeed || 0.8;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;
            console.log(`TTS ì„¤ì •: rate=${utterance.rate}, speed=${voiceSpeed}`);
            
            if (lang === 'ko') {
                utterance.lang = 'ko-KR';
                const voices = tts.getVoices();
                console.log(`ì‚¬ìš© ê°€ëŠ¥í•œ ìŒì„±: ${voices.length}ê°œ`);
                
                // ì‚¬ìš©ìê°€ ì„ íƒí•œ ìŒì„±ì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ìë™ ì„ íƒ
                let voiceToUse = selectedKoreanVoice;
                if (!voiceToUse) {
                    voiceToUse = voices.find(voice => 
                        voice.lang.includes('ko') || voice.name.includes('Korean')
                    );
                }
                
                if (voiceToUse) {
                    utterance.voice = voiceToUse;
                    console.log('í•œêµ­ì–´ ìŒì„± ì‚¬ìš©:', voiceToUse.name);
                } else {
                    console.log('í•œêµ­ì–´ ìŒì„± ì—†ìŒ, ê¸°ë³¸ ìŒì„± ì‚¬ìš©');
                }
            } else {
                utterance.lang = 'en-US';
                const voices = tts.getVoices();
                
                // ì‚¬ìš©ìê°€ ì„ íƒí•œ ìŒì„±ì´ ìˆìœ¼ë©´ ì‚¬ìš©, ì—†ìœ¼ë©´ ìë™ ì„ íƒ
                let voiceToUse = selectedEnglishVoice;
                if (!voiceToUse) {
                    voiceToUse = voices.find(voice => 
                        voice.lang.startsWith('en') && voice.name.includes('Female')
                    ) || voices.find(voice => voice.lang.startsWith('en'));
                }
                
                if (voiceToUse) {
                    utterance.voice = voiceToUse;
                    console.log('ì˜ì–´ ìŒì„± ì‚¬ìš©:', voiceToUse.name);
                }
            }
            
            // ìŒì„± ì™„ë£Œ ì´ë²¤íŠ¸
            utterance.onend = () => {
                console.log('TTS ì™„ë£Œ');
                if (onEnd) onEnd();
            };
            
            utterance.onerror = (event) => {
                console.log('TTS ì˜¤ë¥˜:', event.error);
                // interrupted ì—ëŸ¬ëŠ” ì¼ì‹œì •ì§€ë¡œ ì¸í•œ ì •ìƒì ì¸ ì¤‘ë‹¨ì´ë¯€ë¡œ onEnd í˜¸ì¶œí•˜ì§€ ì•ŠìŒ
                if (event.error === 'interrupted') {
                    console.log('TTSê°€ ì¼ì‹œì •ì§€ë¡œ ì¸í•´ ì¤‘ë‹¨ë¨ - ì¬ê°œ ëŒ€ê¸° ì¤‘');
                    return;
                }
                // ê¸°íƒ€ ì—ëŸ¬ì˜ ê²½ìš°ì—ë§Œ onEnd í˜¸ì¶œ
                if (onEnd) onEnd();
            };
            
            console.log('TTS ì¬ìƒ ì‹œì‘');
            tts.speak(utterance);
        }

        // ë‹µë³€ ìœ ì‚¬ë„ ê³„ì‚° (ê°„ë‹¨ ë²„ì „)
        function calculateAnswerSimilarity(userAnswer, correctAnswer) {
            if (!userAnswer || !correctAnswer) return 0;
            
            // ì†Œë¬¸ìë¡œ ë³€í™˜í•˜ê³  íŠ¹ìˆ˜ë¬¸ì ì œê±°
            const normalize = (str) => str.toLowerCase().replace(/[^\w\s]/g, '').trim();
            const normalizedUser = normalize(userAnswer);
            const normalizedCorrect = normalize(correctAnswer);
            
            // ì™„ì „ ì¼ì¹˜
            if (normalizedUser === normalizedCorrect) return 100;
            
            // ë‹¨ì–´ë³„ ë§¤ì¹­
            const userWords = normalizedUser.split(' ').filter(w => w.length > 0);
            const correctWords = normalizedCorrect.split(' ').filter(w => w.length > 0);
            
            if (userWords.length === 0) return 0;
            
            let matchScore = 0;
            userWords.forEach(userWord => {
                const bestMatch = correctWords.reduce((best, correctWord) => {
                    if (userWord === correctWord) return 1.0;
                    if (userWord.includes(correctWord) || correctWord.includes(userWord)) return 0.7;
                    return Math.max(best, 0);
                }, 0);
                matchScore += bestMatch;
            });
            
            return Math.round((matchScore / Math.max(userWords.length, correctWords.length)) * 100);
        }

        // ë‹¨ê³„ë³„ ì‹œê°„ ì œí•œ (ë°€ë¦¬ì´ˆ)
        function getTimeLimit() {
            if (currentStage === 1) return 3000;      // 3ì´ˆ
            if (currentStage === 2) return 2000;      // 2ì´ˆ  
            if (currentStage === 3) return 1000;      // 1ì´ˆ
            if (currentStage === 4) return 2000;      // ALL: 2ì´ˆ (ì¤‘ê°„ ë‚œì´ë„)
            return 3000; // ê¸°ë³¸ê°’
        }

        // ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (í•œêµ­ì–´ ìŒì„± ì™„ë£Œ í›„)
        function startCountdownAndRecording() {
            const timeLimit = getTimeLimit();
            const countdownSeconds = Math.ceil(timeLimit / 1000);
            let currentCount = countdownSeconds;
            
            countdownTimer.textContent = `${currentCount}ì´ˆ ì•ˆì— ë‹µë³€í•˜ì„¸ìš”!`;
            countdownTimer.style.color = '#ef4444';
            micStatus.textContent = 'ğŸ¤ ìŒì„± ì¸ì‹ ì¤€ë¹„ ì¤‘...';
            micStatus.style.background = '#f59e0b';
            speechResult.textContent = 'ê³§ ìŒì„± ì¸ì‹ì´ ì‹œì‘ë©ë‹ˆë‹¤...';

            // 1ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´
            countdownInterval = setInterval(() => {
                currentCount--;
                if (currentCount > 0) {
                    countdownTimer.textContent = `${currentCount}ì´ˆ ì•ˆì— ë‹µë³€í•˜ì„¸ìš”!`;
                } else {
                    clearInterval(countdownInterval);
                    countdownTimer.textContent = 'ì§€ê¸ˆ ë§í•˜ì„¸ìš”!';
                }
            }, 1000);

            // ì¦‰ì‹œ ìŒì„± ì¸ì‹ ì‹œì‘
            setTimeout(() => {
                startSpeechRecognition();
            }, 100);
        }

        // ìŒì„± ì¸ì‹ ì‹œì‘
        function startSpeechRecognition() {
            currentPhase = 'recognition';
            const startTime = Date.now();
            console.log(`ğŸ¤ [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ì‹œì‘ - 6ì´ˆ ì œí•œì‹œê°„`);
            
            // ëª¨ë“  íƒ€ì´ë¨¸ ê°•ì œ ì •ë¦¬
            forceStopAllTimers();
            
            if (!speechRecognition) {
                speechResult.textContent = 'ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.';
                return;
            }

            if (isRecording) return;

            isRecording = true;
            micStatus.textContent = 'ğŸ”´ ì§€ê¸ˆ ë§í•˜ì„¸ìš”!';
            micStatus.style.background = '#ef4444';
            speechResult.textContent = 'ë“£ê³  ìˆìŠµë‹ˆë‹¤... ì˜ì–´ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”.';
            answerEvaluation.style.display = 'none';

            // ì‹¤ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (6ì´ˆ)
            remainingRecognitionTime = 6;
            countdownTimer.textContent = `${remainingRecognitionTime}ì´ˆ ë‚¨ìŒ`;
            countdownTimer.style.color = '#10b981'; // ì´ˆë¡ìƒ‰
            
            currentRecognitionCountdown = setInterval(() => {
                remainingRecognitionTime--;
                console.log(`â±ï¸ [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ë‚¨ì€ì‹œê°„: ${remainingRecognitionTime}ì´ˆ`);
                
                if (remainingRecognitionTime > 0) {
                    countdownTimer.textContent = `${remainingRecognitionTime}ì´ˆ ë‚¨ìŒ`;
                    
                    // ì‹œê°„ì— ë”°ë¥¸ ìƒ‰ìƒ ë³€ê²½
                    if (remainingRecognitionTime <= 3) {
                        countdownTimer.style.color = '#ef4444'; // ë¹¨ê°„ìƒ‰
                    } else if (remainingRecognitionTime <= 5) {
                        countdownTimer.style.color = '#f59e0b'; // ë…¸ë€ìƒ‰
                    }
                } else {
                    clearInterval(currentRecognitionCountdown);
                    countdownTimer.textContent = 'ì‹œê°„ ì¢…ë£Œ!';
                    countdownTimer.style.color = '#ef4444';
                }
            }, 1000);

            // isCompleted ì´ˆê¸°í™” (ì „ì—­ ë³€ìˆ˜ ì‚¬ìš©)
            isCompleted = false;

            // ìŒì„± ì¸ì‹ ê²°ê³¼ ì²˜ë¦¬
            speechRecognition.onresult = function(event) {
                if (isCompleted) return;
                
                // ë¶€ì •í–‰ìœ„ ë°©ì§€: ì´ë¯¸ ë‹µë³€ì´ ì œì¶œëœ ê²½ìš° ë¬´ì‹œ
                if (recognitionAnswerSubmitted) {
                    console.log(`ğŸš« [${new Date().toLocaleTimeString()}] ì¤‘ë³µ ë‹µë³€ ì‹œë„ ì°¨ë‹¨ - ì´ë¯¸ ì œì¶œëœ ë‹µë³€: "${recognitionUserAnswer}"`);
                    return;
                }
                
                isCompleted = true;
                
                const endTime = Date.now();
                const responseTime = (endTime - startTime) / 1000;
                
                const result = event.results[0][0].transcript;
                console.log(`âœ… [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ì™„ë£Œ - ì‘ë‹µì‹œê°„: ${responseTime.toFixed(1)}ì´ˆ`);
                console.log(`ğŸ“ [${new Date().toLocaleTimeString()}] ì¸ì‹ëœ ìŒì„±: "${result}"`);
                
                // ë‹µë³€ ì œì¶œ ìƒíƒœ ê¸°ë¡ (ë¶€ì •í–‰ìœ„ ë°©ì§€)
                recognitionAnswerSubmitted = true;
                recognitionUserAnswer = result;
                
                if (currentRecognitionCountdown) {
                    clearInterval(currentRecognitionCountdown);
                    currentRecognitionCountdown = null;
                }
                if (currentRecognitionTimeout) {
                    clearTimeout(currentRecognitionTimeout);
                    currentRecognitionTimeout = null;
                }
                
                countdownTimer.textContent = `ì‘ë‹µì‹œê°„: ${responseTime.toFixed(1)}ì´ˆ`;
                countdownTimer.style.color = '#10b981';
                
                // í˜„ì¬ ë¬¸ì œì˜ ì •ë‹µê³¼ ë¹„êµ
                if (currentQuestionData) {
                    const similarity = calculateAnswerSimilarity(result, currentQuestionData.english);
                    const isCorrect = similarity >= 60; // 60% ì´ìƒì´ë©´ ì •ë‹µ
                    
                    // ê²°ê³¼ í‘œì‹œ
                    answerEvaluation.style.display = 'block';
                    if (isCorrect) {
                        answerEvaluation.innerHTML = `
                            <div style="background: #dcfce7; color: #166534; padding: 15px; border-radius: 8px;">
                                âœ… <strong>ì •ë‹µì…ë‹ˆë‹¤!</strong><br>
                                ì •í™•ë„: ${similarity}%<br>
                                ì •ë‹µ: "${currentQuestionData.english}"
                            </div>
                        `;
                        recordCorrectAnswer();
                    } else {
                        answerEvaluation.innerHTML = `
                            <div style="background: #fef2f2; color: #dc2626; padding: 15px; border-radius: 8px;">
                                âŒ <strong>ë‹¤ì‹œ ì‹œë„í•´ë³´ì„¸ìš”</strong><br>
                                ìœ ì‚¬ë„: ${similarity}%<br>
                                ì •ë‹µ: "${currentQuestionData.english}"<br>
                                <small>60% ì´ìƒì´ì–´ì•¼ ì •ë‹µ ì²˜ë¦¬ë©ë‹ˆë‹¤</small>
                            </div>
                        `;
                        recordIncorrectAnswer(result);
                    }
                    
                    // Phaseë¥¼ waitingìœ¼ë¡œ ì„¤ì •í•˜ê³  3ì´ˆ ëŒ€ê¸°
                    currentPhase = 'waiting';
                    remainingWaitTime = 3;
                    
                    console.log(`â±ï¸ [${new Date().toLocaleTimeString()}] ë‹µë³€ í‰ê°€ ì™„ë£Œ - 3ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œë¡œ ì´ë™`);
                    countdownTimer.textContent = `${remainingWaitTime}ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œ`;
                    countdownTimer.style.color = '#10b981';
                    
                    // 1ì´ˆë§ˆë‹¤ ì¹´ìš´íŠ¸ë‹¤ìš´
                    currentWaitTimeout = setInterval(() => {
                        remainingWaitTime--;
                        console.log(`â±ï¸ [${new Date().toLocaleTimeString()}] ë‹¤ìŒ ë¬¸ì œê¹Œì§€ ${remainingWaitTime}ì´ˆ ë‚¨ìŒ`);
                        
                        if (remainingWaitTime > 0) {
                            countdownTimer.textContent = `${remainingWaitTime}ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œ`;
                        } else {
                            clearInterval(currentWaitTimeout);
                            currentWaitTimeout = null;
                            currentPhase = 'idle';
                            proceedToNextQuestion();
                            currentIndex++;
                            showCurrentQuestion();
                        }
                    }, 1000);
                }
            };

            // ì˜¤ë¥˜ ì²˜ë¦¬
            speechRecognition.onerror = function(event) {
                if (isCompleted) return;
                isCompleted = true;
                
                console.log(`âŒ [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ì˜¤ë¥˜: ${event.error}`);
                if (currentRecognitionCountdown) {
                    clearInterval(currentRecognitionCountdown);
                    currentRecognitionCountdown = null;
                }
                if (currentRecognitionTimeout) {
                    clearTimeout(currentRecognitionTimeout);
                    currentRecognitionTimeout = null;
                }
                
                speechResult.textContent = 'ìŒì„± ì¸ì‹ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
                setTimeout(() => {
                    if (isRunning && !isPaused) {
                        proceedToNextQuestion();
                        currentIndex++;
                        showCurrentQuestion();
                    }
                }, 2000);
            };

            // ì‹œê°„ ì œí•œ í›„ ìë™ ì¤‘ì§€ (ë¬´ì‘ë‹µ ì²˜ë¦¬)
            currentRecognitionTimeout = setTimeout(() => {
                if (isRecording && !isCompleted) {
                    isCompleted = true;
                    console.log(`â° [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ì‹œê°„ì´ˆê³¼ (6ì´ˆ)`);
                    if (currentRecognitionCountdown) {
                        clearInterval(currentRecognitionCountdown);
                        currentRecognitionCountdown = null;
                    }
                    handleNoResponse();
                }
            }, 6000); // 6ì´ˆë¡œ ì œí•œ

            // ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸ ê²½ìš° ì¤‘ì§€ í›„ ë‹¤ì‹œ ì‹œì‘
            try {
                speechRecognition.start();
            } catch (error) {
                console.log(`ğŸ”¥ [${new Date().toLocaleTimeString()}] SpeechRecognition ì‹œì‘ ì˜¤ë¥˜:`, error);
                // ì´ë¯¸ ì‹œì‘ëœ ê²½ìš°ë¼ë©´ ì¤‘ì§€ í›„ ë‹¤ì‹œ ì‹œì‘
                if (error.message.includes('already started')) {
                    console.log(`âš ï¸ [${new Date().toLocaleTimeString()}] ì´ë¯¸ ì‹œì‘ëœ ìŒì„±ì¸ì‹ì„ ì¤‘ì§€ í›„ ì¬ì‹œì‘`);
                    speechRecognition.stop();
                    setTimeout(() => {
                        speechRecognition.start();
                    }, 100);
                }
            }
        }

        // ë¬´ì‘ë‹µ ì²˜ë¦¬
        function handleNoResponse() {
            stopSpeechRecognition();
            speechResult.innerHTML = '<span style="color: #dc2626;">ì‹œê°„ ì´ˆê³¼ - ë‹µë³€í•˜ì§€ ì•ŠìŒ</span>';
            
            answerEvaluation.style.display = 'block';
            answerEvaluation.innerHTML = `
                <div style="background: #fef2f2; color: #dc2626; padding: 15px; border-radius: 8px;">
                    â° <strong>ì‹œê°„ ì´ˆê³¼!</strong><br>
                    ${getTimeLimit()/1000}ì´ˆ ì•ˆì— ë‹µë³€í•´ì£¼ì„¸ìš”<br>
                    ì •ë‹µ: "${currentQuestionData?.english || ''}"
                </div>
            `;
            
            // ë¬´ì‘ë‹µì„ í‹€ë¦° ë‹µë³€ìœ¼ë¡œ ê¸°ë¡
            recordIncorrectAnswer('(ì‹œê°„ ì´ˆê³¼)');
            
            // Phaseë¥¼ waitingìœ¼ë¡œ ì„¤ì •í•˜ê³  3ì´ˆ ëŒ€ê¸°
            currentPhase = 'waiting';
            remainingWaitTime = 3;
            
            console.log(`â±ï¸ [${new Date().toLocaleTimeString()}] ì‹œê°„ ì´ˆê³¼ ì²˜ë¦¬ ì™„ë£Œ - 3ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œë¡œ ì´ë™`);
            countdownTimer.textContent = `${remainingWaitTime}ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œ`;
            countdownTimer.style.color = '#ef4444';
            
            // 1ì´ˆë§ˆë‹¤ ì¹´ìš´íŠ¸ë‹¤ìš´
            currentWaitTimeout = setInterval(() => {
                remainingWaitTime--;
                console.log(`â±ï¸ [${new Date().toLocaleTimeString()}] ë‹¤ìŒ ë¬¸ì œê¹Œì§€ ${remainingWaitTime}ì´ˆ ë‚¨ìŒ`);
                
                if (remainingWaitTime > 0) {
                    countdownTimer.textContent = `${remainingWaitTime}ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œ`;
                } else {
                    clearInterval(currentWaitTimeout);
                    currentWaitTimeout = null;
                    currentPhase = 'idle';
                    proceedToNextQuestion();
                    currentIndex++;
                    showCurrentQuestion();
                }
            }, 1000);
        }

        // ìŒì„± ì¸ì‹ ì¤‘ì§€
        function stopSpeechRecognition() {
            if (speechRecognition && isRecording) {
                speechRecognition.stop();
            }
            isRecording = false;
            micStatus.textContent = 'ğŸ¤ ì™„ë£Œ';
            micStatus.style.background = '#6b7280';
            
            // ëª¨ë“  íƒ€ì´ë¨¸ ì •ë¦¬
            if (recordingTimeout) {
                clearTimeout(recordingTimeout);
                recordingTimeout = null;
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            if (autoStartTimeout) {
                clearTimeout(autoStartTimeout);
                autoStartTimeout = null;
            }
        }

        // ìŒì„± ì¸ì‹ ì´ë²¤íŠ¸ ì²˜ë¦¬
        if (speechRecognition) {
            speechRecognition.onresult = function(event) {
                let transcript = '';
                let confidence = 0;
                
                // ìµœì¢… ê²°ê³¼ ì°¾ê¸°
                for (let i = 0; i < event.results.length; i++) {
                    if (event.results[i].isFinal) {
                        transcript = event.results[i][0].transcript;
                        confidence = event.results[i][0].confidence;
                        break;
                    } else {
                        // ì¤‘ê°„ ê²°ê³¼ í‘œì‹œ
                        transcript = event.results[i][0].transcript;
                        speechResult.innerHTML = `<span style="color: #666;">ì¸ì‹ ì¤‘: "${transcript}"</span>`;
                    }
                }
                
                // ìµœì¢… ê²°ê³¼ ì²˜ë¦¬
                if (transcript && event.results[event.results.length - 1].isFinal) {
                    speechResult.innerHTML = `<strong>ì¸ì‹ëœ ë‹µë³€:</strong> "${transcript}"`;
                    
                    // í˜„ì¬ ë¬¸ì œì˜ ì •ë‹µê³¼ ë¹„êµ
                    if (currentQuestionData) {
                        const similarity = calculateAnswerSimilarity(transcript, currentQuestionData.english);
                        const isCorrect = similarity >= 60; // 60% ì´ìƒì´ë©´ ì •ë‹µ
                        
                        // ê²°ê³¼ í‘œì‹œ
                        answerEvaluation.style.display = 'block';
                        if (isCorrect) {
                            answerEvaluation.innerHTML = `
                                <div style="background: #dcfce7; color: #166534; padding: 15px; border-radius: 8px;">
                                    âœ… <strong>ì •ë‹µì…ë‹ˆë‹¤!</strong><br>
                                    ì •í™•ë„: ${similarity}%<br>
                                    ì •ë‹µ: "${currentQuestionData.english}"
                                </div>
                            `;
                            recordCorrectAnswer();
                        } else {
                            answerEvaluation.innerHTML = `
                                <div style="background: #fef2f2; color: #dc2626; padding: 15px; border-radius: 8px;">
                                    âŒ <strong>ë‹¤ì‹œ ì‹œë„í•´ë³´ì„¸ìš”</strong><br>
                                    ìœ ì‚¬ë„: ${similarity}%<br>
                                    ì •ë‹µ: "${currentQuestionData.english}"<br>
                                    <small>60% ì´ìƒì´ì–´ì•¼ ì •ë‹µ ì²˜ë¦¬ë©ë‹ˆë‹¤</small>
                                </div>
                            `;
                            recordIncorrectAnswer(transcript);
                        }
                        
                        // 3ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œë¡œ ìë™ ì§„í–‰
                        setTimeout(() => {
                            if (isRunning && !isPaused) {
                                proceedToNextQuestion();
                                currentIndex++;
                                showCurrentQuestion();
                            }
                        }, 3000);
                    }
                    
                    stopSpeechRecognition();
                }
            };

            speechRecognition.onend = function() {
                console.log(`ğŸ¤ [${new Date().toLocaleTimeString()}] onend ì´ë²¤íŠ¸ - isCompleted: ${isCompleted}, speechResult: "${speechResult.textContent}"`);
                stopSpeechRecognition();
                // ì´ë¯¸ ê²°ê³¼ê°€ ì²˜ë¦¬ëœ ê²½ìš° ë®ì–´ì“°ì§€ ì•ŠìŒ
                if (!isCompleted && 
                    (speechResult.textContent === 'ë“£ê³  ìˆìŠµë‹ˆë‹¤... ì˜ì–´ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”.' || 
                     speechResult.innerHTML.includes('ë“£ê³  ìˆìŠµë‹ˆë‹¤... ì˜ì–´ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”.'))) {
                    console.log(`ğŸ¤ [${new Date().toLocaleTimeString()}] ìŒì„± ë¯¸ì¸ì‹ìœ¼ë¡œ ë©”ì‹œì§€ ë³€ê²½`);
                    speechResult.innerHTML = '<span style="color: #ef4444;">ìŒì„±ì´ ì¸ì‹ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.</span>';
                } else {
                    console.log(`ğŸ¤ [${new Date().toLocaleTimeString()}] ì´ë¯¸ ì²˜ë¦¬ë¨ ë˜ëŠ” ë‹¤ë¥¸ ìƒíƒœ - ë©”ì‹œì§€ ë³€ê²½ ì•ˆí•¨`);
                }
            };

            speechRecognition.onerror = function(event) {
                console.error('ìŒì„± ì¸ì‹ ì˜¤ë¥˜:', event.error);
                stopSpeechRecognition();
                speechResult.textContent = `ì˜¤ë¥˜ ë°œìƒ: ${event.error}`;
            };
        }

        // ê¸°ì¡´ ë§ˆì´í¬ ë²„íŠ¼ ì´ë²¤íŠ¸ ì œê±° (ìë™ ì‹œì‘)

        // Level 1 ì „ìš© êµ¬ì¡° íŒ¨í„´ ë°ì´í„° (19ê°œ ìŠ¤í…Œì´ì§€)
        const level1Patterns = {
            "Beë™ì‚¬ í˜„ì¬": [
                {korean: "ë‚˜ëŠ” í•™ìƒì´ë‹¤", english: "I am a student", verb: "be"},
                {korean: "ê·¸ëŠ” ì„ ìƒë‹˜ì´ë‹¤", english: "He is a teacher", verb: "be"},
                {korean: "ê·¸ë…€ëŠ” ì˜ì‚¬ë‹¤", english: "She is a doctor", verb: "be"},
                {korean: "ìš°ë¦¬ëŠ” ì¹œêµ¬ë‹¤", english: "We are friends", verb: "be"},
                {korean: "ê·¸ë“¤ì€ í•™ìƒë“¤ì´ë‹¤", english: "They are students", verb: "be"}
            ],
            "Beë™ì‚¬ ê³¼ê±°": [
                {korean: "ë‚˜ëŠ” ì–´ì œ ë°”ë¹´ë‹¤", english: "I was busy yesterday", verb: "be"},
                {korean: "ê·¸ëŠ” ì§‘ì— ìˆì—ˆë‹¤", english: "He was at home", verb: "be"},
                {korean: "ê·¸ë…€ëŠ” í–‰ë³µí–ˆë‹¤", english: "She was happy", verb: "be"},
                {korean: "ìš°ë¦¬ëŠ” ëŠ¦ì—ˆë‹¤", english: "We were late", verb: "be"},
                {korean: "ê·¸ë“¤ì€ ì¹œêµ¬ì˜€ë‹¤", english: "They were friends", verb: "be"}
            ],
            "Beë™ì‚¬ ë¯¸ë˜": [
                {korean: "ë‚˜ëŠ” ì˜ì‚¬ê°€ ë  ê²ƒì´ë‹¤", english: "I will be a doctor", verb: "be"},
                {korean: "ê·¸ëŠ” ì—¬ê¸°ì— ìˆì„ ê²ƒì´ë‹¤", english: "He will be here", verb: "be"},
                {korean: "ê·¸ë…€ëŠ” ëŠ¦ì„ ê²ƒì´ë‹¤", english: "She will be late", verb: "be"},
                {korean: "ìš°ë¦¬ëŠ” ì¤€ë¹„ë  ê²ƒì´ë‹¤", english: "We will be ready", verb: "be"},
                {korean: "ê·¸ë“¤ì€ í•™ìƒì´ ë  ê²ƒì´ë‹¤", english: "They will be students", verb: "be"}
            ],
            "ì¼ë°˜ë™ì‚¬ í˜„ì¬": [
                {korean: "ë‚˜ëŠ” ê³µë¶€í•œë‹¤", english: "I study", verb: "study"},
                {korean: "ê·¸ëŠ” ì¼í•œë‹¤", english: "He works", verb: "work"},
                {korean: "ê·¸ë…€ëŠ” ìš”ë¦¬í•œë‹¤", english: "She cooks", verb: "cook"},
                {korean: "ìš°ë¦¬ëŠ” ë†€ì•„", english: "We play", verb: "play"},
                {korean: "ê·¸ë“¤ì€ ì½ëŠ”ë‹¤", english: "They read", verb: "read"}
            ],
            "ì¼ë°˜ë™ì‚¬ ê³¼ê±°": [
                {korean: "ë‚˜ëŠ” ê³µë¶€í–ˆë‹¤", english: "I studied", verb: "study"},
                {korean: "ê·¸ëŠ” ì¼í–ˆë‹¤", english: "He worked", verb: "work"},
                {korean: "ê·¸ë…€ëŠ” ìš”ë¦¬í–ˆë‹¤", english: "She cooked", verb: "cook"},
                {korean: "ìš°ë¦¬ëŠ” ë†€ì•˜ë‹¤", english: "We played", verb: "play"},
                {korean: "ê·¸ë“¤ì€ ì½ì—ˆë‹¤", english: "They read", verb: "read"}
            ],
            "ì¼ë°˜ë™ì‚¬ ë¯¸ë˜": [
                {korean: "ë‚˜ëŠ” ê³µë¶€í•  ê²ƒì´ë‹¤", english: "I will study", verb: "study"},
                {korean: "ê·¸ëŠ” ì¼í•  ê²ƒì´ë‹¤", english: "He will work", verb: "work"},
                {korean: "ê·¸ë…€ëŠ” ìš”ë¦¬í•  ê²ƒì´ë‹¤", english: "She will cook", verb: "cook"},
                {korean: "ìš°ë¦¬ëŠ” ë†€ ê²ƒì´ë‹¤", english: "We will play", verb: "play"},
                {korean: "ê·¸ë“¤ì€ ì½ì„ ê²ƒì´ë‹¤", english: "They will read", verb: "read"}
            ],
            "Beë™ì‚¬ ë¶€ì •": [
                {korean: "ë‚˜ëŠ” í•™ìƒì´ ì•„ë‹ˆë‹¤", english: "I am not a student", verb: "be"},
                {korean: "ê·¸ëŠ” ë°”ì˜ì§€ ì•Šë‹¤", english: "He is not busy", verb: "be"},
                {korean: "ê·¸ë…€ëŠ” ì§‘ì— ì—†ë‹¤", english: "She is not at home", verb: "be"},
                {korean: "ìš°ë¦¬ëŠ” ëŠ¦ì§€ ì•Šì•˜ë‹¤", english: "We are not late", verb: "be"},
                {korean: "ê·¸ë“¤ì€ ì¹œêµ¬ê°€ ì•„ë‹ˆë‹¤", english: "They are not friends", verb: "be"}
            ],
            "ì¼ë°˜ë™ì‚¬ ë¶€ì •": [
                {korean: "ë‚˜ëŠ” ê³µë¶€í•˜ì§€ ì•ŠëŠ”ë‹¤", english: "I don't study", verb: "study"},
                {korean: "ê·¸ëŠ” ì¼í•˜ì§€ ì•ŠëŠ”ë‹¤", english: "He doesn't work", verb: "work"},
                {korean: "ê·¸ë…€ëŠ” ìš”ë¦¬í•˜ì§€ ì•ŠëŠ”ë‹¤", english: "She doesn't cook", verb: "cook"},
                {korean: "ìš°ë¦¬ëŠ” ë†€ì§€ ì•ŠëŠ”ë‹¤", english: "We don't play", verb: "play"},
                {korean: "ê·¸ë“¤ì€ ì½ì§€ ì•ŠëŠ”ë‹¤", english: "They don't read", verb: "read"}
            ]
        };

        // Level 2 ì „ìš© ë¬¸ë²• íŒ¨í„´ ë°ì´í„°
        const level2Patterns = {
            "beë™ì‚¬": [
                {korean: "ë‚˜ëŠ” í•™ìƒì´ë‹¤", english: "I am a student"},
                {korean: "ê·¸ëŠ” ì„ ìƒë‹˜ì´ë‹¤", english: "He is a teacher"},
                {korean: "ìš°ë¦¬ëŠ” ì¹œêµ¬ë‹¤", english: "We are friends"},
                {korean: "ê·¸ë…€ëŠ” ì˜ì‚¬ë‹¤", english: "She is a doctor"},
                {korean: "ê·¸ë“¤ì€ í•™ìƒë“¤ì´ë‹¤", english: "They are students"}
            ],
            "ì¼ë°˜ë™ì‚¬": [
                {korean: "ë‚˜ëŠ” ê³µë¶€í•œë‹¤", english: "I study"},
                {korean: "ê·¸ëŠ” ì¼í•œë‹¤", english: "He works"},
                {korean: "ìš°ë¦¬ëŠ” ë¨¹ëŠ”ë‹¤", english: "We eat"},
                {korean: "ê·¸ë…€ëŠ” ì½ëŠ”ë‹¤", english: "She reads"},
                {korean: "ê·¸ë“¤ì€ ë…¼ë‹¤", english: "They play"}
            ],
            "ì¡°ë™ì‚¬": [
                {korean: "ë‚˜ëŠ” ê°ˆ ìˆ˜ ìˆë‹¤", english: "I can go"},
                {korean: "ê·¸ëŠ” ì™€ì•¼ í•œë‹¤", english: "He must come"},
                {korean: "ìš°ë¦¬ëŠ” í•  ê²ƒì´ë‹¤", english: "We will do"},
                {korean: "ê·¸ë…€ëŠ” í• ì§€ë„ ëª¨ë¥¸ë‹¤", english: "She might do"},
                {korean: "ê·¸ë“¤ì€ í•´ì•¼ í•œë‹¤", english: "They should do"}
            ],
            "í˜„ì¬ì§„í–‰í˜•": [
                {korean: "ë‚˜ëŠ” ê³µë¶€í•˜ê³  ìˆë‹¤", english: "I am studying"},
                {korean: "ê·¸ëŠ” ì¼í•˜ê³  ìˆë‹¤", english: "He is working"},
                {korean: "ìš°ë¦¬ëŠ” ë¨¹ê³  ìˆë‹¤", english: "We are eating"},
                {korean: "ê·¸ë…€ëŠ” ì½ê³  ìˆë‹¤", english: "She is reading"},
                {korean: "ê·¸ë“¤ì€ ë†€ê³  ìˆë‹¤", english: "They are playing"}
            ],
            "ê³¼ê±°í˜•": [
                {korean: "ë‚˜ëŠ” ê³µë¶€í–ˆë‹¤", english: "I studied"},
                {korean: "ê·¸ëŠ” ì¼í–ˆë‹¤", english: "He worked"},
                {korean: "ìš°ë¦¬ëŠ” ë¨¹ì—ˆë‹¤", english: "We ate"},
                {korean: "ê·¸ë…€ëŠ” ì½ì—ˆë‹¤", english: "She read"},
                {korean: "ê·¸ë“¤ì€ ë†€ì•˜ë‹¤", english: "They played"}
            ],
            "ë¯¸ë˜í˜•": [
                {korean: "ë‚˜ëŠ” ê³µë¶€í•  ê²ƒì´ë‹¤", english: "I will study"},
                {korean: "ê·¸ëŠ” ì¼í•  ê²ƒì´ë‹¤", english: "He will work"},
                {korean: "ìš°ë¦¬ëŠ” ë¨¹ì„ ê²ƒì´ë‹¤", english: "We will eat"},
                {korean: "ê·¸ë…€ëŠ” ì½ì„ ê²ƒì´ë‹¤", english: "She will read"},
                {korean: "ê·¸ë“¤ì€ ë†€ ê²ƒì´ë‹¤", english: "They will play"}
            ]
        };

        // ë¬¸ì œ ìƒì„± í•¨ìˆ˜
        function generateQuestions() {
            console.log(`=== ${currentStage}ë‹¨ê³„ ë¬¸ì œ ìƒì„± ì‹œì‘ ===`);
            let questions = [];
            
            // Level 1ì¸ ê²½ìš° êµ¬ì¡° íŒ¨í„´ ê¸°ë°˜ ë¬¸ì œ ìƒì„±
            if (levelSystemData && levelSystemData.level === 1) {
                console.log(`Level 1 - ìŠ¤í…Œì´ì§€: ${levelSystemData.stage}, íŒ¨í„´: ${currentVerb}`);
                
                const patterns = level1Patterns[currentVerb] || level1Patterns["Beë™ì‚¬ í˜„ì¬"];
                console.log(`Level 1 íŒ¨í„´: ${currentVerb}, ë¬¸ì œ ê°œìˆ˜: ${patterns.length}`);
                
                if (currentStage === 1) {
                    questions = [...patterns];
                } else if (currentStage === 2) {
                    questions = [...patterns];
                    for (let i = questions.length - 1; i > 0; i -= 2) {
                        const j = Math.max(0, i - 1);
                        [questions[i], questions[j]] = [questions[j], questions[i]];
                    }
                } else if (currentStage === 4) {
                    // 4ë‹¨ê³„ (ALL): ëª¨ë“  íŒ¨í„´ í¬í•¨
                    questions = [];
                    Object.values(level1Patterns).forEach(patternGroup => {
                        questions = questions.concat([...patternGroup]);
                    });
                    // ì™„ì „íˆ ì„ê¸°
                    for (let i = questions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [questions[i], questions[j]] = [questions[j], questions[i]];
                    }
                } else {
                    // 3ë‹¨ê³„: ì™„ì „ ì„ê¸°
                    questions = [...patterns];
                    for (let i = questions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [questions[i], questions[j]] = [questions[j], questions[i]];
                    }
                }
                console.log(`Level 1 ë¬¸ì œ ìˆ˜: ${questions.length}`);
                return questions;
            }
            
            // Level 2ì¸ ê²½ìš° ë¬¸ë²• íŒ¨í„´ ê¸°ë°˜ ë¬¸ì œ ìƒì„±
            if (levelSystemData && levelSystemData.level === 2) {
                console.log(`Level 2 - íŒ¨í„´: ${currentVerb}`);
                
                // íŒ¨í„´ëª… ë§¤í•‘ (URLì—ì„œ ì „ë‹¬ë°›ëŠ” ì´ë¦„ì„ ì‹¤ì œ í‚¤ë¡œ ë³€í™˜)
                let patternKey = currentVerb;
                if (currentVerb.includes("ì¼ë°˜ë™ì‚¬")) patternKey = "ì¼ë°˜ë™ì‚¬";
                else if (currentVerb.includes("beë™ì‚¬")) patternKey = "beë™ì‚¬";
                else if (currentVerb.includes("ì¡°ë™ì‚¬")) patternKey = "ì¡°ë™ì‚¬";
                else if (currentVerb.includes("í˜„ì¬ì§„í–‰í˜•")) patternKey = "í˜„ì¬ì§„í–‰í˜•";
                else if (currentVerb.includes("ê³¼ê±°")) patternKey = "ê³¼ê±°í˜•";
                else if (currentVerb.includes("ë¯¸ë˜")) patternKey = "ë¯¸ë˜í˜•";
                
                const patterns = level2Patterns[patternKey] || level2Patterns["ì¼ë°˜ë™ì‚¬"];
                console.log(`ë§¤í•‘ëœ íŒ¨í„´: ${patternKey}, ë¬¸ì œ ê°œìˆ˜: ${patterns.length}`);
                
                if (currentStage === 1) {
                    // 1ë‹¨ê³„: ìˆœì„œëŒ€ë¡œ
                    questions = [...patterns];
                } else if (currentStage === 2) {
                    // 2ë‹¨ê³„: ì¡°ê¸ˆ ì„ê¸°
                    questions = [...patterns];
                    for (let i = questions.length - 1; i > 0; i -= 2) {
                        const j = Math.max(0, i - 1);
                        [questions[i], questions[j]] = [questions[j], questions[i]];
                    }
                } else if (currentStage === 4) {
                    // 4ë‹¨ê³„ (ALL): ëª¨ë“  íŒ¨í„´ í¬í•¨
                    questions = [];
                    Object.values(level2Patterns).forEach(patternGroup => {
                        questions = questions.concat([...patternGroup]);
                    });
                    // ì™„ì „íˆ ì„ê¸°
                    for (let i = questions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [questions[i], questions[j]] = [questions[j], questions[i]];
                    }
                } else {
                    // 3ë‹¨ê³„: ì™„ì „ ì„ê¸°
                    questions = [...patterns];
                    for (let i = questions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [questions[i], questions[j]] = [questions[j], questions[i]];
                    }
                }
                console.log(`Level 2 ë¬¸ì œ ìˆ˜: ${questions.length}`);
                return questions;
            }
            
            // Level 3 ì´ìƒì¸ ê²½ìš° ê¸°ë³¸ íŒ¨í„´ ì‚¬ìš©
            if (levelSystemData && levelSystemData.level >= 3) {
                console.log(`Level ${levelSystemData.level} - ê¸°ë³¸ íŒ¨í„´ ì‚¬ìš©`);
                
                // Level 3+ ê¸°ë³¸ íŒ¨í„´ (ê°„ë‹¨í•œ ë¬¸ì¥ë“¤)
                const level3Patterns = [
                    {korean: "ì•ˆë…•í•˜ì„¸ìš”", english: "Hello", verb: "greet"},
                    {korean: "ê°ì‚¬í•©ë‹ˆë‹¤", english: "Thank you", verb: "thank"},
                    {korean: "ì£„ì†¡í•©ë‹ˆë‹¤", english: "I'm sorry", verb: "apologize"},
                    {korean: "ë„ì™€ì£¼ì„¸ìš”", english: "Please help me", verb: "help"},
                    {korean: "ê´œì°®ìŠµë‹ˆë‹¤", english: "It's okay", verb: "be"}
                ];
                
                // ìŠ¤í…Œì´ì§€ë³„ ë¬¸ì œ êµ¬ì„±
                if (currentStage === 4) {
                    // 4ë‹¨ê³„ (ALL): ëª¨ë“  íŒ¨í„´ ë°˜ë³µ
                    questions = [...level3Patterns, ...level3Patterns];
                } else if (currentStage <= 3) {
                    questions = [...level3Patterns];
                } else {
                    // ë” ê³ ê¸‰ ìŠ¤í…Œì´ì§€ëŠ” ë°˜ë³µ
                    questions = [...level3Patterns, ...level3Patterns].slice(0, 5);
                }
                
                console.log(`Level ${levelSystemData.level} ë¬¸ì œ ìˆ˜: ${questions.length}`);
                return questions;
            }
            
            // Level 1 ë˜ëŠ” ê¸°ë³¸ ë™ì‚¬ íŒ¨í„´
            if (currentStage === 1) {
                // 1ë‹¨ê³„: ìˆœì„œëŒ€ë¡œ (í˜„ì¬ ë™ì‚¬ë§Œ)
                console.log(`1ë‹¨ê³„ - ë™ì‚¬: ${currentVerb}`);
                const patterns = verbPatterns[currentVerb];
                if (!patterns) {
                    console.error(`ë™ì‚¬ íŒ¨í„´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${currentVerb}`);
                    return [];
                }
                for (let i = 0; i < patterns.korean.length; i++) {
                    questions.push({
                        korean: patterns.korean[i],
                        english: patterns.english[i],
                        verb: currentVerb
                    });
                }
                console.log(`1ë‹¨ê³„ ë¬¸ì œ ìˆ˜: ${questions.length}`);
            } else if (currentStage === 2) {
                // 2ë‹¨ê³„: ì¡°ê¸ˆ ì„ê¸° (í˜„ì¬ ë™ì‚¬ë§Œ)
                const patterns = verbPatterns[currentVerb];
                if (!patterns) {
                    console.error(`ë™ì‚¬ íŒ¨í„´ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${currentVerb}`);
                    return [];
                }
                const group1 = [0, 1, 2]; // ì¼ë°˜ í˜•íƒœ
                const group2 = [3, 4, 5]; // ì§„í–‰ í˜•íƒœ
                
                questions = questions.concat(shuffle(group1).map(i => ({
                    korean: patterns.korean[i],
                    english: patterns.english[i],
                    verb: currentVerb
                })));
                questions = questions.concat(shuffle(group2).map(i => ({
                    korean: patterns.korean[i],
                    english: patterns.english[i],
                    verb: currentVerb
                })));
            } else if (currentStage === 3) {
                // 3ë‹¨ê³„: ì™„ì „íˆ ì„ê¸° (í˜„ì¬ ë™ì‚¬ë§Œ)
                const patterns = verbPatterns[currentVerb];
                const indices = [0, 1, 2, 3, 4, 5];
                questions = shuffle(indices).map(i => ({
                    korean: patterns.korean[i],
                    english: patterns.english[i],
                    verb: currentVerb
                }));
            } else if (currentStage === 4) {
                // 4ë‹¨ê³„ (ALL): ëª¨ë“  ë™ì‚¬ì˜ ëª¨ë“  íŒ¨í„´ í¬í•¨
                questions = [];
                Object.keys(verbPatterns).forEach(verb => {
                    const patterns = verbPatterns[verb];
                    for (let i = 0; i < patterns.korean.length; i++) {
                        questions.push({
                            korean: patterns.korean[i],
                            english: patterns.english[i],
                            verb: verb
                        });
                    }
                });
                // ì™„ì „íˆ ì„ê¸°
                questions = shuffle(questions);
            }
            
            console.log(`=== ${currentStage}ë‹¨ê³„ ë¬¸ì œ ìƒì„± ì™„ë£Œ: ì´ ${questions.length}ê°œ ===`);
            return questions;
        }

        // ë°°ì—´ ì„ê¸° í•¨ìˆ˜
        function shuffle(array) {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        }
        
        // íŒ¨í„´ íƒ€ì… ì‹ë³„ í•¨ìˆ˜
        function getPatternType(korean) {
            if (korean.includes('ì¤‘ì´')) {
                if (korean.includes('ì•„ë‹ˆë‹¤')) return 'present_continuous_negative';
                if (korean.includes('ë‹ˆ?')) return 'present_continuous_question';
                return 'present_continuous_positive';
            } else {
                if (korean.includes('ì•ˆ') || korean.includes('ì•ˆí•œë‹¤')) return 'present_simple_negative';
                if (korean.includes('ë‹ˆ?')) return 'present_simple_question';
                return 'present_simple_positive';
            }
        }
        
        // ì‚¬ìš©ìê°€ ë‹µì„ ë“¤ì—ˆì„ ë•Œ ì²˜ë¦¬ (ì •ë‹µ ê°„ì£¼)
        function recordCorrectAnswer() {
            if (currentQuestionData && !currentQuestionData.answered) {
                currentQuestionData.answered = true;
                currentQuestionData.responseTime = Date.now() - currentQuestionData.questionStartTime;
                currentQuestionData.isCorrect = true;
                
                // í†µê³„ ì—…ë°ì´íŠ¸ - ì •ë‹µ ì‹œ
                totalAttemptedQuestions++;
                updateProgress();
                
                mistakeCollector.currentSession.correctAnswers++;
                console.log(`âœ… ì •ë‹µ: ${currentQuestionData.korean} â†’ ${currentQuestionData.english}`);
                
                // ë³µìŠµ ëª¨ë“œì—ì„œ ì •ë‹µ ì‹œ ë³µìŠµ ìƒíƒœ ì—…ë°ì´íŠ¸
                if (reviewModeData && currentQuestionData.mistakeId) {
                    const success = StorageManager.completeReview(currentQuestionData.mistakeId, true);
                    if (success) {
                        console.log(`ë³µìŠµ ì™„ë£Œ: ${currentQuestionData.korean}`);
                    }
                }
            }
        }
        
        // ì‚¬ìš©ìê°€ ë‹µì„ í‹€ë ¸ì„ ë•Œ ì²˜ë¦¬ (ìŒì„± ì¸ì‹ ì—°ë™ ì˜ˆì •)
        function recordIncorrectAnswer(userAnswer = '') {
            if (currentQuestionData && !currentQuestionData.answered) {
                currentQuestionData.answered = true;
                currentQuestionData.responseTime = Date.now() - currentQuestionData.questionStartTime;
                currentQuestionData.isCorrect = false;
                currentQuestionData.userAnswer = userAnswer;
                
                // í†µê³„ ì—…ë°ì´íŠ¸ - ì˜¤ë‹µ ì‹œ
                totalAttemptedQuestions++;
                wrongAnswerCount++;
                updateProgress();
                
                // ë³µìŠµ ëª¨ë“œì—ì„œ í‹€ë¦° ê²½ìš° ë³µìŠµ ìƒíƒœ ì—…ë°ì´íŠ¸
                if (reviewModeData && currentQuestionData.mistakeId) {
                    const success = StorageManager.completeReview(currentQuestionData.mistakeId, false);
                    if (success) {
                        console.log(`ë³µìŠµ ì‹¤íŒ¨: ${currentQuestionData.korean} - 1ë‹¨ê³„ë¶€í„° ë‹¤ì‹œ ì‹œì‘`);
                    }
                } else {
                    // ì¼ë°˜ ëª¨ë“œì—ì„œë§Œ ìƒˆ ì‹¤ìˆ˜ë¡œ ì €ì¥
                    const mistakeData = {
                        ...currentQuestionData,
                        mistakeTimestamp: Date.now(),
                        difficulty: currentStage // í˜„ì¬ ë‹¨ê³„ë¥¼ ë‚œì´ë„ë¡œ ì‚¬ìš©
                    };
                    
                    mistakeCollector.currentSession.mistakes.push(mistakeData);
                    
                    // localStorageì— ì¦‰ì‹œ ì €ì¥
                    StorageManager.saveMistake(mistakeData);
                }
                
                console.log(`âŒ ì˜¤ë‹µ: ${currentQuestionData.korean} â†’ ì •ë‹µ: ${currentQuestionData.english}, ë‹µë³€: ${userAnswer}`);
            }
        }

        // ìŒì„± ì¬ìƒ ì‹œê°„ ê³„ì‚° (ë¬¸ì¥ ê¸¸ì´ì™€ ë°°ì† ê³ ë ¤)
        function calculateSpeechDuration(text, rate = voiceSpeed) {
            // ê¸°ë³¸ ì†ë„: í•œêµ­ì–´ ì•½ 3-4ì/ì´ˆ, ì˜ì–´ ì•½ 2-3ë‹¨ì–´/ì´ˆ
            const koreanCharsPerSecond = 3 * rate;
            const englishWordsPerSecond = 2.5 * rate;
            
            if (text.match(/[ã„±-ã…|ã…-ã…£|ê°€-í£]/)) {
                // í•œêµ­ì–´
                return Math.max(1000, (text.length / koreanCharsPerSecond) * 1000);
            } else {
                // ì˜ì–´
                const wordCount = text.split(' ').length;
                return Math.max(1000, (wordCount / englishWordsPerSecond) * 1000);
            }
        }

        // ë‹¨ê³„ë³„ ê¸°ë³¸ ëŒ€ê¸° ì‹œê°„ ì„¤ì • (ì›ë˜ ê³„íšëŒ€ë¡œ)
        function getStageTimeout() {
            if (currentStage === 1) return 3000;      // 3ì´ˆ
            if (currentStage === 2) return 2000;      // 2ì´ˆ
            if (currentStage === 3) return 1000;      // 1ì´ˆ
            if (currentStage === 4) return 2000;      // ALL: 2ì´ˆ (ì¤‘ê°„ ë‚œì´ë„)
            return 1000;                              // ê¸°ë³¸ê°’
        }

        // í˜„ì¬ ë¬¸ì œ í‘œì‹œ
        function showCurrentQuestion() {
            if (currentIndex >= currentQuestions.length) {
                const stageNum = levelSystemData ? levelSystemData.stage : currentStage;
                console.log(`ìŠ¤í…Œì´ì§€ ${stageNum} ì™„ë£Œ!`);
                completeStage();
                return;
            }

            const question = currentQuestions[currentIndex];
            console.log(`ë¬¸ì œ ${currentIndex + 1}/${currentQuestions.length}: ${question.korean} â†’ ${question.english} (ë™ì‚¬: ${question.verb})`);
            
            // ë¶€ì •í–‰ìœ„ ë°©ì§€: ìƒˆ ë¬¸ì œ ì‹œì‘ ì‹œ ë‹µë³€ ì œì¶œ ìƒíƒœ ì´ˆê¸°í™”
            recognitionAnswerSubmitted = false;
            recognitionUserAnswer = '';
            console.log(`ğŸ”„ [${new Date().toLocaleTimeString()}] ìƒˆ ë¬¸ì œ ì‹œì‘ - ë‹µë³€ ì œì¶œ ìƒíƒœ ì´ˆê¸°í™”`);
            
            // í˜„ì¬ ë¬¸ì œ ë°ì´í„° ì €ì¥ (í‹€ë¦° ë¬¸ì œ ìˆ˜ì§‘ì„ ìœ„í•´)
            currentQuestionData = {
                id: `q_${Date.now()}_${currentIndex}`,
                level: mistakeCollector.currentSession.level,
                stage: mistakeCollector.currentSession.stage,
                korean: question.korean,
                english: question.english,
                verb: question.verb,
                pattern: getPatternType(question.korean),
                questionStartTime: Date.now(),
                answered: false
            };
            
            // ì´ ë¬¸ì œ ìˆ˜ ì¦ê°€
            mistakeCollector.currentSession.totalQuestions++;
            
            koreanText.textContent = question.korean;
            englishAnswer.textContent = question.english;
            englishAnswer.classList.remove('show');
            
            updateStats();
            updateProgress();

            if (isRunning && !isPaused) {
                currentPhase = 'tts';
                timer.style.display = 'block';
                speechTestArea.style.display = 'block';
                
                // ìŒì„± ì¸ì‹ ì˜ì—­ ì´ˆê¸°í™”
                countdownTimer.textContent = 'í•œêµ­ì–´ë¥¼ ë“£ê³  ìˆìŠµë‹ˆë‹¤...';
                countdownTimer.style.color = '#3b82f6';
                micStatus.textContent = 'ğŸ¤ ì¤€ë¹„ ì¤‘...';
                micStatus.style.background = '#6b7280';
                speechResult.textContent = 'í•œêµ­ì–´ ì™„ë£Œ í›„ ì¦‰ì‹œ ìŒì„± ì¸ì‹ ì‹œì‘ë©ë‹ˆë‹¤';
                answerEvaluation.style.display = 'none';
                
                // TTS ì´ˆê¸°í™” í™•ì¸ í›„ í•œêµ­ì–´ ìŒì„± ì¬ìƒ
                if (tts && tts.getVoices().length === 0) {
                    // ìŒì„± ëª©ë¡ì´ ì•„ì§ ë¡œë“œë˜ì§€ ì•Šì€ ê²½ìš° ì ì‹œ ê¸°ë‹¤ë¦¼
                    ttsTimeout = setTimeout(() => {
                        proceedWithSpeech();
                    }, 1000);
                } else {
                    proceedWithSpeech();
                }
                
                function proceedWithSpeech() {
                    console.log(`ğŸµ [${new Date().toLocaleTimeString()}] TTS ìƒíƒœ:`, tts ? 'ì‚¬ìš©ê°€ëŠ¥' : 'ì‚¬ìš©ë¶ˆê°€');
                    console.log(`ğŸµ [${new Date().toLocaleTimeString()}] ìŒì„± ê°œìˆ˜:`, tts ? tts.getVoices().length : 0);
                    
                    if (voiceKorean && tts && tts.getVoices().length > 0) {
                        ttsTimeout = setTimeout(() => {
                            speakText(question.korean, 'ko', () => {
                                console.log('í•œêµ­ì–´ ìŒì„± ì™„ë£Œ. 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘.');
                                startCountdownBeforeSpeechRecognition();
                            });
                        }, 500);
                    } else {
                        // í•œêµ­ì–´ ìŒì„±ì´ ì—†ìœ¼ë©´ 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ í›„ ì‹œì‘
                        console.log('í•œêµ­ì–´ ìŒì„± ì—†ìŒ. 3ì´ˆ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘.');
                        speechDelayTimeout = setTimeout(() => {
                            startCountdownBeforeSpeechRecognition();
                        }, 500);
                    }
                }
            }
        }
        
        // ì¼ì‹œì •ì§€ í›„ ì ì ˆí•œ phaseë¶€í„° ì¬ê°œ
        function resumeFromCurrentPhase() {
            switch(currentPhase) {
                case 'tts':
                    // TTS ë‹¨ê³„ì—ì„œ ì¤‘ë‹¨ëœ ê²½ìš° ì‚¬ê³ ì‹œê°„ ë‹¨ê³„ë¡œ ì¦‰ì‹œ ì´ë™
                    console.log(`âš ï¸ [${new Date().toLocaleTimeString()}] TTSì—ì„œ ì¤‘ë‹¨ë¨ - ì‚¬ê³ ì‹œê°„ ë‹¨ê³„ë¡œ ì´ë™`);
                    startCountdownBeforeSpeechRecognition(3);
                    break;
                case 'countdown':
                    // ì¹´ìš´íŠ¸ë‹¤ìš´ ë‹¨ê³„ì—ì„œ ì¤‘ë‹¨ëœ ê²½ìš° ë‚¨ì€ ì‹œê°„ë¶€í„° ì¬ê°œ
                    resumeCountdown();
                    break;
                case 'recognition':
                    // ìŒì„±ì¸ì‹ ë‹¨ê³„ì—ì„œ ì¤‘ë‹¨ëœ ê²½ìš° ë‚¨ì€ ì‹œê°„ë¶€í„° ì¬ê°œ
                    resumeSpeechRecognition();
                    break;
                case 'waiting':
                    // ëŒ€ê¸°ì‹œê°„ì—ì„œ ì¤‘ë‹¨ëœ ê²½ìš° ë‚¨ì€ ì‹œê°„ë¶€í„° ì¬ê°œ
                    resumeWaiting();
                    break;
                default:
                    // ê¸°ë³¸ì ìœ¼ë¡œ ì²˜ìŒë¶€í„°
                    showCurrentQuestion();
            }
        }
        
        // ì¹´ìš´íŠ¸ë‹¤ìš´ ì¬ê°œ
        function resumeCountdown() {
            if (remainingCountdownTime > 0) {
                countdownTimer.textContent = `${remainingCountdownTime}ì´ˆ í›„ ìŒì„± ì¸ì‹ ì‹œì‘...`;
                countdownTimer.style.color = '#ef4444';
                
                currentCountdownInterval = setInterval(() => {
                    remainingCountdownTime--;
                    console.log(`â³ [${new Date().toLocaleTimeString()}] ì‚¬ê³ ì‹œê°„ ë‚¨ìŒ: ${remainingCountdownTime}ì´ˆ (ì¬ê°œë¨)`);
                    countdownTimer.textContent = `${remainingCountdownTime}ì´ˆ í›„ ìŒì„± ì¸ì‹ ì‹œì‘...`;
                    
                    if (remainingCountdownTime <= 0) {
                        clearInterval(currentCountdownInterval);
                        currentCountdownInterval = null;
                        countdownTimer.textContent = 'ì§€ê¸ˆ ì˜ì–´ë¡œ ë§í•´ì£¼ì„¸ìš”!';
                        console.log(`ğŸ”” [${new Date().toLocaleTimeString()}] ì‚¬ê³ ì‹œê°„ ì¢…ë£Œ - ë§ˆì´í¬ ì‹œì‘ìŒ ì¬ìƒ`);
                        
                        playMicrophoneStartSound();
                        console.log(`ğŸ¤ [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ í•¨ìˆ˜ í˜¸ì¶œ ì‹œì‘`);
                        startSpeechRecognition();
                        
                        // ì¤‘ìš”: í•¨ìˆ˜ ì¢…ë£Œí•˜ì—¬ ì¶”ê°€ ì‹¤í–‰ ë°©ì§€
                        return;
                    }
                }, 1000);
            } else {
                // ë‚¨ì€ ì‹œê°„ì´ 0 ì´í•˜ì´ë©´ ì¦‰ì‹œ ìŒì„±ì¸ì‹ ì‹œì‘
                console.log(`âš ï¸ [${new Date().toLocaleTimeString()}] ì‚¬ê³ ì‹œê°„ì´ ìŒìˆ˜ì´ë¯€ë¡œ ì¦‰ì‹œ ìŒì„±ì¸ì‹ ì‹œì‘ (${remainingCountdownTime}ì´ˆ)`);
                countdownTimer.textContent = 'ì§€ê¸ˆ ì˜ì–´ë¡œ ë§í•´ì£¼ì„¸ìš”!';
                playMicrophoneStartSound();
                startSpeechRecognition();
            }
        }
        
        // ëª¨ë“  íƒ€ì´ë¨¸ ê°•ì œ ì •ë¦¬ í•¨ìˆ˜
        function forceStopAllTimers() {
            console.log(`ğŸ›‘ [${new Date().toLocaleTimeString()}] ëª¨ë“  íƒ€ì´ë¨¸ ê°•ì œ ì •ë¦¬ ì‹œì‘`);
            
            if (currentCountdownInterval) {
                clearInterval(currentCountdownInterval);
                currentCountdownInterval = null;
                console.log('âœ… currentCountdownInterval ì •ë¦¬');
            }
            if (currentRecognitionCountdown) {
                clearInterval(currentRecognitionCountdown);
                currentRecognitionCountdown = null;
                console.log('âœ… currentRecognitionCountdown ì •ë¦¬');
            }
            if (currentRecognitionTimeout) {
                clearTimeout(currentRecognitionTimeout);
                currentRecognitionTimeout = null;
                console.log('âœ… currentRecognitionTimeout ì •ë¦¬');
            }
            if (currentWaitTimeout) {
                clearInterval(currentWaitTimeout);
                currentWaitTimeout = null;
                console.log('âœ… currentWaitTimeout ì •ë¦¬');
            }
            
            // ê¸°íƒ€ ëª¨ë“  íƒ€ì´ë¨¸ ì •ë¦¬
            clearTimeout(questionTimer);
            clearTimeout(autoStartTimeout);
            clearTimeout(ttsTimeout);
            clearTimeout(speechDelayTimeout);
            clearTimeout(nextQuestionTimeout);
            
            console.log(`ğŸ›‘ [${new Date().toLocaleTimeString()}] ëª¨ë“  íƒ€ì´ë¨¸ ê°•ì œ ì •ë¦¬ ì™„ë£Œ`);
        }

        // ìŒì„±ì¸ì‹ ì¬ê°œ
        function resumeSpeechRecognition() {
            // ë¶€ì •í–‰ìœ„ ë°©ì§€: ì´ë¯¸ ë‹µë³€ì´ ì œì¶œëœ ê²½ìš° ìŒì„±ì¸ì‹ ì¬ê°œ ë¶ˆê°€
            if (recognitionAnswerSubmitted) {
                console.log(`ğŸš« [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ì¬ê°œ ì°¨ë‹¨ - ì´ë¯¸ ì œì¶œëœ ë‹µë³€: "${recognitionUserAnswer}"`);
                countdownTimer.textContent = `ë‹µë³€ ì œì¶œ ì™„ë£Œ - ë‹¤ìŒ ë¬¸ì œë¡œ ì§„í–‰ ì¤‘...`;
                countdownTimer.style.color = '#10b981';
                micStatus.textContent = 'âœ… ë‹µë³€ ì™„ë£Œ';
                micStatus.style.background = '#10b981';
                
                // ë‹¤ìŒ ë¬¸ì œë¡œ ìë™ ì§„í–‰
                setTimeout(() => {
                    if (isRunning && !isPaused) {
                        proceedToNextQuestion();
                        currentIndex++;
                        showCurrentQuestion();
                    }
                }, 2000);
                return;
            }
            
            if (remainingRecognitionTime > 0) {
                currentPhase = 'recognition';
                const startTime = Date.now();
                console.log(`ğŸ¤ [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ì¬ê°œ - ${remainingRecognitionTime}ì´ˆë¶€í„°`);
                
                // ëª¨ë“  íƒ€ì´ë¨¸ ê°•ì œ ì •ë¦¬
                forceStopAllTimers();
                
                if (!speechRecognition) {
                    speechResult.textContent = 'ìŒì„± ì¸ì‹ì„ ì§€ì›í•˜ì§€ ì•ŠëŠ” ë¸Œë¼ìš°ì €ì…ë‹ˆë‹¤.';
                    return;
                }
                
                if (isRecording) return;
                
                isRecording = true;
                micStatus.textContent = 'ğŸ”´ ì§€ê¸ˆ ë§í•˜ì„¸ìš”!';
                micStatus.style.background = '#ef4444';
                speechResult.textContent = 'ë“£ê³  ìˆìŠµë‹ˆë‹¤... ì˜ì–´ë¡œ ë‹µë³€í•´ì£¼ì„¸ìš”.';
                answerEvaluation.style.display = 'none';
                
                // ê¸€ë¡œë²Œ ë³€ìˆ˜ ì‚¬ìš©í•˜ì—¬ ì‹¤ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´
                countdownTimer.textContent = `${remainingRecognitionTime}ì´ˆ ë‚¨ìŒ`;
                countdownTimer.style.color = remainingRecognitionTime <= 3 ? '#ef4444' : remainingRecognitionTime <= 5 ? '#f59e0b' : '#10b981';
                
                currentRecognitionCountdown = setInterval(() => {
                    remainingRecognitionTime--;
                    console.log(`â±ï¸ [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ë‚¨ì€ì‹œê°„: ${remainingRecognitionTime}ì´ˆ (ì¬ê°œë¨)`);
                    
                    if (remainingRecognitionTime > 0) {
                        countdownTimer.textContent = `${remainingRecognitionTime}ì´ˆ ë‚¨ìŒ`;
                        if (remainingRecognitionTime <= 3) {
                            countdownTimer.style.color = '#ef4444';
                        } else if (remainingRecognitionTime <= 5) {
                            countdownTimer.style.color = '#f59e0b';
                        }
                    } else {
                        clearInterval(currentRecognitionCountdown);
                        currentRecognitionCountdown = null;
                        countdownTimer.textContent = 'ì‹œê°„ ì¢…ë£Œ!';
                        countdownTimer.style.color = '#ef4444';
                        handleNoResponse();
                    }
                }, 1000);
                
                // isCompleted ì´ˆê¸°í™” (ì „ì—­ ë³€ìˆ˜ ì‚¬ìš©)
                isCompleted = false;
                
                // ê¸°ì¡´ ìŒì„±ì¸ì‹ í•¸ë“¤ëŸ¬ ì¬ì„¤ì •
                speechRecognition.onresult = function(event) {
                    if (isCompleted) return;
                    
                    // ë¶€ì •í–‰ìœ„ ë°©ì§€: ì´ë¯¸ ë‹µë³€ì´ ì œì¶œëœ ê²½ìš° ë¬´ì‹œ
                    if (recognitionAnswerSubmitted) {
                        console.log(`ğŸš« [${new Date().toLocaleTimeString()}] ì¤‘ë³µ ë‹µë³€ ì‹œë„ ì°¨ë‹¨ - ì´ë¯¸ ì œì¶œëœ ë‹µë³€: "${recognitionUserAnswer}"`);
                        return;
                    }
                    
                    isCompleted = true;
                    
                    const endTime = Date.now();
                    const responseTime = (endTime - startTime) / 1000;
                    
                    const result = event.results[0][0].transcript;
                    console.log(`âœ… [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ì™„ë£Œ - ì‘ë‹µì‹œê°„: ${responseTime.toFixed(1)}ì´ˆ`);
                    console.log(`ğŸ“ [${new Date().toLocaleTimeString()}] ì¸ì‹ëœ ìŒì„±: "${result}"`);
                    
                    // ë‹µë³€ ì œì¶œ ìƒíƒœ ê¸°ë¡ (ë¶€ì •í–‰ìœ„ ë°©ì§€)
                    recognitionAnswerSubmitted = true;
                    recognitionUserAnswer = result;
                    
                    if (currentRecognitionCountdown) {
                        clearInterval(currentRecognitionCountdown);
                        currentRecognitionCountdown = null;
                    }
                    if (currentRecognitionTimeout) {
                        clearTimeout(currentRecognitionTimeout);
                        currentRecognitionTimeout = null;
                    }
                    
                    countdownTimer.textContent = `ì‘ë‹µì‹œê°„: ${responseTime.toFixed(1)}ì´ˆ`;
                    countdownTimer.style.color = '#10b981';
                    
                    // í˜„ì¬ ë¬¸ì œì˜ ì •ë‹µê³¼ ë¹„êµ
                    if (currentQuestionData) {
                        const similarity = calculateAnswerSimilarity(result, currentQuestionData.english);
                        const isCorrect = similarity >= 60;
                        
                        answerEvaluation.style.display = 'block';
                        if (isCorrect) {
                            answerEvaluation.innerHTML = `
                                <div style="background: #dcfce7; color: #166534; padding: 15px; border-radius: 8px;">
                                    âœ… <strong>ì •ë‹µì…ë‹ˆë‹¤!</strong><br>
                                    ì •í™•ë„: ${similarity}%<br>
                                    ì •ë‹µ: "${currentQuestionData.english}"
                                </div>
                            `;
                            recordCorrectAnswer();
                        } else {
                            answerEvaluation.innerHTML = `
                                <div style="background: #fef2f2; color: #dc2626; padding: 15px; border-radius: 8px;">
                                    âŒ <strong>ë‹¤ì‹œ ì‹œë„í•´ë³´ì„¸ìš”</strong><br>
                                    ìœ ì‚¬ë„: ${similarity}%<br>
                                    ì •ë‹µ: "${currentQuestionData.english}"<br>
                                    <small>60% ì´ìƒì´ì–´ì•¼ ì •ë‹µ ì²˜ë¦¬ë©ë‹ˆë‹¤</small>
                                </div>
                            `;
                            recordIncorrectAnswer(result);
                        }
                        
                        nextQuestionTimeout = setTimeout(() => {
                            if (isRunning && !isPaused) {
                                currentPhase = 'idle';
                                proceedToNextQuestion();
                                currentIndex++;
                                showCurrentQuestion();
                            }
                        }, 3000);
                    }
                };
                
                speechRecognition.onerror = function(event) {
                    if (isCompleted) return;
                    isCompleted = true;
                    
                    console.log(`âŒ [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ì˜¤ë¥˜: ${event.error}`);
                    if (currentRecognitionCountdown) {
                        clearInterval(currentRecognitionCountdown);
                        currentRecognitionCountdown = null;
                    }
                    if (currentRecognitionTimeout) {
                        clearTimeout(currentRecognitionTimeout);
                        currentRecognitionTimeout = null;
                    }
                    
                    speechResult.textContent = 'ìŒì„± ì¸ì‹ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.';
                    setTimeout(() => {
                        if (isRunning && !isPaused) {
                            proceedToNextQuestion();
                            currentIndex++;
                            showCurrentQuestion();
                        }
                    }, 2000);
                };
                
                // ë‚¨ì€ ì‹œê°„ í›„ ìë™ ì¢…ë£Œ
                currentRecognitionTimeout = setTimeout(() => {
                    if (isRecording && !isCompleted) {
                        isCompleted = true;
                        console.log(`â° [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ ì‹œê°„ì´ˆê³¼ (ì¬ê°œ í›„)`);
                        if (currentRecognitionCountdown) {
                            clearInterval(currentRecognitionCountdown);
                            currentRecognitionCountdown = null;
                        }
                        handleNoResponse();
                    }
                }, remainingRecognitionTime * 1000);
                
                // ì´ë¯¸ ì‹¤í–‰ ì¤‘ì¸ ê²½ìš° ì¤‘ì§€ í›„ ë‹¤ì‹œ ì‹œì‘
                try {
                    speechRecognition.start();
                } catch (error) {
                    console.log(`ğŸ”¥ [${new Date().toLocaleTimeString()}] SpeechRecognition ì¬ê°œ ì‹œì‘ ì˜¤ë¥˜:`, error);
                    // ì´ë¯¸ ì‹œì‘ëœ ê²½ìš°ë¼ë©´ ì¤‘ì§€ í›„ ë‹¤ì‹œ ì‹œì‘
                    if (error.message.includes('already started')) {
                        console.log(`âš ï¸ [${new Date().toLocaleTimeString()}] ì´ë¯¸ ì‹œì‘ëœ ìŒì„±ì¸ì‹ì„ ì¤‘ì§€ í›„ ì¬ì‹œì‘ (ì¬ê°œ)`);
                        speechRecognition.stop();
                        setTimeout(() => {
                            speechRecognition.start();
                        }, 100);
                    }
                }
            } else {
                // ë‚¨ì€ ì‹œê°„ì´ 0ì´ë©´ ì‹œê°„ì´ˆê³¼ ì²˜ë¦¬
                handleNoResponse();
            }
        }
        
        // ëŒ€ê¸°ì‹œê°„ ì¬ê°œ
        function resumeWaiting() {
            countdownTimer.textContent = `${remainingWaitTime}ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œ`;
            countdownTimer.style.color = '#10b981';
            
            currentWaitTimeout = setInterval(() => {
                remainingWaitTime--;
                console.log(`â±ï¸ [${new Date().toLocaleTimeString()}] ë‹¤ìŒ ë¬¸ì œê¹Œì§€ ${remainingWaitTime}ì´ˆ ë‚¨ìŒ`);
                
                if (remainingWaitTime > 0) {
                    countdownTimer.textContent = `${remainingWaitTime}ì´ˆ í›„ ë‹¤ìŒ ë¬¸ì œ`;
                } else {
                    clearInterval(currentWaitTimeout);
                    currentWaitTimeout = null;
                    currentPhase = 'idle';
                    proceedToNextQuestion();
                    currentIndex++;
                    showCurrentQuestion();
                }
            }, 1000);
        }
        
        // ë‹¨ê³„ë³„ ì¹´ìš´íŠ¸ë‹¤ìš´ í›„ ìŒì„± ì¸ì‹ ì‹œì‘
        function startCountdownBeforeSpeechRecognition() {
            currentPhase = 'countdown';
            // ë‹¨ê³„ë³„ ëŒ€ê¸°ì‹œê°„ ì„¤ì •
            const waitTime = currentStage === 1 ? 3 : currentStage === 2 ? 2 : currentStage === 3 ? 1 : 2; // ALLì€ 2ì´ˆ
            console.log(`â³ [${new Date().toLocaleTimeString()}] ì‚¬ê³ ì‹œê°„ ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ - ${waitTime}ì´ˆ ëŒ€ê¸°`);
            
            // ëª¨ë“  íƒ€ì´ë¨¸ ê°•ì œ ì •ë¦¬
            forceStopAllTimers();
            
            countdownTimer.textContent = `${waitTime}ì´ˆ í›„ ìŒì„± ì¸ì‹ ì‹œì‘...`;
            countdownTimer.style.color = '#ef4444';
            
            remainingCountdownTime = waitTime;
            currentCountdownInterval = setInterval(() => {
                remainingCountdownTime--;
                console.log(`â³ [${new Date().toLocaleTimeString()}] ì‚¬ê³ ì‹œê°„ ë‚¨ìŒ: ${remainingCountdownTime}ì´ˆ`);
                countdownTimer.textContent = `${remainingCountdownTime}ì´ˆ í›„ ìŒì„± ì¸ì‹ ì‹œì‘...`;
                
                if (remainingCountdownTime <= 0) {
                    clearInterval(currentCountdownInterval);
                    currentCountdownInterval = null;
                    countdownTimer.textContent = 'ì§€ê¸ˆ ì˜ì–´ë¡œ ë§í•´ì£¼ì„¸ìš”!';
                    console.log(`ğŸ”” [${new Date().toLocaleTimeString()}] ì‚¬ê³ ì‹œê°„ ì¢…ë£Œ - ë§ˆì´í¬ ì‹œì‘ìŒ ì¬ìƒ`);
                    
                    // ë§ˆì´í¬ ì‹œì‘ ì†Œë¦¬ ì¬ìƒ
                    playMicrophoneStartSound();
                    
                    // ì‹¤ì œ ìŒì„± ì¸ì‹ ì‹œì‘ (ì¦‰ì‹œ)
                    console.log(`ğŸ¤ [${new Date().toLocaleTimeString()}] ìŒì„±ì¸ì‹ í•¨ìˆ˜ í˜¸ì¶œ ì‹œì‘`);
                    startSpeechRecognition();
                    
                    // ì¤‘ìš”: í•¨ìˆ˜ ì¢…ë£Œí•˜ì—¬ ì¶”ê°€ ì‹¤í–‰ ë°©ì§€
                    return;
                }
            }, 1000);
        }
        
        // ë§ˆì´í¬ ì‹œì‘ ì†Œë¦¬ ì¬ìƒ (Level 3ê³¼ ë™ì¼)
        function playMicrophoneStartSound() {
            if ('AudioContext' in window || 'webkitAudioContext' in window) {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const audioCtx = new AudioContext();
                
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);
                
                oscillator.start(audioCtx.currentTime);
                oscillator.stop(audioCtx.currentTime + 0.2);
            }
        }

        // ë‹¤ìŒ ë¬¸ì œë¡œ ì§„í–‰ (ìŒì„± ì¸ì‹ì—ì„œ í˜¸ì¶œ)
        function proceedToNextQuestion() {
            speechTestArea.style.display = 'none';
            timer.style.display = 'none';
            englishAnswer.classList.remove('show');
        }

        // í†µê³„ ì—…ë°ì´íŠ¸
        function updateStats() {
            currentQuestionEl.textContent = Math.min(currentIndex + 1, currentQuestions.length);
            totalQuestionsEl.textContent = currentQuestions.length;
            const rate = currentQuestions.length > 0 ? Math.round((currentIndex / currentQuestions.length) * 100) : 0;
            completionRateEl.textContent = `${rate}%`;
        }

        // ì§„í–‰ë¥  ì—…ë°ì´íŠ¸
        function updateProgress() {
            const progress = currentQuestions.length > 0 ? (currentIndex / currentQuestions.length) * 100 : 0;
            progressFill.style.width = `${progress}%`;
            
            // ì‹¤ì‹œê°„ í†µê³„ ì—…ë°ì´íŠ¸
            currentQuestionEl.textContent = currentIndex + 1;
            totalQuestionsEl.textContent = currentQuestions.length;
            completionRateEl.textContent = `${Math.round(progress)}%`;
            
            // ì˜¤ë‹µë¥  ê³„ì‚° ë° í‘œì‹œ
            const errorRate = totalAttemptedQuestions > 0 ? (wrongAnswerCount / totalAttemptedQuestions * 100).toFixed(1) : 0;
            errorRateEl.textContent = `${errorRate}%`;
            
            console.log(`ğŸ“Š [${new Date().toLocaleTimeString()}] í†µê³„ ì—…ë°ì´íŠ¸: ${currentIndex + 1}/${currentQuestions.length}, ì™„ë£Œìœ¨: ${Math.round(progress)}%, ì˜¤ë‹µë¥ : ${errorRate}%`);
        }

        // ë‹¨ê³„ ì™„ë£Œ
        function completeStage() {
            isRunning = false;
            isPaused = false;
            clearTimeout(questionTimer);
            timer.style.display = 'none';
            
            // ì„¸ì…˜ ì™„ë£Œ ì²˜ë¦¬
            mistakeCollector.currentSession.endTime = Date.now();
            mistakeCollector.currentSession.duration = mistakeCollector.currentSession.endTime - mistakeCollector.currentSession.startTime;
            mistakeCollector.currentSession.accuracy = mistakeCollector.currentSession.totalQuestions > 0 ? 
                (mistakeCollector.currentSession.correctAnswers / mistakeCollector.currentSession.totalQuestions * 100).toFixed(1) : 0;
            
            // ì‚¬ìš©ì í†µê³„ ì—…ë°ì´íŠ¸
            const currentStats = StorageManager.getUserStats();
            const updatedStats = {
                totalSessions: currentStats.totalSessions + 1,
                totalQuestions: currentStats.totalQuestions + mistakeCollector.currentSession.totalQuestions,
                totalCorrect: currentStats.totalCorrect + mistakeCollector.currentSession.correctAnswers,
                totalMistakes: currentStats.totalMistakes + mistakeCollector.currentSession.mistakes.length,
                totalStudyTime: currentStats.totalStudyTime + mistakeCollector.currentSession.duration
            };
            
            // í‰ê·  ì •í™•ë„ ê³„ì‚°
            updatedStats.averageAccuracy = updatedStats.totalQuestions > 0 ?
                (updatedStats.totalCorrect / updatedStats.totalQuestions * 100).toFixed(1) : 0;
            
            StorageManager.saveUserStats(updatedStats);
            
            // í‹€ë¦° ë¬¸ì œ ìš”ì•½ ì¶œë ¥
            console.log('=== ì„¸ì…˜ ì™„ë£Œ ìš”ì•½ ===');
            console.log(`ë ˆë²¨: ${mistakeCollector.currentSession.level}-${mistakeCollector.currentSession.stage}`);
            console.log(`ì´ ë¬¸ì œ: ${mistakeCollector.currentSession.totalQuestions}`);
            console.log(`ì •ë‹µ: ${mistakeCollector.currentSession.correctAnswers}`);
            console.log(`ì •í™•ë„: ${mistakeCollector.currentSession.accuracy}%`);
            console.log(`í‹€ë¦° ë¬¸ì œ: ${mistakeCollector.currentSession.mistakes.length}ê°œ`);
            console.log(`í•™ìŠµ ì‹œê°„: ${Math.round(mistakeCollector.currentSession.duration / 1000)}ì´ˆ`);
            
            if (mistakeCollector.currentSession.mistakes.length > 0) {
                console.log('=== í‹€ë¦° ë¬¸ì œ ëª©ë¡ ===');
                mistakeCollector.currentSession.mistakes.forEach((mistake, index) => {
                    console.log(`${index + 1}. ${mistake.korean} â†’ ${mistake.english} (íŒ¨í„´: ${mistake.pattern})`);
                    console.log(`   ì‚¬ìš©ì ë‹µë³€: "${mistake.userAnswer}", ì‘ë‹µì‹œê°„: ${mistake.responseTime}ms`);
                });
            }
            
            // ë³µìŠµ ëŒ€ìƒ ë¬¸ì œ í™•ì¸
            const dueReviews = StorageManager.getDueReviews();
            if (dueReviews.length > 0) {
                console.log(`ğŸ“– ë³µìŠµ ëŒ€ìƒ: ${dueReviews.length}ê°œ ë¬¸ì œ`);
            }
            
            // localStorage ë””ë²„ê·¸ ì¶œë ¥
            StorageManager.debugPrint();
            
            const stageNum = levelSystemData ? levelSystemData.stage : currentStage;
            koreanText.textContent = `ìŠ¤í…Œì´ì§€ ${stageNum} ì™„ë£Œ! ğŸ‰`;
            englishAnswer.textContent = 'ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤!';
            englishAnswer.classList.add('show');
            
            startBtn.textContent = 'ğŸš€ ì‹œì‘í•˜ê¸°';
            startBtn.disabled = false;
            // pauseBtn ì œê±°ë¨
            
            updateProgress();
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        stageButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                if (isRunning) return;
                
                stageButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentStage = parseInt(btn.dataset.stage);
                resetTraining();
            });
        });

        verbButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                if (isRunning) return;
                
                verbButtons.forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentVerb = btn.dataset.verb;
                resetTraining();
            });
        });

        startBtn.addEventListener('click', () => {
            if (!isRunning) {
                // TTS í™œì„±í™”ë¥¼ ìœ„í•œ ì‚¬ìš©ì ì¸í„°ë ‰ì…˜ (ë¸Œë¼ìš°ì € ìë™ì¬ìƒ ì •ì±…)
                if (tts && tts.getVoices().length === 0) {
                    console.log('ìŒì„± ëª©ë¡ ê°•ì œ ë¡œë“œ ì‹œë„');
                    tts.getVoices();
                    // ë¹ˆ ìŒì„±ì„ ì¬ìƒí•˜ì—¬ TTS í™œì„±í™”
                    const testUtterance = new SpeechSynthesisUtterance(' ');
                    testUtterance.volume = 0;
                    tts.speak(testUtterance);
                }
                
                // ì‹œì‘
                console.log(`=== ${currentStage}ë‹¨ê³„ ì‹œì‘ ===`);
                isRunning = true;
                isPaused = false;
                currentQuestions = generateQuestions();
                currentIndex = 0;
                wrongAnswerCount = 0;
                totalAttemptedQuestions = 0;
                console.log(`ì´ ìƒì„±ëœ ë¬¸ì œ ìˆ˜: ${currentQuestions.length}`);
                startBtn.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
                // pauseBtn ì œê±°ë¨
                showCurrentQuestion();
            } else {
                // ì¼ì‹œì •ì§€
                isPaused = !isPaused;
                if (isPaused) {
                    pausedAt = Date.now();
                    
                    // í˜„ì¬ phaseë³„ë¡œ ë‚¨ì€ ì‹œê°„ ì €ì¥ (ê¸€ë¡œë²Œ ë³€ìˆ˜ ê°’ ì‚¬ìš©)
                    console.log(`â¸ï¸ [${new Date().toLocaleTimeString()}] ì¼ì‹œì •ì§€ - í˜„ì¬ Phase: ${currentPhase}`);
                    console.log(`â¸ï¸ [${new Date().toLocaleTimeString()}] ì €ì¥ëœ ì‹œê°„: countdown=${remainingCountdownTime}, recognition=${remainingRecognitionTime}, wait=${remainingWaitTime}`);
                    
                    // ëª¨ë“  íƒ€ì´ë¨¸ ê°•ì œ ì •ë¦¬
                    forceStopAllTimers();
                    
                    // ìŒì„± ì¸ì‹ ì¤‘ë‹¨
                    if (speechRecognition && isRecording) {
                        speechRecognition.stop();
                        isRecording = false;
                    }
                    
                    // TTS ì¤‘ë‹¨
                    if (speechSynthesis.speaking) {
                        speechSynthesis.cancel();
                    }
                    
                    // í˜„ì¬ ìƒíƒœì— ë”°ë¼ pause ìƒíƒœ í‘œì‹œ
                    if (currentPhase === 'countdown') {
                        countdownTimer.textContent = `ì¼ì‹œì •ì§€ë¨ - ì‚¬ê³ ì‹œê°„ ${remainingCountdownTime}ì´ˆ ë‚¨ìŒ`;
                        countdownTimer.style.color = '#f59e0b';
                    } else if (currentPhase === 'recognition') {
                        if (recognitionAnswerSubmitted) {
                            countdownTimer.textContent = `ì¼ì‹œì •ì§€ë¨ - ë‹µë³€ ì œì¶œ ì™„ë£Œ (ì¬ë‹µë³€ ë¶ˆê°€)`;
                            countdownTimer.style.color = '#10b981';
                        } else {
                            countdownTimer.textContent = `ì¼ì‹œì •ì§€ë¨ - ìŒì„±ì¸ì‹ ${remainingRecognitionTime}ì´ˆ ë‚¨ìŒ`;
                            countdownTimer.style.color = '#f59e0b';
                        }
                    } else if (currentPhase === 'waiting') {
                        countdownTimer.textContent = `ì¼ì‹œì •ì§€ë¨ - ë‹¤ìŒ ë¬¸ì œê¹Œì§€ ${remainingWaitTime}ì´ˆ ë‚¨ìŒ`;
                        countdownTimer.style.color = '#f59e0b';
                    } else {
                        countdownTimer.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€ë¨';
                        countdownTimer.style.color = '#f59e0b';
                    }
                    micStatus.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
                    micStatus.style.background = '#f59e0b';
                    micStatus.classList.remove('listening');
                    
                    startBtn.textContent = 'â–¶ï¸ ê³„ì†í•˜ê¸°';
                } else {
                    startBtn.textContent = 'â¸ï¸ ì¼ì‹œì •ì§€';
                    // ì¼ì‹œì •ì§€ëœ phaseì— ë”°ë¼ ì ì ˆí•œ ì‹œì ë¶€í„° ì¬ê°œ
                    resumeFromCurrentPhase();
                }
            }
        });

        resetBtn.addEventListener('click', () => {
            resetTraining();
        });

        // ìŒì„± ì„¤ì • ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        voiceKoreanCheck.addEventListener('change', (e) => {
            voiceKorean = e.target.checked;
        });

        voiceEnglishCheck.addEventListener('change', (e) => {
            voiceEnglish = e.target.checked;
        });

        voiceSpeedSlider.addEventListener('input', (e) => {
            voiceSpeed = parseFloat(e.target.value);
            speedValue.textContent = `${voiceSpeed}x`;
        });

        koreanVoiceSelect.addEventListener('change', (e) => {
            if (e.target.value) {
                const voices = tts.getVoices();
                selectedKoreanVoice = voices.find(voice => voice.name === e.target.value);
                console.log('í•œêµ­ì–´ ìŒì„± ì„ íƒ:', selectedKoreanVoice?.name);
            } else {
                selectedKoreanVoice = null;
                console.log('í•œêµ­ì–´ ìŒì„±: ìë™ ì„ íƒ');
            }
        });

        englishVoiceSelect.addEventListener('change', (e) => {
            if (e.target.value) {
                const voices = tts.getVoices();
                selectedEnglishVoice = voices.find(voice => voice.name === e.target.value);
                console.log('ì˜ì–´ ìŒì„± ì„ íƒ:', selectedEnglishVoice?.name);
            } else {
                selectedEnglishVoice = null;
                console.log('ì˜ì–´ ìŒì„±: ìë™ ì„ íƒ');
            }
        });

        // ìŒì„± ëª©ë¡ì„ ë“œë¡­ë‹¤ìš´ì— ë¡œë“œí•˜ëŠ” í•¨ìˆ˜
        function loadVoiceOptions() {
            if (!tts) return;
            
            const voices = tts.getVoices();
            console.log('ìŒì„± ëª©ë¡ ë¡œë“œ ì™„ë£Œ:', voices.length, 'ê°œ');
            
            // í•œêµ­ì–´ ìŒì„± ëª©ë¡
            const koreanVoices = voices.filter(voice => 
                voice.lang.includes('ko') || voice.name.includes('Korean') || voice.name.includes('í•œêµ­')
            );
            koreanVoiceSelect.innerHTML = '<option value="">ìë™ ì„ íƒ</option>';
            koreanVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} (${voice.lang})`;
                koreanVoiceSelect.appendChild(option);
            });
            
            // ì˜ì–´ ìŒì„± ëª©ë¡
            const englishVoices = voices.filter(voice => 
                voice.lang.startsWith('en')
            );
            englishVoiceSelect.innerHTML = '<option value="">ìë™ ì„ íƒ</option>';
            englishVoices.forEach(voice => {
                const option = document.createElement('option');
                option.value = voice.name;
                option.textContent = `${voice.name} (${voice.lang})`;
                englishVoiceSelect.appendChild(option);
            });
            
            console.log(`í•œêµ­ì–´ ìŒì„±: ${koreanVoices.length}ê°œ, ì˜ì–´ ìŒì„±: ${englishVoices.length}ê°œ`);
        }

        // TTS ìŒì„± ë¡œë“œ ëŒ€ê¸°
        if (tts) {
            if (tts.getVoices().length === 0) {
                tts.addEventListener('voiceschanged', function() {
                    loadVoiceOptions();
                }, { once: true });
            } else {
                loadVoiceOptions();
            }
        }

        // í›ˆë ¨ ë¦¬ì…‹
        function resetTraining() {
            isRunning = false;
            isPaused = false;
            currentIndex = 0;
            wrongAnswerCount = 0;
            totalAttemptedQuestions = 0;
            
            // ëª¨ë“  íƒ€ì´ë¨¸ ê°•ì œ ì •ë¦¬
            forceStopAllTimers();
            
            clearTimeout(questionTimer);
            timer.style.display = 'none';
            speechTestArea.style.display = 'none';
            
            // ëª¨ë“  íƒ€ì´ë¨¸ì™€ ìŒì„± ì¸ì‹ ì¤‘ì§€
            if (isRecording) {
                stopSpeechRecognition();
            }
            if (countdownInterval) {
                clearInterval(countdownInterval);
                countdownInterval = null;
            }
            if (autoStartTimeout) {
                clearTimeout(autoStartTimeout);
                autoStartTimeout = null;
            }
            
            koreanText.textContent = 'ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”';
            englishAnswer.textContent = '';
            englishAnswer.classList.remove('show');
            
            startBtn.textContent = 'ğŸš€ ì‹œì‘í•˜ê¸°';
            startBtn.disabled = false;
            // pauseBtn ì œê±°ë¨
            
            progressFill.style.width = '0%';
            updateStats();
        }

        // ë³µìŠµ ëª¨ë“œ ë¬¸ì œ ë¡œë“œ
        function loadReviewQuestions() {
            const mistakes = StorageManager.getMistakes();
            const reviewQuestions = [];
            
            if (reviewModeData.mode === 'single') {
                // ë‹¨ì¼ ë¬¸ì œ ë³µìŠµ
                const mistake = mistakes.find(m => m.id === reviewModeData.reviewId);
                if (mistake) {
                    reviewQuestions.push({
                        korean: mistake.korean,
                        english: mistake.english,
                        pattern: mistake.pattern,
                        verb: mistake.verb,
                        mistakeId: mistake.id
                    });
                }
            } else if (reviewModeData.mode === 'all' || reviewModeData.mode === 'pattern' || reviewModeData.mode === 'weak-patterns') {
                // ì „ì²´ ë³µìŠµ, íŒ¨í„´ í›ˆë ¨, ì•½í•œ íŒ¨í„´ í›ˆë ¨
                reviewModeData.reviewIds.forEach(id => {
                    const mistake = mistakes.find(m => m.id === id);
                    if (mistake) {
                        reviewQuestions.push({
                            korean: mistake.korean,
                            english: mistake.english,
                            pattern: mistake.pattern,
                            verb: mistake.verb,
                            mistakeId: mistake.id
                        });
                    }
                });
            }
            
            return reviewQuestions;
        }

        // ì´ˆê¸°í™”
        const urlParseResult = parseURLParams();
        
        if (urlParseResult === 'review') {
            // ë³µìŠµ ëª¨ë“œ
            console.log('ë³µìŠµ ëª¨ë“œë¡œ ì´ˆê¸°í™”');
            
            // ë³µìŠµ ë¬¸ì œ ë¡œë“œ
            const reviewQuestions = loadReviewQuestions();
            if (reviewQuestions.length === 0) {
                alert('ë³µìŠµí•  ë¬¸ì œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                window.close();
            } else {
            
            // ë¬¸ì œ ì„¤ì •ì„ ë³µìŠµìš©ìœ¼ë¡œ ë³€ê²½
            currentQuestions = reviewQuestions;
            
            // ëª¨ë“œë³„ UI ì œëª© ë³€ê²½
            let titleText = 'ğŸ“– ë³µìŠµ ëª¨ë“œ';
            let subtitleText = `${reviewQuestions.length}ê°œ ë¬¸ì œ ë³µìŠµí•˜ê¸°`;
            
            if (reviewModeData.mode === 'pattern') {
                titleText = `ğŸ¯ íŒ¨í„´ ì§‘ì¤‘ í›ˆë ¨`;
                subtitleText = `${reviewModeData.patternName} íŒ¨í„´ - ${reviewQuestions.length}ê°œ ë¬¸ì œ`;
            } else if (reviewModeData.mode === 'weak-patterns') {
                titleText = `ğŸ”¥ ì•½í•œ íŒ¨í„´ ì§‘ì¤‘ í›ˆë ¨`;
                subtitleText = `ë§ˆìŠ¤í„°ìœ¨ 50% ë¯¸ë§Œ íŒ¨í„´ë“¤ - ${reviewQuestions.length}ê°œ ë¬¸ì œ`;
            } else if (reviewModeData.mode === 'single') {
                titleText = `ğŸ“ ê°œë³„ ë³µìŠµ`;
                subtitleText = `1ê°œ ë¬¸ì œ ì§‘ì¤‘ ë³µìŠµ`;
            }
            
            document.querySelector('h1').textContent = titleText;
            document.querySelector('.subtitle').textContent = subtitleText;
            
            // ìŠ¤í…Œì´ì§€ ì„ íƒ ë²„íŠ¼ ìˆ¨ê¸°ê¸° (ë³µìŠµ ëª¨ë“œì—ì„œëŠ” ë¶ˆí•„ìš”)
            document.querySelector('.stage-selector').style.display = 'none';
            
            // ë’¤ë¡œ ê°€ê¸° ë²„íŠ¼ í‘œì‹œ
            document.getElementById('back-to-level').style.display = 'block';
            }
            
        } else if (urlParseResult === 'level') {
            // ë ˆë²¨ ì‹œìŠ¤í…œì—ì„œ ì˜¨ ê²½ìš° ì„¤ì • ì ìš©
            currentVerb = levelSystemData.verbs[0]; // ì²« ë²ˆì§¸ ë™ì‚¬ë¡œ ì„¤ì •
            
            // í‹€ë¦° ë¬¸ì œ ìˆ˜ì§‘ê¸° ì •ë³´ ì—…ë°ì´íŠ¸
            mistakeCollector.currentSession.level = levelSystemData.level;
            mistakeCollector.currentSession.stage = levelSystemData.stage;
            mistakeCollector.currentSession.startTime = Date.now();
            
            // ë’¤ë¡œ ê°€ê¸° ë²„íŠ¼ í‘œì‹œ
            document.getElementById('back-to-level').style.display = 'block';
            
            // ìŒì„± ì„¤ì • í•­ìƒ í‘œì‹œ (ê°œë°œì ëª¨ë“œì™€ ìƒê´€ì—†ì´)
            const voiceSettings = document.getElementById('voice-settings');
            voiceSettings.style.display = 'flex';
            console.log('ğŸµ ìŒì„± ì„¤ì • í™œì„±í™”');
            
            if (levelSystemData.developerMode) {
                console.log('ğŸ› ï¸ ê°œë°œì ëª¨ë“œ í™œì„±');
            }
            
            // ì œëª© ì—…ë°ì´íŠ¸
            document.querySelector('h1').textContent = `ğŸ¯ Level ${levelSystemData.level}-${levelSystemData.stage}`;
            document.querySelector('.subtitle').textContent = `${levelSystemData.verbs.join(', ')} íŒ¨í„´ ë§ˆìŠ¤í„°`;
            
            // ë™ì‚¬ ì„ íƒê¸° ì—…ë°ì´íŠ¸
            const verbSelector = document.querySelector('.verb-selector');
            verbSelector.innerHTML = '';
            levelSystemData.verbs.forEach((verb, index) => {
                const btn = document.createElement('div');
                btn.className = `verb-btn ${index === 0 ? 'active' : ''}`;
                btn.dataset.verb = verb;
                btn.textContent = verb.charAt(0).toUpperCase() + verb.slice(1);
                verbSelector.appendChild(btn);
                
                // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì¶”ê°€
                btn.addEventListener('click', () => {
                    if (isRunning) return;
                    
                    document.querySelectorAll('.verb-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentVerb = verb;
                    resetTraining();
                });
            });
        } else {
            // ê¸°ë³¸ ëª¨ë“œ (ë©”ì¸ í•™ìŠµ)
            console.log('ê¸°ë³¸ í•™ìŠµ ëª¨ë“œë¡œ ì´ˆê¸°í™”');
            
            // ë’¤ë¡œ ê°€ê¸° ë²„íŠ¼ í‘œì‹œ (ë©”ì¸ í˜ì´ì§€ë¡œ ì´ë™)
            const backButton = document.getElementById('back-to-level');
            backButton.style.display = 'block';
            
            // ë²„íŠ¼ í…ìŠ¤íŠ¸ë¥¼ ë©”ì¸ í˜ì´ì§€ë¡œ ë³€ê²½
            const backButtonElement = backButton.querySelector('button');
            backButtonElement.innerHTML = 'â† ë©”ì¸ í˜ì´ì§€ë¡œ ëŒì•„ê°€ê¸°';
            backButtonElement.onclick = function() {
                window.location.href = '/';
            };
            
            // ìŒì„± ì„¤ì • í‘œì‹œ
            const voiceSettings = document.getElementById('voice-settings');
            voiceSettings.style.display = 'flex';
            console.log('ğŸµ ê¸°ë³¸ ëª¨ë“œ: ìŒì„± ì„¤ì • í™œì„±í™”');
        }
        
        resetTraining();
    </script>
</body>
</html>