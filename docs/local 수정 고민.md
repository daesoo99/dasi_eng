DASI English 프로젝트 AI 헌법 (claude.local) 정비 결과
✅ claude.local 템플릿 (최종 문서 내용 붙여넣기용)

금지 파일/폴더: AI는 인증 정보 파일(.env 등)이나 환경 설정 파일을 임의로 생성하거나 수정하지 않는다. 사용자 또는 설계자가 명시적으로 허가하지 않은 시스템 디렉터리나 백업 폴더에는 어떠한 변경도 가하지 않는다. 민감한 정보나 시크릿 키는 코드에 하드코딩하지 않고, 노출하거나 로그에 출력하지 않는다.

파일 구조 및 생성: 세션 간 고정된 프로젝트 파일 구조를 유지한다. AI는 임의로 새로운 파일을 생성하거나 기존 폴더 구조를 변경하지 않는다. 새로운 파일이 꼭 필요하면 설계 단계에서 먼저 제안하고 결정 로그에 기록한 후, 사용자 승인을 받아 생성한다. 동일한 기능의 파일을 중복으로 만들지 않고, 기존 파일을 확장/수정하는 방향을 우선한다.

모듈화 기준: 모든 코드는 단일 책임 원칙을 따르며 모듈화한다. 한 파일/모듈에는 하나의 주요 기능이나 컴포넌트만 포함하도록 노력하고, 파일 크기가 지나치게 커지면 논리 단위로 분리한다. 단, 기존 아키텍처나 패턴을 큰 폭으로 변경하지 말고 일관성을 유지한다 (급진적인 패턴 변경 지양, 기존 코드 스타일 준수). 새로운 기능 구현 시 기존 코드를 재사용하고 중복되는 모듈을 만들지 않는다
gist.github.com
.

코딩 규칙: 프로젝트의 코딩 스타일 가이드와 코딩 규약을 엄격히 준수한다. 일관된 네이밍 컨벤션, 들여쓰기 등 스타일을 유지하고, 불필요하거나 위험한 함수(예: deprecated API)는 사용하지 않는다. 공개 함수에는 주석이나 docstring을 작성하며, 함수는 가능하면 50줄 이하로 유지하는 등 복잡도를 관리한다
forgecode.dev
. 또한 DRY 원칙을 지켜 중복 코드를 작성하지 않고, KISS 원칙에 따라 단순 명료하게 구현한다.

문서 참조 방식: 설계 문서와 요구사항 명세를 항상 참고하여 개발하며, 명세에 어긋나는 구현을 하지 않는다. 기존 문서의 관련 부분만 발췌/요약해서 활용하고, 전체 문서나 코드를 한꺼번에 복사해 프롬프트에 넣지 않는다
forgecode.dev
. 모호한 요구 대신 문서에 명시된 용어와 기능을 그대로 참조하여 일관성을 유지한다. 문제가 발생하면 관련 설계 문서를 확인하고, 필요한 경우 해당 경로나 섹션을 언급하며 해결한다.

개발 절차: 코딩을 시작하기 전에 구현 계획을 먼저 수립하고 AI로 하여금 그 계획을 스스로 검토하도록 한다. 작은 기능 단위로 Markdown 형태의 계획을 작성한 뒤, 빠진 부분이나 엣지 케이스가 없는지 AI의 자기 검토를 거쳐 개선한다
forgecode.dev
. 이렇게 계획을 확정한 후 구현에 착수하면 중간에 컨텍스트를 잃고 혼란을 겪는 상황의 80%를 예방할 수 있다
forgecode.dev
. 또한 테스트 주도 개발(TDD) 방식을 지향하여, 새로운 기능에 대해 우선 실패하는 테스트 코드를 작성하고(필요 시 AI에게 요청) 그 테스트를 통과시키는 방향으로 구현을 진행한다
forgecode.dev
. AI가 생성한 테스트 코드는 사람이 한 번 검토해 요구사항에 맞는지 확인하고, 이후 AI가 해당 테스트를 통과할 때까지 코드를 개선하도록 한다.

결정 로그 관리: 중요한 설계 결정이나 변경 사항은 Decision Log 등 별도의 로그에 기록한다. 각 세션에서 내린 결정과 그 근거를 로그에 추가하며(Append-Only), 이전 기록을 수정하거나 삭제하지 않는다. 이 결정 로그를 통해 다음 세션에서도 맥락과 의도를 공유하여 컨텍스트 손실 없이 일관된 개발이 가능하도록 한다.

AI 역할 및 책임 범위: AI는 주어진 설계와 요구사항 범위 내에서 구현에 집중하며, 자체적으로 새로운 아키텍처나 외부 라이브러리를 결정하지 않는다
forgecode.dev
. 시스템 설계, 아키텍처 결정, 기술 스택 선정 등 고차원 결정은 사람(개발자)이 주도하고 AI는 이에 따른 세부 구현을 담당한다. 보안상 중요한 코드나 데이터베이스 스키마 변경 등의 작업은 반드시 사람의 검토를 거친다. AI는 작업 중 발견한 잠재적 문제나 엣지 케이스를 보고하고, 해결 방안을 제안할 수 있지만 최종 결정은 사용자에게 맡긴다. 모든 규칙은 세션 전반에 걸쳐 지속적으로 적용되며, 어떤 경우에도 위 규칙을 무시하거나 위반하지 않는다.

🧼 제거 대상 항목 목록

기능 진행 상황 언급: SRS(Spaced Repetition System) 통합 중 등 특정 기능의 진행 상태나 완료 단계에 대한 언급 (예: "SRS 통합 진행 중", "N개 스테이지 완료" 등의 문구). 이러한 내용은 시간이 지나면 변경되는 일시적 정보이므로 제거합니다.

임시 지시사항 및 중간 목표: 현재 진행중인 작업의 TODO나 다음 단계 계획 등 불변 규칙이 아닌 내용 (예: "다음 단계로 ~~를 구현 예정" 등). 이러한 내용은 claude.local의 영구 규칙이 아니므로 모두 삭제합니다.

과거 세션 기록: 이전 AI 세션의 대화 요약이나 히스토리 등이 포함되어 있었다면 제거합니다. AI 헌법에는 컨텍스트 유지 방법은 명시하되, 구체적인 과거 대화 내용 자체는 포함하지 않습니다.

🌍 영어권 바이브코딩 실전 팁 반영 요약

사전 계획 수립 및 자기 검토: 코딩에 들어가기 전에 AI에게 먼저 기능 구현 계획을 제시하고 비판적으로 검토하도록 요청하는 방법이 권장됩니다. 이렇게 interface/기능 단위로 명확한 계획을 세운 후 시작하면, 중간에 AI가 혼선을 빚는 상황을 대폭 줄일 수 있다는 보고가 있습니다 (계획 수립만으로 혼란의 80%를 예방)
forgecode.dev
.

인터페이스 우선 설계: 영어권 커뮤니티에서는 Interface-First Design을 활용하는 사례가 있습니다. 개발자가 구성 요소별 **명세(인터페이스, 타입, 함수 시그니처)**를 먼저 정의하면, AI는 그 틀을 따라 세부 구현에 집중하게 됩니다. 변경 사항이 요구사항에 부합하지 않을 경우 폐기하거나 명세를 조정하면서, 설계(사람)와 구현(AI) 역할을 분리해 통제력을 유지합니다
reddit.com
. 이 방식은 다소 overhead가 있지만 AI에게 구현을 맡기면서도 전체 품질을 관리하는 데 효과적입니다.

테스트 주도 개발(TDD) 활용: AI 코딩 보조를 사용할 때 테스트를 먼저 작성하고 구현을 나중에 하는 접근이 효과적입니다. 예를 들어 필요한 기능에 대한 실패하는 테스트 케이스를 AI가 작성하게 한 뒤, 그 테스트를 통과하도록 코드를 개선시키는 방식입니다
forgecode.dev
. 개발자는 AI가 만든 테스트를 검토하여 요구사항이 정확히 테스트되고 있는지 확인하고, 이후 AI의 구현 결과가 해당 테스트를 모두 통과하면 기능이 요구대로 동작함을 보장받을 수 있습니다.

맥락 최소화 및 명확한 지시: 전체 코드베이스를 한꺼번에 프롬프트로 던지기보다는 필요한 부분만 콕 집어 지시하는 것이 정확도 향상에 중요합니다. 예컨대 버그 수정 요청 시 "코드 전체가 왜 안 되죠?"보다 "auth.js의 85번째 줄에서 JWT가 malformed일 때 None이 나와 발생하는 패닉을 고치고 에러 처리를 추가해줘"처럼 구체적인 파일 경로, 위치, 문제 상황을 언급합니다
forgecode.dev
. 또한 여러 파일을 보여줘야 할 땐 코드 블록을 복붙하기보다 파일 참조 기능을 사용해 현재 내용을 요약하게 하는 등 프롬프트 컨텍스트 용량을 효율적으로 사용하는 팁이 공유됩니다
forgecode.dev
. 이처럼 짧고 구체적인 프롬프트가 모호한 지시나 과도한 맥락 제공보다 훨씬 효과적입니다.

명확한 코딩 스타일 가이드 제시: AI에게 팀의 코딩 스타일을 사전에 명시하면 일관된 결과를 얻을 확률이 높아집니다. 예를 들어 "모든 public 함수에 Docstring 작성", "함수는 50줄 이내로 구현", "에러 처리 시 unwrap 사용 금지" 등의 규칙을 시스템 메시지로 알려주면, AI가 제시하는 코드의 형태와 품질이 팀 규칙에 맞춰집니다
forgecode.dev
. 영어권 개발자들은 이러한 스타일 가이드를 활용해 AI를 팀의 주니어 개발자처럼 훈련시키면, 코드 리뷰 부담을 줄이고 품질을 일정 수준 이상으로 유지할 수 있다고 조언합니다.

아키텍처 결정은 사람 몫: 고수준의 시스템 설계나 아키텍처 결정은 개발자가 직접 수행하고, AI는 그 결정 하에서 코드를 구현하도록 역할을 분담하는 것이 최적의 활용법으로 제시됩니다
forgecode.dev
. AI 모델은 구현력은 뛰어나지만 큰 그림을 잡고 장기적인 설계를 하는 데 한계가 있으므로, 프레임워크 선정이나 모듈 구조 결정 등은 사람이 주도해야 합니다. 이렇게 하면 AI가 구현 단계에서 높은 생산성을 발휘하면서도, 전체적인 일관성과 적합성은 사람이 통제할 수 있습니다.

기존 코드 재활용 및 일관성 유지: Reddit 등지의 vibe coding 팁에 따르면, 가능한 한 기존 코드를 수정·확장하고 새로운 코드 작성을 자제하는 것이 중요합니다. 갑작스럽게 전체 구조를 뒤엎거나 새로운 패턴으로 갈아엎기보다는, 현재 코드베이스의 스타일과 패턴을 유지하며 기능을 추가하라는 것입니다. 이러한 방식은 코드 중복을 예방하고, 단순하고 조직적인 코드를 촉진합니다
gist.github.com
. 변경 역시 한 번에 너무 많은 범위를 다루기보다 현재 작업(task)에 집중해서 국지적으로 수행해야 혼란을 줄일 수 있습니다. 특히 환경 설정 파일(.env 등)은 함부로 건드리지 말고, 외부 서비스 키 등은 안전하게 관리하며 필요 시 모킹은 테스트에서만 최소한으로 사용하는 등 환경에 대한 주의도 언급됩니다. 전반적으로 "DRY 원칙을 지키며, 큰 변화보다는 작은 개선을 반복하라"는 철학으로 요약할 수 있습니다.

Refined claude.local (AI Project Constitution)

📖 지속적 참조: 모든 응답에서 이 규칙들을 고려

🧠 컨텍스트 유지: 세션이 길어져도 초기 설정과 지식을 유지

🛡️ 일관성 보장: 중간에 다른 지시가 와도 기본 원칙을 준수

1. 세션 자동 초기화 지침 (Session Auto-Initialization)

프로젝트 컨텍스트 로드: 새 세션 시작 시 docs/PROJECT_CONTEXT.md를 읽어 최신 SRS(System Requirements)와 상황을 파악합니다.

결정 로그 확인: docs/DECISION_LOG.md를 읽어 최근 의사결정과 맥락을 이해합니다.

Git 상태 점검: 최근 커밋과 변경 파일을 확인하여 최신 코드를 반영합니다.

준비 완료 보고: 초기화 작업 후 “프로젝트 컨텍스트 파악 완료, 개발 작업 준비됨” 문구로 준비 완료를 알립니다.

2. 코드 작성 원칙 (Coding & Architecture Guidelines)

프로젝트 구조 준수: 코드 생성/수정 전에 반드시 PROJECT_STRUCTURE.md를 확인해 모듈 구조와 아키텍처 원칙을 따르세요. 새로운 기능은 기존 모듈을 대체하지 말고 플러그인처럼 추가될 수 있어야 합니다.

하드코딩 금지: 상수 값, 설정, 경로 등을 코드에 직접 작성하지 마세요. 환경변수나 설정 파일, DI(Dependency Injection)를 통해 주입받도록 구현합니다.

의존성 주입 사용: 서비스나 모듈을 생성할 때 new Class()로 직접 생성하지 말고, 인터페이스와 팩토리/레지스트리를 통해 주입받으세요. (예: registry.get('service-name') 패턴 활용)

플러그인 아키텍처: 기능 추가 시 기존 코드를 수정하기보다 플러그인으로 추가하세요. PluginManifest와 registry.registerPlugin() 등을 활용해 모듈을 느슨하게 결합합니다.

인터페이스 우선 설계: 코드를 작성하기 전에 먼저 인터페이스(IService, IProvider 등)를 정의하고, 구현체는 환경별로 교체 가능하도록 분리합니다.

모듈화 & 단일 책임: 한 파일/모듈은 하나의 책임만 가지며, 서로 순환 의존성이 없도록 구조를 유지합니다. 레이어 간 명확한 경계를 지키세요.

환경별 구성 분리: development / production / test 환경에 따라 다른 구현체나 설정을 사용할 수 있게 설계합니다. (if(env==='prod') 분기 대신 설정으로 제어)

이벤트/후킹 활용: 기능 확장은 이벤트 후크(registry.executeHooks)로 구현해 메인 로직에 영향 없이 부가 기능을 붙일 수 있게 합니다.

설정 기반 동작: 모든 동작은 설정(config 서비스 등)으로 제어 가능해야 합니다. 코드 수정 없이 설정 변경으로 기능 토글이나 파라미터 조정이 가능하도록 합니다.

기존 기능 호환 유지: 새로운 기능 추가 시 가능한 한 기존 인터페이스를 유지하고 Backward Compatibility를 확보합니다. 새로운 버전 도입은 Feature Flag나 Adapter 패턴으로 단계적으로 전환하세요.

중복 코드 최소화: 비슷한 코드가 3군데 이상 나오기 전까지는 추상화하지 않되, 한 기능 완성 후에는 10~20분 정도 리팩토링 시간에 중복 제거와 구조 개선을 시행합니다.

3. 순차적 학습 원칙 (Curriculum Sequential Learning Rules)

단계별 문법 한정: Stage N의 문장 생성 시 Stage 1~N까지 배운 문법만 활용하고, 이후 단계의 문법이나 어휘는 사용하지 않습니다.

상위 레벨 내용 금지: Level 2 단계에서는 Level 3 이상의 어떤 내용도 미리 도입하지 않습니다 (레벨 경계 준수).

점진적 복잡도 증가: 문장이 진행될수록 문법 복잡도가 조금씩 증가하도록 구성하되, 한 번에 너무 복잡한 구조를 도입하지 않습니다.

누락 없이 362단계: 전체 362개 Stage 체계를 순서대로 따르고, 각 Stage별로 50개 문장을 충족시킵니다.

선행학습 원칙 엄수: 이전 Stage에서 배운 내용은 적극 활용하되, 아직 배우지 않은 개념은 어떤 형태로든 등장시키지 않습니다.

검증 도구 활용: 생성한 문장은 scripts/validate-curriculum.js 등의 도구로 순차적 학습 원칙 준수 여부를 검증합니다.

4. AI와 인간 작업 분담 (MCP Task Delegation)

🤖 AI 우선 영역: 대량의 데이터 처리나 변환, 반복적인 코드/문서 생성, 포맷 변환 등의 고효율/저위험 작업은 AI가 주도합니다. 예: 수천 문장의 패턴 변환, 포맷 일괄 수정, 단순 반복 코딩 등.

🤝 신중 협업 영역: 리팩토링, 마이그레이션 재개, 설정 파일 수정 등 중간 위험 작업은 AI가 초안을 만들고 사람이 검토합니다. AI는 항상 변경 내역을 설명하고, 중요한 파일은 백업 후 수정합니다.

🚫 인간 담당 영역: 아키텍처 근본 설계, 핵심 비즈니스 로직 결정, UX 전략, 보안 정책 수립, 성능 최적화 전략, 외부 서비스 통합 등 고위험/전략 작업은 인간이 결정합니다. AI는 제안이나 보조만 합니다.

권한 및 승인: AI는 시스템에 치명적 영향을 줄 수 있는 변경(예: 대규모 삭제, 비용 발생 설정 변경)은 사용자 승인 없이 수행하지 않습니다. 필요한 경우 사용자에게 확인을 구하거나 안전한 대안을 제시합니다.

5. 코드 품질 및 테스트 체크리스트 (Quality & CI Checklist)

버전 관리: 의미 있는 작은 단위로 커밋하고, 커밋 메시지에 변경 의도를 명확히 남깁니다. PR 템플릿의 네이밍/복잡도/테스트/보안 항목을 충실히 따릅니다.

테스트 우선: 기능 추가 시 실패 경로를 포함한 단위 테스트를 작성하고, 통합 테스트로 주요 시나리오를 검증합니다. CI 파이프라인에서 lint, typecheck, test가 모두 통과해야만 머지합니다. (예: npm run lint 결과 0 error)

문서 동기화: 새로운 기능 구현이나 아키텍처 변경 시 관련 **설계 문서(README, ADR 등)**를 업데이트하고, PR에 문서 변경 내역을 포함시킵니다. 코드와 문서가 어긋나지 않도록 합니다.

보안 점검: API 키나 비밀은 .env에 분리하고 절대 코드에 노출하지 않습니다. 의존성의 보안 이슈를 정기적으로 점검하며, 개인정보(PII)는 로그에 남기지 않습니다.

성능 모니터링: 주요 API의 p95 지연 시간이 300ms 이내인지 확인하고, 병목이 있는 경우 원인을 파악해 개선 전략을 제안합니다. 불필요한 로그 출력이나 비효율 호출로 성능이나 비용을 악화시키지 않습니다.

모니터링 및 알림: 일일 API 사용량, 인스턴스 활성 시간 등을 모니터링하여 이상 징후(예: 과금 폭증, 오류 증가)를 감지하면 사용자에게 알립니다. App Engine 사용 시 automatic_scaling.max_instances 설정 등 비용 방지 장치를 확인합니다.

6. 아이디어 구현 프로세스 (Idea-to-Code Process)

요구사항 명확화: 새로운 기능 제안 시 AI는 먼저 해당 아이디어의 목적, 핵심 기능, 입출력 등을 사용자와 확인합니다. 모호한 부분은 질문하여 요구사항을 구체화합니다.

설계 초안 제시: 요구사항이 정리되면 시스템 구조를 모듈별로 설계 제안합니다. 주요 컴포넌트, 데이터 흐름, 인터페이스를 그림이나 글로 설명하고 사용자 검토를 받습니다.

계획 검토 및 수정: 사용자의 피드백을 받아 설계를 보완합니다. 누락된 기능이나 잘못된 가정이 없는지 자기 점검 질문을 통해 확인하고, 필요한 경우 AI 스스로 "놓친 부분은 없을까요?"를 자문하여 개선합니다.

작은 사이클로 구현: 개발은 기능을 작은 단위로 나누어 **짧은 사이클(코딩→테스트→커밋)**로 진행합니다. 각 사이클 완료 시 진행 상황을 요약하고 다음 단계 계획을 세워 공유합니다.

검증 및 피드백 반복: 구현 중간중간 결과물을 테스트하고, 사용자의 추가 피드백을 받아 수정합니다. 모든 기능 구현 후 전체 테스트를 수행하고 품질 기준을 만족하는지 확인합니다.

지속적 개선: 과정에서 발견된 개선점(리팩토링 가능 영역, 성능 이슈, 코드 냄새 등)은 백로그에 기록하거나 즉시 개선합니다. 항상 추가 개선 여지를 탐색하며 프로젝트 품질을 높입니다.

7. 결정 기록 및 변경 관리 (Decision Logging)

의사결정 로그 업데이트: 아키텍처 변경, 주요 기능 추가/수정, UI/UX 큰 개선, 새로운 제약 도입, 개발 프로세스 변경, 중요한 리팩토링 등을 할 경우 반드시 DECISION_LOG.md에 기록을 남깁니다. 사소한 테스트 수정이나 일회성 디버깅은 기록하지 않습니다.

기록 형식: 로그는 다음 템플릿을 따릅니다:

## 🎯 YYYY-MM-DD: [작업/결정 제목]
### [변경사항 또는 기능 이름]
**결정**: 무엇을 결정하거나 변경했는지.  
**맥락**: 왜 이러한 결정에 이르게 되었는지 (배경, 고려했던 대안).  
**구현**: 어떤 방식으로 구현 또는 변경했는지.  
**결과**: 기대효과 또는 이후 영향은 무엇인지.


예시: 날짜와 작업 제목을 대제목으로 쓰고, 하위에 변경 기능명을 소제목으로 쓴 뒤 결정/맥락/구현/결과를 기술.

커밋 기록 연계: Git 커밋 메시지에는 무엇을 했는지만 요약하고, 왜와 어떻게는 결정 로그에 자세히 기록합니다. 중요한 결정을 내린 커밋은 결정 로그 섹션과 연계되도록 메시지에 참조합니다.

문서 보존: 장기 참고를 위해 보존할 가치가 있는 옛 문서나 기록은 archive/ 폴더에 이동시키고, 더 이상 사용되지 않는 중복/구버전 파일은 정리합니다. (예: 과거 완료 보고서는 archive_duplicates/에 보관)

8. 현재 우선순위 및 특이사항

스테이지 문장 생성: 현재 레벨별 362개 Stage 중 약 104개는 완료되었으며, 남은 294개 Stage의 예문 생성 작업이 남아 있습니다. AI는 순차적 학습 원칙을 엄격히 지키면서 각 Stage당 50개 문장을 생성하는 작업을 우선적으로 지원합니다. 검증 스크립트 (validate-curriculum.js)를 활용하여 품질을 확인합니다.

기능 개발 우선: 통합 작업이나 문서 정리는 차순위이며, 현재는 핵심 기능 개발과 데이터 생성 작업에 집중합니다. 필요 시 통합 정리는 추후에 진행합니다.

모델 및 데이터 최신화: GPT/Claude 등 AI 모델 파라미터, 단어 리스트 및 패턴 데이터셋은 정기적으로 최신화해야 합니다. STT/TTS 엔진도 최신 버전과 품질을 점검합니다. 망각곡선 스케줄러(Firebase 기반)의 로그 누락이나 오류를 주기적으로 확인합니다.

배포 비용 유의: App Engine 배포 시 automatic_scaling.max_instances 등 과금 방지 설정을 반드시 확인하고, TTS/STT 호출은 가능하면 클라이언트에서 직접 수행하여 이중 과금을 피합니다. 불필요한 상시 인스턴스가 돌고 있지 않도록 크론 작업은 Cloud Functions/Scheduler로 대체합니다. 일일 예산 알림을 설정해 비용 폭증을 모니터링합니다.

🔄 정리: 제거 또는 이동할 항목

프로젝트 세팅 정보 (개발 서버 주소, 명령어 등): 이러한 내용은 개발자용 README나 docs/project_setup.md에 포함하고, claude.local에는 두지 않습니다. 예를 들어 포트 번호, 실행 명령 (npm run dev 등)은 README에서 참고하면 됩니다.

데이터 마이그레이션 절차 (중단 시 대응법 등): 상세 단계 (예: npm run migrate:status → migrate:unlock → migrate:resume 등)는 docs/migration/README.md에서 관리하고, claude.local에서는 제외합니다. 필요 시 AI가 해당 문서를 찾아보도록 합니다.

커리큘럼 재구성 완료 보고 (일시, 문서 경로, 통계 등): 프로젝트 진행 상황에 대한 기록은 결정 로그나 별도 보고서에 보관하고, 더 이상 참조가 필요없는 세부 수치는 claude.local에서 제거합니다. (예: 31,456개 문장 분석 완료 등의 내용)

커리큘럼 구조 설명 (이원화 구조, SSOT 파일 설명 등): 교육 컨텐츠 구조와 각 파일의 역할에 대한 상세 설명은 개발자 문서 (docs/curriculum/STRUCTURE.md 등)에 둡니다. claude.local에는 핵심 원칙(예: "메인 교육 콘텐츠 vs 시스템 검증 데이터의 분리")만 간략히 언급하고 세부 내용은 제거합니다.

AI/Human 역할분담 세부전략 (MCP 상세 목록): 큰 원칙은 claude.local에 요약했으므로, 세부 예시나 추가 설명(예: 어떤 작업이 High Value/Low Risk인지 나열한 부분)은 별도의 설계 문서나 가이드에 기록하고 여기서는 생략합니다.

상세 코드 품질 체크리스트: 일반적인 코드 품질 사항은 요약해서 유지하고, 장황한 목록(예: 10만줄 프로젝트 관리 세부 항목)은 기여자 가이드 (CONTRIBUTING.md나 docs/quality_checklist.md)로 옮깁니다. claude.local에는 중복되는 항목을 제거해 간결성을 유지합니다.

아이디어→코드 프로세스 세부 가드레일: 12가지 세부 수칙 등 상세 내용은 내부 프로세스 문서로 이동합니다. claude.local에는 핵심 흐름 (요구사항→설계→구현 사이클 및 검증 루프)만 남기고, 나머지 세부 항목(예: 에러 타입 정의 코드, PR 체크리스트 예시 등)은 docs/development_process.md 등에 정리합니다.

App Engine 비용 절감 체크리스트: 구체적인 설정값 예시나 코드 블록은 배포 가이드 (docs/deployment/cost_optimization.md)로 분리합니다. claude.local에는 "배포 시 비용 유의" 정도만 언급하고, 세부 항목(예: .gcloudignore에 무엇을 넣는지 등)은 문서에서만 관리합니다.

아키텍처 원칙 상세 내용: DI/플러그인 패턴에 대한 장황한 예시 코드와 단계별 마이그레이션 전략 등은 아키텍처 가이드 (docs/architecture/principles.md)로 옮깁니다. claude.local에는 핵심 원칙만 나열하고, 구체 구현 예시는 제거하여 간결함을 유지합니다.

@@


DASI English 프로젝트 바이브코딩 개선을 위한 심층 리서치
1. 왜 이 가이드가 필요한가? (개요 및 문제 상황)

DASI English는 AI 기반의 방대한 영어 학습 플랫폼으로, 프론트엔드(web_app), 백엔드(backend), 문서(docs) 등 여러 폴더로 구성되어 있습니다
GitHub
. 개발 과정에서 바이브코딩(Vibe-coding, AI와의 협업 코딩)을 활용하고 있으나, 다음과 같은 비효율과 문제점이 나타났습니다:

세션 컨텍스트 단절과 기록 분산: 새로운 AI 채팅 세션을 시작할 때마다 이전 대화 맥락이 사라지고, AI가 기존 코드를 참조하지 못한 채 중복된 파일이나 폴더를 생성하는 경향이 있습니다. 그 결과 useSpacedRepetition.ts와 유사한 SRS(Spaced Repetition System) 로직 파일이 여러 개 생기는 등 코드 중복이 발생했습니다
GitHub
GitHub
. 또한 매 세션마다 decision_log.md나 work.md와 같은 유사한 결정 기록 파일이 새로 만들어져, 프로젝트 전반에 “단일한 진실의 원본(SSOT, Single Source of Truth)”이 없어졌습니다.

중복 구현 및 설계 부재: 프론트엔드 훅(useSpacedRepetition.ts)에서는 망각곡선 간격을 하드코딩하여 복습 일정을 계산하고 로컬 스토리지에 저장하는데
GitHub
GitHub
, 서비스 레이어(reviewAlgorithm.ts나 srsService.ts)와 백엔드(smartReviewService.js)에서도 SuperMemo SM-2 알고리즘 기반의 복습 로직을 각각 다시 구현하고 있습니다
GitHub
GitHub
. 동일한 기능을 하는 코드가 프론트엔드와 백엔드에 걸쳐 최소 세 곳 이상 중복되면서, 로직 수정 시 모든 장소를 일일이 변경해야 하고 유지보수가 어려워졌습니다. 예를 들어, 프론트 훅은 1일→3일→7일→14일로 고정된 4단계 복습 일정을 사용하지만
GitHub
GitHub
, 웹 서비스 계층과 백엔드에서는 정답 품질에 따라 간격과 easeFactor를 동적으로 조정하는 SM-2 방식을 사용하고 있습니다
GitHub
GitHub
. 이러한 불일치는 시스템의 일관성을 해칩니다.

설계/문서화 부족: 현재 README나 기존 문서에는 프로젝트 구조와 기능 소개가 간략히 기술되어 있을 뿐, 각 모듈의 구체적인 책임, 인터페이스(입출력), 내부 설계 원칙이 명확히 문서화되어 있지 않습니다. README에는 폴더 구조 등이 소개되어 있지만 상세 아키텍처 설명이나 모듈 간 관계 정리가 미흡합니다
GitHub
. 또한 앞서 언급한 대로 여러 세션에 걸쳐 설계 결정이 여러 개의 로그 파일로 분산되어 있어, 어느 것이 최신 결정 사항인지 파악하기 어렵습니다.

이러한 문제들은 바이브코딩 활용 시 초기 아키텍처 확립과 지속적 컨텍스트 공유의 중요성을 보여줍니다. 본 가이드는 DC Inside 개발자 커뮤니티에서 공유된 바이브코딩 성공 팁들을 바탕으로, DASI English 프로젝트의 SRS 엔진 통합을 최우선 과제로 하여 전반적인 개발 프로세스와 코드 품질을 개선하는 구체적인 방안을 제시합니다. (전체 아키텍처 개선과 문서화 정비 등도 다루지만, 우선순위는 SRS 로직의 Single Source of Truth 확립입니다.)

2. 핵심 문제점 (요약 정리)

SRS 엔진 로직의 중복 구현: 현재 프론트엔드와 백엔드에 걸쳐 망각곡선 알고리즘이 여러 번 반복 구현되어 있습니다. 프론트 훅인 useSpacedRepetition.ts에서는 1일/3일/7일/14일 간격의 고정 복습 일정을 사용하며 오답 시 1일로 리셋합니다
GitHub
GitHub
. 한편 프론트 서비스 ReviewAlgorithmService와 SRSService, 백엔드 서비스 SmartReviewService는 SuperMemo SM-2 알고리즘을 사용하여 첫 복습 1일, 두 번째 6일, 이후 easeFactor에 따른 증가 및 오답 시 간격 초기화를 수행하는 유사한 코드를 각각 가지고 있습니다
GitHub
GitHub
. 예를 들어 모든 구현체가 “첫 복습 1일, 두 번째 6일” 규칙을 중복으로 정의하고 있으며, easeFactor 조정 공식 또한 곳곳에 반복되어 있습니다
GitHub
GitHub
. 이러한 중복과 불일치로 인해 로직 수정 시 누락 위험이 있고, 알고리즘이 한쪽에서는 업데이트되어도 다른 부분에 적용되지 않을 수 있습니다.

세션 컨텍스트 손실로 인한 비일관성: AI를 활용한 바이브코딩 과정에서, 새로운 채팅 세션마다 이전 코드 설계 맥락이 전달되지 않아 이미 존재하는 모듈을 무시하고 새로운 파일을 만드는 오류가 발생했습니다. 그 결과, 예를 들어 이미 있는 useSpacedRepetition 훅과 별개로 ReviewAlgorithmService나 srsService 등이 만들어져 동일 기능을 이중 구현하게 되었습니다. 또한 의사결정 기록도 DECISION_LOG.md, work.md, SESSION_SUMMARY_...md 등 여러 파일에 분산되는 문제가 있었습니다. 이런 컨텍스트 단절은 개발자가 “어떤 방향으로 설계 중이었는지”를 추적하기 어렵게 하고, 협업 AI의 혼선을 가중시킵니다.

설계 원칙 미준수와 문서화 부족: 프로젝트 전반에 걸쳐 각 모듈의 역할, 상호 인터페이스, 데이터 흐름이 명확히 정의되어 있지 않습니다. 초기 아키텍처 설계 단계의 부재로 인해, 유사 기능이 군데군데 퍼져 있고 (예: SRS 로직) 모듈 간 경계가 모호합니다. 또한 README와 일부 문서에서 큰 그림 소개는 있지만, 세부 구현 결정이나 모듈 계약(spec)이 체계적으로 문서화되지 않았습니다. 예를 들어 SRS 엔진과 관련된 프론트/백엔드 모듈 간 API 계약, 데이터 포맷 등에 대한 공식 문서를 찾기 어렵습니다. 이는 AI와 개발자 모두에게 일관된 가이드라인 부재를 야기하여, 세션마다 다른 제안이나 구현으로 빗나가는 원인이 됩니다.

요약하면, “하나의 시스템을 여러 개의 AI 세션이 제각기 만들고 있었다.” 이것을 해결하려면, SSOT 철학 아래 중복을 제거하고, 초기 설계를 공고히 문서화하며, AI에게 컨텍스트를 지속적으로 주입하는 개발 문화로 전환해야 합니다.

3. DC 커뮤니티에서 제안된 바이브코딩 성공 원칙 (요약)

국내 개발자 커뮤니티(DC Inside)에서 공유된 바이브코딩 팁들을 종합하면, AI와의 협업 개발에는 아래와 같은 아키텍처 원칙과 전략이 중요합니다:

🗺️ 초반 충분한 설계: 기능을 구현하기 전에 아키텍처 청사진을 그립니다. 주요 모듈을 식별하고 각자의 책임과 인터페이스를 명확히 정의하세요. 초기 설계 단계에 시간을 투자하는 것이, 이후 AI가 해당 틀 내에서 코딩하도록 유도하는 핵심입니다. 모듈 교체가 용이하도록 추상화 계층을 두고, 결합도를 낮춘 플러그인 구조를 지향합니다.

🔖 단일한 진실의 원본(SSOT): 동일한 기능은 오직 한 곳의 코드에서만 구현하고, 다른 곳에서는 그것을 가져다 쓰도록 합니다. 같은 로직의 여러 버전을 만들지 않기 위해, 불가피한 복사본이 생기면 deprecated 폴더로 이동하거나 AI에게 금지할 파일 목록을 사전에 알려줍니다. 항상 하나의 모듈만 수정하면 전체 시스템에 적용되도록 구조를 유지합니다.

📝 지속적인 문서화와 공유: todo.md나 DECISION_LOG.md 등 단일 문서에 의사결정과 진행 상황을 기록하여, 다음 AI 세션에서도 반드시 참조하게 합니다. 새로운 세션을 시작한다고 새로운 로그 파일을 만들지 않도록 하고, 로그는 append-only 방식으로 한 파일에 계속 축적합니다. 또한 각 기능/모듈별 설계 스펙 문서를 작성해, AI가 모듈 구현 시 참고하도록 유도합니다.

🔄 작은 사이클로 완결 개발: “설계 → 구현 → 테스트 → 문서” 사이클을 너무 크게 잡지 말고, 작은 기능 단위로 끊어서 끝까지 완수하고 커밋까지 하는 것을 권장합니다. 하나의 기능을 완료하기 전에 AI 세션이 종료되면 컨텍스트가 끊기므로, 될 수 있으면 한두 시간 내에 소규모 사이클을 돌려 결과물을 확정하는 식으로 진행합니다. 이는 맥락 소실을 줄이고, 부분 완료물이라도 쌓이게 하는 효과가 있습니다.

🧹 리팩토링 및 테스트 주기: 기능이 동작한 후에는 주기적으로 리팩토링을 거쳐 코드 중복, 부정확한 네이밍 등을 개선하고, 그 과정에서 단위 테스트를 추가해 기술 부채를 상환합니다. 바이브코딩 초기에는 속도에 집중하기 쉽지만, 일정 주기로 코드품질 점검 (Lint/타입 체크)과 중요한 로직의 테스트를 도입해야 장기적으로 AI 도움 개발이 안정화됩니다.

이러한 원칙들은 DASI English 프로젝트의 현 문제 해결에도 직접 적용될 수 있습니다. 특히 SSOT 확립과 설계 문서화는 중복 SRS 엔진 문제를 푸는 열쇠이며, 작은 구현 사이클과 AI 프롬프트 관리는 세션 컨텍스트 문제에 대한 방책입니다.

4. 개선을 위한 단계별 로드맵

아래 로드맵은 문제 해결을 위한 단계를 설계 문서화(4.1) → SRS 엔진 통합(4.2) → 세션 컨텍스트 유지(4.3) → 코드 품질/테스트 강화(4.4) → 운영상의 개선(4.5) 순으로 정리합니다. 특히 4.2 SRS 시스템 통합에 최우선 순위를 두었으며, 나머지 개선사항은 이를 뒷받침하거나 이후 병행 추진합니다. 각 단계에는 구현 가이드, 예시 코드 또는 다이어그램, 그리고 실행 계획 표를 포함하여 Claude CLI 등의 AI 에이전트가 바로 작업을 수행할 수 있을 정도로 구체적인 지침을 제공합니다.

4.1. 아키텍처 청사진 수립 및 문서화 일원화

(1) 최상위 맥락 문서 정비: 프로젝트 전반의 구조와 원칙을 담은 상위 문서를 만들고, AI가 모든 세션에서 이를 참조하도록 강제합니다. 예를 들어 docs/PROJECT_CONTEXT.md를 생성하여 전체 시스템 구성 요소와 각 모듈의 책임을 일람 표 형태로 정리합니다. 여기에는 프론트엔드 훅/컴포넌트, 백엔드 서비스, 학습 알고리즘 엔진, 데이터베이스 등 주요 컴포넌트가 무엇이며 어떻게 협력하는지 기술합니다. 또한 “금지 규칙” 섹션을 둬서 AI가 새로 만들지 말아야 할 파일이나 규칙을 명시합니다. (예: ❌ useSpacedRepetitionV2.ts 생성 금지, ❌ services/learning/ 디렉터리 추가 금지 등.)

그리고 docs/DECISION_LOG.md를 프로젝트 결정의 Single Source of Truth로 삼습니다. 이전에 난립한 decision_log_***.md나 work.md, 세션 별 summary 문서들을 모두 이 파일로 병합하세요. 과거 로그 파일들은 docs/archived_logs/ 폴더를 만들어 보관하고, 앞으로의 모든 AI와의 대화 결정은 이 한 파일에 Append-only로 추가합니다. 새로운 대화를 시작할 때마다 AI에게 다음과 같이 지시합니다:

프롬프트 예시: “작업을 시작하기 전에 docs/PROJECT_CONTEXT.md와 docs/DECISION_LOG.md 내용을 숙지하세요. 새로운 파일을 만들지 말고, 정해진 싱글 소스 모듈을 확장하거나 수정하여 기능을 추가하세요.”

위와 같은 안내를 시드 프롬프트로 활용하여, AI가 반드시 최신 설계 맥락을 가지고 작업하게 합니다. 이로써 세션이 달라져도 설계 의도가 일관되게 전달됩니다.

(2) 모듈별 API/스펙 문서 작성: 각 주요 모듈이나 도메인 로직에 대한 스펙 문서를 만들어 둡니다 (docs/specs/ 또는 docs/api/ 디렉토리 등 활용). 예를 들어 SRS 엔진, TTS 엔진, 학습 레벨 관리 모듈 등에 대해, 입력과 출력, 해당 모듈의 책임과 비즈니스 규칙을 문서화합니다. 이를테면 “SRS Engine Spec” 문서에는 함수 시그니처(calculateNextReview, scheduleReview 등), 입력 데이터 구조(CardData, ReviewResult 등), 출력 값의 의미(다음 복습 날짜 계산 방법) 등을 명시합니다. 이러한 스펙 문서는 AI가 코드를 구현하거나 수정할 때 참고 문맥으로 제공되어 혼선이 줄어듭니다.

특히 SRS 관련 프론트 훅과 백엔드 서비스 간에 계약(interface) 명세를 정리하십시오. 예를 들어, 프론트엔드 useSpacedRepetition 훅과 백엔드 SmartReviewService가 동일한 SRS 엔진 알고리즘을 따른다면, 둘 사이에 주고받는 데이터 포맷 (예: mistakeId, qualityScore, nextReview 필드 등)이 일치해야 합니다. 이러한 계약을 문서화하면, AI도 그 포맷대로 구현을 맞추게 됩니다.

(3) 아키텍처 다이어그램 작성: 문서에 ASCII 아키텍처 다이어그램을 포함하여, 주요 모듈 간 관계와 데이터 흐름을 시각화합니다. 아래는 목표로 하는 SRS 엔진 통합 구조에 대한 예시 ASCII 다이어그램입니다.

Frontend (React)                             Backend (Node.js/Firebase)
---------------------                       ----------------------------
| useSpacedRepetition (Hook) |             | SmartReviewService (API)   |
|  - calls SRS Engine        |             |  - calls SRS Engine        |
|  - uses LocalStorage       |             |  - uses Firestore DB       |
---------------------                       ----------------------------
             \                               /
              \    +--------------------+    /
               ----|   SRS Engine Core  |----      <<-- 중앙 통합 SRS 알고리즘 모듈
                   |  (shared logic)   |
                   +---------+----------+
                             |
               +-------------+---------------+
               |        Storage Interface     |         <<-- 저장소 추상 계층
               +-------------+---------------+
                             |
            -----------------+--------------------
            |                                  |
   +----------------------+         +-----------------------+
   | LocalStorageBackend  |         | FirestoreBackend      |
   | (implements SRS      |         | (implements SRS       |
   |  Storage interface)  |         |  Storage interface)   |
   +----------------------+         +-----------------------+


위 다이어그램에서 볼 수 있듯이, SRS Engine Core 모듈이 모든 SRS 로직을 단일 구현으로 담고, 프론트엔드와 백엔드는 이를 호출만 하도록 합니다. 엔진은 추상화된 Storage Interface를 통해 데이터 저장소에 접근하므로, 로컬 스토리지나 Firestore 등 환경에 따라 다른 구현체를 주입할 수 있습니다. 결과적으로 Frontend 훅, Service 레이어, Backend 서비스가 동일한 엔진 함수를 호출하여 복습 일정을 계산하게 되므로, 로직의 일관성이 보장됩니다.

(4) 액션 플랜 표 작성: 개선 작업을 수행하는 과정을 팀과 AI가 공유하기 쉽게, 단계별 작업 항목을 표로 정리합니다. 각 행에는 단계 번호, 작업 내용, 담당자, 비고(참고 사항) 등을 기입하세요. 예시:

단계	작업 내용	담당	비고 (방법/도구)
1	SRS 관련 코드 위치 전수 조사	🟢 백엔드
🟢 프론트	grep으로 "review", "forgetting", "interval" 등 키워드 검색 (프론트 web_app, 백엔드 backend)
2	중앙 SRS 엔진 모듈 설계 및 인터페이스 정의	🟢 설계 담당
🟢 FE 리드	docs/specs/SRS_ENGINE.md 작성 – 함수 시그니처, 데이터 구조 명시
3	SRS Engine 코어 모듈 구현	🟢 프론트 개발자	src/services/srs/engine.ts 생성 – SM-2 알고리즘 구현 (테스트 포함)
4	Storage 인터페이스 및 구현체 작성	🟢 프론트 개발자
🔵 백엔드 개발자	SRSStorage 인터페이스 정의;
LocalStorageBackend (FE), FirestoreBackend (BE) 구현
5	기존 SRS 코드 리팩토링 (엔진 활용)	🟢 프론트 개발자
🔵 백엔드 개발자	useSpacedRepetition.ts, reviewAlgorithm.ts, smartReviewService.js 등에서 중복 로직 제거, 엔진 호출로 대체
6	문서 및 금지 규칙 업데이트	🟢 설계 담당	docs/PROJECT_CONTEXT.md에 새로운 구조 반영;
DECISION_LOG.md에 변경 기록 추가; AI 프롬프트 지침 갱신
7	테스트 및 검증	🟢 QA/테스트
🟢 개발자	SRS 엔진 단위 테스트, 통합 테스트 실행;
기존 사용자 데이터 마이그레이션 여부 확인
8	코드 품질 도구/CI 적용	🔵 백엔드 개발자
🟢 프론트 개발자	ESLint/Prettier 설정 업데이트, GitHub Actions CI에 테스트 워크플로 추가

(표 설명: 🟢는 주작업 담당, 🔵는 협업 또는 검토 담당 예시)

위와 같은 Action Plan을 통해 팀원들과 AI 모두 현재 어느 단계를 하고 있는지 명확히 인지하게 됩니다. 특히 AI에게는 "지금 Plan의 3단계를 구현해"와 같이 지시할 수 있고, AI도 해당 맥락에서 작업 결과를 DECISION_LOG.md에 기록하게 할 수 있습니다.

4.2. SRS 시스템 통합 (최우선 과제)

중복 구현된 SRS(Spaced Repetition) 로직을 하나의 중앙 엔진 모듈로 통합하는 단계입니다. 이 작업이 핵심 우선순위이며, 이를 통해 앞서 식별된 중복 코드 문제를 해결하고자 합니다. 구체적인 수행 방안은 다음과 같습니다:

(1) 중복 SRS 로직 식별 및 제거 대상 선정: 앞서 조사한 결과, SRS 알고리즘 관련 로직이 존재하는 곳은 최소 네 군데입니다:

프론트엔드 훅: web_app/src/hooks/useSpacedRepetition.ts – 고정 4단계 간격 사용
GitHub
.

프론트엔드 서비스: web_app/src/services/reviewAlgorithm.ts – SM-2 알고리즘 구현 (품질 점수 기반)
GitHub
.

프론트엔드 SRS 관리: web_app/src/services/srsService.ts – SM-2 알고리즘 유사 구현 (로컬 스토리지 사용)
GitHub
.

백엔드 서비스: backend/src/services/smartReviewService.js – SM-2 알고리즘 구현 (Firestore 사용)
GitHub
.

이 중 reviewAlgorithm.ts와 srsService.ts, smartReviewService.js는 모두 SuperMemo 기반으로 로직이 상당 부분 중복/유사합니다. useSpacedRepetition.ts는 로컬 저장소 기반의 간이 알고리즘이지만, 결국 “오답 시 1일로 리셋” 등 기본 원칙은 SM-2의 하위집합이라 볼 수 있습니다. 따라서 이 네 곳을 모두 통합 대상으로 정합니다. 앞으로는 단 하나의 SRS Engine 모듈에서 로직을 구현하고, 다른 코드는 이를 호출만 하도록 변경할 것입니다.

(2) 공통 SRS 엔진 모듈 설계: src/services/srs/engine.ts (혹은 유사 경로)에 새로운 SRS 엔진 코어 모듈을 만듭니다. 이 모듈은 순수 비즈니스 로직만 담당하며, 외부 환경(React 훅이나 DB 등)에 의존하지 않도록 합니다. 구체적으로:

SRS 엔진은 예를 들어 SRSEngine 클래스 또는 함수 집합으로 구현합니다.

calculateNextReview(cardData, performance): ReviewOutcome 와 같은 핵심 함수를 제공합니다. 여기서 cardData는 현재 항목의 상태(예: 이전 간격, 반복 횟수, easeFactor 등)를 담고, performance는 이번 학습 결과(정답여부, 응답시간 등)를 담습니다. 반환값 ReviewOutcome에는 업데이트된 interval, easeFactor, nextReviewDate 등이 포함됩니다.

가능하다면 알고리즘 파라미터(예: 첫 번째 간격 1일, 두 번째 6일 등의 상수)도 상수화하여 관리하거나 외부에서 주입 가능하도록 해두면 향후 조정에 용이합니다.

예시 코드 설계 (TypeScript 형태):

// src/services/srs/engine.ts
export interface CardState {
  intervalDays: number;     // 현재 복습 간격 (일 기준)
  easeFactor: number;       // 현재 ease factor (난이도 계수)
  repetitions: number;      // 현재까지 연속 정답 횟수 (또는 reviewCount)
  strength?: number;        // (선택) 기억 강도 지표
}

export interface ReviewResult {
  accuracy: number;         // 정답 정확도 (0~1)
  difficulty: 'easy' | 'medium' | 'hard';
  responseTime: number;     // 응답 시간 (초)
  isCorrect: boolean;       // 정답 여부 (혹은 accuracy 기준 판정)
}

export interface NextReviewOutcome {
  newInterval: number;
  newEaseFactor: number;
  newRepetitions: number;
  newStrength?: number;
  nextReviewDate: Date;
}

export class SRSEngine {
  // SuperMemo SM-2 기반 다음 복습 계산 메서드
  calculateNextReview(current: CardState, result: ReviewResult): NextReviewOutcome {
    const { intervalDays, easeFactor, repetitions } = current;
    const { accuracy, difficulty, responseTime, isCorrect } = result;
    // 1. 품질 점수 계산 (0~5 정수)
    const quality = this.calculateQuality(accuracy, difficulty, responseTime);
    let newEase = easeFactor;
    let newInterval = intervalDays;
    let newReps = repetitions;
    let newStrength = current.strength ?? 0.5;

    if (quality >= 3) {
      // 성공적인 복습
      if (newReps === 0) {
        newInterval = 1;
      } else if (newReps === 1) {
        newInterval = 6;
      } else {
        newInterval = Math.round(intervalDays * easeFactor);
      }
      newReps += 1;
      // ease factor 조정
      newEase = Math.max(1.3, easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02)));
      // (선택) 기억 강도 증가
      newStrength = Math.min(1.0, newStrength + (quality / 5) * 0.3);
    } else {
      // 실패한 복습
      newInterval = 1;
      newReps = 0;
      newEase = Math.max(1.3, easeFactor - 0.2);
      // (선택) 기억 강도 감소
      newStrength = Math.max(0.1, newStrength - ((3 - quality) / 5) * 0.4);
    }
    // 다음 복습 날짜 계산
    const nextReviewDate = new Date();
    nextReviewDate.setDate(nextReviewDate.getDate() + newInterval);

    return {
      newInterval,
      newEaseFactor: newEase,
      newRepetitions: newReps,
      newStrength,
      nextReviewDate
    };
  }

  private calculateQuality(accuracy: number, difficulty: string, responseTime: number): number {
    // (프론트/백엔드의 calculateQuality 로직 통합)
    let qualityScore = Math.round(accuracy * 5);
    // 응답 시간 가중치
    if (responseTime < 3) {
      qualityScore *= 0.8;
    } else if (responseTime <= 7) {
      qualityScore *= 1.0;
    } else if (responseTime <= 15) {
      qualityScore *= (1.0 - (responseTime - 7) / 20);
    } else {
      qualityScore *= 0.6;
    }
    // 난이도 가중치
    const diffWeight = { easy: 0.8, medium: 1.0, hard: 1.2 };
    qualityScore *= diffWeight[difficulty] || 1.0;
    // 0~5 범위 반올림
    return Math.max(0, Math.min(5, Math.round(qualityScore)));
  }
}


(주의: 위 코드는 개념 전달을 위한 부분적 예시입니다. 실제 구현 시 현재 프로젝트 코드 스타일과 통일하고, 필요시 Type/interface 조정 필요.)

위 SRSEngine 클래스의 calculateNextReview 메서드는 이미 존재하는 세 곳의 SM-2 알고리즘 코드를 한데 모은 것입니다. 첫 복습 1일, 두 번째 6일 이후 easeFactor 곱 적용 로직이 통합되었고, easeFactor 최소값 1.3 적용과 오답 시 간격 1일 리셋 등의 규칙도 하나의 진실로 정의됩니다. 또한 calculateQuality 메서드를 통합하여, 프론트와 백엔드에서 약간씩 다르게 쓰였을 가능성이 있는 “응답 시간에 따른 가중치 계산”도 일치시켰습니다
GitHub
GitHub
. 이렇게 함으로써 앞으로 품질 점수 계산 방식이나 간격 산정 방식을 변경해야 할 때 한 곳만 고치면 되도록 합니다.

(3) 저장소 추상화 계층 도입: SRS 엔진은 로직만 담당하고 실제 데이터를 어디에 저장할지는 신경 쓰지 않도록, Storage Interface를 설계합니다. 예컨대 SpacedRepetitionStorage라는 인터페이스를 정의하고, saveCard(userId, cardId, state)나 loadCard(userId, cardId) 등의 메서드를 선언합니다. 프론트엔드에서는 이 인터페이스의 구현체로 LocalStorageBackend를 만들어 localStorage에 데이터를 get/set하고, 백엔드에서는 FirestoreBackend를 구현하여 Firestore DB에 데이터를 읽고 씁니다. 둘 다 SpacedRepetitionStorage를 구현하므로, SRS 엔진 코드에서는 storage.saveCard(...)처럼 같은 방식으로 호출하고, 실제 동작은 주입된 구현에 따라 다르게 수행됩니다.

이 패턴을 적용하려면 프론트엔드 훅/서비스에서 SRS 엔진을 초기화할 때 적절한 Storage 구현을 넘겨줘야 합니다. 예를 들어:

// 프론트엔드 초기화 코드 (예: useSpacedRepetition 훅 내부)
const engine = new SRSEngine();
const storage: SpacedRepetitionStorage = new LocalStorageBackend();
...
// 복습 완료 처리 예시:
function onReviewComplete(item: MistakeItem, isCorrect: boolean) {
  const performance: ReviewResult = { 
    accuracy: isCorrect ? 1 : 0, 
    difficulty: item.difficulty, 
    responseTime: item.lastResponseTime, 
    isCorrect 
  };
  const outcome = engine.calculateNextReview(item, performance);
  // item 및 outcome 기반으로 MistakeItem 갱신
  item.intervalDays = outcome.newInterval;
  item.easeFactor = outcome.newEaseFactor;
  item.reviewCount = outcome.newRepetitions; 
  item.nextReview = outcome.nextReviewDate.getTime();
  ...
  storage.saveCard(userId, item.id, item);
}


위의 흐름에서 볼 수 있듯, engine.calculateNextReview로 얻은 결과를 가지고 현 상태를 업데이트하고, storage.saveCard로 저장 처리합니다. 백엔드의 경우에도 SmartReviewService에서 비슷하게 엔진을 써서 결과를 얻고 FirestoreBackend.saveCard 등을 호출하면 됩니다. 핵심은 엔진은 동일하게 쓰이고, storage 구현만 다르게 주입된다는 점입니다.

(4) 기존 모듈들의 리팩토링: SRS 엔진 및 인터페이스 구현이 준비되면, 이제 기존 코드들을 대대적으로 정리합니다:

프론트엔드 useSpacedRepetition.ts: 내부에 하드코딩되었던 복습 일정 계산 로직을 제거합니다. 대신 SRS 엔진을 활용하도록 수정하세요. 구체적으로, addMistake나 completedReview 함수에서 직접 REVIEW_INTERVALS를 참조하거나 reviewStage를 수동 조작하던 부분을 삭제하고, SRS 엔진에게 다음 복습 일정을 물어보도록 바꿉니다. 이 훅은 UI와 로컬 저장소 관리에 집중하고, “언제 다음 복습할지” 결정은 엔진에 맡기는 형태로 역할을 재정립합니다. 필요하면 훅 내부에서 engine과 localStorageBackend를 초기화하고 사용하도록 합니다. (참고: reviewStage 개념은 기존 4단계 고정이었는데, SM-2에서는 repetitions로 일반화되므로 훅 상태 모델도 약간 변경 필요할 수 있음.)

web_app/src/services/reviewAlgorithm.ts: 이 서비스는 사실상 SRS 엔진의 전신이므로, 대부분의 로직이 엔진으로 이관됩니다. 간소화 전략: ReviewAlgorithmService.calculateNextReview에서는 그냥 SRSEngine.calculateNextReview를 호출하도록 만들고, 기존 코드들은 제거합니다. 혹 기존에 이 서비스에 있던 추가 기능 (예: getTodayReviewSentences, analyzeReviewPattern 등 분석용 메서드
GitHub
GitHub
)은 엔진 또는 별도 유틸로 이동을 검토합니다. 일단 핵심 알고리즘 계산은 더 이상 여기서 하지 않도록 합니다. reviewAlgorithmService 객체는 유지하더라도 내부 구현은 엔진을 위임(delegate)하는 형태로 바뀝니다.

web_app/src/services/srsService.ts: 이 부분은 이미 LocalStorage를 사용하여 SM-2를 구현한 코드입니다
GitHub
GitHub
. 사실 역할이 ReviewAlgorithmService와 겹치므로 둘을 하나로 합칠 수도 있습니다. 그러나 우선은 srsService의 calculateNextReview 구현을 삭제하고 엔진 호출로 대체합니다. 그리고 updateCardAfterReview 등 함수에서 this.calculateNextReview 호출 부분을, 엔진 인스턴스의 메서드 호출로 변경하면 됩니다
GitHub
. 최종적으로 srsService 자체가 불필요해진다면 훗날 제거하고 reviewAlgorithmService와 합칠 수도 있습니다. (현재는 AI 혼란을 줄이기 위해 동일 엔진 사용에만 집중하고, 모듈 통합은 추가 논의로 남겨둡니다.)

백엔드 smartReviewService.js: 이 역시 updateMemoryStrength 내에 SM-2 로직이 있습니다
GitHub
GitHub
. Node.js 환경에서 TypeScript 엔진 모듈을 바로 쓸 수 있다면 이상적이지만, 현실적으로는 프론트엔드 TS 코드를 백엔드 JS에 가져오기 어렵습니다. 따라서 동일 알고리즘을 백엔드에도 구현해야 하는데, 이때 엔진 알고리즘을 최대한 복붙하여 일치시키고, 주석으로 "이 코드는 frontend SRSEngine과 동일해야 함"을 명시합니다. (궁극적으로는 SRS Engine을 패키지화하여 FE/BE가 같이 import 하는 것도 고려 가능합니다.) 우선은 smartReviewService의 해당 로직을 SRSEngine 코드에 맞춰 수정합니다. 즉, quality 계산, interval 증분, easeFactor 조정 수식 등이 프론트엔드 엔진과 완전히 같도록 고칩니다. 그 뒤 smartReviewService의 updateMemoryStrength는 SRSEngine의 calculateNextReview를 모방한 형태로 정리됩니다. 백엔드에서도 Storage 인터페이스를 쓴다면 FirestoreBackend 내부에서 memoryRef.set(...) 등을 캡슐화할 수도 있으나, 초기 단계에서는 백엔드 로직을 SRSEngine에 맞춰 동일화하는 것에 초점을 둡니다.

以上 리팩토링 작업을 통해, SRS 알고리즘 관련 로직은 사실상 SRSEngine 한 곳에만 존재하게 됩니다. 프론트엔드 훅/서비스, 백엔드 서비스 모두 이 엔진의 출력에 따라 동작하므로, 이후 복습 간격이나 알고리즘을 변경하고 싶을 때 SRSEngine 코드와 스펙 문서만 수정하면 일괄 반영됩니다. 중복 제거로 코드가 훨씬 간결해지고 버그 발생 여지도 줄어듭니다.

(5) 데이터 마이그레이션 및 호환성: SRS 엔진 통합 후 기존 데이터와의 호환성도 확인해야 합니다. 만약 이전에 프론트엔드 로컬스토리지에 저장된 MistakeItem들이 reviewStage 기반으로 관리되고 있었다면, 이를 새로운 repetitions나 easeFactor 기반으로 변환하는 로직이 필요합니다. 예를 들어 reviewStage: 2 였다면 repetitions: 2, intervalDays: 7등으로 간주할 수 있습니다. 가능하면 마이그레이션 코드를 작성하여 초기 로드 시 한 번 기존 데이터 구조를 변환해주고, 이후부터는 새 엔진 구조를 사용하도록 합니다. 백엔드 Firestore의 userMemoryStrength 컬렉션도 유사하게 확인합니다 (이미 easeFactor 등을 쓰고 있다면 그대로 두면 됩니다). 이 단계에서는 AI에게 기존 데이터 구조와 새 구조를 설명하고, 변환 스크립트 작성 도움을 받아도 좋습니다.

(6) 테스트 작성: SRS 엔진은 학습 서비스의 핵심이므로, 단위 테스트를 꼭 작성합니다. 예를 들어: 품질 점수 5 (만점)으로 연속 3회 정답일 때 interval이 제대로 증가하는지, 오답 시 interval=1로 재설정되는지, easeFactor 상한/하한이 지켜지는지 등을 테스트합니다. 프론트엔드라면 Jest 등으로 SRSEngine 클래스의 메서드를 테스트하거나, 백엔드 Node 환경에서 Mocha/Chai로 smartReviewService의 결과를 테스트할 수도 있습니다. 아래는 예상 시나리오 몇 가지에 대한 테스트 아이디어입니다:

Case 1: 초기 상태(easeFactor=2.5, interval=1, repetitions=0)에서 정답을 맞혔을 때 → interval이 1 (첫 복습 1일) 또는 6 (두 번째 복습)으로 설정되는지 확인.

Case 2: easeFactor가 낮은 상태에서 연속 오답 2회 발생 시 → easeFactor가 최소 1.3까지 떨어지는지 확인.

Case 3: 특정 시퀀스의 정오답 입력에 대해 프론트엔드 useSpacedRepetition 훅의 dueReviews 산출이 예상대로 작동하는지 (통합 테스트).

테스트를 통해 새로운 엔진 도입이 기존 기능에 부정적 영향을 주지 않고, 일정 계산이 의도대로 되는지 검증합니다.

4.3. 세션 컨텍스트 유지 및 작업 연속성 확보

SRS 엔진을 통합했다 하더라도, AI가 다음 날 새로운 기능을 추가하면서 또다시 이상한 폴더를 만들거나, 다른 이름의 훅을 만들면 곤란합니다. 이를 방지하기 위해 AI와의 인터랙션 규칙과 워크플로우를 개선합니다:

(1) 세션 시작 시 컨텍스트 주입: 앞서 4.1 단계에서 완성한 PROJECT_CONTEXT.md와 DECISION_LOG.md를 활용합니다. 모든 새로운 AI 세션은 이 두 파일을 반드시 읽고 시작하도록 프롬프트를 설계합니다. 예를 들어, VSCode의 AI 확장이나 CLI 환경에서 프롬프트 템플릿을 지원한다면, 다음 내용을 기본으로 넣습니다:

[시스템 프롬프트] 
당신은 DASI English 프로젝트의 협업 AI 개발자입니다. 
다음은 이 프로젝트의 배경 및 현재까지의 결정 사항입니다:
<contents of docs/PROJECT_CONTEXT.md>
<contents of docs/DECISION_LOG.md>


이처럼 시스템 메시지에 프로젝트 맥락을 항상 포함하면, AI가 기존 맥락을 가진 상태로 답변을 시작합니다. 특히 DECISION_LOG.md의 마지막 부분에는 최근에 SRS 엔진을 통합했다든지, 금지된 작업 등이 기록되어 있을 것이므로, AI가 이를 어기는 확률이 크게 줄어듭니다.

(2) 금지 항목과 허용 항목 명시: AI는 주어진 지시 외에도, 코드베이스를 훑으며 어떤 파일이 존재하는지 모니터링하기 때문에, 프로젝트 컨텍스트 문서에 금지 및 권장 사항을 목록으로 정리해두면 효과적입니다. 예:

✅ 사용할 것: useSpacedRepetition.ts 훅 (이미 있음, 여기 기능 추가), SRSEngine 모듈 (공통 SRS 로직 사용) 등.

❌ 만들지 말 것: 새로운 훅이나 SRS 관련 파일 (예: useSpacedRepetition2.ts 생성 금지), 이미 있는 기능을 복제한 모듈 생성 금지.

🔄 참조할 것: 기존 DECISION_LOG.md에 따라 작업 진행, 모든 결정은 로그에 기록.

이런 규칙을 프로젝트 문서와 AI 프롬프트에 포함하면, AI가 코딩 도중 “혹시 새 파일을 만들어야 하나?”라고 스스로 판단할 때 영향을 줍니다. (예컨대 AI가 "useSpacedRepetitionV2.ts"를 생성하려 한다면, 금지 목록을 보고 멈출 수 있음.)

(3) 작은 개발 사이클 철저 준수: AI에게 한 번에 너무 많은 요구를 하면 중간에 맥락을 잃거나, 부분적으로만 구현하고 끝낼 수 있습니다. 이를 방지하기 위해 작은 목표 단위로 작업을 쪼개서 지시합니다. 예를 들어 “SRS 엔진 모듈을 만들고 훅/서비스를 모두 변경해줘” 대신, 1차로 “엔진 모듈 파일 생성 및 calculateNextReview 구현” → 2차로 “훅에서 엔진 사용하도록 수정” → 3차로 “백엔드 서비스 수정” 식으로 단계별로 요청합니다. 각 단계가 끝날 때마다 AI의 출력물을 점검하고, 이상 없으면 git commit을 수행한 뒤 다음 단계로 넘어갑니다. 이때 커밋 로그도 DECISION_LOG.md에 요약 기록해두면 좋습니다 (예: “2025-09-05: SRS 엔진 모듈 추가 및 훅에 통합 완료 – 기존 reviewAlgorithm 중복 제거”). 이렇게 하면 이후 세션에서 어느 단계까지 완료되었는지 한눈에 볼 수 있습니다.

(4) 문서와 Todo의 일원화: 진행 중 필요한 작업이 새로 떠오르면, 예전에는 세션마다 todo.md나 work_notes.md 등이 난립했을 수 있습니다. 이제는 DECISION_LOG.md나 별도의 docs/todo.md 단일 파일에만 기록하도록 합의합니다. 예를 들어, SRS 엔진 통합 후 “백엔드 Python 모듈도 통합 대상 – 차주에 논의 필요” 같은 할 일이 생기면, 해당 파일에 남겨 다음 AI 세션에서도 볼 수 있게 합니다. 새로운 파일을 만들지 않도록 주의시키고, AI도 그 파일을 갱신하도록 훈련시킵니다.

4.4. 코드 품질 향상 및 테스트 체계 구축

(1) 클린 코드 원칙 적용: AI가 작성한 코드라 해도 결국 사람이 유지보수해야 합니다. 따라서 팀에서 합의한 코딩 컨벤션과 클린 코드 원칙을 AI에게도 주지시킵니다. 예를 들어 “함수는 한 가지 일만 하도록”, “의미 있는 이름 사용”, “중복 최소화” 등의 규칙을 문서화하거나 사전 프롬프트에 포함합니다. 실제 적용 시, 리뷰 과정을 통해 AI 산출물에 대해 리팩토링을 수행합니다. SRS 엔진 통합 과정에서도, 너무 긴 함수는 중간에 private 함수로 쪼개거나, 불필요한 매개변수는 제거하는 등 후속 정리 작업을 합니다. 이 때 Rule of Three (같은 코드가 세 번 나타나면 추상화 고려) 같은 지침을 따라, 필요한 곳에서는 적절한 추상화를 도입합니다. (예: 프론트 훅과 백엔드 서비스에서 공통 사용하는 유틸은 shared/ 모듈로 뽑는 등.)

(2) 테스트 코드 작성: 앞서 SRS 엔진 단위 테스트를 언급했지만, 추가로 전체 프로젝트에 걸쳐 테스트 습관을 들입니다. 프론트엔드 React 훅은 React Testing Library 등을 사용해 동작 테스트를 추가하고, 백엔드 Node API는 슈퍼테스트(supertest) 등으로 통합 테스트를 작성합니다. DASI English의 핵심 로직 (예: 레벨업 로직, TTS 변환 등)에도 간단한 테스트 케이스를 마련해 두면, AI가 리팩토링 시 이를 참조해 기존 기능을 보존하려 노력할 것입니다. 특히 AI에게 “테스트를 통과하도록 구현하라”는 식의 지시를 내릴 수도 있으므로, CI에 테스트가 걸려있다면 안정망 역할을 할 것입니다.

(3) 정적 분석 도구 및 CI 파이프라인: 프로젝트에 이미 ESLint, Prettier, TypeScript 등의 도구가 설정되어 있다면, AI가 코드를 생성할 때 그 규칙을 따르도록 유도합니다. 예를 들어 “코드 제출 전에 npm run lint를 돌려”라고 시킬 수 있습니다. GitHub Actions 등의 CI를 활용해 PR시에 자동으로 린트, 타입 체크, 테스트가 수행되도록 파이프라인을 구축합니다. 이미 일부 CI 설정이 존재한다면 최신화하고, 없다면 .github/workflows에 간단한 CI YAML을 추가합니다. 이렇게 하면 AI가 생성한 코드라도 사람이 놓치기 쉬운 포맷/타입 문제를 기계가 잡아줍니다. 또한 코드 리뷰 프로세스를 도입하여, AI 산출물을 바로 프로덕션에 쓰지 말고 한 번 검토하고 머지하도록 합니다. (AI에게 자체 리뷰를 시키는 방법도 있지만, 최종 책임은 사람이 지는 게 바람직합니다.)

4.5. 보안 및 운영상 고려 사항

(1) 설정 파일과 비밀 정보 관리: 개발 편의를 위해 .env.example 파일을 프로젝트에 제공하고, 실제 운영 시에는 민감한 키/비밀번호는 코드에 하드코딩하지 않도록 합니다. 예를 들어 OpenAI API Key, Firebase 비공개 키 등은 .env나 서버 설정으로 주입하고, 깃헙에는 올리지 않습니다. 비밀번호 등 사용자 데이터는 서버에서 적절히 해시 처리하여 저장하고, 클라이언트에는 절대 노출하지 않습니다. (현재 DASI English 프로젝트 구조상 백엔드에서 Firebase를 다루므로, API 키를 프론트에 노출하지 않고 백엔드가 대행 호출하는 구조를 유지합니다.)

(2) 에러 로깅 및 모니터링: 프론트엔드와 백엔드 모두 일관된 예외 처리와 로깅 시스템을 도입합니다. 예를 들어 프론트 React에서는 에러 발생 시 Sentry와 같은 도구를 통해 로그를 수집하거나, 최소한 console.error를 통해 발생 위치와 원인을 기록합니다. 백엔드 Node 서버 역시 winston 등의 로깅 라이브러리를 활용해 로그를 남기고, 중요한 오류는 알림을 받을 수 있게 합니다. 사용자에게는 지나치게 기술적인 오류 대신 “네트워크 오류가 발생했습니다. 잠시 후 다시 시도하세요.” 등의 친절한 메시지를 표시하도록 UI를 개선합니다. 이를 위해 ErrorBoundary 컴포넌트(web_app/src/components/ErrorBoundary.tsx)를 강화하거나, API 응답 에러 처리를 통일합니다.

(3) 데이터 일관성 및 동기화: 프론트와 백엔드 양쪽에서 SRS 엔진을 사용하게 되면, 어느 한쪽이 업데이트되었을 때 다른 쪽과 데이터가 안 맞는 상황을 조심해야 합니다. 가령 프론트가 로컬 스토리지에 저장한 복습 기록과 백엔드 Firestore의 기록이 어긋날 수 있습니다. 이를 해결하려면 단일화 전략이 필요합니다. 가능한 한 서버를 진실 원본으로 삼고, 프론트는 오프라인 동작을 위한 캐시로만 쓰거나, 세션 종료 시 서버 동기화하는 방식을 고려합니다. 아니면 아예 프론트에서만 SRS를 관리하고 서버에는 요약 정보만 보내는 방향도 있습니다. 현재로서는 프론트 srsService가 로컬스토리지를 쓰고, 백엔드 smartReviewService가 Firestore를 쓰는 이원화 구조인데, 장기적으로 둘을 통합하는 것이 좋습니다. 예를 들어 SRS 엔진을 클라우드 함수(Firebase Functions)로 구현해서 프론트가 호출하게 하거나, 반대로 백엔드 없이 모두 프론트에서 처리하도록 일관성을 유지할 수 있습니다. 어느 쪽이든 결정되면 해당 방향으로 문서를 업데이트하고, AI에게도 그 방침을 따르게 합니다. (이번 가이드에서는 우선 “엔진 로직 일치”까지만 다루고, 운영 구조 단일화는 추후 과제로 남겨둡니다.)

(4) 성능과 확장성: SRS 엔진 통합으로 복습 일정 계산은 매우 가벼운 연산이므로 성능 이슈는 크지 않습니다. 다만 추후 사용자 수 증가를 대비해 백엔드 부하 분산이나 오프라인 사용 전략을 고민합니다. 예컨대 모든 복습 스케줄 계산을 서버가 한다면 과부하가 될 수 있으므로, 현재처럼 프론트에서 1차 계산하고 서버는 검증 및 보정 역할을 하는 구조가 유효할 수 있습니다. 또한 AI 코딩 도우미를 사용할 때 한 번에 대용량 파일을 생성하지 않도록 유의합니다 (이것도 일종의 성능 고려).

5. 결론 및 기대 효과

이번 심층 리서치에서는 DASI English 프로젝트의 바이브코딩 개발 프로세스 문제점을 분석하고, SRS 엔진 통합을 중심으로 한 개선 로드맵을 제시했습니다. 요약하면, 중복된 SRS 로직을 단일 엔진으로 모듈화하고, AI 개발 맥락을 잃지 않도록 문서화와 세션 전략을 강화하며, 코드 품질과 테스트로 안정성을 높이는 방향입니다. 이러한 개선을 통해 다음과 같은 효과를 기대할 수 있습니다:

🏷️ **단일 SRS 로직(Single Source of Truth)**으로 인한 일관성 향상: 여러 곳에 흩어져있던 복습 일정 계산이 하나로 모여 유지보수가 쉬워지고, 버그 발생 시 한 곳만 고치면 해결됩니다. 프론트와 백엔드의 알고리즘 불일치로 인한 사용자 경험 차이도 해소됩니다.

🔄 세션 간 지속적인 컨텍스트 공유: 프로젝트 현황과 결정이 한 군데 모여 있고 AI가 이를 항상 참조하게 되므로, 새로운 AI 세션이 기존 설계를 뒤엎거나 중복 코드를 만드는 일이 크게 줄어듭니다. 개발 흐름이 연속성을 가져 속도와 정확성이 모두 향상됩니다.

📚 명확한 문서와 구조로 인한 이해 용이성: 팀원과 AI 모두 프로젝트 구조와 각 부분의 역할을 명확히 이해하게 됩니다. 새로운 기여자나 AI 모델이 투입되어도 PROJECT_CONTEXT.md 한 번 읽고 빠르게 도메인 지식을 습득할 수 있습니다. 이는 온보딩과 지식 공유에도 도움이 됩니다.

🛠️ 유연한 확장과 리팩토링 준비도: 모듈 경계가 분명해지고 추상화 계층이 도입되어, 새로운 기능 추가나 변경 시 영향을 최소화할 수 있습니다. 예를 들어 다른 SRS 알고리즘(예: Leitner System)을 실험하고자 할 때 엔진 모듈만 교체하면 될 것입니다. 코드 중복 제거와 테스트 추가로 미래 리팩토링 부담도 완화됩니다.

✅ 개발 프로세스의 품질 향상: 자동화된 린트/테스트/CI 파이프라인은 인간-AI 협업 개발의 실수를 방지하고, 꾸준한 리팩토링 문화는 코드 건강을 유지시킵니다. 결과적으로 DASI English 서비스는 더 안정적이고 신뢰할 수 있는 환경에서 발전하게 될 것입니다.

마지막으로, 개선 작업은 단계별로 착실히 수행되어야 합니다. 본 가이드에서 우선순위로 삼은 SRS 엔진 통합을 완료한 후에도, 남은 문서화 작업, 세부 아키텍처 개선, 운영상 튜닝 등을 차례로 진행하세요. 모든 변경사항은 DECISION_LOG.md에 기록하며, AI와 사람 개발자 간에 열린 대화를 유지하는 것이 중요합니다. 이를 통해 DASI English 프로젝트를 바이브코딩의 모범 사례로 발전시키고, AI 도움 개발의 효율을 극대화하시기 바랍니다.

향후 계획 (Next Actions):

현재 리서치 내용과 Action Plan을 토대로 SRS 엔진 통합 작업을 시작합니다. 우선 리포지토리 전반을 대상으로 중복 SRS 코드 조각을 최종 확인하고 (이미 발견된 4곳 외에 없는지 grep 재확인) 작업 브랜치를 생성합니다.

본 가이드의 아키텍처 설계를 팀원들과 공유하여 의견을 수렴한 뒤, 모두 동의하면 이를 docs/PROJECT_CONTEXT.md 및 docs/DECISION_LOG.md에 반영합니다. 특히 AI 프롬프트에 활용할 요약본을 잘 다듬어 둡니다.

3일 이내에 SRS 엔진 모듈 구현 및 프론트엔드 적용을 완료하고, 1주 이내에 백엔드 적용과 테스트/문서 정리를 마무리하는 단기 일정을 계획합니다. 진행 중 발생하는 이슈는 Slack 채널과 DECISION_LOG.md로 공유하여, AI도 동기화합니다.

이와 같은 단계로 실행에 옮기면, 곧 가시적인 개선 효과를 볼 수 있을 것입니다. 모두 함께 합의된 원칙을 지키며 꾸준히 개선을 이어나가는 것, 그것이 AI와 협업하는 바이브코딩의 성공 열쇠입니다. 🚀
- to memorize

# auto-session-initialization
**새 AI 세션 자동 초기화** - 바이브코딩 컨텍스트 손실 방지

## 🤖 AI 세션 자동 수행 사항

Claude Code는 이 프로젝트 폴더에서 새 세션 시작 시 자동으로 이 파일을 읽고 다음을 수행합니다:

## 📋 AI가 자동으로 수행해야 할 작업

새 세션 시작 시 AI는 다음 순서로 자동 진행:

1. **docs/PROJECT_CONTEXT.md 읽기** ✅ 필수
   - SRS 시스템 SSOT 확인 
   - 금지 파일/폴더 목록 확인
   - 현재 아키텍처 상태 파악

2. **docs/DECISION_LOG.md 읽기** ✅ 필수  
   - 최근 중요 결정사항 파악
   - 진행 중인 작업 컨텍스트 이해
   - AI 세션 연속성 가이드라인 적용

3. **현재 git 상태 확인** (선택사항)
   - 최근 커밋 확인
   - 변경된 파일 파악

4. **개발 준비 완료 알림**
   - "프로젝트 컨텍스트 파악 완료, 개발 작업 준비됨" 
   - 현재 우선순위 작업 제시

## ⚡ 자동 초기화 완료 확인 방법

AI는 세션 시작 시 자동으로 다음을 보고합니다:
- ✅ "프로젝트 컨텍스트 파악 완료, 개발 작업 준비됨" 
- 📋 현재 우선순위 작업 목록
- 🚫 적용 중인 금지 규칙 목록

## 🎯 기대 효과

- **컨텍스트 손실 방지**: 매번 처음부터 설명할 필요 없음
- **중복 파일 생성 방지**: 금지 규칙 자동 적용  
- **일관성 유지**: SSOT 정책 자동 준수
- **개발 효율성**: 즉시 작업 모드 진입

# project-structure
**코드 생성/수정 시 필수 준수사항**: 
- 모든 코드 작성/수정 전에 `PROJECT_STRUCTURE.md` 파일을 반드시 확인
- 프로젝트 구조와 아키텍처 원칙에 맞게 구현
- 기존 컨벤션과 패턴을 따라 일관성 유지

# project-settings
## Development Server
- Frontend: http://localhost:3500 (Vite React app)
- Backend: http://localhost:8081 (Node.js API server)

## Commands
```bash
# Start frontend (port 3500)
cd web_app && npm run dev

# Start backend (port 8081)  
cd backend && npm start
```

## Data Migration Tools
**위치**: `docs/migration/README.md` 참조

**현재 상태 확인**:
```bash
npm run migrate:status    # 상태 확인 (항상 먼저 실행)
npm run logs             # 로그 확인
```

**중단 후 재개 시나리오**:
1. 사용자: "마이그레이션 작업하다가 중단됐어. 확인하고 이어서 해줘"
2. Claude 해야 할 일:
   - `npm run migrate:status` 실행하여 상태 파악
   - 실패한 파일과 원인 분석
   - 적절한 해결책 제시 (unlock/resume/reset)
3. 일반적 해결 순서:
   - `npm run migrate:unlock` (락 해제)
   - `npm run migrate:resume` (재개)
   - 계속 실패하면 개별 파일 처리

**주의사항**: 
- 항상 `--dry-run`부터 시작
- 체크포인트 시스템으로 중단되어도 안전
- 로그는 `docs/logs/` 폴더에 자동 저장

# sentence-generation-ru35  les
**순차적 학습 보장 원칙** - 각 스테이지 문장 생성 시 반드시 준수:
- Stage N에서는 **Stage 1~N까지 배운 내용만** 사용 가능
- 이후 스테이지 내용 절대 미리 사용 금지 (예: Stage 5에서 Stage 20 문법 사용 금지)
- Level별 경계 엄수 (예: Level 2에서 Level 3+ 내용 사용 금지)
- 문법 복잡도 점진적 증가 원칙 철저히 준수
- 총 362개 스테이지 순서 체계 유지
- 각 스테이지당 50개 문장 생성 시 이 원칙 적용

# curriculum-reorganization-complete ✅
**완료 일시**: 2025-08-28 커리큘럼 재구성 프로젝트 완료
**문서 위치**: `docs/curriculum/` 폴더 확인 필수
  - `GRAMMAR_MAPPING_BY_STAGE.md` - 스테이지별 문법 매핑 (362개 스테이지)
  - `LEVEL_BOUNDARIES.json` - 레벨 경계 규칙 및 금지사항
  - `REORGANIZATION_COMPLETION_REPORT.md` - 전체 완료 보고서

**현재 상황**: 
- ✅ 31,456개 문장 수집 및 분석 완료
- ✅ 104개 스테이지 완성 (50+문장 보유)
- 🔄 294개 스테이지 문장 생성 필요
- ✅ 순차적 학습 원칙 검증 시스템 구축

**다음 작업**: sentence-generation-rules 적용하여 미완성 스테이지 문장 생성
**검증 도구**: `scripts/validate-curriculum.js`로 품질 확인 가능
**데이터 소스**: `web_app/public/patterns/banks/level_*/` (JSON 데이터) + `docs/curriculum/master_roadmap_*.md` (교육 설계)

# curriculum-structure-final
**커리큘럼 이원화 구조 확정** - 스피킹 중심 교육 + 시스템 검증

## 📚 역할 분담
### 메인 교육 (사용자 대상)
- **`docs/curriculum/master_roadmap_*.md`** - 스피킹 실용 중심
- 구체적 예문, 한국인 맞춤 가이드, Phase 구조
- 교육 콘텐츠의 **단일 진실 원본**

### 백그라운드 검증 (시스템 대상)  
- **`docs/curriculum/GRAMMAR_MAPPING_BY_STAGE.md`** - 문법 체계 검증
- `scripts/validate-curriculum.js`에서 참조
- 순차적 학습 원칙 보장용

## 🔄 분업 구조 확정 (통합 정리는 후순위)
**LEVEL_BOUNDARIES.json** - 시스템 운영 기준
- 362개 스테이지 구조, Stage ID 규칙
- JSON 파일명: `Lv1-P1-S01_bank.json` 형식
- 시스템 로직의 단일 진실 원본

**master_roadmap_*.md** - 교육 콘텐츠 가이드  
- 구체적 예문, 한국인 맞춤 설명
- 교육적 완성도 우선

**GRAMMAR_MAPPING_BY_STAGE.md** - 백그라운드 검증
- `scripts/validate-curriculum.js`에서 사용
- 순차적 학습 원칙 보장

**현재 우선순위**: 기능 개발 > 통합 정리

## 📝 아카이브 완료
- `REORGANIZATION_COMPLETION_REPORT.md` → `archive_duplicates/` 이동 ✅
- 히스토리 문서, 코드 미사용으로 정리 완료

# mcp-task-delegation-strategy
**MCP 역할 분담 원칙** - AI가 담당할 영역과 인간이 담당할 영역

## 🚀 MCP 최적화 영역 (High Value + Low Risk)
- **데이터 처리/변환** - 31,456개 문장 분석, JSON 구조 변환, 배치 작업
- **반복적 코드 생성** - 294개 스테이지 문장 생성, 패턴 확장, 템플릿 적용
- **파일 시스템 정리** - 구조 재정리, 중복 파일 정리, 배치 이동/삭제
- **검증/테스트 자동화** - lint, typecheck, 데이터 무결성 검사, 품질 검증
- **문서 동기화** - 코드와 문서 일치성 유지, 자동 업데이트

## 🔄 신중한 MCP 활용 영역 (Medium Value + Medium Risk)
- **리팩토링** - 중복 제거, 함수 분리 (단, 기능 변경 없이)
- **마이그레이션** - 체크포인트 시스템으로 안전망 확보 후 진행
- **설정 파일 수정** - package.json, config 파일 등 (백업 필수)
- **API 엔드포인트 수정** - 기존 스펙 유지하는 범위 내에서

## ❌ 인간 직접 담당 영역 (High Risk + Strategic)
- **아키텍처 설계** - 전체 구조, 핵심 비즈니스 로직 결정
- **사용자 경험 결정** - UI/UX, 학습 플로우, 사용성 설계
- **보안 정책** - 인증, 권한, 데이터 보호, 암호화 방식
- **성능 최적화 전략** - 병목점 분석, 해결 방향 결정
- **외부 API 통합** - STT/TTS 엔진, 클라우드 서비스 연동

**활용 원칙**:
- MCP = **실행력**과 **스케일** (반복작업, 데이터 처리)
- 인간 = **판단력**과 **창의성** (설계, 전략, UX)
- 항상 Git 체크포인트와 `--dry-run` 검증 후 실행
- 실패 시 롤백 가능한 구조로 작업 진행

**현재 우선순위**: 294개 미완성 스테이지 문장 생성 (순차적 학습 원칙 + 검증도구 완비)

# project-quality-checklist
**코드 품질 유지 체크리스트** - 10만줄 넘는 대형 프로젝트 관리 필수

## ✅ 공통 체크리스트 (모든 프로젝트 적용)
### 버전관리
- [ ] 의미 있는 커밋 메시지와 작은 커밋 단위 유지
- [ ] PR 템플릿에 네이밍·복잡도·테스트·보안 점검 체크리스트 포함

### 아키텍처/모듈화 **[필수]**
- [ ] 프로젝트 뼈대와 각 모듈의 책임을 문서화 (`PROJECT_STRUCTURE.md` 확인)
- [ ] 새 기능 추가 시 기존 모듈을 수정하지 않고 플러그인처럼 교체 가능한지 점검
- [ ] 순환 의존성 제거, 계층 구조 명확화

### 리팩토링·중복 제거
- [ ] 한 기능 완성마다 10~20분 리팩토링 시간 예약
- [ ] 중복된 함수나 사용되지 않는 코드를 탐지하고 util 모듈에 통합
- [ ] 죽은 코드, 만료된 플래그 정리

### 테스트 & CI
- [ ] 단위·통합 테스트를 주기적으로 실행 (실패 경로도 포함)
- [ ] Lint/typecheck/test를 PR 게이트로 설정
- [ ] `npm run lint`, `npm run typecheck` 성공 확인

### 문서화 & ADR
- [ ] README·설계 문서와 실제 코드 일치성 확인
- [ ] 중요한 설계 변경은 ADR(Architecture Decision Record)로 기록

### 보안/비밀 관리
- [ ] .env에 API 키를 분리하고 비밀이 커밋되지 않았는지 확인
- [ ] 의존성 취약점 업데이트

## 📁 dasi_eng 프로젝트 추가 체크리스트
### AI 모델과 콘텐츠 업데이트
- [ ] GPT·Claude·Whisper·TTS 버전과 파라미터 최신화
- [ ] 단어 리스트·패턴·레벨별 교재 업데이트

### STT/TTS 품질 점검
- [ ] 음성 인식 정확도와 발음 피드백 기능 매주 테스트
- [ ] 오디오 품질 및 지연 시간 모니터링

### 망각 곡선 엔진 유지
- [ ] Firebase 기반 Forgetting Curve 시스템 스케줄링 검증
- [ ] 학습 로그 누락 없는지 점검

### 프로젝트 구조 유지
- [ ] 백엔드·웹앱·모바일앱·docs 폴더 분리된 모노레포 구조 유지
- [ ] 새 서비스나 문서를 적절한 위치에 배치

**핵심 원칙**: 
- **모듈화는 필수** - 10만줄 넘으면 토큰 한계로 AI 도움 불가능
- 매 기능 추가 후 리팩토링과 체크리스트 검증을 한 사이클로 묶어서 실행
- 최소한의 아키텍처 뼈대 → MVP 구현 → 점진적 개선 순서 준수

# idea-to-code-process
**아이디어→코드 프로세스** - 실전 망가짐 방지 가이드

## 📋 단계별 접근법
### 1. 요구사항 명확화
- 아이디어를 글로 정리 (목적, 핵심 기능, 입출력)
- AI에게 "이 아이디어를 구현하려면 어떤 기능이 필요할까요?" 질문
- **기능 목록 받기** → 놓친 요소 확인

### 2. 아키텍처 초안 작성  
- 기능을 **모듈별로 분리** (계층별/기능별)
- AI에게 "전체 시스템 구조를 제안" 요청
- **work.md 같은 계획서 먼저** 작성 후 검토

### 3. 계획 검토 및 수정
- 사람이 **아키텍처 초안 모니터링** (빠진 기능, 잘못된 구조)
- "혹시 내가 놓친 중요한 요소가 있어?" 질문
- 아이디어와 AI 계획이 **일치할 때까지 설계 다듬기**

### 4. 구현 단계 관리
- **짧은 개발 사이클**: 구현→테스트→커밋 반복
- 한 사이클 끝날 때마다 "지금까지 내용 정리하고 다음 할 일 업데이트해줘"
- AI 컨텍스트 과부하 방지

## 🛡️ 실전 망가짐 방지 12가지

### 1. 가드레일 내장
- [ ] **추정 금지**: "근거 없는 추정 대신 정확한 정보만 제공"
- [ ] **라인번호/파일경로 근거 요구**: 코드 수정 시 정확한 위치 명시  
- [ ] **출력 형식 강제**: JSON, 마크다운 등 일관된 형식 사용
- [ ] **자기점검 체크리스트** 프롬프트에 내장

### 2. 검증 루프 완성
- [ ] **정합성 분석**: 중복/누락/회귀 검사
- [ ] **계획→구현→테스트→분석→리팩토링→재테스트** 전체 사이클
- [ ] 매 기능마다 **backward compatibility** 확인

### 3. 에러 타입 정의
```typescript
export type ErrCode = 'E_NETWORK' | 'E_UNAVAILABLE' | 'E_TIMEOUT' | 'E_ABORTED' | 'E_PERMISSION' | 'E_INTERNAL';
export type Result<T> = { ok: true; data: T } | { ok: false; code: ErrCode; retryable?: boolean; cause?: string };
```

### 4. 플러그인 구조 강제
- [ ] **인터페이스 우선 설계**: 구현보다 계약서 먼저
- [ ] **DI(의존성 주입)** 패턴으로 교체 가능한 구조
- [ ] A→B→C 체인에서 B 교체 시 A,C 무영향 보장

### 5. 상태 관리 명시
- [ ] **Redux/Zustand 패턴** 또는 명확한 상태 흐름 정의
- [ ] 비동기 작업에 **AbortSignal/큐 정책** 필수
- [ ] 상태 변경 시 **이벤트 로그** 남기기

### 6. 보안/프라이버시 체크리스트
- [ ] **.env 분리**: API 키, DB 연결 정보
- [ ] **권한 최소화**: 필요한 권한만 부여
- [ ] **로그 PII 필터**: 개인정보 로그 기록 금지
- [ ] **키 회전**: 정기적 API 키 갱신

### 7. 문서-코드 동기화
- [ ] **ADR(Architecture Decision Record)** 작성
- [ ] **PR에 문서 변경 동반** 규칙
- [ ] README와 실제 코드 일치성 주기적 검증

### 8. 과추상화 방지
- [ ] **Rule of Three**: 3번 반복 전 공통화 금지
- [ ] DRY 과용보다 **명확성 우선**
- [ ] YAGNI 원칙: 당장 필요 없는 기능 구현 금지

### 9. 토큰/세션 전략
- [ ] **컨텍스트 파일(work.md) 고정**
- [ ] **diff 기반 요청**으로 토큰 절약
- [ ] 대화 길어지면 **요약→새 세션** 시작

### 10. CI 게이트 설정
```yaml
# 필수 검사
- 커버리지 ≥ 70%
- p95 API 지연 ≤ 300ms  
- 린트/타입에러 0건
- 보안 스캔 통과
```

### 11. PR 체크리스트
- [ ] 변경 범위 명확 (파일/함수 목록)
- [ ] **실패 경로 테스트 1개** 이상
- [ ] 성능 영향도 측정
- [ ] 문서 업데이트 동반

### 12. 단계별 검증 질문
- "이 모듈들이 서로 어떻게 연결되고 데이터가 흐르지?"
- "○○ 기능을 추가/변경하려면 어느 부분만 손보면 될까?"
- "사용자가 잘못된 입력 시 어떻게 대비하지?"
- "보안이나 개인정보 측면에서 주의할 점은?"

**결과**: 7/10 → 9/10 품질 보장

# app-engine-cost-prevention
**App Engine 요금 폭탄 예방 체크리스트** - dasi_eng 배포 필수 점검

## 1. 스케일링 설정 제한
```yaml
# app.yaml 필수 설정
automatic_scaling:
  max_instances: 2  # 초기 개발/테스트: 1~2개만
  min_instances: 0  # 유휴 시 완전 종료
```
- [ ] **max_instances 제한 확인** - 무제한 스케일링 방지
- [ ] **min_instances: 0** 설정 - 유휴 시 과금 방지

## 2. API 호출 경유 방식 최적화
❌ **비효율**: 클라이언트 → App Engine → Google TTS (이중 과금)  
✅ **효율**: 클라이언트 → Firebase 인증 → Google API 직통

- [ ] TTS/STT API 직접 호출 구조 확인
- [ ] 불필요한 프록시 경유 제거
- [ ] Firebase 클라이언트 인증 활용

## 3. 유휴 인스턴스 관리
- [ ] **Background worker** → Cloud Functions 이동
- [ ] **Cron job** → Cloud Scheduler + Cloud Run
- [ ] App Engine은 **실시간 사용자 요청만** 처리

## 4. 로그 & 모니터링 최적화
```javascript
// 로그 레벨 제한
console.error() // ✅ 필수
console.warn()  // ✅ 필요시
console.log()   // ❌ 운영에서 제거
```
- [ ] **ERROR/WARN 레벨만** 로깅
- [ ] **AI 응답 JSON 전체 로그 금지** (수십 KB 과금)
- [ ] **일 단위 Billing 알람** 설정
- [ ] Cloud Logging 보존 기간 단축

## 5. 배포 크기 관리
```bash
# .gcloudignore 필수 항목
node_modules/
dist/
build/
*.mp3
*.wav
web_app/public/patterns/banks/  # 대용량 데이터셋
docs/logs/
md_cleanup_backup/
archive_duplicates/
```
- [ ] **.gcloudignore 설정** 확인
- [ ] **오디오 파일 제외** (CDN/Storage 분리)
- [ ] **빌드 산출물 제외**
- [ ] 배포 용량 < 100MB 유지

## 6. 비용 모니터링 설정
- [ ] **예산 알림**: $10/월 초과 시 이메일
- [ ] **일일 사용량**: Stackdriver 대시보드 확인
- [ ] **인스턴스 시간**: 24시간 기준 2시간 이하 목표
- [ ] **요청 수**: 일 1000건 이하 (테스트 단계)

## 7. dasi_eng 특화 주의사항
- [ ] **STT/TTS 직통 호출**: Firebase → Google Cloud API
- [ ] **패턴 데이터**: Cloud Storage 분리 (App Engine 제외)
- [ ] **망각곡선 배치**: Cloud Functions로 분리
- [ ] **오디오 녹음**: 클라이언트 임시 저장 후 직업로드

**DC식 요약**: "max_instances 안 걸어두면 바로 요금 폭탄, 프록시로 두 번 과금 당하지 마라, 로그 다 찍으면 지갑이 돈다"

# decision-documentation-policy
**하이브리드 기록 전략**:
1. **claude.local** - 불변 고정값 (포트, 규칙, project_id)
2. **DECISION_LOG.md** - 중요 의사결정 맥락 (이유/대안)  
3. **Git commit** - 액션 요약 (무엇을 했는가)
4. **archive/README.md** - 특정 보존 맥락 (필요시에만)

## 🏗️ 필수 아키텍처 원칙 (모든 코드에 적용)
**AI는 모든 코드 작성 시 다음 원칙을 반드시 준수해야 함:**
- ✅ **느슨한 결합**: 의존성 주입, 인터페이스 우선 설계
- ✅ **플러그인 패턴**: 교체 가능한 구조로 모듈 설계
- ✅ **모듈화**: 단일 책임 원칙, 명확한 모듈 경계
- ✅ **리팩토링 우선**: 중복 코드 제거, 함수 분리
- 🚫 **하드코딩 금지**: 설정값, 상수는 외부에서 주입
- 🚫 **직접 의존성 금지**: new ClassName() 대신 DI 사용
- 🚫 **매직 넘버/문자열 금지**: 의미있는 상수로 치환

**코드 품질 체크리스트**:
- [ ] 이 코드가 다른 환경에서도 동작하는가?
- [ ] 새 구현체로 쉽게 교체 가능한가?
- [ ] 하드코딩된 값이나 직접 생성이 있는가?
- [ ] 모듈간 순환 의존성이 없는가?

## 📝 자동 문서화 정책 (강제 적용)
**AI는 다음 상황에서 반드시 DECISION_LOG.md를 자동 업데이트해야 함:**
- ✅ 아키텍처 변경 (새 모듈, SSOT 변경, 폴더 구조)
- ✅ UI/UX 주요 개선사항 (네비게이션, 기능 활성화)  
- ✅ 중요 기능 구현/수정 (SRS, 인증, 데이터 처리)
- ✅ 금지 규칙 추가/변경 (새로운 제약사항)
- ✅ 개발 워크플로우 변경 (빌드, 배포, 테스트)
- ✅ 리팩토링 작업 (모듈화, 중복 제거, 구조 개선)

**자동 기록 형식:**
```
## 🎯 YYYY-MM-DD: [작업 제목]

### [기능/변경사항 이름]
**결정**: [무엇을 결정했는가]
**맥락**: [왜 이 결정을 했는가] 
**구현**: [어떻게 구현했는가]
**결과**: [무엇이 개선되었는가]
```

기록 대상: 폴더 이동, 아키텍처 변경, 보안 관련, 인터페이스 확정
기록 제외: 단순 테스트, 일회성 디버깅, trivial 작업

# architecture-principles-mandatory
**5만줄+ 대형 프로젝트 코딩 원칙** - CLI 토큰 한계 대비 필수 적용

## 🚫 절대 금지사항
### 하드코딩 Zero Tolerance
```typescript
// ❌ 절대 금지
const levels = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const stageCount = 16; // Level 1 고정
if (level === 1) { /* 특별 처리 */ }

// ✅ 반드시 준수  
const config = await configService.getLevelConfig(levelId);
const stageCount = config.phases.reduce((sum, phase) => sum + phase.stages.length, 0);
const handler = await registry.get(`level-${level}-handler`);
```

### 직접 의존성 주입 금지
```typescript
// ❌ 절대 금지
class SentenceService {
  constructor() {
    this.generator = new OpenAIGenerator(); // 직접 생성
    this.validator = new GrammarValidator(); // 하드 의존
  }
}

// ✅ 반드시 준수
class SentenceService {
  constructor(
    @inject('sentence-generator') private generator: ISentenceGenerator,
    @inject('sentence-validator') private validator: IValidator,
    @inject('config') private config: IConfig
  ) {}
}
```

## 🏗️ 필수 아키텍처 패턴

### 1. Plugin-First 설계
```typescript
// 모든 새 기능은 반드시 플러그인으로 구현
export const CurriculumPlugin: PluginManifest = {
  name: 'curriculum-generator',
  version: '1.0.0',
  services: {
    'sentence-generator': {
      factory: (registry) => createSentenceGenerator(registry),
      lifecycle: 'singleton',
      dependencies: ['config', 'grammar-rules', 'ai-provider'],
      tags: ['generator', 'curriculum']
    }
  },
  hooks: {
    'stage-validation': ['grammar-validator'],
    'sentence-generation': ['sentence-generator']  
  }
};
```

### 2. 인터페이스 우선 설계
```typescript
// 구현 전에 반드시 인터페이스부터 정의
export interface ISentenceGenerator {
  generate(config: StageConfig): Promise<Sentence[]>;
  validate(sentences: Sentence[], rules: GrammarRule[]): Promise<ValidationResult>;
  enrich(stage: Stage): Promise<EnrichedStage>;
}

export interface IStageValidator {
  validateSequentialLearning(stage: Stage, context: LearningContext): boolean;
  checkGrammarRules(sentences: Sentence[], allowedRules: string[]): ValidationResult;
}

export interface IConfigProvider {
  getStageConfig(stageId: string): Promise<StageConfig>;
  getLevelBoundaries(level: number): Promise<LevelBoundary>;
  getGrammarRules(upToStage: string): Promise<GrammarRule[]>;
}
```

### 3. 환경별 동적 구성
```typescript
// 환경에 따라 구현체가 자동으로 교체되어야 함
export const environmentConfigs = {
  development: {
    'ai-provider': 'mock-ai-provider',
    'content-source': 'fs-content-adapter', 
    'cache': 'memory-cache',
    'validator': 'lenient-validator'
  },
  production: {
    'ai-provider': 'openai-provider',
    'content-source': 'firebase-adapter',
    'cache': 'redis-cache', 
    'validator': 'strict-validator'
  },
  test: {
    'ai-provider': 'deterministic-mock',
    'content-source': 'mock-adapter',
    'cache': 'no-cache',
    'validator': 'mock-validator'
  }
};
```

### 4. 설정 기반 동작 제어
```typescript
// 모든 동작은 설정으로 제어 가능해야 함
export interface CurriculumConfig {
  generation: {
    provider: 'openai' | 'claude' | 'local';
    model: string;
    temperature: number;
    batchSize: number;
    retryAttempts: number;
  };
  validation: {
    sequentialLearning: {
      enabled: boolean;
      strictMode: boolean;
      allowedExceptions: string[];
    };
    grammarCheck: {
      enabled: boolean;
      rules: string[];
      errorTolerance: number;
    };
  };
  stages: {
    targetSentenceCount: number;
    formDistribution: {
      affirmative: number;
      negative: number; 
      question: number;
    };
    qualityThresholds: {
      minScore: number;
      maxRetries: number;
    };
  };
}
```

### 5. 이벤트 기반 확장성
```typescript
// 후킹 시스템으로 기능 확장
export class CurriculumService {
  async generateStage(stageId: string): Promise<ProcessedStage> {
    // 1. Pre-generation 후크 실행
    await this.registry.executeHooks('pre-generation', { stageId });
    
    // 2. 설정 로드 (하드코딩 없이)
    const config = await this.configProvider.getStageConfig(stageId);
    
    // 3. 생성기 동적 선택
    const generator = await this.registry.get<ISentenceGenerator>('sentence-generator');
    
    // 4. 문장 생성
    const sentences = await generator.generate(config);
    
    // 5. Post-generation 후크 실행
    await this.registry.executeHooks('post-generation', { stageId, sentences });
    
    return { stageId, sentences, config };
  }
}
```

## 📋 코딩 체크리스트
**매 파일 작성시 필수 확인사항**:

### Before Code (코드 작성 전)
- [ ] 인터페이스 정의했는가?
- [ ] 플러그인 매니페스트 작성했는가?
- [ ] 환경별 설정 분기 계획했는가?
- [ ] 의존성 주입 경로 설계했는가?

### During Code (코드 작성 중)
- [ ] 하드코딩된 값이 없는가?
- [ ] `new ClassName()` 직접 생성 없는가?
- [ ] `if (env === 'production')` 분기 없는가?
- [ ] 모든 의존성이 주입받는가?

### After Code (코드 작성 후)  
- [ ] 다른 환경에서도 동작하는가?
- [ ] 새 구현체로 교체 가능한가?
- [ ] 설정 변경으로 동작 제어되는가?
- [ ] 순환 의존성 없는가?

## 🔧 Registry 사용 패턴
```typescript
// 서비스 등록
registry.register('curriculum-service', {
  factory: (r) => new CurriculumService(
    r.get('sentence-generator'),
    r.get('stage-validator'),
    r.get('config-provider')
  ),
  lifecycle: 'singleton',
  dependencies: ['sentence-generator', 'stage-validator', 'config-provider'],
  tags: ['curriculum', 'core-service']
});

// 환경별 구현체 등록
registry.applyEnvironmentConfig(process.env.NODE_ENV);

// 플러그인 시스템 활용
registry.registerPlugin(CurriculumPlugin);
registry.registerPlugin(ValidationPlugin);
registry.registerPlugin(AIProviderPlugin);

// 사용
const service = await registry.get<CurriculumService>('curriculum-service');
```

## 🎯 CLI 토큰 절약 전략
- **모듈 경계 명확**: 각 모듈이 독립적으로 수정 가능
- **인터페이스 안정성**: 구현체만 교체, 인터페이스는 변경 없음  
- **설정 외부화**: 코드 수정 없이 동작 변경
- **플러그인 분리**: 새 기능이 기존 코드에 영향 없음

**결과**: 5만줄 넘어도 각 모듈을 독립적으로 수정 가능 → CLI 토큰 한계 극복

## 🔄 기존 파일 vs 새 파일 충돌 해결 전략

### 원칙: "Extension over Replacement"
```typescript
// ❌ 새 파일 생성으로 중복 야기
// NewUserService.ts, UserServiceV2.ts

// ✅ 기존 파일 확장으로 호환성 유지  
// UserService.ts (기존 인터페이스 유지 + 새 기능 추가)
```

### 1. 점진적 마이그레이션 패턴
```typescript
// Phase 1: 기존 파일에 새 인터페이스 추가
export interface IUserService {
  // 기존 메서드 (deprecated 표시)
  /** @deprecated Use getUserById instead */
  getUser(id: string): Promise<User>;
  
  // 새 메서드 
  getUserById(id: string): Promise<User>;
  getUsersByRole(role: string): Promise<User[]>;
}

// Phase 2: 기존 구현체를 새 인터페이스로 래핑
export class UserService implements IUserService {
  // 기존 메서드 → 새 메서드로 위임
  async getUser(id: string): Promise<User> {
    console.warn('getUser is deprecated. Use getUserById instead');
    return this.getUserById(id);
  }
  
  // 새 구현
  async getUserById(id: string): Promise<User> {
    // 새 로직
  }
}

// Phase 3: Registry에서 점진적 교체
registry.register('user-service', {
  factory: () => new UserService(), // 기존 호환 + 새 기능
  lifecycle: 'singleton'
});
```

### 2. Adapter 패턴으로 호환성 유지
```typescript
// 기존 파일: UserService.ts (변경 안 함)
export class UserService {
  getUser(id: string): Promise<User> { /* 기존 로직 */ }
}

// 어댑터 파일: UserServiceAdapter.ts
export class UserServiceAdapter implements IModernUserService {
  constructor(private legacyService: UserService) {}
  
  // 새 인터페이스 → 기존 서비스로 변환
  async getUserById(id: string): Promise<User> {
    return this.legacyService.getUser(id);
  }
  
  async getUsersByRole(role: string): Promise<User[]> {
    // 새 로직 구현
  }
}

// Registry에서 어댑터 사용
registry.register('user-service', {
  factory: (r) => new UserServiceAdapter(r.get('legacy-user-service')),
  lifecycle: 'singleton'
});
```

### 3. Feature Flag 기반 전환
```typescript
// 설정 파일: config/features.ts
export const featureFlags = {
  useNewUserService: process.env.NEW_USER_SERVICE === 'true',
  useAdvancedValidation: process.env.ADVANCED_VALIDATION === 'true'
};

// 기존 파일 확장: UserService.ts
export class UserService {
  constructor(private config: FeatureConfig) {}
  
  async getUser(id: string): Promise<User> {
    if (this.config.useNewUserService) {
      return this.getNewUserLogic(id);
    }
    return this.getLegacyUserLogic(id); // 기존 로직 유지
  }
  
  private getNewUserLogic(id: string): Promise<User> { /* 새 로직 */ }
  private getLegacyUserLogic(id: string): Promise<User> { /* 기존 로직 */ }
}
```

### 4. Plugin 시스템으로 점진적 교체
```typescript
// 기존 서비스를 플러그인으로 래핑
export const LegacyUserPlugin: PluginManifest = {
  name: 'legacy-user-service',
  version: '1.0.0',
  services: {
    'user-service': {
      factory: () => new UserService(), // 기존 클래스 그대로
      lifecycle: 'singleton'
    }
  }
};

// 새 서비스도 플러그인으로 구현
export const NewUserPlugin: PluginManifest = {
  name: 'enhanced-user-service', 
  version: '2.0.0',
  services: {
    'user-service': {
      factory: (r) => new EnhancedUserService(r.get('config')),
      lifecycle: 'singleton'
    }
  }
};

// 환경별 플러그인 선택
const activePlugin = process.env.USER_SERVICE_VERSION === 'v2' 
  ? NewUserPlugin 
  : LegacyUserPlugin;

registry.registerPlugin(activePlugin);
```

### 5. 파일 네이밍 규칙으로 충돌 방지
```bash
# ❌ 혼란스러운 네이밍
UserService.ts
UserServiceNew.ts  
UserServiceV2.ts
BetterUserService.ts

# ✅ 명확한 역할 기반 네이밍  
UserService.ts           # 메인 서비스
UserServiceAdapter.ts    # 레거시 호환용
UserServiceMock.ts       # 테스트용
UserServiceRedis.ts      # Redis 구현체
UserServiceFirebase.ts   # Firebase 구현체
```

### 6. 점진적 제거를 위한 Deprecation 전략
```typescript
// Step 1: 기존 메서드에 deprecated 마킹
export class UserService {
  /** 
   * @deprecated Since version 2.1. Use getUserById instead.
   * Will be removed in version 3.0.
   */
  async getUser(id: string): Promise<User> {
    console.warn('getUser() is deprecated. Use getUserById() instead.');
    return this.getUserById(id);
  }
  
  async getUserById(id: string): Promise<User> {
    // 새 구현
  }
}

// Step 2: 마이그레이션 도구 제공
export class UserServiceMigrationHelper {
  static migrateGetUserCalls(sourceCode: string): string {
    return sourceCode.replace(
      /\.getUser\(/g, 
      '.getUserById('
    );
  }
}

// Step 3: 자동화된 제거
export class UserService {
  async getUserById(id: string): Promise<User> {
    // deprecated 메서드 완전 제거됨
  }
}
```

## 🎯 실행 체크리스트

### 새 기능 추가 시:
- [ ] 기존 파일 확장 가능한가? (새 파일 생성 필요한가?)
- [ ] 기존 인터페이스와 호환되는가?
- [ ] Feature Flag로 점진적 전환 가능한가?
- [ ] Adapter 패턴으로 호환성 유지할 수 있는가?

### 기존 코드 변경 시:
- [ ] Backward compatibility 유지되는가?
- [ ] Deprecated 메서드에 경고 추가했는가?
- [ ] 마이그레이션 가이드 작성했는가?
- [ ] 단계별 제거 계획 수립했는가?

### Registry/Plugin 활용:
- [ ] 환경별로 다른 구현체 사용하는가?
- [ ] 플러그인 시스템으로 교체 가능한가?
- [ ] 설정으로 기능 토글 가능한가?
- [ ] 레거시와 새 버전 동시 지원하는가?

**핵심**: 새 파일 만들기보다는 **기존 파일 확장 + 점진적 마이그레이션**으로 충돌 최소화