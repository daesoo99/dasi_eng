
> dasi-english-web@1.0.0 lint
> eslint src --ext ts,tsx --report-unused-disable-directives --max-warnings 0 --format=json

[{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\adapters\\AudioContextAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\adapters\\BrowserAPIAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\adapters\\SpeechRecognitionAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\adapters\\SpeechSynthesisAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\AudioRecorder.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\AudioTest.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\AudioTestSimple.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\AudioV2Test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\AuthModal.tsx","messages":[{"ruleId":"no-undef","severity":1,"message":"'useMemo' is not defined.","line":127,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":127,"endColumn":29},{"ruleId":"no-undef","severity":1,"message":"'useMemo' is not defined.","line":131,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":131,"endColumn":35},{"ruleId":"no-undef","severity":1,"message":"'useMemo' is not defined.","line":136,"column":28,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, memo } from 'react';\r\nimport { getAuthService } from '../lib/firebase';\r\nimport { createUserWithEmailAndPassword, signInWithEmailAndPassword, updateProfile, signInWithPopup, GoogleAuthProvider } from 'firebase/auth';\r\nimport { auth } from '../lib/firebase';\r\n\r\ninterface AuthModalProps {\r\n  isOpen: boolean;\r\n  onClose: () => void;\r\n  onAuthSuccess: (user: any) => void;\r\n}\r\n\r\ntype AuthMode = 'login' | 'signup';\r\n\r\nexport const AuthModal: React.FC<AuthModalProps> = memo(({ isOpen, onClose, onAuthSuccess }) => {\r\n  const [authMode, setAuthMode] = useState<AuthMode>('login');\r\n  const [email, setEmail] = useState('');\r\n  const [password, setPassword] = useState('');\r\n  const [displayName, setDisplayName] = useState('');\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  // Auth 에러 메시지 처리 함수\r\n  const getAuthErrorMessage = useCallback((error: any): string => {\r\n    switch (error.code) {\r\n      case 'auth/user-not-found':\r\n        return '등록되지 않은 이메일입니다.';\r\n      case 'auth/wrong-password':\r\n        return '잘못된 비밀번호입니다.';\r\n      case 'auth/email-already-in-use':\r\n        return '이미 사용 중인 이메일입니다.';\r\n      case 'auth/weak-password':\r\n        return '비밀번호는 6자 이상이어야 합니다.';\r\n      case 'auth/invalid-email':\r\n        return '올바르지 않은 이메일 형식입니다.';\r\n      case 'auth/popup-closed-by-user':\r\n        return '로그인이 취소되었습니다.';\r\n      default:\r\n        return error.message || '로그인 중 오류가 발생했습니다.';\r\n    }\r\n  }, []);\r\n\r\n  const handleEmailAuth = useCallback(async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    setIsLoading(true);\r\n    setError(null);\r\n\r\n    console.log(`[DEBUG] 📧 이메일 ${authMode} 시도:`, { email, hasPassword: !!password });\r\n\r\n    try {\r\n      let userCredential;\r\n      \r\n      if (authMode === 'signup') {\r\n        userCredential = await createUserWithEmailAndPassword(auth, email, password);\r\n        \r\n        // 회원가입 시 displayName 설정\r\n        if (displayName && userCredential.user) {\r\n          await updateProfile(userCredential.user, {\r\n            displayName: displayName\r\n          });\r\n          console.log('[DEBUG] ✅ 프로필 업데이트 완료:', displayName);\r\n        }\r\n      } else {\r\n        userCredential = await signInWithEmailAndPassword(auth, email, password);\r\n      }\r\n\r\n      console.log('[DEBUG] ✅ 이메일 인증 성공:', userCredential.user.uid);\r\n      onAuthSuccess(userCredential.user);\r\n      onClose();\r\n    } catch (error: any) {\r\n      console.error('[DEBUG] ❌ 이메일 인증 실패:', error);\r\n      setError(getAuthErrorMessage(error));\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [authMode, email, password, displayName, onAuthSuccess, onClose, getAuthErrorMessage]);\r\n\r\n  const handleGoogleAuth = useCallback(async () => {\r\n    setIsLoading(true);\r\n    setError(null);\r\n    \r\n    console.log('[DEBUG] 🔍 구글 로그인 시도');\r\n\r\n    try {\r\n      const provider = new GoogleAuthProvider();\r\n      const userCredential = await signInWithPopup(auth, provider);\r\n      \r\n      console.log('[DEBUG] ✅ 구글 로그인 성공:', userCredential.user.uid);\r\n      onAuthSuccess(userCredential.user);\r\n      onClose();\r\n    } catch (error: any) {\r\n      console.error('[DEBUG] ❌ 구글 로그인 실패:', error);\r\n      setError(getAuthErrorMessage(error));\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [onAuthSuccess, onClose, getAuthErrorMessage]);\r\n\r\n  const handleAnonymousAuth = useCallback(async () => {\r\n    setIsLoading(true);\r\n    setError(null);\r\n    \r\n    console.log('[DEBUG] 👤 익명 로그인 시도');\r\n\r\n    try {\r\n      // 🎯 모듈화: Firebase 의존성을 동적으로 로드 \r\n      const auth = await getAuthService();\r\n      const { signInAnonymously } = await import('firebase/auth');\r\n      \r\n      const userCredential = await signInAnonymously(auth);\r\n      \r\n      console.log('[DEBUG] ✅ 익명 로그인 성공:', userCredential.user.uid);\r\n      onAuthSuccess(userCredential.user);\r\n      onClose();\r\n    } catch (error: any) {\r\n      console.error('[DEBUG] ❌ 익명 로그인 실패:', error);\r\n      setError(getAuthErrorMessage(error));\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [onAuthSuccess, onClose, getAuthErrorMessage]);\r\n\r\n  const handleModeToggle = useCallback(() => {\r\n    setAuthMode(authMode === 'login' ? 'signup' : 'login');\r\n    setError(null);\r\n  }, [authMode]);\r\n\r\n  const modalTitle = useMemo(() => {\r\n    return authMode === 'login' ? '로그인' : '회원가입';\r\n  }, [authMode]);\r\n\r\n  const submitButtonText = useMemo(() => {\r\n    if (isLoading) return '처리 중...';\r\n    return authMode === 'login' ? '로그인' : '회원가입';\r\n  }, [isLoading, authMode]);\r\n\r\n  const toggleButtonText = useMemo(() => {\r\n    return authMode === 'login' ? '계정이 없으신가요? 회원가입' : '이미 계정이 있으신가요? 로그인';\r\n  }, [authMode]);\r\n\r\n  if (!isOpen) return null;\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg p-8 max-w-md w-full mx-4 transition-colors duration-300\">\r\n        <div className=\"flex justify-between items-center mb-6\">\r\n          <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white\">\r\n            {modalTitle}\r\n          </h2>\r\n          <button\r\n            onClick={onClose}\r\n            className=\"text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 transition-colors duration-200\"\r\n            aria-label=\"닫기\"\r\n          >\r\n            ✕\r\n          </button>\r\n        </div>\r\n\r\n        {error && (\r\n          <div className=\"mb-4 p-3 bg-red-100 dark:bg-red-900 border border-red-400 dark:border-red-600 text-red-700 dark:text-red-200 rounded\">\r\n            {error}\r\n          </div>\r\n        )}\r\n\r\n        {/* 이메일/비밀번호 로그인 */}\r\n        <form onSubmit={handleEmailAuth} className=\"space-y-4\">\r\n          {authMode === 'signup' && (\r\n            <div>\r\n              <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\r\n                닉네임 (선택사항)\r\n              </label>\r\n              <input\r\n                type=\"text\"\r\n                value={displayName}\r\n                onChange={(e) => setDisplayName(e.target.value)}\r\n                className=\"w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 bg-white dark:bg-gray-700 text-gray-900 dark:text-white transition-colors duration-200\"\r\n                placeholder=\"표시될 이름을 입력하세요\"\r\n              />\r\n            </div>\r\n          )}\r\n          \r\n          <div>\r\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\r\n              이메일\r\n            </label>\r\n            <input\r\n              type=\"email\"\r\n              required\r\n              value={email}\r\n              onChange={(e) => setEmail(e.target.value)}\r\n              className=\"w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 bg-white dark:bg-gray-700 text-gray-900 dark:text-white transition-colors duration-200\"\r\n              placeholder=\"이메일을 입력하세요\"\r\n            />\r\n          </div>\r\n          \r\n          <div>\r\n            <label className=\"block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1\">\r\n              비밀번호\r\n            </label>\r\n            <input\r\n              type=\"password\"\r\n              required\r\n              minLength={6}\r\n              value={password}\r\n              onChange={(e) => setPassword(e.target.value)}\r\n              className=\"w-full px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500 dark:focus:ring-blue-400 bg-white dark:bg-gray-700 text-gray-900 dark:text-white transition-colors duration-200\"\r\n              placeholder=\"비밀번호를 입력하세요\"\r\n            />\r\n          </div>\r\n          \r\n          <button\r\n            type=\"submit\"\r\n            disabled={isLoading}\r\n            className=\"w-full bg-blue-500 dark:bg-blue-600 hover:bg-blue-600 dark:hover:bg-blue-700 disabled:bg-gray-300 dark:disabled:bg-gray-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200\"\r\n          >\r\n            {submitButtonText}\r\n          </button>\r\n        </form>\r\n\r\n        {/* 구분선 */}\r\n        <div className=\"my-6 flex items-center\">\r\n          <div className=\"flex-grow border-t border-gray-300 dark:border-gray-600\"></div>\r\n          <span className=\"mx-4 text-gray-500 dark:text-gray-400 text-sm\">또는</span>\r\n          <div className=\"flex-grow border-t border-gray-300 dark:border-gray-600\"></div>\r\n        </div>\r\n\r\n        {/* 소셜 로그인 */}\r\n        <div className=\"space-y-3\">\r\n          <button\r\n            onClick={handleGoogleAuth}\r\n            disabled={isLoading}\r\n            className=\"w-full bg-red-500 dark:bg-red-600 hover:bg-red-600 dark:hover:bg-red-700 disabled:bg-gray-300 dark:disabled:bg-gray-600 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center space-x-2\"\r\n          >\r\n            <span>🔍</span>\r\n            <span>구글 로그인</span>\r\n          </button>\r\n          \r\n          <button\r\n            onClick={handleAnonymousAuth}\r\n            disabled={isLoading}\r\n            className=\"w-full bg-gray-500 dark:bg-gray-600 hover:bg-gray-600 dark:hover:bg-gray-700 disabled:bg-gray-300 dark:disabled:bg-gray-700 text-white font-bold py-2 px-4 rounded-md transition-colors duration-200 flex items-center justify-center space-x-2\"\r\n          >\r\n            <span>👤</span>\r\n            <span>체험하기 (익명)</span>\r\n          </button>\r\n        </div>\r\n\r\n        {/* 모드 전환 */}\r\n        <div className=\"mt-6 text-center\">\r\n          <button\r\n            onClick={handleModeToggle}\r\n            className=\"text-blue-500 dark:text-blue-400 hover:text-blue-700 dark:hover:text-blue-300 text-sm transition-colors duration-200\"\r\n          >\r\n            {toggleButtonText}\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default AuthModal;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\AutoSpeakingFlow.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'flowState' and 'startAutomaticFlow'. Either include them or remove the dependency array.","line":83,"column":6,"nodeType":"ArrayExpression","endLine":83,"endColumn":29,"suggestions":[{"desc":"Update the dependencies array to be: [currentCard, flowState, isActive, startAutomaticFlow]","fix":{"range":[2514,2537],"text":"[currentCard, flowState, isActive, startAutomaticFlow]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'speech.confidence'. Either include it or remove the dependency array.","line":174,"column":6,"nodeType":"ArrayExpression","endLine":174,"endColumn":76,"suggestions":[{"desc":"Update the dependencies array to be: [speech.transcript, flowState, countdown, autoTimeout, onSpeechResult, speech.confidence]","fix":{"range":[4850,4920],"text":"[speech.transcript, flowState, countdown, autoTimeout, onSpeechResult, speech.confidence]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\r\nimport { useSpeech } from '@/hooks/useSpeech';\r\nimport { useCountdown } from '@/hooks/useCountdown';\r\n\r\ninterface AutoSpeakingFlowProps {\r\n  currentCard: any;\r\n  onSpeechResult: (transcript: string, confidence: number) => void;\r\n  onTimeout?: () => void;\r\n  isActive: boolean;\r\n}\r\n\r\nexport const AutoSpeakingFlow: React.FC<AutoSpeakingFlowProps> = ({\r\n  currentCard,\r\n  onSpeechResult,\r\n  onTimeout,\r\n  isActive\r\n}) => {\r\n  const [flowState, setFlowState] = useState<'idle' | 'tts' | 'beep' | 'recording' | 'processing'>('idle');\r\n  const [autoTimeout, setAutoTimeout] = useState<NodeJS.Timeout | null>(null);\r\n  const [isPaused, setIsPaused] = useState<boolean>(false);\r\n  \r\n  const countdown = useCountdown(() => {\r\n    console.log('[AutoSpeakingFlow] Timer completed, handling timeout');\r\n    handleTimeoutComplete();\r\n  });\r\n  \r\n  // 시간 초과 처리 함수\r\n  const handleTimeoutComplete = async () => {\r\n    try {\r\n      // 현재 녹음 중지\r\n      if (speech.isRecording) {\r\n        speech.stopRecording();\r\n      }\r\n      \r\n      // 상태를 processing으로 변경\r\n      setFlowState('processing');\r\n      setIsPaused(false);\r\n      \r\n      // 정답 TTS 재생 (1.5초 후)\r\n      if (currentCard?.target_en) {\r\n        setTimeout(async () => {\r\n          try {\r\n            console.log('[AutoSpeakingFlow] Playing answer TTS:', currentCard.target_en);\r\n            await speech.speak(currentCard.target_en, { lang: 'en-US' });\r\n            \r\n            // TTS 완료 후 콜백 호출\r\n            setTimeout(() => {\r\n              console.log('[AutoSpeakingFlow] Timeout processing complete');\r\n              setFlowState('idle');\r\n              onTimeout?.();\r\n            }, 1000);\r\n          } catch (error) {\r\n            console.error('[AutoSpeakingFlow] Error playing answer TTS:', error);\r\n            setFlowState('idle');\r\n            onTimeout?.();\r\n          }\r\n        }, 1500);\r\n      } else {\r\n        // 정답이 없으면 바로 다음으로\r\n        setTimeout(() => {\r\n          setFlowState('idle');\r\n          onTimeout?.();\r\n        }, 1500);\r\n      }\r\n    } catch (error) {\r\n      console.error('[AutoSpeakingFlow] Error in timeout handling:', error);\r\n      setFlowState('idle');\r\n      onTimeout?.();\r\n    }\r\n  };\r\n\r\n  const speech = useSpeech({\r\n    apiBaseUrl: import.meta.env.VITE_API_BASE_URL,\r\n    preferCloudSTT: false,\r\n    language: 'en-US',\r\n  });\r\n\r\n  // 카드 변경 시 자동 플로우 시작\r\n  useEffect(() => {\r\n    if (currentCard && isActive && flowState === 'idle') {\r\n      startAutomaticFlow();\r\n    }\r\n  }, [currentCard, isActive]);\r\n\r\n  // 컴포넌트 언마운트 시 정리\r\n  useEffect(() => {\r\n    return () => {\r\n      countdown.stop();\r\n      if (autoTimeout) clearTimeout(autoTimeout);\r\n      speech.stopAll();\r\n    };\r\n  }, [countdown, autoTimeout, speech]);\r\n\r\n  const startAutomaticFlow = async () => {\r\n    if (!currentCard) return;\r\n    \r\n    console.log('🎤 자동 Speaking 플로우 시작');\r\n    setFlowState('tts');\r\n    \r\n    // 1. 한국어 TTS 재생\r\n    if (speech.isTTSAvailable) {\r\n      await speech.speak(currentCard.front_ko, 'ko-KR');\r\n      \r\n      // TTS 완료 후 1초 대기\r\n      setTimeout(() => {\r\n        playBeepAndStartRecording();\r\n      }, 1000);\r\n    } else {\r\n      // TTS가 없으면 바로 녹음 시작\r\n      setTimeout(() => {\r\n        playBeepAndStartRecording();\r\n      }, 2000);\r\n    }\r\n  };\r\n\r\n  const playBeepAndStartRecording = () => {\r\n    console.log('🔔 비프음 재생 및 녹음 시작');\r\n    setFlowState('beep');\r\n    \r\n    // 비프음 재생\r\n    playBeep();\r\n    \r\n    // 비프음 후 500ms 대기 후 녹음 시작\r\n    setTimeout(() => {\r\n      if (!isPaused) {\r\n        setFlowState('recording');\r\n        speech.startRecording();\r\n        \r\n        // 10초 카운트다운 시작\r\n        countdown.start(10);\r\n      }\r\n    }, 500);\r\n  };\r\n\r\n  const playBeep = () => {\r\n    // Web Audio API로 비프음 생성\r\n    try {\r\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      const oscillator = audioContext.createOscillator();\r\n      const gainNode = audioContext.createGain();\r\n      \r\n      oscillator.connect(gainNode);\r\n      gainNode.connect(audioContext.destination);\r\n      \r\n      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);\r\n      oscillator.type = 'sine';\r\n      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\r\n      \r\n      oscillator.start();\r\n      oscillator.stop(audioContext.currentTime + 0.2);\r\n    } catch (error) {\r\n      console.error('비프음 재생 실패:', error);\r\n    }\r\n  };\r\n\r\n  // 음성 인식 결과 처리\r\n  useEffect(() => {\r\n    if (speech.transcript && flowState === 'recording') {\r\n      setFlowState('processing');\r\n      \r\n      // 타이머 정리\r\n      countdown.stop();\r\n      if (autoTimeout) {\r\n        clearTimeout(autoTimeout);\r\n        setAutoTimeout(null);\r\n      }\r\n      \r\n      // 부모 컴포넌트로 결과 전달\r\n      onSpeechResult(speech.transcript, speech.confidence);\r\n      \r\n      // 상태 초기화\r\n      setFlowState('idle');\r\n    }\r\n  }, [speech.transcript, flowState, countdown, autoTimeout, onSpeechResult]);\r\n\r\n  const getStatusMessage = () => {\r\n    switch (flowState) {\r\n      case 'tts':\r\n        return '🔊 문제를 들려드리고 있습니다...';\r\n      case 'beep':\r\n        return '🔔 곧 녹음이 시작됩니다...';\r\n      case 'recording':\r\n        const remainingSeconds = Math.ceil(countdown.remaining);\r\n        return countdown.isPaused ? `⏸️ 일시정지됨 (남은 시간: ${remainingSeconds}초)` : `🎤 말씀해 주세요... (남은 시간: ${remainingSeconds}초)`;\r\n      case 'processing':\r\n        return '🤖 답변을 분석 중입니다...';\r\n      default:\r\n        return '';\r\n    }\r\n  };\r\n\r\n  const getProgressWidth = () => {\r\n    if (flowState === 'recording') {\r\n      const elapsed = 10 - countdown.remaining;\r\n      return `${Math.min((elapsed / 10) * 100, 100)}%`;\r\n    }\r\n    return '0%';\r\n  };\r\n\r\n  // 일시정지/재개 제어\r\n  const handlePauseResume = () => {\r\n    console.log(`[AutoSpeakingFlow] ${countdown.isPaused || isPaused ? 'Resume' : 'Pause'} requested, flowState: ${flowState}`);\r\n    \r\n    if (countdown.isPaused || isPaused) {\r\n      // 재개\r\n      if (flowState === 'tts' && speech.isTTSPaused()) {\r\n        console.log('[AutoSpeakingFlow] Resuming TTS');\r\n        speech.resumeTTS();\r\n      } else if (flowState === 'recording') {\r\n        console.log('[AutoSpeakingFlow] Resuming countdown');\r\n        countdown.resume();\r\n      }\r\n      setIsPaused(false);\r\n    } else {\r\n      // 일시정지\r\n      if (flowState === 'tts' && speech.isTTSSpeaking()) {\r\n        console.log('[AutoSpeakingFlow] Pausing TTS');\r\n        speech.pauseTTS();\r\n      } else if (flowState === 'recording') {\r\n        console.log('[AutoSpeakingFlow] Pausing countdown');\r\n        countdown.pause();\r\n      } else if (flowState === 'beep') {\r\n        console.log('[AutoSpeakingFlow] Stopping beep');\r\n        speech.stopBeep();\r\n      }\r\n      setIsPaused(true);\r\n    }\r\n  };\r\n\r\n  // 완전 중지\r\n  const handleStop = () => {\r\n    setFlowState('idle');\r\n    setIsPaused(false);\r\n    countdown.stop();\r\n    speech.stopAll();\r\n    if (autoTimeout) {\r\n      clearTimeout(autoTimeout);\r\n      setAutoTimeout(null);\r\n    }\r\n  };\r\n\r\n  if (!isActive || flowState === 'idle') {\r\n    return null;\r\n  }\r\n\r\n  return (\r\n    <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-6 mb-6\">\r\n      <div className=\"text-center\">\r\n        <div className=\"text-lg font-semibold text-blue-800 mb-4\">\r\n          {getStatusMessage()}\r\n        </div>\r\n        \r\n        {flowState === 'recording' && (\r\n          <>\r\n            {/* 진행 바 */}\r\n            <div className=\"w-full bg-blue-200 rounded-full h-2 mb-4\">\r\n              <div \r\n                className=\"bg-blue-600 h-2 rounded-full transition-all duration-100\"\r\n                style={{ width: getProgressWidth() }}\r\n              />\r\n            </div>\r\n            \r\n            {/* 녹음 표시기 */}\r\n            <div className=\"flex items-center justify-center space-x-3\">\r\n              <div className={`w-3 h-3 rounded-full ${countdown.isPaused ? 'bg-yellow-500' : 'bg-red-500 animate-pulse'}`}></div>\r\n              <span className=\"text-sm text-blue-700\">\r\n                {countdown.isPaused ? '일시정지됨' : '음성을 인식하고 있습니다...'} (남은 시간: {Math.ceil(countdown.remaining)}초)\r\n              </span>\r\n            </div>\r\n            \r\n            {/* 제어 버튼 */}\r\n            <div className=\"flex justify-center space-x-3 mt-4\">\r\n              <button\r\n                onClick={handlePauseResume}\r\n                className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors text-sm font-medium\"\r\n              >\r\n                {countdown.isPaused ? '▶️ 재개' : '⏸️ 일시정지'}\r\n              </button>\r\n              <button\r\n                onClick={handleStop}\r\n                className=\"px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors text-sm font-medium\"\r\n              >\r\n                ⏹️ 중지\r\n              </button>\r\n            </div>\r\n          </>\r\n        )}\r\n        \r\n        {flowState === 'tts' && (\r\n          <>\r\n            <div className=\"flex items-center justify-center space-x-3\">\r\n              <div className={`w-3 h-3 rounded-full ${speech.isTTSPaused() ? 'bg-yellow-500' : 'bg-green-500 animate-pulse'}`}></div>\r\n              <span className=\"text-sm text-blue-700\">\r\n                {speech.isTTSPaused() ? '음성 재생 일시정지됨' : '한국어 문제를 재생 중...'}\r\n              </span>\r\n            </div>\r\n            \r\n            {/* TTS 제어 버튼 */}\r\n            <div className=\"flex justify-center space-x-3 mt-4\">\r\n              <button\r\n                onClick={handlePauseResume}\r\n                className=\"px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors text-sm font-medium\"\r\n              >\r\n                {speech.isTTSPaused() ? '▶️ 재개' : '⏸️ 일시정지'}\r\n              </button>\r\n              <button\r\n                onClick={handleStop}\r\n                className=\"px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors text-sm font-medium\"\r\n              >\r\n                ⏹️ 중지\r\n              </button>\r\n            </div>\r\n          </>\r\n        )}\r\n        \r\n        {flowState === 'beep' && (\r\n          <>\r\n            <div className=\"flex items-center justify-center space-x-3\">\r\n              <div className=\"w-3 h-3 bg-yellow-500 rounded-full animate-pulse\"></div>\r\n              <span className=\"text-sm text-blue-700\">신호음 후 말씀해 주세요</span>\r\n            </div>\r\n            \r\n            {/* 비프음 중지 버튼 */}\r\n            <div className=\"flex justify-center space-x-3 mt-4\">\r\n              <button\r\n                onClick={handleStop}\r\n                className=\"px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors text-sm font-medium\"\r\n              >\r\n                ⏹️ 중지\r\n              </button>\r\n            </div>\r\n          </>\r\n        )}\r\n        \r\n        {flowState === 'processing' && (\r\n          <div className=\"flex items-center justify-center space-x-3\">\r\n            <div className=\"animate-spin rounded-full h-4 w-4 border-b-2 border-blue-600\"></div>\r\n            <span className=\"text-sm text-blue-700\">답변 분석 중...</span>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\AutoSpeakingFlowV2.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ControlPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\CurriculumLint.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\CurriculumSmokeTest.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\CustomFeedbackPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ErrorBoundary.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":160,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":160,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { Component, ReactNode, ErrorInfo } from 'react';\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error?: Error;\n  errorInfo?: ErrorInfo;\n  retryCount: number;\n  isRetrying: boolean;\n}\n\ninterface ErrorBoundaryProps {\n  children: ReactNode;\n  fallback?: ReactNode;\n  onError?: (error: Error, errorInfo: ErrorInfo) => void;\n  maxRetries?: number;\n  resetOnPropsChange?: boolean;\n  resetKeys?: Array<string | number>;\n  level?: 'page' | 'section' | 'component';\n}\n\n/**\n * ErrorBoundary component to catch and handle React component errors\n * Prevents the entire application from crashing when a component error occurs\n */\nexport class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { \n      hasError: false, \n      retryCount: 0,\n      isRetrying: false \n    };\n  }\n\n  /**\n   * Static method to update state when an error is caught\n   * @param error - The error that was thrown\n   * @returns Updated state object\n   */\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    // Update state so the next render will show the fallback UI\n    return { hasError: true, error };\n  }\n\n  /**\n   * Component lifecycle method called when an error is caught\n   * @param error - The error that was thrown\n   * @param errorInfo - Additional information about the error\n   */\n  componentDidCatch(error: Error, errorInfo: ErrorInfo) {\n    // Enhanced logging for learning flow debugging\n    console.error('[DEBUG] ❌ ErrorBoundary 에러 포착:', {\n      error: {\n        name: error.name,\n        message: error.message,\n        stack: error.stack\n      },\n      errorInfo: {\n        componentStack: errorInfo.componentStack\n      },\n      level: this.props.level || 'component',\n      timestamp: new Date().toISOString(),\n      url: window.location.href,\n      userAgent: navigator.userAgent\n    });\n    \n    // Update state with error details\n    this.setState({\n      error,\n      errorInfo\n    });\n\n    // Call optional error handler\n    if (this.props.onError) {\n      this.props.onError(error, errorInfo);\n    }\n  }\n\n  /**\n   * Reset the error boundary state\n   */\n  resetError = () => {\n    this.setState({ hasError: false, error: undefined, errorInfo: undefined });\n  };\n\n  render() {\n    if (this.state.hasError) {\n      // Custom fallback UI\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      // Default fallback UI\n      return (\n        <div className=\"error-boundary-container p-6 bg-red-50 border border-red-200 rounded-lg m-4\">\n          <div className=\"text-center\">\n            <div className=\"text-red-600 mb-4\">\n              <svg className=\"w-16 h-16 mx-auto mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z\" />\n              </svg>\n            </div>\n            \n            <h2 className=\"text-xl font-bold text-red-800 mb-2\">\n              문제가 발생했습니다\n            </h2>\n            \n            <p className=\"text-red-600 mb-4\">\n              이 구성 요소에서 예상치 못한 오류가 발생했습니다.\n            </p>\n\n            <button\n              onClick={this.resetError}\n              className=\"px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors mb-4\"\n            >\n              다시 시도\n            </button>\n\n            {/* Show error details in development */}\n            {process.env.NODE_ENV === 'development' && this.state.error && (\n              <details className=\"text-left bg-red-100 p-4 rounded border mt-4\">\n                <summary className=\"cursor-pointer font-medium text-red-800 mb-2\">\n                  오류 세부정보 (개발 모드)\n                </summary>\n                <div className=\"text-sm text-red-700 space-y-2\">\n                  <div>\n                    <strong>Error:</strong> {this.state.error.message}\n                  </div>\n                  <div>\n                    <strong>Stack:</strong>\n                    <pre className=\"whitespace-pre-wrap text-xs mt-1 bg-red-50 p-2 rounded\">\n                      {this.state.error.stack}\n                    </pre>\n                  </div>\n                  {this.state.errorInfo && (\n                    <div>\n                      <strong>Component Stack:</strong>\n                      <pre className=\"whitespace-pre-wrap text-xs mt-1 bg-red-50 p-2 rounded\">\n                        {this.state.errorInfo.componentStack}\n                      </pre>\n                    </div>\n                  )}\n                </div>\n              </details>\n            )}\n          </div>\n        </div>\n      );\n    }\n\n    return this.props.children;\n  }\n}\n\n/**\n * Higher-order component wrapper for functional components\n * @param Component - The component to wrap with error boundary\n * @param errorBoundaryProps - Props to pass to the ErrorBoundary\n * @returns Wrapped component with error boundary\n */\nexport function withErrorBoundary<P extends object>(\n  Component: React.ComponentType<P>,\n  errorBoundaryProps?: Omit<ErrorBoundaryProps, 'children'>\n) {\n  const WrappedComponent = (props: P) => (\n    <ErrorBoundary {...errorBoundaryProps}>\n      <Component {...props} />\n    </ErrorBoundary>\n  );\n\n  WrappedComponent.displayName = `withErrorBoundary(${Component.displayName || Component.name})`;\n  \n  return WrappedComponent;\n}\n\nexport default ErrorBoundary;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ExplanationModeSession.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'proceedToNext'. Either include it or remove the dependency array.","line":71,"column":6,"nodeType":"ArrayExpression","endLine":71,"endColumn":102,"suggestions":[{"desc":"Update the dependencies array to be: [session, isAnswering, currentQuestionIndex, userAnswer, settings.showDetailedFeedback, proceedToNext]","fix":{"range":[2168,2264],"text":"[session, isAnswering, currentQuestionIndex, userAnswer, settings.showDetailedFeedback, proceedToNext]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'completeSession'. Either include it or remove the dependency array.","line":86,"column":6,"nodeType":"ArrayExpression","endLine":86,"endColumn":37,"suggestions":[{"desc":"Update the dependencies array to be: [session, currentQuestionIndex, completeSession]","fix":{"range":[2646,2677],"text":"[session, currentQuestionIndex, completeSession]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, memo, useCallback } from 'react';\r\nimport { speedDifficultyService, type SpeedSession, type ExplanationModeSettings } from '@/services/speedDifficultyModes';\r\n\r\ninterface ExplanationModeSessionProps {\r\n  userId: string;\r\n  settings: ExplanationModeSettings;\r\n  questionCount: number;\r\n  onComplete: (results: any) => void;\r\n  onExit: () => void;\r\n}\r\n\r\nexport const ExplanationModeSession: React.FC<ExplanationModeSessionProps> = memo(({\r\n  userId,\r\n  settings,\r\n  questionCount,\r\n  onComplete,\r\n  onExit\r\n}) => {\r\n  const [session, setSession] = useState<SpeedSession | null>(null);\r\n  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);\r\n  const [userAnswer, setUserAnswer] = useState('');\r\n  const [results, setResults] = useState<any[]>([]);\r\n  const [showExplanation, setShowExplanation] = useState(false);\r\n  const [currentResult, setCurrentResult] = useState<any>(null);\r\n  const [isAnswering, setIsAnswering] = useState(true);\r\n\r\n  // 세션 초기화\r\n  useEffect(() => {\r\n    const initSession = async () => {\r\n      try {\r\n        const newSession = await speedDifficultyService.createExplanationSession(userId, settings, questionCount);\r\n        setSession(newSession);\r\n      } catch (error) {\r\n        console.error('해설 모드 세션 초기화 실패:', error);\r\n      }\r\n    };\r\n\r\n    initSession();\r\n  }, [userId, settings, questionCount]);\r\n\r\n  // 답변 제출\r\n  const handleSubmit = useCallback(async () => {\r\n    if (!session || !isAnswering) return;\r\n\r\n    setIsAnswering(false);\r\n    \r\n    try {\r\n      const currentQuestion = session.questions[currentQuestionIndex];\r\n      const responseTime = 5000; // 해설 모드는 시간 제한 없음\r\n      \r\n      const result = await speedDifficultyService.processAnswer(\r\n        session.sessionId,\r\n        currentQuestion.questionId,\r\n        userAnswer,\r\n        responseTime\r\n      );\r\n\r\n      setCurrentResult(result);\r\n      setResults(prev => [...prev, result]);\r\n      \r\n      // 해설 표시\r\n      if (settings.showDetailedFeedback) {\r\n        setShowExplanation(true);\r\n      } else {\r\n        proceedToNext();\r\n      }\r\n\r\n    } catch (error) {\r\n      console.error('답변 처리 실패:', error);\r\n    }\r\n  }, [session, isAnswering, currentQuestionIndex, userAnswer, results, settings.showDetailedFeedback]);\r\n\r\n  // 다음 문제로 진행\r\n  const proceedToNext = useCallback(() => {\r\n    if (!session) return;\r\n\r\n    if (currentQuestionIndex < session.questions.length - 1) {\r\n      setCurrentQuestionIndex(prev => prev + 1);\r\n      setUserAnswer('');\r\n      setShowExplanation(false);\r\n      setCurrentResult(null);\r\n      setIsAnswering(true);\r\n    } else {\r\n      completeSession();\r\n    }\r\n  }, [session, currentQuestionIndex]);\r\n\r\n  // 세션 완료\r\n  const completeSession = useCallback(async () => {\r\n    if (!session) return;\r\n\r\n    try {\r\n      const finalResults = await speedDifficultyService.completeSession(session.sessionId);\r\n      onComplete(finalResults);\r\n    } catch (error) {\r\n      console.error('세션 완료 실패:', error);\r\n    }\r\n  }, [session, onComplete]);\r\n\r\n  if (!session) {\r\n    return (\r\n      <div className=\"flex items-center justify-center min-h-screen\">\r\n        <div className=\"text-center\">\r\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-purple-500 mx-auto mb-4\"></div>\r\n          <div className=\"text-gray-600\">해설 모드를 준비하고 있습니다...</div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const currentQuestion = session.questions[currentQuestionIndex];\r\n  const progress = ((currentQuestionIndex + 1) / session.questions.length) * 100;\r\n\r\n  return (\r\n    <div className=\"max-w-4xl mx-auto p-6\">\r\n      {/* 헤더 */}\r\n      <div className=\"bg-white rounded-lg shadow-lg p-6 mb-6\">\r\n        <div className=\"flex items-center justify-between mb-4\">\r\n          <div>\r\n            <h1 className=\"text-2xl font-bold text-gray-900\">📚 해설 모드</h1>\r\n            <p className=\"text-gray-600\">\r\n              문제 {currentQuestionIndex + 1} / {session.questions.length}\r\n            </p>\r\n          </div>\r\n          \r\n          <div className=\"text-center\">\r\n            <div className=\"text-sm text-gray-600\">진행률</div>\r\n            <div className=\"text-xl font-bold text-purple-600\">{Math.round(progress)}%</div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* 진행률 바 */}\r\n        <div className=\"w-full bg-gray-200 rounded-full h-2\">\r\n          <div \r\n            className=\"bg-purple-600 h-2 rounded-full transition-all duration-300\"\r\n            style={{ width: `${progress}%` }}\r\n          />\r\n        </div>\r\n      </div>\r\n\r\n      {!showExplanation ? (\r\n        /* 문제 화면 */\r\n        <div className=\"bg-white rounded-lg shadow-lg p-8 mb-6\">\r\n          <div className=\"mb-6\">\r\n            <div className=\"flex items-center gap-2 mb-4\">\r\n              <span className=\"bg-purple-100 text-purple-800 text-xs font-medium px-2.5 py-0.5 rounded\">\r\n                Level {currentQuestion.level}\r\n              </span>\r\n              <span className={`text-xs font-medium px-2.5 py-0.5 rounded ${\r\n                currentQuestion.difficulty === 'easy' ? 'bg-green-100 text-green-800' :\r\n                currentQuestion.difficulty === 'medium' ? 'bg-yellow-100 text-yellow-800' :\r\n                'bg-red-100 text-red-800'\r\n              }`}>\r\n                {currentQuestion.difficulty}\r\n              </span>\r\n              {currentQuestion.tags.map(tag => (\r\n                <span key={tag} className=\"bg-gray-100 text-gray-700 text-xs px-2 py-1 rounded\">\r\n                  {tag}\r\n                </span>\r\n              ))}\r\n            </div>\r\n            \r\n            <h2 className=\"text-2xl font-semibold text-gray-900 mb-4\">\r\n              {currentQuestion.content}\r\n            </h2>\r\n            \r\n            <div className=\"text-sm text-gray-600 mb-4\">\r\n              💡 <strong>해설 모드:</strong> 시간 제한이 없으니 충분히 생각해보세요. \r\n              답변 후 상세한 설명을 확인할 수 있습니다.\r\n            </div>\r\n          </div>\r\n\r\n          {/* 답변 입력 */}\r\n          <div className=\"space-y-4\">\r\n            <input\r\n              type=\"text\"\r\n              value={userAnswer}\r\n              onChange={(e) => setUserAnswer(e.target.value)}\r\n              onKeyPress={(e) => e.key === 'Enter' && isAnswering && userAnswer.trim() && handleSubmit()}\r\n              className=\"w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-purple-500 focus:border-transparent text-lg\"\r\n              placeholder=\"답을 입력하세요...\"\r\n              disabled={!isAnswering}\r\n              autoFocus\r\n            />\r\n            \r\n            <button\r\n              onClick={handleSubmit}\r\n              disabled={!isAnswering || !userAnswer.trim()}\r\n              className=\"w-full bg-purple-600 hover:bg-purple-700 disabled:bg-gray-400 text-white font-bold py-3 px-6 rounded-lg transition-colors text-lg\"\r\n            >\r\n              {isAnswering ? '답변 제출 및 해설 보기' : '처리 중...'}\r\n            </button>\r\n          </div>\r\n        </div>\r\n      ) : (\r\n        /* 해설 화면 */\r\n        <div className=\"space-y-6\">\r\n          {/* 답변 결과 */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-6\">\r\n            <div className=\"flex items-center justify-between mb-4\">\r\n              <h3 className=\"text-xl font-semibold text-gray-900\">📝 답변 결과</h3>\r\n              <div className={`px-3 py-1 rounded-full text-sm font-medium ${\r\n                currentResult?.isCorrect \r\n                  ? 'bg-green-100 text-green-800' \r\n                  : 'bg-red-100 text-red-800'\r\n              }`}>\r\n                {currentResult?.isCorrect ? '✅ 정답' : '❌ 오답'}\r\n              </div>\r\n            </div>\r\n            \r\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\r\n              <div>\r\n                <div className=\"text-sm text-gray-600 mb-1\">내 답변</div>\r\n                <div className=\"text-lg font-medium text-gray-900 bg-gray-50 p-3 rounded\">\r\n                  {currentResult?.userAnswer || '(답변 없음)'}\r\n                </div>\r\n              </div>\r\n              <div>\r\n                <div className=\"text-sm text-gray-600 mb-1\">정답</div>\r\n                <div className=\"text-lg font-medium text-green-700 bg-green-50 p-3 rounded\">\r\n                  {currentResult?.correctAnswer}\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* 상세 해설 */}\r\n          {settings.showDetailedFeedback && currentResult?.explanation && (\r\n            <div className=\"bg-white rounded-lg shadow-lg p-6\">\r\n              <h3 className=\"text-xl font-semibold text-gray-900 mb-4\">🎯 상세 해설</h3>\r\n              <div className=\"prose max-w-none\">\r\n                <div \r\n                  className=\"text-gray-700 leading-relaxed whitespace-pre-line\"\r\n                  dangerouslySetInnerHTML={{ \r\n                    __html: currentResult.explanation.replace(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>')\r\n                      .replace(/`(.*?)`/g, '<code class=\"bg-gray-100 px-1 py-0.5 rounded text-sm\">$1</code>')\r\n                  }}\r\n                />\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* 문법 노트 (설정에 따라) */}\r\n          {settings.includeGrammarNotes && (\r\n            <div className=\"bg-gradient-to-r from-blue-50 to-indigo-50 border border-blue-200 rounded-lg p-6\">\r\n              <h3 className=\"text-lg font-semibold text-blue-900 mb-3\">📖 문법 노트</h3>\r\n              <div className=\"space-y-3 text-blue-800\">\r\n                <div>\r\n                  <strong>핵심 문법:</strong> {currentQuestion.tags.includes('grammar') ? '조건문 (Conditional)' : '비즈니스 표현'}\r\n                </div>\r\n                <div>\r\n                  <strong>난이도:</strong> {currentQuestion.difficulty} 수준\r\n                </div>\r\n                <div>\r\n                  <strong>학습 팁:</strong> 이 유형의 문제는 반복 학습을 통해 패턴을 익히는 것이 중요합니다.\r\n                </div>\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* 예문 (설정에 따라) */}\r\n          {settings.includeExamples && (\r\n            <div className=\"bg-gradient-to-r from-green-50 to-emerald-50 border border-green-200 rounded-lg p-6\">\r\n              <h3 className=\"text-lg font-semibold text-green-900 mb-3\">📚 추가 예문</h3>\r\n              <div className=\"space-y-2\">\r\n                <div className=\"text-green-800\">\r\n                  • If I had more time, I would learn Spanish.\r\n                </div>\r\n                <div className=\"text-green-800\">\r\n                  • If she had called earlier, we could have met.\r\n                </div>\r\n                <div className=\"text-green-800\">\r\n                  • If they had studied harder, they would have passed.\r\n                </div>\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* 다음 버튼 */}\r\n          <div className=\"flex justify-center\">\r\n            <button\r\n              onClick={proceedToNext}\r\n              className=\"bg-purple-600 hover:bg-purple-700 text-white font-bold py-3 px-8 rounded-lg transition-colors text-lg\"\r\n            >\r\n              {currentQuestionIndex < session.questions.length - 1 ? '다음 문제로 →' : '해설 모드 완료하기'}\r\n            </button>\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {/* 하단 컨트롤 */}\r\n      <div className=\"flex justify-between mt-6\">\r\n        <button\r\n          onClick={onExit}\r\n          className=\"bg-gray-500 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded transition-colors\"\r\n        >\r\n          나가기\r\n        </button>\r\n        \r\n        {!showExplanation && (\r\n          <div className=\"text-sm text-gray-600 flex items-center\">\r\n            <span>Enter 키로 답변 제출</span>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n});\r\n\r\nExplanationModeSession.displayName = 'ExplanationModeSession';","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\FeedbackPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\LoadingOverlay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\LoadingSkeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\MetricsDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\MigrationDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\MixedLevelSession.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\PatternTrainingFlowFinal.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'getCountdownTime' function makes the dependencies of useCallback Hook (at line 358) change on every render. Move it inside the useCallback callback. Alternatively, wrap the definition of 'getCountdownTime' in its own useCallback() Hook.","line":67,"column":9,"nodeType":"VariableDeclarator","endLine":73,"endColumn":4},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'handleResult' and 'handleTimeout'. Either include them or remove the dependency array.","line":273,"column":6,"nodeType":"ArrayExpression","endLine":273,"endColumn":38,"suggestions":[{"desc":"Update the dependencies array to be: [flowState.isRecording, handleResult, handleTimeout, onError]","fix":{"range":[8750,8782],"text":"[flowState.isRecording, handleResult, handleTimeout, onError]"}}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'startFlow'. Either include it or remove the dependency array.","line":369,"column":6,"nodeType":"ArrayExpression","endLine":369,"endColumn":53,"suggestions":[{"desc":"Update the dependencies array to be: [autoStartKey, autoStart, koreanText, disabled, startFlow]","fix":{"range":[11897,11944],"text":"[autoStartKey, autoStart, koreanText, disabled, startFlow]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { useLocalStorage, STORAGE_KEYS } from '@/hooks/useLocalStorage';\nimport { getCountdownDuration, type SpeakingStage } from '@/utils/speakingStageUtils';\n\n// 🔒 모듈 스코프 가드: StrictMode 재마운트까지 차단\nconst __autoStartGuards = new Set<string>();\nconst makeKey = (stage: number, ko: string, en: string) =>\n  `${stage}::${ko}::${en}`;\n\ninterface PatternTrainingFlowFinalProps {\n  koreanText: string;\n  expectedEnglish: string;\n  onResult: (userAnswer: string, isCorrect: boolean, confidence: number, responseTime: number) => void;\n  onError?: (error: string) => void;\n  stage: number;\n  disabled?: boolean;\n  autoStart?: boolean;\n  className?: string;\n  mistakeId?: string;\n  showCorrectAnswer?: boolean;\n}\n\ntype FlowPhase = 'idle' | 'tts' | 'countdown' | 'recognition' | 'completed';\n\nexport const PatternTrainingFlowFinal: React.FC<PatternTrainingFlowFinalProps> = ({\n  koreanText,\n  expectedEnglish,\n  onResult,\n  onError,\n  stage,\n  disabled = false,\n  autoStart = false,\n  className = '',\n  mistakeId: _mistakeId,\n  showCorrectAnswer = true\n}) => {\n  // Single state object to prevent re-render issues\n  const [flowState, setFlowState] = useState({\n    phase: 'idle' as FlowPhase,\n    countdownTimer: 0,\n    recognitionTimer: 0,\n    speechResult: '',\n    showAnswer: false,\n    isRecording: false,\n    ttsInitialized: false,\n    recognitionStartTime: 0,\n    hasStarted: false // Prevent duplicate starts\n  });\n  \n  // Voice settings\n  const { value: voiceSettings } = useLocalStorage(STORAGE_KEYS.VOICE_SETTINGS);\n  \n  // Auto-start 키 생성\n  const autoStartKey = makeKey(stage, koreanText || '', expectedEnglish || '');\n  \n  // Single ref for all cleanup\n  const flowRef = useRef({\n    recognition: null as any,\n    countdownInterval: null as NodeJS.Timeout | null,\n    recordingTimeout: null as NodeJS.Timeout | null,\n    timerInterval: null as NodeJS.Timeout | null,\n    hasReceivedResult: false,\n    isCleaningUp: false\n  });\n\n  // Get stage-based timing using utility function\n  const getCountdownTime = () => {\n    // 정규 단계는 유틸리티 함수 사용, 기타는 기본값 2초\n    if (stage >= 1 && stage <= 3) {\n      return getCountdownDuration(stage as SpeakingStage);\n    }\n    return 2; // 기본값: 2초\n  };\n\n  // Force cleanup all timers and recognition\n  const forceCleanup = useCallback(() => {\n    if (flowRef.current.isCleaningUp) return;\n    flowRef.current.isCleaningUp = true;\n    \n    try {\n      // Clear all intervals and timeouts\n      if (flowRef.current.countdownInterval) {\n        clearInterval(flowRef.current.countdownInterval);\n        flowRef.current.countdownInterval = null;\n      }\n      if (flowRef.current.recordingTimeout) {\n        clearTimeout(flowRef.current.recordingTimeout);\n        flowRef.current.recordingTimeout = null;\n      }\n      if (flowRef.current.timerInterval) {\n        clearInterval(flowRef.current.timerInterval);\n        flowRef.current.timerInterval = null;\n      }\n      \n      // Stop speech recognition\n      if (flowRef.current.recognition && flowState.isRecording) {\n        flowRef.current.recognition.stop();\n      }\n      \n      // 🔧 플러그인을 통한 TTS 중지\n      try {\n        const ServiceContainer = (await import('@/container/ServiceContainer')).default;\n        const container = ServiceContainer.getInstanceSync();\n        const speechService = container.getSpeechProcessingService();\n        speechService.stopAllSpeech();\n      } catch (error) {\n        console.warn('Plugin TTS stop failed:', error);\n      }\n      \n      setFlowState(prev => ({ ...prev, isRecording: false }));\n    } catch (error) {\n      console.warn('Cleanup error:', error);\n    } finally {\n      flowRef.current.isCleaningUp = false;\n    }\n  }, [flowState.isRecording]);\n\n  // 🔧 플러그인 시스템을 통한 TTS 함수\n  const speakText = useCallback(async (text: string, lang: 'ko' | 'en' = 'ko'): Promise<void> => {\n    try {\n      // Check voice settings\n      if (lang === 'ko' && !voiceSettings.koreanEnabled) {\n        return;\n      }\n      if (lang === 'en' && !voiceSettings.englishEnabled) {\n        return;\n      }\n\n      // ServiceContainer를 통해 speechService 사용\n      const ServiceContainer = (await import('@/container/ServiceContainer')).default;\n      const container = ServiceContainer.getInstanceSync();\n      const speechService = container.getSpeechProcessingService();\n\n      // 기존 TTS 중지\n      speechService.stopAllSpeech();\n\n      // 플러그인을 통해 TTS 실행\n      await speechService.speakAnswer(text, {\n        language: lang === 'ko' ? 'ko-KR' : 'en-US',\n        rate: voiceSettings.speed,\n        volume: 1.0,\n        pitch: 1.0\n      });\n\n    } catch (error) {\n      console.error('[PatternTrainingFlowFinal] Speech service error:', error);\n\n      // 🔧 플러그인 fallback: AdvancedSpeechPlugin 시도\n      try {\n        const ServiceContainer = (await import('@/container/ServiceContainer')).default;\n        const container = ServiceContainer.getInstanceSync();\n        const advancedPlugin = container.getAdvancedSpeechPlugin();\n\n        if (advancedPlugin) {\n          // 기존 TTS 중지\n          advancedPlugin.stopAll();\n\n          await advancedPlugin.speakText(text, {\n            language: lang === 'ko' ? 'ko-KR' : 'en-US',\n            rate: voiceSettings.speed,\n            volume: 1.0,\n            pitch: 1.0\n          });\n        } else {\n          console.warn('[PatternTrainingFlowFinal] No speech plugins available');\n        }\n      } catch (pluginError) {\n        console.error('[PatternTrainingFlowFinal] All speech plugins failed:', pluginError);\n      }\n    }\n  }, [voiceSettings]);\n\n  // Play beep sound\n  const playBeep = useCallback(() => {\n    try {\n      const AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n      if (!AudioContext) return;\n      \n      const audioCtx = new AudioContext();\n      const oscillator = audioCtx.createOscillator();\n      const gainNode = audioCtx.createGain();\n      \n      oscillator.connect(gainNode);\n      gainNode.connect(audioCtx.destination);\n      \n      oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);\n      gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);\n      \n      oscillator.start(audioCtx.currentTime);\n      oscillator.stop(audioCtx.currentTime + 0.2);\n    } catch (error) {\n      console.warn('Beep error:', error);\n    }\n  }, []);\n\n  // Start speech recognition\n  const startSpeechRecognition = useCallback(() => {\n    if (flowState.isRecording || flowRef.current.hasReceivedResult) {\n      console.log('음성인식 중복 실행 방지');\n      return;\n    }\n\n    console.log('🎤 음성인식 시작');\n    setFlowState(prev => ({ ...prev, phase: 'recognition', isRecording: true, recognitionStartTime: Date.now() }));\n\n    if (!('webkitSpeechRecognition' in window)) {\n      onError?.('음성 인식을 지원하지 않는 브라우저입니다.');\n      return;\n    }\n\n    const SpeechRecognition = (window as any).webkitSpeechRecognition;\n    const recognition = new SpeechRecognition();\n    \n    recognition.continuous = false;\n    recognition.interimResults = false;\n    recognition.lang = 'en-US';\n    recognition.maxAlternatives = 1;\n\n    flowRef.current.recognition = recognition;\n    flowRef.current.hasReceivedResult = false;\n\n    // Timer for recognition progress\n    flowRef.current.timerInterval = setInterval(() => {\n      setFlowState(prev => ({ ...prev, recognitionTimer: prev.recognitionTimer + 0.1 }));\n    }, 100);\n\n    // 6-second timeout\n    flowRef.current.recordingTimeout = setTimeout(() => {\n      if (!flowRef.current.hasReceivedResult) {\n        console.log('6초 타임아웃');\n        flowRef.current.hasReceivedResult = true;\n        recognition.stop();\n        handleTimeout();\n      }\n    }, 6000);\n\n    recognition.onresult = (event: any) => {\n      if (flowRef.current.hasReceivedResult) return;\n      flowRef.current.hasReceivedResult = true;\n      \n      const result = event.results[0][0].transcript.trim();\n      const confidence = event.results[0][0].confidence || 0.9;\n      \n      console.log(`음성인식 결과: \"${result}\"`);\n      recognition.stop();\n      handleResult(result, confidence);\n    };\n\n    recognition.onerror = (event: any) => {\n      if (flowRef.current.hasReceivedResult) return;\n      console.error('음성인식 오류:', event.error);\n      \n      if (event.error === 'no-speech' || event.error === 'aborted') {\n        flowRef.current.hasReceivedResult = true;\n        handleTimeout();\n      }\n    };\n\n    recognition.onend = () => {\n      if (!flowRef.current.hasReceivedResult) {\n        flowRef.current.hasReceivedResult = true;\n        handleTimeout();\n      }\n    };\n\n    try {\n      recognition.start();\n    } catch (error) {\n      console.error('음성인식 시작 실패:', error);\n      handleTimeout();\n    }\n  }, [flowState.isRecording, onError]);\n\n  // Handle recognition result\n  const handleResult = useCallback((userAnswer: string, confidence: number) => {\n    forceCleanup();\n    \n    const isCorrect = userAnswer.toLowerCase().trim() === expectedEnglish.toLowerCase().trim();\n    const responseTime = flowState.recognitionStartTime ? Date.now() - flowState.recognitionStartTime : 0;\n    \n    setFlowState(prev => ({\n      ...prev,\n      phase: 'completed',\n      speechResult: `인식된 답변: \"${userAnswer}\"`,\n      showAnswer: !isCorrect && showCorrectAnswer,\n      isRecording: false\n    }));\n\n    // Speak correct answer if wrong\n    if (!isCorrect && showCorrectAnswer) {\n      setTimeout(() => {\n        speakText(expectedEnglish, 'en');\n      }, 500);\n    }\n\n    onResult(userAnswer, isCorrect, confidence, responseTime);\n  }, [expectedEnglish, flowState.recognitionStartTime, showCorrectAnswer, speakText, onResult, forceCleanup]);\n\n  // Handle timeout\n  const handleTimeout = useCallback(() => {\n    forceCleanup();\n    \n    setFlowState(prev => ({\n      ...prev,\n      phase: 'completed',\n      speechResult: '음성을 인식하지 못했습니다.',\n      isRecording: false\n    }));\n\n    onResult('', false, 0, 0);\n  }, [onResult, forceCleanup]);\n\n  // Main flow\n  const startFlow = useCallback(async () => {\n    if (flowState.hasStarted || disabled || !koreanText) return;\n    \n    console.log('🚀 Flow 시작:', koreanText);\n    setFlowState(prev => ({ \n      ...prev, \n      hasStarted: true,\n      phase: 'tts',\n      speechResult: '',\n      showAnswer: false,\n      countdownTimer: 0,\n      recognitionTimer: 0\n    }));\n\n    try {\n      // Step 1: Korean TTS\n      await speakText(koreanText, 'ko');\n      \n      // Step 2: Countdown\n      setFlowState(prev => ({ ...prev, phase: 'countdown' }));\n      const countdownTime = getCountdownTime();\n      setFlowState(prev => ({ ...prev, countdownTimer: countdownTime }));\n      \n      flowRef.current.countdownInterval = setInterval(() => {\n        setFlowState(prev => {\n          const remaining = prev.countdownTimer - 1;\n          if (remaining <= 0) {\n            if (flowRef.current.countdownInterval) {\n              clearInterval(flowRef.current.countdownInterval);\n              flowRef.current.countdownInterval = null;\n            }\n            // Play beep and start recognition\n            playBeep();\n            setTimeout(() => startSpeechRecognition(), 200);\n          }\n          return { ...prev, countdownTimer: Math.max(0, remaining) };\n        });\n      }, 1000);\n      \n    } catch (error) {\n      console.error('Flow 오류:', error);\n      onError?.(error instanceof Error ? error.message : 'Flow 실행 실패');\n    }\n  }, [flowState.hasStarted, disabled, koreanText, speakText, getCountdownTime, playBeep, startSpeechRecognition, onError]);\n\n  // Auto-start effect (StrictMode 완전 차단)\n  useEffect(() => {\n    if (!autoStart || !koreanText || disabled) return;\n    if (__autoStartGuards.has(autoStartKey)) return;\n    __autoStartGuards.add(autoStartKey);\n\n    const t = setTimeout(() => { startFlow(); }, 300);\n    return () => clearTimeout(t);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [autoStartKey, autoStart, koreanText, disabled]);\n\n  // Cleanup on unmount\n  useEffect(() => {\n    return () => {\n      forceCleanup();\n    };\n  }, [forceCleanup]);\n\n  return (\n    <div className={`text-center ${className}`}>\n      {/* Korean text display */}\n      <div className=\"mb-8\">\n        <div className=\"text-3xl font-bold text-gray-800 mb-4 min-h-[60px] flex items-center justify-center\">\n          {koreanText || '문제를 기다리는 중...'}\n        </div>\n        \n        {/* Show correct answer when wrong */}\n        {flowState.showAnswer && (\n          <div className=\"text-2xl font-semibold text-green-600 mb-4 animate-pulse\">\n            정답: {expectedEnglish}\n          </div>\n        )}\n      </div>\n\n      {/* Status display */}\n      {flowState.phase !== 'idle' && (\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-6 mb-6\">\n          <div className=\"text-lg font-semibold text-blue-800 mb-4\">\n            {flowState.phase === 'tts' && '🔊 문제를 들려드리고 있습니다...'}\n            {flowState.phase === 'countdown' && `⏳ ${flowState.countdownTimer}초 후 음성 인식 시작...`}\n            {flowState.phase === 'recognition' && `🎤 말씀해 주세요... (${flowState.recognitionTimer.toFixed(1)}초 / 6초)`}\n            {flowState.phase === 'completed' && '✅ 완료!'}\n          </div>\n          \n          {/* Progress bar */}\n          {flowState.phase === 'recognition' && (\n            <div className=\"w-full bg-blue-200 rounded-full h-2 mb-4\">\n              <div \n                className=\"bg-blue-600 h-2 rounded-full transition-all duration-100\"\n                style={{ width: `${Math.min((flowState.recognitionTimer / 6) * 100, 100)}%` }}\n              />\n            </div>\n          )}\n        </div>\n      )}\n\n      {/* Speech result */}\n      {flowState.speechResult && (\n        <div className=\"mb-4 p-4 bg-gray-50 border border-gray-200 rounded-lg\">\n          <div className=\"text-sm text-gray-600 mb-1\">음성 인식 결과:</div>\n          <div className=\"font-medium text-gray-800\">\"{flowState.speechResult}\"</div>\n        </div>\n      )}\n\n      {/* Manual start button */}\n      {flowState.phase === 'idle' && !autoStart && (\n        <button\n          onClick={startFlow}\n          disabled={disabled || !koreanText}\n          className=\"px-8 py-4 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 disabled:bg-gray-400 transition-colors text-lg\"\n        >\n          🎤 시작하기\n        </button>\n      )}\n    </div>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\PatternTrainingFlowSimple.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'getCountdownTime' function makes the dependencies of useCallback Hook (at line 461) change on every render. To fix this, wrap the definition of 'getCountdownTime' in its own useCallback() Hook.","line":54,"column":9,"nodeType":"VariableDeclarator","endLine":60,"endColumn":4,"suggestions":[{"desc":"Wrap the definition of 'getCountdownTime' in its own useCallback() Hook.","fix":{"range":[1985,2173],"text":"useCallback(() => {\n    // ALL mode나 기타 단계는 2초, 정규 단계는 유틸리티 함수 사용\n    if (stage >= 1 && stage <= 3) {\n      return getCountdownDuration(stage as SpeakingStage);\n    }\n    return 2; // ALL mode: 2초\n  })"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'currentPhase', 'evaluateAndSubmitAnswer', 'handleRecognitionTimeout', and 'stopSpeechRecognition'. Either include them or remove the dependency array.","line":339,"column":6,"nodeType":"ArrayExpression","endLine":339,"endColumn":48,"suggestions":[{"desc":"Update the dependencies array to be: [currentPhase, isRecording, forceStopAllTimers, onError, handleRecognitionTimeout, stopSpeechRecognition, evaluateAndSubmitAnswer]","fix":{"range":[10518,10560],"text":"[currentPhase, isRecording, forceStopAllTimers, onError, handleRecognitionTimeout, stopSpeechRecognition, evaluateAndSubmitAnswer]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'voiceSettings.englishEnabled'. Either exclude it or remove the dependency array.","line":399,"column":6,"nodeType":"ArrayExpression","endLine":399,"endColumn":115,"suggestions":[{"desc":"Update the dependencies array to be: [expectedEnglish, onResult, recognitionStartTime, showCorrectAnswer, speakText]","fix":{"range":[12441,12550],"text":"[expectedEnglish, onResult, recognitionStartTime, showCorrectAnswer, speakText]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'autoStart', 'currentPhase', 'disabled', and 'startFlow'. Either include them or remove the dependency array.","line":506,"column":6,"nodeType":"ArrayExpression","endLine":506,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [autoStart, currentPhase, disabled, koreanText, startFlow]","fix":{"range":[16124,16136],"text":"[autoStart, currentPhase, disabled, koreanText, startFlow]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback, useRef } from 'react';\nimport { useLocalStorage, STORAGE_KEYS } from '@/hooks/useLocalStorage';\nimport { getCountdownDuration, type SpeakingStage } from '@/utils/speakingStageUtils';\n\ninterface PatternTrainingFlowSimpleProps {\n  koreanText: string;\n  expectedEnglish: string;\n  onResult: (userAnswer: string, isCorrect: boolean, confidence: number, responseTime: number) => void;\n  onError?: (error: string) => void;\n  stage: number;\n  disabled?: boolean;\n  autoStart?: boolean;\n  className?: string;\n  mistakeId?: string;\n  showCorrectAnswer?: boolean;\n}\n\ntype FlowPhase = 'idle' | 'tts' | 'countdown' | 'recognition' | 'completed';\n\nexport const PatternTrainingFlowSimple: React.FC<PatternTrainingFlowSimpleProps> = ({\n  koreanText,\n  expectedEnglish,\n  onResult,\n  onError,\n  stage,\n  disabled = false,\n  autoStart = false,\n  className = '',\n  mistakeId,\n  showCorrectAnswer = true\n}) => {\n  // State management\n  const [currentPhase, setCurrentPhase] = useState<FlowPhase>('idle');\n  const [countdownTimer, setCountdownTimer] = useState<number>(0);\n  const [recognitionTimer, setRecognitionTimer] = useState<number>(0);\n  const [speechResult, setSpeechResult] = useState<string>('');\n  const [showAnswer, setShowAnswer] = useState<boolean>(false);\n  const [isRecording, setIsRecording] = useState<boolean>(false);\n  const [ttsInitialized, setTtsInitialized] = useState<boolean>(false);\n  \n  // Timing\n  const [recognitionStartTime, setRecognitionStartTime] = useState<number>(0);\n  \n  // Voice settings\n  const { value: voiceSettings } = useLocalStorage(STORAGE_KEYS.VOICE_SETTINGS);\n  \n  // Refs for cleanup\n  const recognitionRef = useRef<any>(null);\n  const countdownIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const recordingTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const timerIntervalRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Get stage-based timing using utility function\n  const getCountdownTime = () => {\n    // ALL mode나 기타 단계는 2초, 정규 단계는 유틸리티 함수 사용\n    if (stage >= 1 && stage <= 3) {\n      return getCountdownDuration(stage as SpeakingStage);\n    }\n    return 2; // ALL mode: 2초\n  };\n\n  /**\n   * 🔧 플러그인을 통한 TTS 초기화\n   */\n  const initializeTTS = useCallback(async () => {\n    if (ttsInitialized) {\n      return Promise.resolve();\n    }\n\n    try {\n      console.log('🔧 플러그인 TTS 초기화 시작...');\n\n      // ServiceContainer를 통해 speechService 사용\n      const ServiceContainer = (await import('@/container/ServiceContainer')).default;\n      const container = ServiceContainer.getInstanceSync();\n      container.getSpeechProcessingService(); // 초기화만 수행\n\n      // 플러그인을 통한 초기화 (실제 음성 없이 준비만)\n      console.log('🔧 플러그인 TTS 초기화 완료');\n      setTtsInitialized(true);\n      return Promise.resolve();\n    } catch (error) {\n      console.warn('🔧 플러그인 TTS 초기화 오류:', error);\n      setTtsInitialized(true);\n      return Promise.resolve();\n    }\n  }, [ttsInitialized]);\n\n  /**\n   * 🔧 플러그인 시스템을 통한 Text-to-Speech 함수\n   */\n  const speakText = useCallback(async (text: string, lang: 'ko' | 'en' = 'ko'): Promise<void> => {\n    try {\n      // Initialize TTS if not already done\n      if (!ttsInitialized) {\n        await initializeTTS();\n      }\n\n      // Check if voice is enabled for this language\n      if (lang === 'ko' && !voiceSettings.koreanEnabled) {\n        return;\n      }\n      if (lang === 'en' && !voiceSettings.englishEnabled) {\n        return;\n      }\n\n      // ServiceContainer를 통해 speechService 사용\n      const ServiceContainer = (await import('@/container/ServiceContainer')).default;\n      const container = ServiceContainer.getInstanceSync();\n      const speechService = container.getSpeechProcessingService();\n\n      // 기존 TTS 중지\n      speechService.stopAllSpeech();\n\n      // 플러그인을 통해 TTS 실행\n      await speechService.speakAnswer(text, {\n        language: lang === 'ko' ? 'ko-KR' : 'en-US',\n        rate: voiceSettings.speed,\n        volume: 1.0,\n        pitch: 1.0\n      });\n\n      console.log(`🔧 ${lang.toUpperCase()} TTS 완료 (플러그인)`);\n\n    } catch (error) {\n      console.error(`🔧 [PatternTrainingFlowSimple] Speech service error:`, error);\n\n      // 🔧 플러그인 fallback: AdvancedSpeechPlugin 시도\n      try {\n        const ServiceContainer = (await import('@/container/ServiceContainer')).default;\n        const container = ServiceContainer.getInstanceSync();\n        const advancedPlugin = container.getAdvancedSpeechPlugin();\n\n        if (advancedPlugin) {\n          // 기존 TTS 중지\n          advancedPlugin.stopAll();\n\n          await advancedPlugin.speakText(text, {\n            language: lang === 'ko' ? 'ko-KR' : 'en-US',\n            rate: voiceSettings.speed,\n            volume: 1.0,\n            pitch: 1.0\n          });\n\n          console.log(`🔧 ${lang.toUpperCase()} TTS 완료 (고급 플러그인)`);\n        } else {\n          console.warn(`🔧 [PatternTrainingFlowSimple] No speech plugins available`);\n        }\n      } catch (pluginError) {\n        console.error(`🔧 [PatternTrainingFlowSimple] All speech plugins failed:`, pluginError);\n      }\n    }\n  }, [voiceSettings, ttsInitialized, initializeTTS]);\n\n  /**\n   * Force stop all timers and activities\n   */\n  const forceStopAllTimers = useCallback(() => {\n    try {\n      // Clear countdown interval\n      if (countdownIntervalRef.current) {\n        clearInterval(countdownIntervalRef.current);\n        countdownIntervalRef.current = null;\n      }\n      \n      // Clear recording timeout\n      if (recordingTimeoutRef.current) {\n        clearTimeout(recordingTimeoutRef.current);\n        recordingTimeoutRef.current = null;\n      }\n\n      // Clear timer interval\n      if (timerIntervalRef.current) {\n        clearInterval(timerIntervalRef.current);\n        timerIntervalRef.current = null;\n      }\n      \n      // Stop speech recognition safely\n      if (recognitionRef.current && isRecording) {\n        try {\n          recognitionRef.current.stop();\n        } catch (error) {\n          console.warn('Error stopping speech recognition:', error);\n        }\n      }\n      \n      // 🔧 플러그인을 통한 TTS 중지 (동기적으로 처리)\n      try {\n        import('@/container/ServiceContainer').then((module) => {\n          const container = module.default.getInstanceSync();\n          const speechService = container.getSpeechProcessingService();\n          speechService.stopAllSpeech();\n        }).catch((error) => {\n          console.warn('🔧 Error stopping TTS (plugin):', error);\n        });\n      } catch (error) {\n        console.warn('🔧 Error importing ServiceContainer:', error);\n      }\n      \n      setIsRecording(false);\n    } catch (error) {\n      console.error('Error in forceStopAllTimers:', error);\n      setIsRecording(false);\n    }\n  }, [isRecording]);\n\n  /**\n   * Start speech recognition\n   */\n  const startSpeechRecognition = useCallback(() => {\n    if (currentPhase === 'recognition' || isRecording) {\n      console.log('음성인식이 이미 진행 중 - 중복 실행 방지');\n      return;\n    }\n    \n    setCurrentPhase('recognition');\n    console.log('음성인식 시작 - 6초 제한시간');\n    \n    forceStopAllTimers();\n    \n    if (!('webkitSpeechRecognition' in window || 'SpeechRecognition' in window)) {\n      const errorMsg = '음성 인식을 지원하지 않는 브라우저입니다.';\n      setSpeechResult(errorMsg);\n      onError?.(errorMsg);\n      return;\n    }\n\n    const SpeechRecognition = (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition;\n    const recognition = new SpeechRecognition();\n    \n    recognition.continuous = false;\n    recognition.interimResults = false;\n    recognition.lang = 'en-US';\n    recognition.maxAlternatives = 3;\n\n    recognitionRef.current = recognition;\n    setIsRecording(true);\n    setSpeechResult('음성을 인식하고 있습니다...');\n\n    let hasReceivedResult = false;\n    let recognitionStopped = false;\n\n    recognition.onstart = () => {\n      if (recognitionStopped) return;\n      console.log('음성인식 실제 시작');\n      setRecognitionTimer(0);\n      setRecognitionStartTime(Date.now());\n      \n      // Start timer\n      const interval = setInterval(() => {\n        setRecognitionTimer(prev => prev + 0.1);\n      }, 100);\n      timerIntervalRef.current = interval;\n      \n      // 6초 타임아웃 설정\n      recordingTimeoutRef.current = setTimeout(() => {\n        if (!hasReceivedResult && !recognitionStopped) {\n          console.log('6초 타임아웃 - 강제 중지');\n          recognitionStopped = true;\n          recognition.stop();\n          handleRecognitionTimeout();\n        }\n      }, 6000);\n    };\n\n    recognition.onresult = (event: any) => {\n      if (hasReceivedResult || recognitionStopped) {\n        console.log('중복 답변 시도 차단');\n        return;\n      }\n      \n      hasReceivedResult = true;\n      recognitionStopped = true;\n      \n      const result = event.results[0][0].transcript.trim();\n      const confidence = event.results[0][0].confidence || 0.9;\n      \n      console.log(`음성인식 결과: \"${result}\" (신뢰도: ${confidence})`);\n      \n      // 즉시 인식 중지\n      recognition.stop();\n      stopSpeechRecognition();\n      \n      // 결과 평가 및 전달\n      evaluateAndSubmitAnswer(result, confidence);\n    };\n\n    recognition.onerror = (event: any) => {\n      console.error('음성인식 오류:', event.error);\n      stopSpeechRecognition();\n      \n      switch (event.error) {\n        case 'no-speech':\n          handleRecognitionTimeout();\n          break;\n        case 'audio-capture':\n          const audioError = '마이크에 접근할 수 없습니다. 브라우저 설정을 확인해주세요.';\n          setSpeechResult(audioError);\n          onError?.(audioError);\n          break;\n        case 'not-allowed':\n          const permissionError = '마이크 권한이 거부되었습니다. 설정에서 권한을 허용해주세요.';\n          setSpeechResult(permissionError);\n          onError?.(permissionError);\n          break;\n        case 'network':\n          const networkError = '네트워크 연결을 확인해주세요.';\n          setSpeechResult(networkError);\n          onError?.(networkError);\n          break;\n        case 'aborted':\n          console.log('음성 인식이 취소되었습니다.');\n          setCurrentPhase('idle');\n          break;\n        default:\n          const errorMsg = `음성 인식 오류: ${event.error}`;\n          setSpeechResult(errorMsg);\n          onError?.(errorMsg);\n      }\n    };\n\n    recognition.onend = () => {\n      console.log('음성인식 종료');\n      if (!hasReceivedResult && !recognitionStopped) {\n        recognitionStopped = true;\n        handleRecognitionTimeout();\n      }\n    };\n\n    try {\n      recognition.start();\n    } catch (error) {\n      console.error('음성인식 시작 실패:', error);\n      stopSpeechRecognition();\n      const errorMsg = '음성 인식을 시작할 수 없습니다.';\n      setSpeechResult(errorMsg);\n      onError?.(errorMsg);\n    }\n  }, [isRecording, forceStopAllTimers, onError]);\n\n  /**\n   * Stop speech recognition safely\n   */\n  const stopSpeechRecognition = useCallback(() => {\n    if (recognitionRef.current && isRecording) {\n      recognitionRef.current.stop();\n    }\n    setIsRecording(false);\n    \n    if (recordingTimeoutRef.current) {\n      clearTimeout(recordingTimeoutRef.current);\n      recordingTimeoutRef.current = null;\n    }\n\n    if (timerIntervalRef.current) {\n      clearInterval(timerIntervalRef.current);\n      timerIntervalRef.current = null;\n    }\n  }, [isRecording]);\n\n  /**\n   * Handle recognition timeout\n   */\n  const handleRecognitionTimeout = useCallback(() => {\n    console.log('음성인식 타임아웃');\n    setCurrentPhase('completed');\n    setSpeechResult('음성을 인식하지 못했습니다.');\n    \n    // 타임아웃을 오답으로 처리\n    onResult('', false, 0, 0);\n  }, [onResult]);\n\n  /**\n   * Evaluate user answer and submit result\n   */\n  const evaluateAndSubmitAnswer = useCallback((userAnswer: string, confidence: number) => {\n    const isCorrect = userAnswer.toLowerCase().trim() === expectedEnglish.toLowerCase().trim();\n    const responseTime = recognitionStartTime ? Date.now() - recognitionStartTime : 0;\n    \n    console.log(`답변 평가: \"${userAnswer}\" vs \"${expectedEnglish}\" = ${isCorrect ? '정답' : '오답'}`);\n    \n    setCurrentPhase('completed');\n    setSpeechResult(`인식된 답변: \"${userAnswer}\"`);\n    \n    // Show correct answer if enabled and answer was wrong\n    if (showCorrectAnswer && !isCorrect) {\n      setShowAnswer(true);\n      // Always speak the correct answer in English when wrong (new enhancement)\n      console.log(`틀린 답변 - 정답 TTS 재생: \"${expectedEnglish}\"`);\n      setTimeout(() => {\n        speakText(expectedEnglish, 'en').catch(error => {\n          console.warn('영어 TTS 실패:', error);\n        });\n      }, 500); // Shorter delay for better user experience\n    }\n    \n    // 결과 전달\n    onResult(userAnswer, isCorrect, confidence, responseTime);\n  }, [expectedEnglish, onResult, recognitionStartTime, showCorrectAnswer, voiceSettings.englishEnabled, speakText]);\n\n  /**\n   * Play beep sound before speech recognition (matching original HTML)\n   */\n  const playMicrophoneStartSound = useCallback(() => {\n    if ('AudioContext' in window || 'webkitAudioContext' in window) {\n      const AudioContext = window.AudioContext || window.webkitAudioContext;\n      const audioCtx = new AudioContext();\n      \n      const oscillator = audioCtx.createOscillator();\n      const gainNode = audioCtx.createGain();\n      \n      oscillator.connect(gainNode);\n      gainNode.connect(audioCtx.destination);\n      \n      oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);\n      gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.2);\n      \n      oscillator.start(audioCtx.currentTime);\n      oscillator.stop(audioCtx.currentTime + 0.2);\n    }\n  }, []);\n\n  /**\n   * Start countdown before speech recognition (matching original HTML flow)\n   */\n  const startCountdownBeforeSpeechRecognition = useCallback(() => {\n    setCurrentPhase('countdown');\n    const waitTime = getCountdownTime();\n    \n    console.log(`사고시간 카운트다운 시작 - ${waitTime}초 대기`);\n    \n    forceStopAllTimers();\n    \n    setCountdownTimer(waitTime);\n    \n    countdownIntervalRef.current = setInterval(() => {\n      setCountdownTimer(prev => {\n        const remaining = prev - 1;\n        console.log(`사고시간 남음: ${remaining}초`);\n        \n        if (remaining <= 0) {\n          if (countdownIntervalRef.current) {\n            clearInterval(countdownIntervalRef.current);\n            countdownIntervalRef.current = null;\n          }\n          \n          // Play beep sound before speech recognition (like original HTML)\n          console.log('🔔 사고시간 종료 - 마이크 시작음 재생');\n          playMicrophoneStartSound();\n          \n          // Start speech recognition immediately after beep\n          setTimeout(() => {\n            console.log('🎤 음성인식 함수 호출 시작');\n            startSpeechRecognition();\n          }, 100); // Small delay to ensure beep plays\n        }\n        return remaining;\n      });\n    }, 1000);\n  }, [getCountdownTime, forceStopAllTimers, startSpeechRecognition, playMicrophoneStartSound]);\n\n  /**\n   * Main flow start function with proper TTS initialization\n   */\n  const startFlow = useCallback(async () => {\n    if (disabled || !koreanText) return;\n    \n    console.log('Pattern Training Flow 시작');\n    \n    // Reset all states\n    setCurrentPhase('tts');\n    setSpeechResult('');\n    setCountdownTimer(0);\n    setRecognitionTimer(0);\n    setShowAnswer(false);\n    \n    try {\n      // Initialize TTS first (handles browser autoplay policy)\n      if (!ttsInitialized) {\n        console.log('TTS 초기화 중...');\n        await initializeTTS();\n      }\n      \n      // Step 1: Play Korean TTS\n      console.log(`한국어 TTS 시작: \"${koreanText}\"`);\n      await speakText(koreanText, 'ko');\n      \n      // Step 2: Start countdown immediately after TTS (no additional delay)\n      startCountdownBeforeSpeechRecognition();\n      \n    } catch (error) {\n      console.error('Flow 시작 오류:', error);\n      setCurrentPhase('idle');\n      const errorMsg = error instanceof Error ? error.message : 'Flow 시작 실패';\n      onError?.(errorMsg);\n    }\n  }, [disabled, koreanText, speakText, startCountdownBeforeSpeechRecognition, onError, ttsInitialized, initializeTTS]);\n\n  // Auto-start effect (prevent duplicate execution)\n  useEffect(() => {\n    if (autoStart && koreanText && currentPhase === 'idle' && !disabled) {\n      console.log('Auto-start triggered for:', koreanText);\n      startFlow();\n    }\n  }, [koreanText]); // Only depend on koreanText to prevent re-execution\n\n  // Cleanup effect on unmount\n  useEffect(() => {\n    return () => {\n      try {\n        forceStopAllTimers();\n        setCurrentPhase('idle');\n        setIsRecording(false);\n        \n        if (recognitionRef.current) {\n          try {\n            recognitionRef.current.abort();\n          } catch (error) {\n            console.warn('Error aborting recognition on unmount:', error);\n          }\n          recognitionRef.current = null;\n        }\n        \n        try {\n          // 🔧 플러그인을 통한 TTS 중지 (동기적으로 처리)\n          import('@/container/ServiceContainer').then((module) => {\n            const container = module.default.getInstanceSync();\n            const speechService = container.getSpeechProcessingService();\n            speechService.stopAllSpeech();\n          }).catch((error) => {\n            console.warn('🔧 Error stopping TTS on unmount (plugin):', error);\n          });\n        } catch (error) {\n          console.warn('🔧 Error importing ServiceContainer on unmount:', error);\n        }\n        \n        console.log('PatternTrainingFlowSimple cleanup completed');\n      } catch (error) {\n        console.error('Error during cleanup:', error);\n      }\n    };\n  }, [forceStopAllTimers]);\n\n  return (\n    <div className={`text-center ${className}`}>\n      {/* Korean text display */}\n      <div className=\"mb-8\">\n        <div className=\"text-3xl font-bold text-gray-800 mb-4 min-h-[60px] flex items-center justify-center\">\n          {koreanText || '문제를 기다리는 중...'}\n        </div>\n        \n        {/* Show correct answer when enabled */}\n        {showAnswer && showCorrectAnswer && (\n          <div className=\"text-2xl font-semibold text-green-600 mb-4 animate-pulse\">\n            정답: {expectedEnglish}\n          </div>\n        )}\n      </div>\n\n      {/* Flow status display */}\n      {currentPhase !== 'idle' && (\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-6 mb-6\">\n          <div className=\"text-center\">\n            <div className=\"text-lg font-semibold text-blue-800 mb-4\">\n              {currentPhase === 'tts' && '🔊 문제를 들려드리고 있습니다...'}\n              {currentPhase === 'countdown' && `⏳ ${countdownTimer}초 후 음성 인식 시작...`}\n              {currentPhase === 'recognition' && `🎤 말씀해 주세요... (${recognitionTimer.toFixed(1)}초 / 6초)`}\n              {currentPhase === 'completed' && '✅ 완료!'}\n            </div>\n            \n            {/* Progress bar for recognition */}\n            {currentPhase === 'recognition' && (\n              <>\n                <div className=\"w-full bg-blue-200 rounded-full h-2 mb-4\">\n                  <div \n                    className=\"bg-blue-600 h-2 rounded-full transition-all duration-100\"\n                    style={{ width: `${Math.min((recognitionTimer / 6) * 100, 100)}%` }}\n                  />\n                </div>\n                \n                <div className=\"flex items-center justify-center space-x-3\">\n                  <div className=\"w-3 h-3 bg-red-500 rounded-full animate-pulse\"></div>\n                  <span className=\"text-sm text-blue-700\">음성을 인식하고 있습니다...</span>\n                </div>\n              </>\n            )}\n            \n            {/* TTS indicator */}\n            {currentPhase === 'tts' && (\n              <div className=\"flex items-center justify-center space-x-3\">\n                <div className=\"w-3 h-3 bg-green-500 rounded-full animate-pulse\"></div>\n                <span className=\"text-sm text-blue-700\">한국어 문제를 재생 중...</span>\n              </div>\n            )}\n            \n            {/* Countdown indicator */}\n            {currentPhase === 'countdown' && (\n              <div className=\"flex items-center justify-center space-x-3\">\n                <div className=\"w-3 h-3 bg-yellow-500 rounded-full animate-pulse\"></div>\n                <span className=\"text-sm text-blue-700\">생각할 시간을 드리고 있습니다</span>\n              </div>\n            )}\n          </div>\n        </div>\n      )}\n\n      {/* Speech result display */}\n      {speechResult && (\n        <div className=\"mb-4 p-4 bg-gray-50 border border-gray-200 rounded-lg\">\n          <div className=\"text-sm text-gray-600 mb-1\">음성 인식 결과:</div>\n          <div className=\"font-medium text-gray-800\">\"{speechResult}\"</div>\n        </div>\n      )}\n\n      {/* Control buttons */}\n      <div className=\"space-y-4\">\n        {/* Manual start button */}\n        {currentPhase === 'idle' && !autoStart && (\n          <button\n            onClick={async () => {\n              // Initialize TTS on user interaction to comply with autoplay policy\n              if (!ttsInitialized) {\n                await initializeTTS();\n              }\n              startFlow();\n            }}\n            disabled={disabled || !koreanText}\n            className=\"px-8 py-4 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors text-lg\"\n          >\n            🎤 시작하기\n          </button>\n        )}\n        \n        {/* Emergency stop button */}\n        {(currentPhase === 'tts' || currentPhase === 'countdown' || currentPhase === 'recognition') && (\n          <button\n            onClick={() => {\n              forceStopAllTimers();\n              setCurrentPhase('idle');\n              onError?.('사용자가 플로우를 중지했습니다.');\n            }}\n            className=\"px-4 py-2 bg-red-600 text-white font-medium rounded-lg hover:bg-red-700 transition-colors text-sm\"\n          >\n            ⏹️ 중지\n          </button>\n        )}\n      </div>\n\n      {/* Debug info (remove in production) */}\n      {process.env.NODE_ENV === 'development' && (\n        <div className=\"mt-4 text-xs text-gray-400 space-y-1\">\n          <div>Phase: {currentPhase}</div>\n          <div>Stage: {stage} | Countdown: {getCountdownTime()}s</div>\n          <div>Recording: {isRecording ? 'Yes' : 'No'}</div>\n          <div>TTS Initialized: {ttsInitialized ? 'Yes' : 'No'}</div>\n          <div>Voice: KO={voiceSettings.koreanEnabled ? 'On' : 'Off'} | EN={voiceSettings.englishEnabled ? 'On' : 'Off'} | Speed={voiceSettings.speed}x</div>\n          {mistakeId && <div>Review Mode: {mistakeId}</div>}\n        </div>\n      )}\n    </div>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\PerformanceDashboard.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'container'. Either include it or remove the dependency array.","line":63,"column":6,"nodeType":"ArrayExpression","endLine":63,"endColumn":43,"suggestions":[{"desc":"Update the dependencies array to be: [state.isVisible, state.isMonitoring, container]","fix":{"range":[1980,2017],"text":"[state.isVisible, state.isMonitoring, container]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'container'. Either include it or remove the dependency array.","line":86,"column":6,"nodeType":"ArrayExpression","endLine":86,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [container]","fix":{"range":[2614,2616],"text":"[container]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Performance Dashboard Component\r\n * @description 실시간 성능 모니터링 대시보드 - Service Container와 연동\r\n */\r\n\r\nimport React, { useState, useEffect, useRef } from 'react';\r\nimport { getServiceContainerSync } from '@/container/ServiceContainer';\r\nimport type { PerformanceStats, PerformanceEvent } from '@/plugins/performance/IPerformancePlugin';\r\n\r\ninterface DashboardState {\r\n  isVisible: boolean;\r\n  stats: PerformanceStats | null;\r\n  recentEvents: PerformanceEvent[];\r\n  containerStatus: any;\r\n  audioLatencyHistory: number[];\r\n  isMonitoring: boolean;\r\n}\r\n\r\nexport const PerformanceDashboard: React.FC = () => {\r\n  const [state, setState] = useState<DashboardState>({\r\n    isVisible: false,\r\n    stats: null,\r\n    recentEvents: [],\r\n    containerStatus: null,\r\n    audioLatencyHistory: [],\r\n    isMonitoring: false\r\n  });\r\n\r\n  const intervalRef = useRef<NodeJS.Timeout>();\r\n  const container = getServiceContainerSync();\r\n\r\n  // 실시간 데이터 업데이트\r\n  useEffect(() => {\r\n    if (state.isVisible && state.isMonitoring) {\r\n      intervalRef.current = setInterval(async () => {\r\n        try {\r\n          // Performance Plugin에서 데이터 가져오기\r\n          const performancePlugin = await container.ensurePerformancePlugin();\r\n          const statsResult = await performancePlugin.getPerformanceStats();\r\n          \r\n          if (statsResult.success) {\r\n            setState(prev => ({\r\n              ...prev,\r\n              stats: statsResult.data,\r\n              containerStatus: container.getServicesStatus(),\r\n              audioLatencyHistory: [\r\n                ...prev.audioLatencyHistory.slice(-9), // 최근 10개만 유지\r\n                statsResult.data.audioPerformance.averageLatency\r\n              ]\r\n            }));\r\n          }\r\n        } catch (error) {\r\n          console.error('[PerformanceDashboard] Data update failed:', error);\r\n        }\r\n      }, 1000);\r\n    }\r\n\r\n    return () => {\r\n      if (intervalRef.current) {\r\n        clearInterval(intervalRef.current);\r\n      }\r\n    };\r\n  }, [state.isVisible, state.isMonitoring]);\r\n\r\n  // Performance Plugin 이벤트 리스너\r\n  useEffect(() => {\r\n    const handlePerformanceEvent = (event: PerformanceEvent) => {\r\n      setState(prev => ({\r\n        ...prev,\r\n        recentEvents: [\r\n          event,\r\n          ...prev.recentEvents.slice(0, 4) // 최근 5개만 유지\r\n        ]\r\n      }));\r\n    };\r\n\r\n    container.ensurePerformancePlugin().then(plugin => {\r\n      plugin.onPerformanceEvent(handlePerformanceEvent);\r\n    });\r\n\r\n    return () => {\r\n      container.ensurePerformancePlugin().then(plugin => {\r\n        plugin.offPerformanceEvent(handlePerformanceEvent);\r\n      });\r\n    };\r\n  }, []);\r\n\r\n  const toggleDashboard = () => {\r\n    setState(prev => ({ ...prev, isVisible: !prev.isVisible }));\r\n  };\r\n\r\n  const toggleMonitoring = async () => {\r\n    try {\r\n      const performancePlugin = await container.ensurePerformancePlugin();\r\n      \r\n      if (state.isMonitoring) {\r\n        performancePlugin.stopMonitoring();\r\n      } else {\r\n        performancePlugin.startMonitoring();\r\n      }\r\n      \r\n      setState(prev => ({ ...prev, isMonitoring: !prev.isMonitoring }));\r\n    } catch (error) {\r\n      console.error('[PerformanceDashboard] Toggle monitoring failed:', error);\r\n    }\r\n  };\r\n\r\n  const generateReport = async () => {\r\n    try {\r\n      const performancePlugin = await container.ensurePerformancePlugin();\r\n      const reportResult = await performancePlugin.generatePerformanceReport();\r\n      \r\n      if (reportResult.success) {\r\n        console.log('[PerformanceDashboard] Report generated:', reportResult.data);\r\n        // 리포트를 JSON으로 다운로드\r\n        const blob = new Blob([JSON.stringify(reportResult.data, null, 2)], {\r\n          type: 'application/json'\r\n        });\r\n        const url = URL.createObjectURL(blob);\r\n        const a = document.createElement('a');\r\n        a.href = url;\r\n        a.download = `performance-report-${new Date().toISOString()}.json`;\r\n        a.click();\r\n        URL.revokeObjectURL(url);\r\n      }\r\n    } catch (error) {\r\n      console.error('[PerformanceDashboard] Report generation failed:', error);\r\n    }\r\n  };\r\n\r\n  const clearMetrics = async () => {\r\n    try {\r\n      const performancePlugin = await container.ensurePerformancePlugin();\r\n      await performancePlugin.clearMetrics();\r\n      setState(prev => ({\r\n        ...prev,\r\n        stats: null,\r\n        recentEvents: [],\r\n        audioLatencyHistory: []\r\n      }));\r\n    } catch (error) {\r\n      console.error('[PerformanceDashboard] Clear metrics failed:', error);\r\n    }\r\n  };\r\n\r\n  const getLatencyColor = (latency: number) => {\r\n    if (latency < 1000) return 'text-green-500';\r\n    if (latency < 2000) return 'text-yellow-500';\r\n    return 'text-red-500';\r\n  };\r\n\r\n  const getScoreColor = (score: number) => {\r\n    if (score >= 80) return 'text-green-500';\r\n    if (score >= 60) return 'text-yellow-500';\r\n    return 'text-red-500';\r\n  };\r\n\r\n  if (!state.isVisible) {\r\n    return (\r\n      <div className=\"fixed bottom-4 right-4 z-50\">\r\n        <button\r\n          onClick={toggleDashboard}\r\n          className=\"bg-blue-500 hover:bg-blue-600 text-white p-3 rounded-full shadow-lg transition-colors\"\r\n          title=\"Open Performance Dashboard\"\r\n        >\r\n          📊\r\n        </button>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"fixed bottom-4 right-4 z-50 bg-white dark:bg-gray-800 rounded-lg shadow-2xl border border-gray-300 dark:border-gray-600 w-96 max-h-[80vh] overflow-y-auto\">\r\n      {/* Header */}\r\n      <div className=\"flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700\">\r\n        <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white\">\r\n          Performance Monitor\r\n        </h3>\r\n        <div className=\"flex items-center space-x-2\">\r\n          <button\r\n            onClick={toggleMonitoring}\r\n            className={`px-3 py-1 rounded text-sm font-medium transition-colors ${\r\n              state.isMonitoring\r\n                ? 'bg-red-500 hover:bg-red-600 text-white'\r\n                : 'bg-green-500 hover:bg-green-600 text-white'\r\n            }`}\r\n          >\r\n            {state.isMonitoring ? 'Stop' : 'Start'}\r\n          </button>\r\n          <button\r\n            onClick={toggleDashboard}\r\n            className=\"text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200\"\r\n          >\r\n            ✕\r\n          </button>\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"p-4 space-y-4\">\r\n        {/* Service Container Status */}\r\n        {state.containerStatus && (\r\n          <div className=\"bg-gray-50 dark:bg-gray-700 rounded-lg p-3\">\r\n            <h4 className=\"font-medium text-gray-900 dark:text-white mb-2\">Service Status</h4>\r\n            <div className=\"grid grid-cols-2 gap-2 text-sm\">\r\n              {Object.entries(state.containerStatus).map(([key, value]) => (\r\n                <div key={key} className=\"flex justify-between\">\r\n                  <span className=\"text-gray-600 dark:text-gray-300\">\r\n                    {key.replace(/([A-Z])/g, ' $1').replace(/^./, str => str.toUpperCase())}:\r\n                  </span>\r\n                  <span className={typeof value === 'boolean' ? (value ? 'text-green-500' : 'text-red-500') : 'text-gray-900 dark:text-white'}>\r\n                    {typeof value === 'boolean' ? (value ? '✓' : '✗') : value}\r\n                  </span>\r\n                </div>\r\n              ))}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* Performance Stats */}\r\n        {state.stats && (\r\n          <div className=\"space-y-3\">\r\n            {/* Audio Performance */}\r\n            <div className=\"bg-blue-50 dark:bg-blue-900/20 rounded-lg p-3\">\r\n              <h4 className=\"font-medium text-blue-900 dark:text-blue-100 mb-2\">Audio Performance</h4>\r\n              <div className=\"space-y-1 text-sm\">\r\n                <div className=\"flex justify-between\">\r\n                  <span>Average Latency:</span>\r\n                  <span className={getLatencyColor(state.stats.audioPerformance.averageLatency)}>\r\n                    {state.stats.audioPerformance.averageLatency.toFixed(0)}ms\r\n                  </span>\r\n                </div>\r\n                <div className=\"flex justify-between\">\r\n                  <span>Measurements:</span>\r\n                  <span>{state.stats.audioPerformance.totalMeasurements}</span>\r\n                </div>\r\n                <div className=\"flex justify-between\">\r\n                  <span>Score:</span>\r\n                  <span className={getScoreColor(state.stats.audioPerformance.performanceScore)}>\r\n                    {state.stats.audioPerformance.performanceScore.toFixed(1)}\r\n                  </span>\r\n                </div>\r\n              </div>\r\n            </div>\r\n\r\n            {/* API Performance */}\r\n            <div className=\"bg-green-50 dark:bg-green-900/20 rounded-lg p-3\">\r\n              <h4 className=\"font-medium text-green-900 dark:text-green-100 mb-2\">API Performance</h4>\r\n              <div className=\"space-y-1 text-sm\">\r\n                <div className=\"flex justify-between\">\r\n                  <span>Response Time:</span>\r\n                  <span>{state.stats.apiPerformance.averageResponseTime.toFixed(0)}ms</span>\r\n                </div>\r\n                <div className=\"flex justify-between\">\r\n                  <span>Total Calls:</span>\r\n                  <span>{state.stats.apiPerformance.totalCalls}</span>\r\n                </div>\r\n                <div className=\"flex justify-between\">\r\n                  <span>Error Rate:</span>\r\n                  <span className={state.stats.apiPerformance.errorRate > 5 ? 'text-red-500' : 'text-green-500'}>\r\n                    {(state.stats.apiPerformance.errorRate * 100).toFixed(1)}%\r\n                  </span>\r\n                </div>\r\n              </div>\r\n            </div>\r\n\r\n            {/* Memory Usage */}\r\n            <div className=\"bg-purple-50 dark:bg-purple-900/20 rounded-lg p-3\">\r\n              <h4 className=\"font-medium text-purple-900 dark:text-purple-100 mb-2\">Memory Usage</h4>\r\n              <div className=\"space-y-1 text-sm\">\r\n                <div className=\"flex justify-between\">\r\n                  <span>Current:</span>\r\n                  <span>{(state.stats.memory.currentUsage / 1024 / 1024).toFixed(1)} MB</span>\r\n                </div>\r\n                <div className=\"flex justify-between\">\r\n                  <span>Peak:</span>\r\n                  <span>{(state.stats.memory.peakUsage / 1024 / 1024).toFixed(1)} MB</span>\r\n                </div>\r\n                <div className=\"flex justify-between\">\r\n                  <span>Average:</span>\r\n                  <span>{(state.stats.memory.averageUsage / 1024 / 1024).toFixed(1)} MB</span>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* Audio Latency Chart */}\r\n        {state.audioLatencyHistory.length > 0 && (\r\n          <div className=\"bg-gray-50 dark:bg-gray-700 rounded-lg p-3\">\r\n            <h4 className=\"font-medium text-gray-900 dark:text-white mb-2\">Latency Trend</h4>\r\n            <div className=\"flex items-end space-x-1 h-16\">\r\n              {state.audioLatencyHistory.map((latency, index) => (\r\n                <div\r\n                  key={index}\r\n                  className=\"bg-blue-500 rounded-t\"\r\n                  style={{\r\n                    height: `${Math.min(100, (latency / 3000) * 100)}%`,\r\n                    width: '100%'\r\n                  }}\r\n                  title={`${latency.toFixed(0)}ms`}\r\n                />\r\n              ))}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* Recent Events */}\r\n        {state.recentEvents.length > 0 && (\r\n          <div className=\"bg-gray-50 dark:bg-gray-700 rounded-lg p-3\">\r\n            <h4 className=\"font-medium text-gray-900 dark:text-white mb-2\">Recent Events</h4>\r\n            <div className=\"space-y-1\">\r\n              {state.recentEvents.map((event, index) => (\r\n                <div key={index} className=\"text-xs flex justify-between\">\r\n                  <span className={\r\n                    event.type === 'error' ? 'text-red-500' :\r\n                    event.type === 'warning' ? 'text-yellow-500' :\r\n                    'text-gray-600 dark:text-gray-300'\r\n                  }>\r\n                    {event.type}\r\n                  </span>\r\n                  <span className=\"text-gray-500\">\r\n                    {new Date(event.timestamp).toLocaleTimeString()}\r\n                  </span>\r\n                </div>\r\n              ))}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* Actions */}\r\n        <div className=\"flex space-x-2\">\r\n          <button\r\n            onClick={generateReport}\r\n            className=\"flex-1 bg-blue-500 hover:bg-blue-600 text-white py-2 px-3 rounded text-sm font-medium transition-colors\"\r\n          >\r\n            Export Report\r\n          </button>\r\n          <button\r\n            onClick={clearMetrics}\r\n            className=\"flex-1 bg-gray-500 hover:bg-gray-600 text-white py-2 px-3 rounded text-sm font-medium transition-colors\"\r\n          >\r\n            Clear Data\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PerformanceDashboard;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\PracticeHistory.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'loadInterviews' and 'loadStorageInfo'. Either include them or remove the dependency array.","line":21,"column":6,"nodeType":"ArrayExpression","endLine":21,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [loadInterviews, loadStorageInfo]","fix":{"range":[910,912],"text":"[loadInterviews, loadStorageInfo]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'stopAllAudio'. Either include it or remove the dependency array.","line":28,"column":6,"nodeType":"ArrayExpression","endLine":28,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [stopAllAudio]","fix":{"range":[1013,1015],"text":"[stopAllAudio]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef, useCallback, memo } from 'react';\nimport { interviewStorage, InterviewRecord } from '../services/interviewStorage.ts';\nimport { webSpeechAPI } from '../services/webSpeechAPI.ts';\n\ninterface Props {\n  onBack: () => void;\n}\n\nconst InterviewHistory: React.FC<Props> = memo(({ onBack }) => {\n  const [interviews, setInterviews] = useState<InterviewRecord[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [selectedInterview, setSelectedInterview] = useState<InterviewRecord | null>(null);\n  const [storageInfo, setStorageInfo] = useState<{ used: number; quota: number }>({ used: 0, quota: 0 });\n  const [playingIndex, setPlayingIndex] = useState<number | null>(null);\n  const currentAudioRef = useRef<HTMLAudioElement | null>(null);\n  const audioUrlRef = useRef<string | null>(null);\n\n  useEffect(() => {\n    loadInterviews();\n    loadStorageInfo();\n  }, []);\n\n  // 컴포넌트 언마운트 시 오디오 중지\n  useEffect(() => {\n    return () => {\n      stopAllAudio();\n    };\n  }, []);\n\n  // selectedInterview가 변경될 때 오디오 중지\n  useEffect(() => {\n    stopAllAudio();\n  }, [selectedInterview, stopAllAudio]);\n\n  const stopAllAudio = useCallback(() => {\n    // TTS 중지\n    webSpeechAPI.stopSpeaking();\n    \n    // HTML Audio 중지\n    if (currentAudioRef.current) {\n      currentAudioRef.current.pause();\n      currentAudioRef.current.currentTime = 0;\n      currentAudioRef.current = null;\n    }\n    \n    // URL 정리\n    if (audioUrlRef.current) {\n      URL.revokeObjectURL(audioUrlRef.current);\n      audioUrlRef.current = null;\n    }\n    \n    setPlayingIndex(null);\n  }, []);\n\n  const loadInterviews = useCallback(async () => {\n    try {\n      setLoading(true);\n      const records = await interviewStorage.getAllInterviews();\n      setInterviews(records);\n    } catch (error) {\n      console.error('면접 기록 로드 실패:', error);\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  const loadStorageInfo = useCallback(async () => {\n    try {\n      const info = await interviewStorage.getStorageUsage();\n      setStorageInfo(info);\n    } catch (error) {\n      console.error('저장 공간 정보 로드 실패:', error);\n    }\n  }, []);\n\n  const deleteInterview = useCallback(async (id: string) => {\n    if (window.confirm('이 면접 기록을 삭제하시겠습니까?')) {\n      try {\n        await interviewStorage.deleteInterview(id);\n        await loadInterviews();\n        setSelectedInterview(null);\n        alert('면접 기록이 삭제되었습니다.');\n      } catch (error) {\n        console.error('면접 기록 삭제 실패:', error);\n        alert('면접 기록 삭제에 실패했습니다.');\n      }\n    }\n  }, [loadInterviews]);\n\n  const formatDate = useCallback((date: Date) => {\n    return new Date(date).toLocaleString('ko-KR', {\n      year: 'numeric',\n      month: 'short',\n      day: 'numeric',\n      hour: '2-digit',\n      minute: '2-digit'\n    });\n  }, []);\n\n  const formatTime = useCallback((seconds: number) => {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}분 ${remainingSeconds}초`;\n  }, []);\n\n  const formatBytes = useCallback((bytes: number) => {\n    if (bytes === 0) return '0 Bytes';\n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }, []);\n\n  const playAnswer = async (qa: any, index: number) => {\n    if (playingIndex === index) {\n      // 현재 재생 중인 경우 중지\n      stopAllAudio();\n      return;\n    }\n\n    try {\n      // 이전 오디오 중지\n      stopAllAudio();\n      \n      setPlayingIndex(index);\n      \n      // 실제 녹음된 음성이 있으면 그것을 재생, 없으면 TTS 사용\n      if (qa.audioBlob && qa.audioBlob.size > 0) {\n        try {\n          // 오디오 blob 유효성 검사\n          if (!(qa.audioBlob instanceof Blob)) {\n            console.warn('오디오 데이터가 Blob 형식이 아닙니다. TTS로 대체합니다.');\n            await playTTS(qa.answer);\n            return;\n          }\n\n          // 지원되는 오디오 타입인지 확인\n          const audioType = qa.audioBlob.type;\n          if (!audioType || !audioType.startsWith('audio/')) {\n            console.warn('지원되지 않는 오디오 형식입니다:', audioType, 'TTS로 대체합니다.');\n            await playTTS(qa.answer);\n            return;\n          }\n\n          const audio = new Audio();\n          const audioUrl = URL.createObjectURL(qa.audioBlob);\n          \n          // ref에 저장\n          currentAudioRef.current = audio;\n          audioUrlRef.current = audioUrl;\n          \n          // 오디오 이벤트 리스너 설정\n          const cleanup = () => {\n            setPlayingIndex(null);\n            if (audioUrlRef.current) {\n              URL.revokeObjectURL(audioUrlRef.current);\n              audioUrlRef.current = null;\n            }\n            currentAudioRef.current = null;\n          };\n          \n          audio.onended = cleanup;\n          audio.onerror = (e) => {\n            console.error(`[InterviewHistory] 오디오 재생 실패 (답변 ${index + 1}):`, e);\n            console.log(`[InterviewHistory] 오디오 blob 정보:`, {\n              size: qa.audioBlob?.size || 'undefined',\n              type: qa.audioBlob?.type || 'undefined',\n              url: audioUrl,\n              hasBlob: !!qa.audioBlob,\n              blobConstructor: qa.audioBlob?.constructor?.name\n            });\n            \n            // 즉시 정리하고 TTS로 대체\n            try {\n              cleanup();\n              console.log(`[InterviewHistory] TTS로 대체 재생 시작: \"${qa.answer.substring(0, 50)}...\"`);\n              playTTS(qa.answer).catch(ttsError => {\n                console.error('[InterviewHistory] TTS 재생도 실패:', ttsError);\n                setPlayingIndex(null);\n              });\n            } catch (fallbackError) {\n              console.error('[InterviewHistory] 폴백 처리 중 오류:', fallbackError);\n              setPlayingIndex(null);\n            }\n          };\n\n          // 타임아웃 설정 (5초 후에도 로드되지 않으면 TTS로 대체)\n          const loadTimeout = setTimeout(() => {\n            console.warn('오디오 로드 시간 초과, TTS로 대체합니다.');\n            cleanup();\n            playTTS(qa.answer);\n          }, 5000);\n          \n          audio.oncanplaythrough = () => {\n            clearTimeout(loadTimeout);\n            // 🔧 FIX: Check paused state before calling play() to prevent duplicate sounds\n            if (audio.paused) {\n              console.log('[DEBUG] 🔊 PracticeHistory: 재생 시작 (paused=true)');\n              audio.play().catch((e) => {\n                console.error('오디오 play() 실패:', e);\n                cleanup();\n                playTTS(qa.answer);\n              });\n            } else {\n              console.log('[DEBUG] 🚫 PracticeHistory: 이미 재생 중 - 스킨');\n            }\n          };\n\n          audio.onloadeddata = () => {\n            clearTimeout(loadTimeout);\n          };\n          \n          audio.src = audioUrl;\n          audio.load(); // 명시적으로 로드\n        } catch (error) {\n          console.error('오디오 객체 생성 실패:', error);\n          await playTTS(qa.answer);\n        }\n      } else {\n        // 녹음된 음성이 없으면 TTS 사용\n        await playTTS(qa.answer);\n      }\n    } catch (error) {\n      console.error('답변 재생 오류:', error);\n      setPlayingIndex(null);\n    }\n  };\n\n  const playTTS = async (answer: string) => {\n    try {\n      console.log('[InterviewHistory] TTS 재생 시작:', {\n        textLength: answer.length,\n        preview: answer.substring(0, 100),\n        ttsSupported: webSpeechAPI.isTTSSupported()\n      });\n      \n      if (!webSpeechAPI.isTTSSupported()) {\n        throw new Error('브라우저에서 TTS를 지원하지 않습니다.');\n      }\n      \n      await webSpeechAPI.speak(answer, 'ko-KR');\n      console.log('[InterviewHistory] TTS 재생 완료');\n      setPlayingIndex(null);\n    } catch (error) {\n      console.error('[InterviewHistory] TTS 재생 오류:', error);\n      alert('음성 재생에 실패했습니다. 브라우저에서 음성 합성을 지원하지 않거나 오류가 발생했습니다.');\n      setPlayingIndex(null);\n    }\n  };\n\n  if (selectedInterview) {\n    return (\n      <div style={{\n        minHeight: '100vh',\n        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',\n        color: 'white',\n        fontFamily: 'Arial, sans-serif',\n        padding: '20px'\n      }}>\n        <div style={{\n          background: 'rgba(255,255,255,0.95)',\n          padding: '40px',\n          borderRadius: '15px',\n          boxShadow: '0 10px 30px rgba(0,0,0,0.2)',\n          maxWidth: '900px',\n          margin: '0 auto',\n          color: '#333'\n        }}>\n          <div style={{\n            display: 'flex',\n            justifyContent: 'space-between',\n            alignItems: 'center',\n            marginBottom: '30px',\n            paddingBottom: '20px',\n            borderBottom: '2px solid #f0f0f0'\n          }}>\n            <h2 style={{ margin: 0, fontSize: '1.8rem' }}>\n              📝 면접 기록 상세\n            </h2>\n            <div style={{ display: 'flex', gap: '10px' }}>\n              <button\n                onClick={() => deleteInterview(selectedInterview.id)}\n                style={{\n                  padding: '10px 20px',\n                  background: '#ff4757',\n                  color: 'white',\n                  border: 'none',\n                  borderRadius: '8px',\n                  fontSize: '14px',\n                  cursor: 'pointer'\n                }}\n              >\n                🗑️ 삭제\n              </button>\n              <button\n                onClick={() => {\n                  stopAllAudio();\n                  setSelectedInterview(null);\n                }}\n                style={{\n                  padding: '10px 20px',\n                  background: '#666',\n                  color: 'white',\n                  border: 'none',\n                  borderRadius: '8px',\n                  fontSize: '14px',\n                  cursor: 'pointer'\n                }}\n              >\n                ← 목록으로\n              </button>\n            </div>\n          </div>\n\n          {/* 면접 기본 정보 */}\n          <div style={{\n            background: '#f8f9fa',\n            padding: '20px',\n            borderRadius: '10px',\n            marginBottom: '25px'\n          }}>\n            <h3 style={{ margin: '0 0 15px 0', color: '#495057' }}>🏢 면접 정보</h3>\n            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '15px' }}>\n              <div><strong>회사:</strong> {selectedInterview.config.company}</div>\n              <div><strong>직무:</strong> {selectedInterview.config.position}</div>\n              <div><strong>경력:</strong> {selectedInterview.config.experience}</div>\n              <div><strong>면접 날짜:</strong> {formatDate(selectedInterview.timestamp)}</div>\n              {selectedInterview.config.companyType && (\n                <div><strong>회사 규모:</strong> {selectedInterview.config.companyType}</div>\n              )}\n              {selectedInterview.config.industryType && (\n                <div><strong>업계:</strong> {selectedInterview.config.industryType}</div>\n              )}\n            </div>\n          </div>\n\n          {/* 면접 통계 */}\n          <div style={{\n            background: '#e8f5e8',\n            padding: '20px',\n            borderRadius: '10px',\n            marginBottom: '25px'\n          }}>\n            <h3 style={{ margin: '0 0 15px 0', color: '#2d5016' }}>📊 면접 통계</h3>\n            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '15px' }}>\n              <div><strong>실제 면접시간:</strong> {formatTime(selectedInterview.statistics.actualInterviewTime || selectedInterview.statistics.totalTime - (selectedInterview.statistics.totalFeedbackTime || 0))}</div>\n              <div><strong>답변 시간:</strong> {formatTime(selectedInterview.statistics.totalAnswerTime)}</div>\n              <div><strong>사고 시간:</strong> {formatTime(selectedInterview.statistics.totalThinkingTime)} <span style={{fontSize: '0.8rem', color: '#666'}}>(질문 듣고 생각하는 시간)</span></div>\n              {selectedInterview.statistics.totalFeedbackTime && (\n                <div><strong>면접관 피드백:</strong> {formatTime(selectedInterview.statistics.totalFeedbackTime)}</div>\n              )}\n              <div><strong>질문 개수:</strong> {selectedInterview.statistics.questionCount}개</div>\n            </div>\n          </div>\n\n          {/* 질문과 답변 */}\n          <div>\n            <h3 style={{ margin: '0 0 20px 0', color: '#333' }}>💬 질문과 답변</h3>\n            {selectedInterview.questionsAndAnswers.map((qa, index) => (\n              <div key={index} style={{\n                background: 'white',\n                border: '1px solid #e9ecef',\n                borderRadius: '10px',\n                padding: '20px',\n                marginBottom: '20px'\n              }}>\n                <div style={{\n                  background: '#667eea',\n                  color: 'white',\n                  padding: '10px 15px',\n                  borderRadius: '8px',\n                  marginBottom: '15px',\n                  fontSize: '16px',\n                  fontWeight: '500'\n                }}>\n                  Q{index + 1}. {qa.question}\n                </div>\n                <div style={{\n                  background: '#f8f9fc',\n                  padding: '15px',\n                  borderRadius: '8px',\n                  borderLeft: '4px solid #4CAF50',\n                  lineHeight: '1.6'\n                }}>\n                  <div style={{ marginBottom: '10px' }}>\n                    <strong>답변:</strong> {qa.answer}\n                  </div>\n                  <div style={{ \n                    display: 'flex', \n                    justifyContent: 'space-between', \n                    alignItems: 'center',\n                    marginTop: '15px' \n                  }}>\n                    <div style={{ fontSize: '0.9rem', color: '#666' }}>\n                      <strong>답변 시간:</strong> {formatTime(qa.answerTime)}\n                    </div>\n                    <button\n                      onClick={() => playAnswer(qa, index)}\n                      style={{\n                        padding: '8px 16px',\n                        background: playingIndex === index ? '#ff4757' : (qa.audioBlob ? '#2196F3' : '#4CAF50'),\n                        color: 'white',\n                        border: 'none',\n                        borderRadius: '6px',\n                        fontSize: '14px',\n                        cursor: 'pointer',\n                        display: 'flex',\n                        alignItems: 'center',\n                        gap: '5px'\n                      }}\n                    >\n                      {playingIndex === index ? (\n                        <>⏹️ 중지</>\n                      ) : qa.audioBlob ? (\n                        <>🎵 내 목소리 듣기</>\n                      ) : (\n                        <>🔊 TTS로 듣기</>\n                      )}\n                    </button>\n                  </div>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div style={{\n      minHeight: '100vh',\n      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',\n      color: 'white',\n      fontFamily: 'Arial, sans-serif',\n      padding: '20px'\n    }}>\n      <div style={{\n        background: 'rgba(255,255,255,0.95)',\n        padding: '40px',\n        borderRadius: '15px',\n        boxShadow: '0 10px 30px rgba(0,0,0,0.2)',\n        maxWidth: '1200px',\n        margin: '0 auto',\n        color: '#333'\n      }}>\n        <div style={{\n          display: 'flex',\n          justifyContent: 'space-between',\n          alignItems: 'center',\n          marginBottom: '30px',\n          paddingBottom: '20px',\n          borderBottom: '2px solid #f0f0f0'\n        }}>\n          <h2 style={{ margin: 0, fontSize: '1.8rem' }}>\n            📚 면접 기록\n          </h2>\n          <button\n            onClick={() => {\n              stopAllAudio();\n              onBack();\n            }}\n            style={{\n              padding: '12px 24px',\n              background: '#667eea',\n              color: 'white',\n              border: 'none',\n              borderRadius: '8px',\n              fontSize: '16px',\n              cursor: 'pointer'\n            }}\n          >\n            ← 메인으로\n          </button>\n        </div>\n\n        {/* 저장 공간 정보 */}\n        {storageInfo.quota > 0 && (\n          <div style={{\n            background: '#fff3cd',\n            padding: '15px',\n            borderRadius: '8px',\n            marginBottom: '25px',\n            fontSize: '0.9rem'\n          }}>\n            💾 저장 공간: {formatBytes(storageInfo.used)} / {formatBytes(storageInfo.quota)} 사용 중\n            ({((storageInfo.used / storageInfo.quota) * 100).toFixed(1)}%)\n          </div>\n        )}\n\n        {loading ? (\n          <div style={{ textAlign: 'center', padding: '50px', fontSize: '1.2rem', color: '#666' }}>\n            면접 기록을 불러오는 중...\n          </div>\n        ) : interviews.length === 0 ? (\n          <div style={{ textAlign: 'center', padding: '50px' }}>\n            <div style={{ fontSize: '4rem', marginBottom: '20px' }}>📝</div>\n            <div style={{ fontSize: '1.2rem', color: '#666', marginBottom: '10px' }}>\n              아직 저장된 면접 기록이 없습니다.\n            </div>\n            <div style={{ fontSize: '1rem', color: '#999' }}>\n              면접을 완료하면 여기에 기록이 저장됩니다.\n            </div>\n          </div>\n        ) : (\n          <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(350px, 1fr))', gap: '20px' }}>\n            {interviews.map((interview) => (\n              <div\n                key={interview.id}\n                onClick={() => setSelectedInterview(interview)}\n                style={{\n                  background: 'white',\n                  border: '1px solid #e9ecef',\n                  borderRadius: '12px',\n                  padding: '20px',\n                  cursor: 'pointer',\n                  transition: 'transform 0.2s, box-shadow 0.2s',\n                  boxShadow: '0 2px 8px rgba(0,0,0,0.1)'\n                }}\n                onMouseEnter={(e) => {\n                  e.currentTarget.style.transform = 'translateY(-3px)';\n                  e.currentTarget.style.boxShadow = '0 8px 25px rgba(0,0,0,0.15)';\n                }}\n                onMouseLeave={(e) => {\n                  e.currentTarget.style.transform = 'translateY(0)';\n                  e.currentTarget.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';\n                }}\n              >\n                <div style={{\n                  display: 'flex',\n                  justifyContent: 'space-between',\n                  alignItems: 'flex-start',\n                  marginBottom: '15px'\n                }}>\n                  <div>\n                    <h3 style={{ margin: '0 0 5px 0', fontSize: '1.3rem', fontWeight: 'bold' }}>\n                      {interview.config.company}\n                    </h3>\n                    <div style={{ color: '#666', fontSize: '1rem' }}>\n                      {interview.config.position}\n                    </div>\n                  </div>\n                  <div style={{\n                    background: '#e8f5e8',\n                    color: '#2d5016',\n                    padding: '4px 10px',\n                    borderRadius: '12px',\n                    fontSize: '0.8rem',\n                    fontWeight: '600'\n                  }}>\n                    {interview.config.experience}\n                  </div>\n                </div>\n\n                <div style={{ marginBottom: '15px', fontSize: '0.9rem', color: '#666' }}>\n                  📅 {formatDate(interview.timestamp)}\n                </div>\n\n                <div style={{\n                  display: 'grid',\n                  gridTemplateColumns: '1fr 1fr',\n                  gap: '10px',\n                  marginBottom: '15px',\n                  fontSize: '0.85rem'\n                }}>\n                  <div><strong>실제 면접:</strong> {formatTime(interview.statistics.actualInterviewTime || interview.statistics.totalTime - (interview.statistics.totalFeedbackTime || 0))}</div>\n                  <div><strong>질문 수:</strong> {interview.statistics.questionCount}개</div>\n                  <div><strong>답변 시간:</strong> {formatTime(interview.statistics.totalAnswerTime)}</div>\n                  <div><strong>사고 시간:</strong> {formatTime(interview.statistics.totalThinkingTime)}</div>\n                </div>\n\n                <div style={{\n                  textAlign: 'center',\n                  color: '#667eea',\n                  fontSize: '0.9rem',\n                  fontWeight: '600'\n                }}>\n                  클릭하여 상세 보기 →\n                </div>\n              </div>\n            ))}\n          </div>\n        )}\n      </div>\n    </div>\n  );\n});\n\nexport default InterviewHistory;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\PracticeRoom.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\PracticeSetup.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ProgressDashboard.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadProgressData'. Either include it or remove the dependency array.","line":37,"column":6,"nodeType":"ArrayExpression","endLine":37,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [loadProgressData, userId]","fix":{"range":[1098,1106],"text":"[loadProgressData, userId]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, memo } from 'react';\r\nimport { progressManagementService } from '../services/progressManagement';\r\n\r\ninterface ProgressDashboardProps {\r\n  userId: string;\r\n}\r\n\r\ninterface LevelProgress {\r\n  level: number;\r\n  totalStages: number;\r\n  completedStages: number;\r\n  averageCompletionRate: number;\r\n  totalTimeSpent: number;\r\n  overallAccuracy: number;\r\n  weakStages: string[];\r\n  strongStages: string[];\r\n}\r\n\r\ninterface OverallProgress {\r\n  totalLevels: number;\r\n  completedLevels: number;\r\n  currentLevel: number;\r\n  totalTimeSpent: number;\r\n  overallAccuracy: number;\r\n  totalSentencesStudied: number;\r\n  achievementBadges: string[];\r\n}\r\n\r\nconst ProgressDashboard: React.FC<ProgressDashboardProps> = memo(({ userId }) => {\r\n  const [overallProgress, setOverallProgress] = useState<OverallProgress | null>(null);\r\n  const [levelProgresses, setLevelProgresses] = useState<LevelProgress[]>([]);\r\n  const [selectedLevel, setSelectedLevel] = useState<number>(1);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n\r\n  useEffect(() => {\r\n    loadProgressData();\r\n  }, [userId]);\r\n\r\n  const loadProgressData = async () => {\r\n    setIsLoading(true);\r\n    try {\r\n      // 전체 진도와 레벨별 진도를 병렬로 로드\r\n      const [overall, ...levels] = await Promise.all([\r\n        progressManagementService.getOverallProgress(userId),\r\n        ...Array.from({length: 10}, (_, i) => \r\n          progressManagementService.getLevelProgress(userId, i + 1)\r\n        )\r\n      ]);\r\n      \r\n      setOverallProgress(overall);\r\n      setLevelProgresses(levels);\r\n      setSelectedLevel(overall.currentLevel);\r\n      \r\n    } catch (error) {\r\n      console.error('진도 데이터 로드 실패:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const formatTime = (minutes: number): string => {\r\n    if (minutes < 60) {\r\n      return `${Math.round(minutes)}분`;\r\n    } else {\r\n      const hours = Math.floor(minutes / 60);\r\n      const remainingMinutes = Math.round(minutes % 60);\r\n      return `${hours}시간 ${remainingMinutes}분`;\r\n    }\r\n  };\r\n\r\n  const formatPercentage = (value: number): string => {\r\n    return `${Math.round(value * 100)}%`;\r\n  };\r\n\r\n  const getLevelStatusColor = (completionRate: number, accuracy: number): string => {\r\n    if (completionRate >= 0.8 && accuracy >= 0.9) return 'bg-green-500';\r\n    if (completionRate >= 0.6 && accuracy >= 0.7) return 'bg-blue-500';\r\n    if (completionRate >= 0.3) return 'bg-yellow-500';\r\n    return 'bg-gray-400';\r\n  };\r\n\r\n  const getLevelTitle = (level: number): string => {\r\n    const titles = {\r\n      1: '기초 표현',\r\n      2: '기본 패턴',\r\n      3: '고급 문법',\r\n      4: '비즈니스',\r\n      5: '학술 연구',\r\n      6: '실용 영어',\r\n      7: '비즈니스 영어',\r\n      8: '고급 담화',\r\n      9: '전문가 담화',\r\n      10: '원어민 수준'\r\n    };\r\n    return titles[level as keyof typeof titles] || `Level ${level}`;\r\n  };\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center min-h-64\">\r\n        <div className=\"text-center\">\r\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4\"></div>\r\n          <p className=\"text-gray-600\">진도 데이터를 로드하고 있습니다...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!overallProgress) {\r\n    return (\r\n      <div className=\"text-center py-12\">\r\n        <h3 className=\"text-lg font-medium text-gray-900 mb-2\">진도 데이터가 없습니다</h3>\r\n        <p className=\"text-gray-600\">학습을 시작하면 진도를 추적할 수 있습니다!</p>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const selectedLevelData = levelProgresses.find(lp => lp.level === selectedLevel);\r\n\r\n  return (\r\n    <div className=\"max-w-6xl mx-auto p-6\">\r\n      <div className=\"mb-6\">\r\n        <h2 className=\"text-2xl font-bold text-gray-900 mb-2\">📊 학습 진도 관리</h2>\r\n        <p className=\"text-gray-600\">전체 학습 현황과 레벨별 상세 진도를 확인하세요</p>\r\n      </div>\r\n\r\n      {/* 전체 진도 요약 */}\r\n      <div className=\"bg-gradient-to-r from-blue-500 to-purple-600 text-white rounded-lg p-6 mb-8\">\r\n        <h3 className=\"text-lg font-semibold mb-4\">🎯 전체 학습 현황</h3>\r\n        \r\n        <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 mb-6\">\r\n          <div className=\"text-center\">\r\n            <div className=\"text-2xl font-bold\">{overallProgress.currentLevel}</div>\r\n            <div className=\"text-sm opacity-90\">현재 레벨</div>\r\n          </div>\r\n          <div className=\"text-center\">\r\n            <div className=\"text-2xl font-bold\">{overallProgress.completedLevels}/{overallProgress.totalLevels}</div>\r\n            <div className=\"text-sm opacity-90\">완료 레벨</div>\r\n          </div>\r\n          <div className=\"text-center\">\r\n            <div className=\"text-2xl font-bold\">{formatTime(overallProgress.totalTimeSpent)}</div>\r\n            <div className=\"text-sm opacity-90\">총 학습 시간</div>\r\n          </div>\r\n          <div className=\"text-center\">\r\n            <div className=\"text-2xl font-bold\">{formatPercentage(overallProgress.overallAccuracy)}</div>\r\n            <div className=\"text-sm opacity-90\">전체 정확도</div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* 성취 배지 */}\r\n        {overallProgress.achievementBadges.length > 0 && (\r\n          <div>\r\n            <h4 className=\"font-medium mb-3\">🏆 획득한 배지</h4>\r\n            <div className=\"flex flex-wrap gap-2\">\r\n              {overallProgress.achievementBadges.map((badge, index) => (\r\n                <span key={index} className=\"px-3 py-1 bg-white bg-opacity-20 rounded-full text-sm\">\r\n                  {badge}\r\n                </span>\r\n              ))}\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* 레벨별 진도 */}\r\n      <div className=\"bg-white border border-gray-200 rounded-lg p-6 mb-8\">\r\n        <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">📚 레벨별 진도</h3>\r\n        \r\n        <div className=\"grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-4 mb-6\">\r\n          {levelProgresses.map((levelProgress) => (\r\n            <div\r\n              key={levelProgress.level}\r\n              onClick={() => setSelectedLevel(levelProgress.level)}\r\n              className={`cursor-pointer border-2 rounded-lg p-4 transition-all ${\r\n                selectedLevel === levelProgress.level\r\n                  ? 'border-blue-500 bg-blue-50'\r\n                  : 'border-gray-200 hover:border-gray-300'\r\n              }`}\r\n            >\r\n              <div className=\"text-center\">\r\n                <div className={`w-8 h-8 rounded-full mx-auto mb-2 flex items-center justify-center text-white text-sm font-bold ${\r\n                  getLevelStatusColor(levelProgress.averageCompletionRate, levelProgress.overallAccuracy)\r\n                }`}>\r\n                  L{levelProgress.level}\r\n                </div>\r\n                <div className=\"text-sm font-medium text-gray-900\">\r\n                  {getLevelTitle(levelProgress.level)}\r\n                </div>\r\n                <div className=\"text-xs text-gray-600 mt-1\">\r\n                  {levelProgress.completedStages}/{levelProgress.totalStages} 완료\r\n                </div>\r\n                <div className=\"text-xs text-gray-600\">\r\n                  {formatPercentage(levelProgress.averageCompletionRate)}\r\n                </div>\r\n              </div>\r\n            </div>\r\n          ))}\r\n        </div>\r\n      </div>\r\n\r\n      {/* 선택된 레벨 상세 정보 */}\r\n      {selectedLevelData && (\r\n        <div className=\"bg-white border border-gray-200 rounded-lg p-6\">\r\n          <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">\r\n            📖 Level {selectedLevel} - {getLevelTitle(selectedLevel)} 상세 현황\r\n          </h3>\r\n          \r\n          {/* 상세 메트릭 */}\r\n          <div className=\"grid grid-cols-1 md:grid-cols-4 gap-4 mb-6\">\r\n            <div className=\"bg-gray-50 rounded-lg p-4 text-center\">\r\n              <div className=\"text-2xl font-bold text-blue-600\">\r\n                {selectedLevelData.completedStages}/{selectedLevelData.totalStages}\r\n              </div>\r\n              <div className=\"text-sm text-gray-600\">완료 스테이지</div>\r\n            </div>\r\n            \r\n            <div className=\"bg-gray-50 rounded-lg p-4 text-center\">\r\n              <div className=\"text-2xl font-bold text-green-600\">\r\n                {formatPercentage(selectedLevelData.averageCompletionRate)}\r\n              </div>\r\n              <div className=\"text-sm text-gray-600\">평균 완료율</div>\r\n            </div>\r\n            \r\n            <div className=\"bg-gray-50 rounded-lg p-4 text-center\">\r\n              <div className=\"text-2xl font-bold text-purple-600\">\r\n                {formatPercentage(selectedLevelData.overallAccuracy)}\r\n              </div>\r\n              <div className=\"text-sm text-gray-600\">전체 정확도</div>\r\n            </div>\r\n            \r\n            <div className=\"bg-gray-50 rounded-lg p-4 text-center\">\r\n              <div className=\"text-2xl font-bold text-orange-600\">\r\n                {formatTime(selectedLevelData.totalTimeSpent)}\r\n              </div>\r\n              <div className=\"text-sm text-gray-600\">학습 시간</div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* 진도 바 */}\r\n          <div className=\"mb-6\">\r\n            <div className=\"flex justify-between text-sm text-gray-600 mb-2\">\r\n              <span>레벨 진행도</span>\r\n              <span>{formatPercentage(selectedLevelData.completedStages / selectedLevelData.totalStages)}</span>\r\n            </div>\r\n            <div className=\"w-full bg-gray-200 rounded-full h-3\">\r\n              <div \r\n                className=\"bg-blue-600 h-3 rounded-full transition-all duration-300\"\r\n                style={{ width: `${(selectedLevelData.completedStages / selectedLevelData.totalStages) * 100}%` }}\r\n              ></div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* 취약점 및 강점 */}\r\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\r\n            {/* 취약한 스테이지 */}\r\n            <div>\r\n              <h4 className=\"font-medium text-gray-900 mb-3\">⚠️ 집중 필요 스테이지</h4>\r\n              {selectedLevelData.weakStages.length > 0 ? (\r\n                <div className=\"space-y-2\">\r\n                  {selectedLevelData.weakStages.map((stageId, index) => (\r\n                    <div key={index} className=\"flex items-center gap-3 p-3 bg-red-50 border border-red-200 rounded-lg\">\r\n                      <span className=\"w-2 h-2 bg-red-500 rounded-full\"></span>\r\n                      <span className=\"text-sm text-red-800\">{stageId}</span>\r\n                      <button className=\"ml-auto text-xs text-red-600 hover:text-red-800\">\r\n                        복습하기\r\n                      </button>\r\n                    </div>\r\n                  ))}\r\n                </div>\r\n              ) : (\r\n                <p className=\"text-sm text-gray-600 italic\">취약한 스테이지가 없습니다! 🎉</p>\r\n              )}\r\n            </div>\r\n\r\n            {/* 강점 스테이지 */}\r\n            <div>\r\n              <h4 className=\"font-medium text-gray-900 mb-3\">✨ 잘하는 스테이지</h4>\r\n              {selectedLevelData.strongStages.length > 0 ? (\r\n                <div className=\"space-y-2\">\r\n                  {selectedLevelData.strongStages.map((stageId, index) => (\r\n                    <div key={index} className=\"flex items-center gap-3 p-3 bg-green-50 border border-green-200 rounded-lg\">\r\n                      <span className=\"w-2 h-2 bg-green-500 rounded-full\"></span>\r\n                      <span className=\"text-sm text-green-800\">{stageId}</span>\r\n                      <span className=\"ml-auto text-xs text-green-600\">마스터!</span>\r\n                    </div>\r\n                  ))}\r\n                </div>\r\n              ) : (\r\n                <p className=\"text-sm text-gray-600 italic\">아직 마스터한 스테이지가 없습니다.</p>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default ProgressDashboard;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ProgressIndicator.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'status?.step'. Either include it or remove the dependency array.","line":96,"column":6,"nodeType":"ArrayExpression","endLine":96,"endColumn":59,"suggestions":[{"desc":"Update the dependencies array to be: [onComplete, onError, operation, stepMessages, speak, status?.step]","fix":{"range":[3372,3425],"text":"[onComplete, onError, operation, stepMessages, speak, status?.step]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback, useMemo, memo } from 'react';\r\nimport { io, Socket } from 'socket.io-client';\r\nimport { useVoiceGuidance } from '../hooks/useVoiceGuidance';\r\n\r\ninterface ProgressState {\r\n  step: string;\r\n  message?: string;\r\n  progress?: number;\r\n  data?: any;\r\n}\r\n\r\ninterface ProgressIndicatorProps {\r\n  operation: 'migrate' | 'validate' | 'pipeline';\r\n  onComplete?: (result: any) => void;\r\n  onError?: (error: any) => void;\r\n}\r\n\r\nexport const ProgressIndicator: React.FC<ProgressIndicatorProps> = memo(({\r\n  operation,\r\n  onComplete,\r\n  onError\r\n}) => {\r\n  const [socket, setSocket] = useState<Socket | null>(null);\r\n  const [status, setStatus] = useState<ProgressState | null>(null);\r\n  const [isRunning, setIsRunning] = useState(false);\r\n  const [logs, setLogs] = useState<string[]>([]);\r\n  const { speak } = useVoiceGuidance();\r\n\r\n  // Memoize step messages to prevent recreation on every render\r\n  const stepMessages = useMemo(() => ({\r\n    'STARTING': 'Starting operation',\r\n    'VALIDATION': 'Validating files',\r\n    'BACKUP': 'Creating backup',\r\n    'MIGRATION': 'Migrating files',\r\n    'FINALIZATION': 'Finalizing',\r\n    'STT_START': 'Starting speech recognition',\r\n    'STT_DONE': 'Speech recognition complete',\r\n    'LLM_START': 'Processing with AI',\r\n    'LLM_DONE': 'AI processing complete',\r\n    'TTS_START': 'Generating speech',\r\n    'TTS_DONE': 'Speech generation complete'\r\n  }), []);\r\n\r\n  // Memoize step weights to prevent recreation on every render\r\n  const stepWeights = useMemo(() => ({\r\n    'STARTING': 5,\r\n    'VALIDATION': 20,\r\n    'BACKUP': 30,\r\n    'MIGRATION': 70,\r\n    'FINALIZATION': 90,\r\n    'COMPLETED': 100,\r\n    'STT_START': 10,\r\n    'STT_DONE': 30,\r\n    'LLM_START': 50,\r\n    'LLM_DONE': 80,\r\n    'TTS_START': 90,\r\n    'TTS_DONE': 100\r\n  }), []);\r\n\r\n  useEffect(() => {\r\n    const socketConnection = io('http://localhost:8081');\r\n    setSocket(socketConnection);\r\n\r\n    socketConnection.on('progress', (msg: ProgressState) => {\r\n      console.log('[PROGRESS EVENT]', msg.step, msg.data, { progress: msg.progress, message: msg.message });\r\n      setStatus(msg);\r\n      setLogs(prev => [...prev, `[${new Date().toLocaleTimeString()}] ${msg.step}: ${msg.message || ''}`]);\r\n      \r\n      // Voice guidance for progress updates\r\n      if (stepMessages[msg.step]) {\r\n        speak(stepMessages[msg.step], 'system');\r\n      }\r\n    });\r\n\r\n    socketConnection.on('result', (res: any) => {\r\n      console.log('[RESULT EVENT]', res, { operation, timestamp: new Date().toISOString() });\r\n      setStatus({ step: 'COMPLETED', message: 'Operation completed successfully' });\r\n      setIsRunning(false);\r\n      setLogs(prev => [...prev, `[${new Date().toLocaleTimeString()}] RESULT: Success`]);\r\n      speak(`${operation} completed successfully`, 'system');\r\n      onComplete?.(res);\r\n    });\r\n\r\n    socketConnection.on('error', (err: any) => {\r\n      console.error('[ERROR EVENT]', err, { operation, step: status?.step, timestamp: new Date().toISOString() });\r\n      setStatus({ step: 'ERROR', message: err.message });\r\n      setIsRunning(false);\r\n      setLogs(prev => [...prev, `[${new Date().toLocaleTimeString()}] ERROR: ${err.message}`]);\r\n      speak(`${operation} failed: ${err.message}`, 'system');\r\n      onError?.(err);\r\n    });\r\n\r\n    return () => {\r\n      socketConnection.disconnect();\r\n    };\r\n  }, [onComplete, onError, operation, stepMessages, speak]);\r\n\r\n  const startOperation = useCallback((payload?: any) => {\r\n    if (!socket || isRunning) return;\r\n    \r\n    console.log('[OPERATION START]', { operation, payload, isRunning, socketConnected: !!socket });\r\n    setIsRunning(true);\r\n    setStatus({ step: 'STARTING', message: 'Initializing...' });\r\n    setLogs([`[${new Date().toLocaleTimeString()}] Starting ${operation} operation`]);\r\n    speak(`Starting ${operation} operation`, 'system');\r\n    \r\n    switch (operation) {\r\n      case 'migrate':\r\n        socket.emit('migrate-batch', payload);\r\n        break;\r\n      case 'validate':\r\n        socket.emit('validate-curriculum', payload);\r\n        break;\r\n      case 'pipeline':\r\n        socket.emit('pipeline', payload);\r\n        break;\r\n    }\r\n  }, [socket, isRunning, operation, speak]);\r\n\r\n  const getProgressPercentage = useCallback(() => {\r\n    if (!status) return 0;\r\n    if (status.progress) return status.progress;\r\n    \r\n    return stepWeights[status.step] || 0;\r\n  }, [status, stepWeights]);\r\n\r\n  const getStepColor = useCallback(() => {\r\n    if (!status) return 'bg-gray-200';\r\n    if (status.step === 'ERROR') return 'bg-red-500';\r\n    if (status.step === 'COMPLETED') return 'bg-green-500';\r\n    return 'bg-blue-500';\r\n  }, [status]);\r\n\r\n  return (\r\n    <div className=\"w-full max-w-2xl mx-auto p-6 bg-white rounded-lg shadow-lg\">\r\n      <div className=\"mb-4\">\r\n        <h3 className=\"text-lg font-semibold mb-2 capitalize\">{operation} Progress</h3>\r\n        \r\n        <div className=\"w-full bg-gray-200 rounded-full h-2.5\">\r\n          <div \r\n            className={`h-2.5 rounded-full transition-all duration-300 ${getStepColor()}`}\r\n            style={{ width: `${getProgressPercentage()}%` }}\r\n          />\r\n        </div>\r\n        \r\n        {status && (\r\n          <div className=\"mt-2 text-sm text-gray-600\">\r\n            <span className=\"font-medium\">{status.step}</span>\r\n            {status.message && <span className=\"ml-2\">{status.message}</span>}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {!isRunning && (\r\n        <button\r\n          onClick={() => startOperation()}\r\n          className=\"w-full bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded transition-colors\"\r\n          aria-label={`Start ${operation} operation`}\r\n        >\r\n          <span aria-hidden=\"true\">🎙️</span> Start {operation}\r\n        </button>\r\n      )}\r\n\r\n      {isRunning && (\r\n        <button\r\n          disabled\r\n          className=\"w-full bg-gray-400 text-white font-bold py-2 px-4 rounded cursor-not-allowed\"\r\n          aria-label={`${operation} operation in progress`}\r\n          aria-describedby=\"operation-status\"\r\n        >\r\n          <span aria-hidden=\"true\">⏳</span> {operation} in progress...\r\n        </button>\r\n      )}\r\n      \r\n      {status && (\r\n        <div id=\"operation-status\" className=\"sr-only\" aria-live=\"polite\">\r\n          Current step: {status.step}. {status.message}\r\n        </div>\r\n      )}\r\n\r\n      {logs.length > 0 && (\r\n        <div className=\"mt-4\">\r\n          <h4 className=\"text-sm font-medium mb-2\">Activity Log:</h4>\r\n          <div className=\"bg-gray-50 rounded p-3 max-h-48 overflow-y-auto\">\r\n            {logs.map((log, index) => (\r\n              <div key={index} className=\"text-xs text-gray-700 font-mono\">\r\n                {log}\r\n              </div>\r\n            ))}\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default ProgressIndicator;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\QuestionCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\QuestionDisplay.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ReviewAnalyticsDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ReviewCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ReviewSystem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\SentenceServiceTest.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\SmartReviewSession.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'initializeSession'. Either include it or remove the dependency array.","line":44,"column":6,"nodeType":"ArrayExpression","endLine":44,"endColumn":14,"suggestions":[{"desc":"Update the dependencies array to be: [initializeSession, userId]","fix":{"range":[1352,1360],"text":"[initializeSession, userId]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'calculateAccuracy' and 'completeSession'. Either include them or remove the dependency array.","line":170,"column":6,"nodeType":"ArrayExpression","endLine":170,"endColumn":78,"suggestions":[{"desc":"Update the dependencies array to be: [sentences, currentIndex, startTime, calculateAccuracy, userAnswer, userId, completeSession]","fix":{"range":[5631,5703],"text":"[sentences, currentIndex, startTime, calculateAccuracy, userAnswer, userId, completeSession]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'analyzeImprovementAreas'. Either include it or remove the dependency array.","line":194,"column":6,"nodeType":"ArrayExpression","endLine":194,"endColumn":34,"suggestions":[{"desc":"Update the dependencies array to be: [sessionResults, analyzeImprovementAreas, onComplete]","fix":{"range":[6586,6614],"text":"[sessionResults, analyzeImprovementAreas, onComplete]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback, memo } from 'react';\r\nimport { reviewAlgorithmService } from '../services/reviewAlgorithm';\r\nimport { ErrorBoundary } from './ErrorBoundary';\r\nimport { getRandomSentences } from '../services/sentenceService';\r\n\r\ninterface ReviewSentence {\r\n  id: string;\r\n  kr: string;\r\n  en: string;\r\n  level: number;\r\n  stage: string;\r\n  difficulty: 'easy' | 'medium' | 'hard';\r\n}\r\n\r\ninterface ReviewSessionProps {\r\n  userId: string;\r\n  onComplete: (results: ReviewResults) => void;\r\n}\r\n\r\ninterface ReviewResults {\r\n  totalSentences: number;\r\n  correctAnswers: number;\r\n  averageTime: number;\r\n  improvementAreas: string[];\r\n}\r\n\r\nconst SmartReviewSession: React.FC<ReviewSessionProps> = memo(({ userId, onComplete }) => {\r\n  const [sentences, setSentences] = useState<ReviewSentence[]>([]);\r\n  const [currentIndex, setCurrentIndex] = useState(0);\r\n  const [userAnswer, setUserAnswer] = useState('');\r\n  const [showAnswer, setShowAnswer] = useState(false);\r\n  const [startTime, setStartTime] = useState<number>(0);\r\n  const [sessionResults, setSessionResults] = useState<any[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [sessionStats, setSessionStats] = useState({\r\n    correct: 0,\r\n    total: 0,\r\n    streak: 0,\r\n    maxStreak: 0\r\n  });\r\n\r\n  useEffect(() => {\r\n    initializeSession();\r\n  }, [userId]);\r\n\r\n  const initializeSession = useCallback(async () => {\r\n    console.log('[DEBUG] 🔄 복습 세션 초기화 시작:', { userId });\r\n    setIsLoading(true);\r\n    try {\r\n      // 오늘의 복습 문장들 가져오기\r\n      const sentenceIds = await reviewAlgorithmService.getTodayReviewSentences(userId, 30);\r\n      console.log('[DEBUG] 📝 복습 문장 ID들:', sentenceIds);\r\n      \r\n      // 실제 문장 데이터 가져오기 - 다양한 레벨에서 랜덤 선택\r\n      const reviewSentences: ReviewSentence[] = [];\r\n      const levels = [1, 2, 3, 4, 5, 6];\r\n      const stagesPerLevel = ['S01', 'S02', 'S03', 'S04', 'S05'];\r\n      \r\n      for (let i = 0; i < sentenceIds.length && i < 30; i++) {\r\n        const level = levels[Math.floor(Math.random() * levels.length)];\r\n        const stage = stagesPerLevel[Math.floor(Math.random() * stagesPerLevel.length)];\r\n        const stageId = `Lv${level}-P1-${stage}`;\r\n        \r\n        console.log('[DEBUG] 🎲 문장 요청:', { level, stageId, index: i });\r\n        \r\n        try {\r\n          const sentences = await getRandomSentences(level, stageId, 1);\r\n          if (sentences.length > 0) {\r\n            const sentenceData = sentences[0];\r\n            reviewSentences.push({\r\n              id: sentenceData.sentence.id,\r\n              kr: sentenceData.sentence.kr,\r\n              en: sentenceData.sentence.en,\r\n              level: level,\r\n              stage: stageId,\r\n              difficulty: level <= 2 ? 'easy' : level <= 4 ? 'medium' : 'hard'\r\n            });\r\n            console.log('[DEBUG] ✅ 문장 추가:', { kr: sentenceData.sentence.kr });\r\n          } else {\r\n            console.warn('[DEBUG] ⚠️ 문장 없음, fallback 사용:', { level, stageId });\r\n            // Fallback 문장\r\n            reviewSentences.push({\r\n              id: `fallback-${i}`,\r\n              kr: `복습 문장 ${i + 1}`,\r\n              en: `Review sentence ${i + 1}`,\r\n              level: level,\r\n              stage: stageId,\r\n              difficulty: 'medium'\r\n            });\r\n          }\r\n        } catch (error) {\r\n          console.error('[DEBUG] ❌ 문장 로드 실패:', error);\r\n          // Fallback 문장 추가\r\n          reviewSentences.push({\r\n            id: `error-fallback-${i}`,\r\n            kr: `복습 문장 ${i + 1}`,\r\n            en: `Review sentence ${i + 1}`,\r\n            level: level,\r\n            stage: stageId,\r\n            difficulty: 'medium'\r\n          });\r\n        }\r\n      }\r\n      \r\n      console.log('[DEBUG] 📚 복습 세션 문장들 로드 완료:', { count: reviewSentences.length });\r\n      setSentences(reviewSentences);\r\n      setStartTime(Date.now());\r\n    } catch (error) {\r\n      console.error('[DEBUG] ❌ 복습 세션 초기화 실패:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [userId]);\r\n\r\n  const handleSubmitAnswer = useCallback(() => {\r\n    if (!userAnswer.trim()) return;\r\n    \r\n    setShowAnswer(true);\r\n  }, [userAnswer]);\r\n\r\n  const handleDifficultyFeedback = useCallback(async (difficulty: 'easy' | 'medium' | 'hard') => {\r\n    const currentSentence = sentences[currentIndex];\r\n    const responseTime = Date.now() - startTime;\r\n    \r\n    // 정확도 계산 (간단한 유사도 비교)\r\n    const accuracy = calculateAccuracy(userAnswer, currentSentence.en);\r\n    \r\n    // 복습 세션 데이터 저장\r\n    const sessionData = {\r\n      sentenceId: currentSentence.id,\r\n      userId,\r\n      accuracy,\r\n      responseTime,\r\n      difficulty,\r\n      timestamp: new Date(),\r\n      reviewCount: 0, // 실제로는 기존 카운트 + 1\r\n      intervalDays: 1\r\n    };\r\n\r\n    // 알고리즘에 피드백 전달 및 다음 복습 일정 계산\r\n    try {\r\n      // await reviewAlgorithmService.recordReviewSession(sessionData);\r\n      \r\n      // 세션 결과 기록\r\n      setSessionResults(prev => [...prev, { ...sessionData, correct: accuracy > 0.7 }]);\r\n      \r\n      // 통계 업데이트\r\n      const isCorrect = accuracy > 0.7;\r\n      setSessionStats(prev => ({\r\n        correct: prev.correct + (isCorrect ? 1 : 0),\r\n        total: prev.total + 1,\r\n        streak: isCorrect ? prev.streak + 1 : 0,\r\n        maxStreak: Math.max(prev.maxStreak, isCorrect ? prev.streak + 1 : prev.streak)\r\n      }));\r\n      \r\n    } catch (error) {\r\n      console.error('복습 결과 저장 실패:', error);\r\n    }\r\n\r\n    // 다음 문장으로 이동\r\n    if (currentIndex < sentences.length - 1) {\r\n      setCurrentIndex(prev => prev + 1);\r\n      setUserAnswer('');\r\n      setShowAnswer(false);\r\n      setStartTime(Date.now());\r\n    } else {\r\n      // 세션 완료\r\n      completeSession();\r\n    }\r\n  }, [sentences, currentIndex, userAnswer, userId, startTime, sessionResults]);\r\n\r\n  const calculateAccuracy = useCallback((userAnswer: string, correctAnswer: string): number => {\r\n    // 간단한 유사도 계산 (실제로는 더 정교한 알고리즘 사용)\r\n    const userWords = userAnswer.toLowerCase().split(' ');\r\n    const correctWords = correctAnswer.toLowerCase().split(' ');\r\n    \r\n    let matches = 0;\r\n    correctWords.forEach(word => {\r\n      if (userWords.includes(word)) matches++;\r\n    });\r\n    \r\n    return correctWords.length > 0 ? matches / correctWords.length : 0;\r\n  }, []);\r\n\r\n  const completeSession = useCallback(() => {\r\n    const results: ReviewResults = {\r\n      totalSentences: sessionResults.length,\r\n      correctAnswers: sessionResults.filter(r => r.correct).length,\r\n      averageTime: sessionResults.reduce((sum, r) => sum + r.responseTime, 0) / sessionResults.length,\r\n      improvementAreas: analyzeImprovementAreas()\r\n    };\r\n    \r\n    onComplete(results);\r\n  }, [sessionResults, onComplete]);\r\n\r\n  const analyzeImprovementAreas = (): string[] => {\r\n    const areas: string[] = [];\r\n    \r\n    // 응답 시간 분석\r\n    const avgTime = sessionResults.reduce((sum, r) => sum + r.responseTime, 0) / sessionResults.length;\r\n    if (avgTime > 10000) areas.push('응답 속도 개선');\r\n    \r\n    // 정확도 분석\r\n    const accuracy = sessionResults.filter(r => r.correct).length / sessionResults.length;\r\n    if (accuracy < 0.7) areas.push('정확도 향상');\r\n    \r\n    // 어려운 문장 분석\r\n    const hardSentenceErrors = sessionResults.filter(r => r.difficulty === 'hard' && !r.correct);\r\n    if (hardSentenceErrors.length > 2) areas.push('고급 문법 집중 학습');\r\n    \r\n    return areas;\r\n  };\r\n\r\n  const getProgressPercentage = () => {\r\n    return sentences.length > 0 ? ((currentIndex + 1) / sentences.length) * 100 : 0;\r\n  };\r\n\r\n  const getDifficultyColor = (difficulty: string) => {\r\n    switch (difficulty) {\r\n      case 'easy': return 'text-green-600';\r\n      case 'medium': return 'text-yellow-600';\r\n      case 'hard': return 'text-red-600';\r\n      default: return 'text-gray-600';\r\n    }\r\n  };\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"flex items-center justify-center min-h-64\">\r\n        <div className=\"text-center\">\r\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4\"></div>\r\n          <p className=\"text-gray-600\">개인 맞춤 복습 세션을 준비하고 있습니다...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (sentences.length === 0) {\r\n    return (\r\n      <div className=\"text-center py-12\">\r\n        <h3 className=\"text-lg font-medium text-gray-900 mb-2\">오늘 복습할 문장이 없습니다!</h3>\r\n        <p className=\"text-gray-600\">새로운 학습을 시작하거나 내일 다시 확인해보세요.</p>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const currentSentence = sentences[currentIndex];\r\n\r\n  return (\r\n    <ErrorBoundary \r\n      level=\"component\"\r\n      onError={(error, errorInfo) => {\r\n        console.error('[DEBUG] SmartReviewSession 에러:', error, errorInfo);\r\n      }}\r\n    >\r\n      <div className=\"max-w-4xl mx-auto p-6\">\r\n      {/* 진행률 및 통계 */}\r\n      <div className=\"mb-6\">\r\n        <div className=\"flex justify-between items-center mb-4\">\r\n          <h2 className=\"text-2xl font-bold text-gray-900\">🧠 스마트 복습</h2>\r\n          <div className=\"flex gap-4 text-sm\">\r\n            <span className=\"text-green-600\">정답: {sessionStats.correct}</span>\r\n            <span className=\"text-gray-600\">총계: {sessionStats.total}</span>\r\n            <span className=\"text-blue-600\">연속: {sessionStats.streak}</span>\r\n          </div>\r\n        </div>\r\n        \r\n        <div className=\"w-full bg-gray-200 rounded-full h-2 mb-2\">\r\n          <div \r\n            className=\"bg-blue-600 h-2 rounded-full transition-all duration-300\"\r\n            style={{ width: `${getProgressPercentage()}%` }}\r\n          ></div>\r\n        </div>\r\n        \r\n        <div className=\"flex justify-between text-sm text-gray-600\">\r\n          <span>{currentIndex + 1} / {sentences.length}</span>\r\n          <span className={getDifficultyColor(currentSentence.difficulty)}>\r\n            {currentSentence.difficulty.toUpperCase()}\r\n          </span>\r\n        </div>\r\n      </div>\r\n\r\n      {/* 문장 정보 */}\r\n      <div className=\"bg-white border border-gray-200 rounded-lg p-6 mb-6\">\r\n        <div className=\"flex justify-between items-start mb-4\">\r\n          <div>\r\n            <span className=\"text-sm text-gray-500\">{currentSentence.stage}</span>\r\n            <span className=\"ml-2 px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded\">\r\n              Level {currentSentence.level}\r\n            </span>\r\n          </div>\r\n        </div>\r\n        \r\n        <div className=\"mb-6\">\r\n          <p className=\"text-lg text-gray-900 mb-2\">다음 문장을 영어로 번역하세요:</p>\r\n          <p className=\"text-xl font-medium text-blue-900 bg-blue-50 p-4 rounded-lg\">\r\n            {currentSentence.kr}\r\n          </p>\r\n        </div>\r\n\r\n        {/* 답변 입력 */}\r\n        <div className=\"mb-6\">\r\n          <textarea\r\n            value={userAnswer}\r\n            onChange={(e) => setUserAnswer(e.target.value)}\r\n            placeholder=\"영어 번역을 입력하세요...\"\r\n            className=\"w-full p-4 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\r\n            rows={3}\r\n            disabled={showAnswer}\r\n          />\r\n        </div>\r\n\r\n        {/* 답변 확인 또는 결과 */}\r\n        {!showAnswer ? (\r\n          <button\r\n            onClick={handleSubmitAnswer}\r\n            disabled={!userAnswer.trim()}\r\n            className=\"w-full px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors\"\r\n          >\r\n            답변 확인\r\n          </button>\r\n        ) : (\r\n          <div>\r\n            <div className=\"mb-6 p-4 bg-gray-50 rounded-lg\">\r\n              <h4 className=\"font-medium text-gray-900 mb-2\">정답:</h4>\r\n              <p className=\"text-lg text-gray-800\">{currentSentence.en}</p>\r\n              \r\n              <h4 className=\"font-medium text-gray-900 mt-4 mb-2\">내 답변:</h4>\r\n              <p className=\"text-lg text-blue-800\">{userAnswer}</p>\r\n            </div>\r\n\r\n            <div className=\"mb-4\">\r\n              <p className=\"text-sm text-gray-600 mb-3\">이 문제의 난이도는 어떠셨나요?</p>\r\n              <div className=\"flex gap-3\">\r\n                <button\r\n                  onClick={() => handleDifficultyFeedback('easy')}\r\n                  className=\"flex-1 px-4 py-2 bg-green-100 text-green-800 rounded-lg hover:bg-green-200 transition-colors\"\r\n                >\r\n                  😊 쉬웠어요\r\n                </button>\r\n                <button\r\n                  onClick={() => handleDifficultyFeedback('medium')}\r\n                  className=\"flex-1 px-4 py-2 bg-yellow-100 text-yellow-800 rounded-lg hover:bg-yellow-200 transition-colors\"\r\n                >\r\n                  🤔 보통이에요\r\n                </button>\r\n                <button\r\n                  onClick={() => handleDifficultyFeedback('hard')}\r\n                  className=\"flex-1 px-4 py-2 bg-red-100 text-red-800 rounded-lg hover:bg-red-200 transition-colors\"\r\n                >\r\n                  😅 어려웠어요\r\n                </button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* 세션 통계 (실시간) */}\r\n      {sessionStats.total > 0 && (\r\n        <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\r\n          <h4 className=\"font-medium text-blue-900 mb-2\">현재 세션 통계</h4>\r\n          <div className=\"grid grid-cols-3 gap-4 text-sm\">\r\n            <div className=\"text-center\">\r\n              <div className=\"text-lg font-bold text-blue-600\">\r\n                {Math.round((sessionStats.correct / sessionStats.total) * 100)}%\r\n              </div>\r\n              <div className=\"text-gray-600\">정확도</div>\r\n            </div>\r\n            <div className=\"text-center\">\r\n              <div className=\"text-lg font-bold text-green-600\">{sessionStats.maxStreak}</div>\r\n              <div className=\"text-gray-600\">최고 연속</div>\r\n            </div>\r\n            <div className=\"text-center\">\r\n              <div className=\"text-lg font-bold text-purple-600\">\r\n                {sessionResults.length > 0 ? \r\n                  Math.round(sessionResults.reduce((sum, r) => sum + r.responseTime, 0) / sessionResults.length / 1000) : 0}초\r\n              </div>\r\n              <div className=\"text-gray-600\">평균 시간</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )}\r\n      </div>\r\n    </ErrorBoundary>\r\n  );\r\n});\r\n\r\nSmartReviewSession.displayName = 'SmartReviewSession';\r\n\r\nexport default SmartReviewSession;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\SpeakingFlowController.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'currentPhase' and 'startSpeakingFlow'. Either include them or remove the dependency array.","line":70,"column":6,"nodeType":"ArrayExpression","endLine":70,"endColumn":36,"suggestions":[{"desc":"Update the dependencies array to be: [autoStart, disabled, card.id, currentPhase, startSpeakingFlow]","fix":{"range":[2260,2290],"text":"[autoStart, disabled, card.id, currentPhase, startSpeakingFlow]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\r\nimport type { DrillCard } from '@/types';\r\n\r\ninterface SpeakingFlowControllerProps {\r\n  card: DrillCard;\r\n  stage: 1 | 2 | 3;\r\n  onResult: (transcript: string, confidence: number) => void;\r\n  onError?: (error: string) => void;\r\n  disabled?: boolean;\r\n  autoStart?: boolean;\r\n}\r\n\r\ntype FlowPhase = 'idle' | 'tts' | 'countdown' | 'recognition' | 'waiting' | 'completed';\r\n\r\nexport const SpeakingFlowController: React.FC<SpeakingFlowControllerProps> = ({\r\n  card,\r\n  stage,\r\n  onResult,\r\n  onError,\r\n  disabled = false,\r\n  autoStart = false,\r\n}) => {\r\n  const [currentPhase, setCurrentPhase] = useState<FlowPhase>('idle');\r\n  const [countdown, setCountdown] = useState<number>(0);\r\n  const [speechTimer, setSpeechTimer] = useState<number>(0);\r\n  const [recognizedText, setRecognizedText] = useState<string>('');\r\n  const [isCompleted, setIsCompleted] = useState(false);\r\n\r\n  // Refs for cleanup\r\n  const countdownIntervalRef = useRef<NodeJS.Timeout | null>(null);\r\n  const speechTimerRef = useRef<NodeJS.Timeout | null>(null);\r\n  const recognitionTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n  const recognitionRef = useRef<any>(null);\r\n\r\n  // Stage configuration\r\n  const stageConfig = {\r\n    1: { thinkingTime: 3, description: '3초 사고시간' },\r\n    2: { thinkingTime: 2, description: '2초 사고시간' }, \r\n    3: { thinkingTime: 1, description: '1초 사고시간' },\r\n  };\r\n\r\n  // Cleanup function\r\n  const cleanup = () => {\r\n    if (countdownIntervalRef.current) {\r\n      clearInterval(countdownIntervalRef.current);\r\n      countdownIntervalRef.current = null;\r\n    }\r\n    if (speechTimerRef.current) {\r\n      clearInterval(speechTimerRef.current);\r\n      speechTimerRef.current = null;\r\n    }\r\n    if (recognitionTimeoutRef.current) {\r\n      clearTimeout(recognitionTimeoutRef.current);\r\n      recognitionTimeoutRef.current = null;\r\n    }\r\n    if (recognitionRef.current) {\r\n      recognitionRef.current.stop();\r\n      recognitionRef.current = null;\r\n    }\r\n  };\r\n\r\n  // Auto start effect\r\n  useEffect(() => {\r\n    if (autoStart && !disabled && currentPhase === 'idle') {\r\n      const timer = setTimeout(() => {\r\n        startSpeakingFlow();\r\n      }, 500);\r\n      return () => clearTimeout(timer);\r\n    }\r\n  }, [autoStart, disabled, card.id]);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return cleanup;\r\n  }, []);\r\n\r\n  // Reset when card changes\r\n  useEffect(() => {\r\n    setCurrentPhase('idle');\r\n    setIsCompleted(false);\r\n    setRecognizedText('');\r\n    cleanup();\r\n  }, [card.id]);\r\n\r\n  const startSpeakingFlow = async () => {\r\n    if (disabled || isCompleted) return;\r\n    \r\n    console.log('🎤 Speaking 플로우 시작:', card.front_ko);\r\n    setCurrentPhase('tts');\r\n    setIsCompleted(false);\r\n    \r\n    try {\r\n      // 🔧 플러그인을 통한 한국어 TTS 재생\r\n      console.log('🔊 TTS 재생 시작 (플러그인):', card.front_ko);\r\n\r\n      try {\r\n        const ServiceContainer = (await import('@/container/ServiceContainer')).default;\r\n        const container = ServiceContainer.getInstanceSync();\r\n        const speechService = container.getSpeechProcessingService();\r\n\r\n        // 기존 TTS 중지\r\n        speechService.stopAllSpeech();\r\n\r\n        console.log('🔊 TTS 시작됨 (플러그인):', card.front_ko);\r\n\r\n        await speechService.speakAnswer(card.front_ko, {\r\n          language: 'ko-KR',\r\n          rate: 0.8,\r\n          volume: 1.0,\r\n          pitch: 1.0\r\n        });\r\n\r\n        console.log('🔊 TTS 완료됨 (플러그인):', card.front_ko);\r\n        setTimeout(() => {\r\n          if (!isCompleted) startCountdown();\r\n        }, 1000);\r\n\r\n      } catch (speechError) {\r\n        console.error('🔊 TTS 플러그인 오류:', speechError);\r\n        // 플러그인 실패시 카운트다운 시작\r\n        setTimeout(() => {\r\n          if (!isCompleted) startCountdown();\r\n        }, 2000);\r\n      }\r\n    } catch (error) {\r\n      console.error('🔧 TTS 시스템 오류:', error);\r\n      if (onError) {\r\n        onError('음성 재생에 실패했습니다.');\r\n      }\r\n    }\r\n  };\r\n\r\n  const startCountdown = () => {\r\n    console.log('⏳ 사고시간 카운트다운 시작');\r\n    setCurrentPhase('countdown');\r\n    \r\n    const thinkingTime = stageConfig[stage].thinkingTime;\r\n    setCountdown(thinkingTime);\r\n    \r\n    countdownIntervalRef.current = setInterval(() => {\r\n      setCountdown(prev => {\r\n        if (prev <= 1) {\r\n          if (countdownIntervalRef.current) {\r\n            clearInterval(countdownIntervalRef.current);\r\n            countdownIntervalRef.current = null;\r\n          }\r\n          \r\n          // 비프음 재생 후 음성 인식 시작\r\n          playBeepSound();\r\n          setTimeout(() => {\r\n            if (!isCompleted) startSpeechRecognition();\r\n          }, 200);\r\n          \r\n          return 0;\r\n        }\r\n        return prev - 1;\r\n      });\r\n    }, 1000);\r\n  };\r\n\r\n  const playBeepSound = () => {\r\n    try {\r\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      const oscillator = audioContext.createOscillator();\r\n      const gainNode = audioContext.createGain();\r\n      \r\n      oscillator.connect(gainNode);\r\n      gainNode.connect(audioContext.destination);\r\n      \r\n      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);\r\n      oscillator.type = 'sine';\r\n      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\r\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);\r\n      \r\n      oscillator.start(audioContext.currentTime);\r\n      oscillator.stop(audioContext.currentTime + 0.2);\r\n    } catch (error) {\r\n      console.error('비프음 재생 실패:', error);\r\n    }\r\n  };\r\n\r\n  const startSpeechRecognition = () => {\r\n    if (isCompleted || currentPhase === 'recognition') {\r\n      console.log('⚠️ 이미 음성 인식 중이거나 완료됨 - 중복 실행 방지');\r\n      return;\r\n    }\r\n    \r\n    console.log('🎤 음성 인식 시작 - 10초 제한');\r\n    setCurrentPhase('recognition');\r\n    setSpeechTimer(0);\r\n    setRecognizedText('');\r\n    \r\n    // 음성인식 타이머 시작\r\n    speechTimerRef.current = setInterval(() => {\r\n      setSpeechTimer(prev => prev + 0.1);\r\n    }, 100);\r\n\r\n    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {\r\n      const SpeechRecognition = (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition;\r\n      const recognition = new SpeechRecognition();\r\n      recognitionRef.current = recognition;\r\n      \r\n      recognition.continuous = false;\r\n      recognition.interimResults = true; // HTML 버전과 동일\r\n      recognition.lang = 'en-US';\r\n      recognition.maxAlternatives = 5; // HTML 버전과 동일\r\n      \r\n      // 음성인식 정확도 개선 설정 (HTML 버전에서 가져옴)\r\n      if (recognition.serviceURI) {\r\n        recognition.serviceURI = 'wss://www.google.com/speech-api/v2/recognize';\r\n      }\r\n      \r\n      let recognitionCompleted = false;\r\n      \r\n      recognition.onstart = () => {\r\n        console.log('🎯 음성 인식 시작됨');\r\n      };\r\n      \r\n      recognition.onresult = (event: any) => {\r\n        if (recognitionCompleted || isCompleted) return;\r\n        recognitionCompleted = true;\r\n        \r\n        console.log('✅ 음성 인식 완료');\r\n        \r\n        if (event.results && event.results.length > 0) {\r\n          const transcript = event.results[0][0].transcript;\r\n          const confidence = event.results[0][0].confidence || 0.9;\r\n          \r\n          console.log('📝 인식된 텍스트:', transcript);\r\n          setRecognizedText(transcript);\r\n          \r\n          // 정리 작업\r\n          cleanup();\r\n          setCurrentPhase('completed');\r\n          setIsCompleted(true);\r\n          \r\n          // 결과 전달 - HTML 버전처럼 즉시 전달하고 4초 후 다음으로\r\n          onResult(transcript.trim(), confidence);\r\n        }\r\n      };\r\n      \r\n      recognition.onerror = (event: any) => {\r\n        if (recognitionCompleted || isCompleted) return;\r\n        recognitionCompleted = true;\r\n        \r\n        console.error('😨 음성 인식 오류:', event.error);\r\n        cleanup();\r\n        setCurrentPhase('completed');\r\n        setIsCompleted(true);\r\n        \r\n        // 오류가 발생해도 빈 답변으로 처리하여 다음으로 진행\r\n        console.log('🔄 음성 인식 오류 - 빈 답변으로 처리하여 진행');\r\n        setTimeout(() => {\r\n          onResult('', 0.1); // 빈 답변으로 처리\r\n        }, 0);\r\n      };\r\n      \r\n      recognition.onend = () => {\r\n        console.log('🔇 음성 인식 종료');\r\n      };\r\n      \r\n      // 10초 타임아웃 설정 (더 길게)\r\n      recognitionTimeoutRef.current = setTimeout(() => {\r\n        if (recognitionCompleted || isCompleted) return;\r\n        recognitionCompleted = true;\r\n        \r\n        console.log('⏰ 음성 인식 시간 초과 (10초) - 빈 답변으로 처리하여 진행');\r\n        recognition.stop();\r\n        cleanup();\r\n        setCurrentPhase('completed');\r\n        setIsCompleted(true);\r\n        \r\n        // 시간 초과 시에도 빈 답변으로 처리하여 다음으로 진행\r\n        setTimeout(() => {\r\n          onResult('', 0.1);\r\n        }, 0);\r\n      }, 10000);\r\n      \r\n      recognition.start();\r\n    } else {\r\n      if (onError) {\r\n        onError('이 브라우저는 음성 인식을 지원하지 않습니다.');\r\n      }\r\n    }\r\n  };\r\n\r\n  const handleManualStart = () => {\r\n    if (!disabled && currentPhase === 'idle') {\r\n      startSpeakingFlow();\r\n    }\r\n  };\r\n\r\n  const handleStop = () => {\r\n    cleanup();\r\n    setCurrentPhase('idle');\r\n    setIsCompleted(false);\r\n    setRecognizedText('');\r\n  };\r\n\r\n  return (\r\n    <div className=\"bg-white rounded-lg shadow-lg p-6\">\r\n      <div className=\"text-center\">\r\n        {/* Phase Status Display */}\r\n        {currentPhase !== 'idle' && (\r\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-6 mb-6\">\r\n            <div className=\"text-center\">\r\n              <div className=\"text-lg font-semibold text-blue-800 mb-4\">\r\n                {currentPhase === 'tts' && '🔊 한국어를 들려드리고 있습니다...'}\r\n                {currentPhase === 'countdown' && `⏳ ${countdown}초 후 음성 인식 시작 (${stageConfig[stage].description})`}\r\n                {currentPhase === 'recognition' && `🎤 지금 영어로 말해주세요! (${speechTimer.toFixed(1)}초 / 10초)`}\r\n                {currentPhase === 'waiting' && '⌛ 잠시 기다려주세요...'}\r\n                {currentPhase === 'completed' && '✅ 음성 인식 완료!'}\r\n              </div>\r\n              \r\n              {currentPhase === 'recognition' && (\r\n                <>\r\n                  {/* 진행 바 */}\r\n                  <div className=\"w-full bg-blue-200 rounded-full h-3 mb-4\">\r\n                    <div \r\n                      className=\"bg-red-500 h-3 rounded-full transition-all duration-100\"\r\n                      style={{ width: `${Math.min((speechTimer / 10) * 100, 100)}%` }}\r\n                    />\r\n                  </div>\r\n                  \r\n                  {/* 녹음 표시기 */}\r\n                  <div className=\"flex items-center justify-center space-x-3\">\r\n                    <div className=\"w-3 h-3 bg-red-500 rounded-full animate-pulse\"></div>\r\n                    <span className=\"text-sm text-blue-700\">\r\n                      음성을 인식하고 있습니다... ({speechTimer.toFixed(1)}초 / 10초)\r\n                    </span>\r\n                  </div>\r\n                </>\r\n              )}\r\n              \r\n              {currentPhase === 'tts' && (\r\n                <div className=\"flex items-center justify-center space-x-3\">\r\n                  <div className=\"w-3 h-3 bg-green-500 rounded-full animate-pulse\"></div>\r\n                  <span className=\"text-sm text-blue-700\">한국어 문제를 재생 중...</span>\r\n                </div>\r\n              )}\r\n              \r\n              {currentPhase === 'countdown' && countdown > 0 && (\r\n                <div className=\"flex items-center justify-center space-x-3\">\r\n                  <div className=\"w-3 h-3 bg-yellow-500 rounded-full animate-pulse\"></div>\r\n                  <span className=\"text-sm text-blue-700\">사고시간: {countdown}초 남음</span>\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* Manual start button */}\r\n        {currentPhase === 'idle' && !autoStart && (\r\n          <button\r\n            onClick={handleManualStart}\r\n            disabled={disabled}\r\n            className=\"px-8 py-4 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors text-lg\"\r\n          >\r\n            🎤 Speaking 시작하기\r\n          </button>\r\n        )}\r\n        \r\n        {/* Stop button during recognition */}\r\n        {currentPhase === 'recognition' && (\r\n          <button\r\n            onClick={handleStop}\r\n            className=\"px-6 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition-colors\"\r\n          >\r\n            ⏹️ 중지\r\n          </button>\r\n        )}\r\n\r\n        {/* Recognized text display */}\r\n        {recognizedText && (\r\n          <div className=\"mt-4 p-4 bg-green-50 border border-green-200 rounded-lg\">\r\n            <div className=\"text-sm text-green-600 mb-1\">인식된 음성:</div>\r\n            <div className=\"font-medium text-green-800\">\"{recognizedText}\"</div>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\SpeakingStageSelector.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\SpeechRecorder.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'autoFlow', 'autoFlowState', and 'handleAutoFlowStart'. Either include them or remove the dependency array.","line":61,"column":6,"nodeType":"ArrayExpression","endLine":61,"endColumn":39,"suggestions":[{"desc":"Update the dependencies array to be: [koreanText, autoStart, disabled, autoFlow, autoFlowState, handleAutoFlowStart]","fix":{"range":[2086,2119],"text":"[koreanText, autoStart, disabled, autoFlow, autoFlowState, handleAutoFlowStart]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'autoTimeout' and 'timerInterval'. Either include them or remove the dependency array.","line":69,"column":6,"nodeType":"ArrayExpression","endLine":69,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [autoTimeout, timerInterval]","fix":{"range":[2307,2309],"text":"[autoTimeout, timerInterval]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'onResult' and 'speech.confidence'. Either include them or remove the dependency array. If 'onResult' changes too often, find the parent component that defines it and wrap that definition in useCallback.","line":316,"column":6,"nodeType":"ArrayExpression","endLine":316,"endColumn":52,"suggestions":[{"desc":"Update the dependencies array to be: [speech.transcript, autoFlow, isAutoRecording, speech.confidence, onResult]","fix":{"range":[9549,9595],"text":"[speech.transcript, autoFlow, isAutoRecording, speech.confidence, onResult]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback, useMemo, memo } from 'react';\r\nimport { useSpeech } from '@/hooks/useSpeech';\r\n\r\ninterface SpeechRecorderProps {\r\n  onResult: (transcript: string, confidence: number) => void;\r\n  onError?: (error: string) => void;\r\n  phraseHints?: string[];\r\n  disabled?: boolean;\r\n  className?: string;\r\n  // Auto-flow props\r\n  autoFlow?: boolean;\r\n  koreanText?: string;\r\n  autoStart?: boolean;\r\n  onAutoFlowStateChange?: (state: 'idle' | 'tts' | 'beep' | 'waiting' | 'recording') => void;\r\n}\r\n\r\nexport const SpeechRecorder: React.FC<SpeechRecorderProps> = memo(({\r\n  onResult,\r\n  onError,\r\n  phraseHints = [], // 음성 인식 힌트 (향후 구현 예정)\r\n  disabled = false,\r\n  className = '',\r\n  autoFlow = false,\r\n  koreanText = '',\r\n  autoStart = false,\r\n  onAutoFlowStateChange,\r\n}) => {\r\n  const [isPressed, setIsPressed] = useState(false);\r\n  const [autoFlowState, setAutoFlowState] = useState<'idle' | 'tts' | 'beep' | 'waiting' | 'recording'>('idle');\r\n  const [isAutoRecording, setIsAutoRecording] = useState(false);\r\n  const [speechTimer, setSpeechTimer] = useState<number>(0);\r\n  const [timerInterval, setTimerInterval] = useState<NodeJS.Timeout | null>(null);\r\n  const [autoTimeout, setAutoTimeout] = useState<NodeJS.Timeout | null>(null);\r\n  \r\n  const speechConfig = useMemo(() => ({\r\n    apiBaseUrl: import.meta.env.VITE_API_BASE_URL,\r\n    preferCloudSTT: false, // Start with browser STT\r\n    language: 'en-US',\r\n  }), []);\r\n  \r\n  const speech = useSpeech(speechConfig);\r\n\r\n  // Auto-flow state management\r\n  const updateAutoFlowState = useCallback((newState: typeof autoFlowState) => {\r\n    setAutoFlowState(newState);\r\n    if (onAutoFlowStateChange) {\r\n      onAutoFlowStateChange(newState);\r\n    }\r\n  }, [onAutoFlowStateChange]);\r\n\r\n  // Auto-start effect\r\n  useEffect(() => {\r\n    if (autoFlow && autoStart && koreanText && autoFlowState === 'idle' && !disabled) {\r\n      // 0.5초 딜레이 후 자동 시작\r\n      const startDelay = setTimeout(() => {\r\n        handleAutoFlowStart();\r\n      }, 500);\r\n      \r\n      return () => clearTimeout(startDelay);\r\n    }\r\n  }, [koreanText, autoStart, disabled]);\r\n\r\n  // Cleanup timers\r\n  useEffect(() => {\r\n    return () => {\r\n      if (timerInterval) clearInterval(timerInterval);\r\n      if (autoTimeout) clearTimeout(autoTimeout);\r\n    };\r\n  }, []);\r\n\r\n  const playBeep = useCallback(() => {\r\n    try {\r\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      const oscillator = audioContext.createOscillator();\r\n      const gainNode = audioContext.createGain();\r\n      \r\n      oscillator.connect(gainNode);\r\n      gainNode.connect(audioContext.destination);\r\n      \r\n      oscillator.frequency.setValueAtTime(800, audioContext.currentTime);\r\n      oscillator.type = 'sine';\r\n      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\r\n      \r\n      oscillator.start();\r\n      oscillator.stop(audioContext.currentTime + 0.2);\r\n    } catch (error) {\r\n      console.error('비프음 재생 실패:', error);\r\n    }\r\n  }, []);\r\n\r\n  // Auto-flow start button handler\r\n  const handleAutoFlowStart = async () => {\r\n    if (disabled || !autoFlow || !koreanText) return;\r\n    \r\n    console.log('🎤 자동 Speaking 플로우 시작');\r\n    updateAutoFlowState('tts');\r\n    \r\n    try {\r\n      // 1. 한국어 TTS 재생\r\n      if (speech.isTTSAvailable) {\r\n        await speech.speak(koreanText, 'ko-KR');\r\n        \r\n        // TTS 완료 후 1초 대기\r\n        setTimeout(() => {\r\n          playBeepAndStartRecording();\r\n        }, 1000);\r\n      } else {\r\n        // TTS가 없으면 2초 대기 후 녹음 시작\r\n        setTimeout(() => {\r\n          playBeepAndStartRecording();\r\n        }, 2000);\r\n      }\r\n    } catch (error) {\r\n      console.error('TTS 재생 실패:', error);\r\n      updateAutoFlowState('idle');\r\n      if (onError) {\r\n        onError('음성 재생에 실패했습니다.');\r\n      }\r\n    }\r\n  };\r\n\r\n  const playBeepAndStartRecording = () => {\r\n    console.log('🔔 비프음 재생 및 녹음 시작');\r\n    updateAutoFlowState('beep');\r\n    \r\n    // 비프음 재생\r\n    playBeep();\r\n    \r\n    // 비프음 후 500ms 대기 후 녹음 시작\r\n    setTimeout(() => {\r\n      startDirectSpeechRecognition();\r\n    }, 500);\r\n  };\r\n\r\n  const startDirectSpeechRecognition = () => {\r\n    console.log('🎤 직접 음성 인식 시작');\r\n    updateAutoFlowState('recording');\r\n    setIsAutoRecording(true);\r\n    \r\n    // 타이머 시작\r\n    setSpeechTimer(0);\r\n    const interval = setInterval(() => {\r\n      setSpeechTimer(prev => prev + 0.1);\r\n    }, 100);\r\n    setTimerInterval(interval);\r\n    \r\n    // Web Speech API 직접 사용\r\n    if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {\r\n      const SpeechRecognition = (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition;\r\n      const recognition = new SpeechRecognition();\r\n      \r\n      recognition.continuous = false;\r\n      recognition.interimResults = false;\r\n      recognition.lang = 'en-US';\r\n      recognition.maxAlternatives = 1;\r\n      \r\n      // phraseHints 활용 (grammar 힌트 제공)\r\n      if (phraseHints.length > 0) {\r\n        console.log('🎯 Speech recognition hints applied:', phraseHints);\r\n        // 실제 구현: 브라우저별로 다른 방식으로 힌트 적용\r\n        if (recognition.grammars) {\r\n          const grammarList = new (window as any).SpeechGrammarList();\r\n          const grammar = `#JSGF V1.0; grammar phrases; public <phrase> = ${phraseHints.join(' | ')};`;\r\n          grammarList.addFromString(grammar, 1);\r\n          recognition.grammars = grammarList;\r\n        }\r\n      }\r\n      \r\n      let isCompleted = false; // 핵심: 중복 처리 방지\r\n      \r\n      recognition.onstart = () => {\r\n        console.log('🎯 음성 인식 시작됨');\r\n      };\r\n      \r\n      recognition.onresult = (event: any) => {\r\n        if (isCompleted) {\r\n          console.log('⚠️ 이미 처리된 결과 - 건너뜀');\r\n          return;\r\n        }\r\n        isCompleted = true;\r\n        \r\n        console.log('🎤 음성 인식 결과 수신:', event);\r\n        \r\n        if (event.results && event.results.length > 0) {\r\n          const transcript = event.results[0][0].transcript;\r\n          const confidence = event.results[0][0].confidence || 0.9;\r\n          \r\n          console.log('🎯 인식된 텍스트:', transcript);\r\n          console.log('🎯 신뢰도:', confidence);\r\n          \r\n          // 즉시 음성 인식 중지를 위해 recognition.stop() 호출\r\n          recognition.stop();\r\n          \r\n          // 타이머 정리\r\n          clearAllTimers();\r\n          \r\n          // 상태 초기화\r\n          updateAutoFlowState('idle');\r\n          setIsAutoRecording(false);\r\n          setSpeechTimer(0);\r\n          \r\n          // 결과 전달 - 즉시 실행\r\n          console.log('🚀 SpeechRecorder: onResult 콜백 호출', { \r\n            transcript: transcript.trim(), \r\n            confidence,\r\n            onResultType: typeof onResult \r\n          });\r\n          \r\n          // setTimeout으로 React 상태 업데이트 후 콜백 실행 보장\r\n          setTimeout(() => {\r\n            console.log('🎯 SpeechRecorder: 콜백 실행');\r\n            onResult(transcript.trim(), confidence);\r\n          }, 0);\r\n        }\r\n      };\r\n      \r\n      recognition.onerror = (event: any) => {\r\n        if (isCompleted) return;\r\n        isCompleted = true;\r\n        \r\n        console.error('😨 음성 인식 오류:', event.error);\r\n        \r\n        clearAllTimers();\r\n        updateAutoFlowState('idle');\r\n        setIsAutoRecording(false);\r\n        setSpeechTimer(0);\r\n        \r\n        if (onError) {\r\n          onError(`음성 인식 오류: ${event.error}`);\r\n        }\r\n      };\r\n      \r\n      recognition.onend = () => {\r\n        console.log('🔊 음성 인식 종료');\r\n        \r\n        // 만약 아직 녹음 상태이고 결과가 없었다면 실패로 처리\r\n        if (!isCompleted && isAutoRecording) {\r\n          console.log('😨 음성 인식 실패 - 결과 없이 종료');\r\n          isCompleted = true;\r\n          \r\n          clearAllTimers();\r\n          updateAutoFlowState('idle');\r\n          setIsAutoRecording(false);\r\n          setSpeechTimer(0);\r\n          \r\n          if (onError) {\r\n            onError('음성을 인식하지 못했습니다. 다시 시도해주세요.');\r\n          }\r\n        }\r\n      };\r\n      \r\n      // 10초 타임아웃 설정\r\n      const timeout = setTimeout(() => {\r\n        if (isCompleted) return;\r\n        isCompleted = true;\r\n        \r\n        console.log('⏰ 10초 타임아웃 - 녹음 중지');\r\n        recognition.stop();\r\n        clearAllTimers();\r\n        updateAutoFlowState('idle');\r\n        setIsAutoRecording(false);\r\n        setSpeechTimer(0);\r\n        \r\n        if (onError) {\r\n          onError('음성 인식 시간이 초과되었습니다. 다시 시도해주세요.');\r\n        }\r\n      }, 10000);\r\n      setAutoTimeout(timeout);\r\n      \r\n      // 음성 인식 시작\r\n      recognition.start();\r\n    } else {\r\n      // Web Speech API가 지원되지 않는 경우\r\n      console.error('😨 Web Speech API가 지원되지 않습니다');\r\n      clearAllTimers();\r\n      updateAutoFlowState('idle');\r\n      setIsAutoRecording(false);\r\n      setSpeechTimer(0);\r\n      \r\n      if (onError) {\r\n        onError('이 브라우저는 음성 인식을 지원하지 않습니다.');\r\n      }\r\n    }\r\n  };\r\n\r\n  const clearAllTimers = () => {\r\n    if (timerInterval) {\r\n      clearInterval(timerInterval);\r\n      setTimerInterval(null);\r\n    }\r\n    if (autoTimeout) {\r\n      clearTimeout(autoTimeout);\r\n      setAutoTimeout(null);\r\n    }\r\n  };\r\n\r\n  // 기존 useSpeech 후크 결과 처리는 제거 (직접 Web Speech API 사용으로 대체)\r\n\r\n  // Manual button handlers (for non-auto mode)\r\n  const handleManualStart = useCallback(() => {\r\n    if (disabled) return;\r\n    setIsPressed(true);\r\n    speech.startRecording();\r\n  }, [disabled, speech]);\r\n\r\n  const handleManualStop = useCallback(() => {\r\n    setIsPressed(false);\r\n    speech.stopRecording();\r\n  }, [speech]);\r\n\r\n  // Handle speech results for manual mode\r\n  useEffect(() => {\r\n    if (speech.transcript && !autoFlow && !isAutoRecording) {\r\n      onResult(speech.transcript, speech.confidence);\r\n    }\r\n  }, [speech.transcript, autoFlow, isAutoRecording]);\r\n\r\n  // Error handling\r\n  useEffect(() => {\r\n    if (speech.error && onError) {\r\n      onError(speech.error);\r\n    }\r\n  }, [speech.error, onError]);\r\n\r\n  if (autoFlow) {\r\n    return (\r\n      <div className={`text-center ${className}`}>\r\n        {/* Auto-flow status display */}\r\n        {autoFlowState !== 'idle' && (\r\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-6 mb-6\">\r\n            <div className=\"text-center\">\r\n              <div className=\"text-lg font-semibold text-blue-800 mb-4\">\r\n                {autoFlowState === 'tts' && '🔊 문제를 들려드리고 있습니다...'}\r\n                {autoFlowState === 'beep' && '🔔 곧 녹음이 시작됩니다...'}\r\n                {autoFlowState === 'recording' && `🎤 말씀해 주세요... (${speechTimer.toFixed(1)}초)`}\r\n              </div>\r\n              \r\n              {autoFlowState === 'recording' && (\r\n                <>\r\n                  {/* 진행 바 */}\r\n                  <div className=\"w-full bg-blue-200 rounded-full h-2 mb-4\">\r\n                    <div \r\n                      className=\"bg-blue-600 h-2 rounded-full transition-all duration-100\"\r\n                      style={{ width: `${Math.min((speechTimer / 10) * 100, 100)}%` }}\r\n                    />\r\n                  </div>\r\n                  \r\n                  {/* 녹음 표시기 */}\r\n                  <div className=\"flex items-center justify-center space-x-3\">\r\n                    <div className=\"w-3 h-3 bg-red-500 rounded-full animate-pulse\"></div>\r\n                    <span className=\"text-sm text-blue-700\">\r\n                      음성을 인식하고 있습니다... ({speechTimer.toFixed(1)}초 / 10초)\r\n                    </span>\r\n                  </div>\r\n                </>\r\n              )}\r\n              \r\n              {autoFlowState === 'tts' && (\r\n                <div className=\"flex items-center justify-center space-x-3\">\r\n                  <div className=\"w-3 h-3 bg-green-500 rounded-full animate-pulse\"></div>\r\n                  <span className=\"text-sm text-blue-700\">한국어 문제를 재생 중...</span>\r\n                </div>\r\n              )}\r\n              \r\n              {autoFlowState === 'beep' && (\r\n                <div className=\"flex items-center justify-center space-x-3\">\r\n                  <div className=\"w-3 h-3 bg-yellow-500 rounded-full animate-pulse\"></div>\r\n                  <span className=\"text-sm text-blue-700\">신호음 후 말씀해 주세요</span>\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* Manual start button for auto-flow mode */}\r\n        {autoFlowState === 'idle' && !autoStart && (\r\n          <button\r\n            onClick={handleAutoFlowStart}\r\n            disabled={disabled}\r\n            className=\"min-h-[60px] min-w-[60px] px-8 py-4 bg-blue-600 text-white font-bold rounded-lg hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition-colors text-lg touch-manipulation\"\r\n            aria-label={autoFlowState === 'idle' ? '음성 녹음 세션 시작하기' : '녹음 진행 중'}\r\n            aria-pressed={autoFlowState !== 'idle'}\r\n            aria-describedby=\"recording-instructions\"\r\n            role=\"button\"\r\n          >\r\n            🎤 시작하기\r\n          </button>\r\n        )}\r\n        \r\n        {/* Screen reader instructions */}\r\n        <div id=\"recording-instructions\" className=\"sr-only\">\r\n          이 버튼을 누르면 자동 음성 녹음이 시작됩니다. 한국어 텍스트가 재생된 후 영어로 말씀해 주세요.\r\n        </div>\r\n        \r\n        {/* Live status updates for screen readers */}\r\n        <div aria-live=\"polite\" aria-atomic=\"true\" className=\"sr-only\">\r\n          {autoFlowState === 'tts' && '한국어 오디오를 재생하고 있습니다...'}\r\n          {autoFlowState === 'beep' && '신호음 후 녹음이 시작됩니다...'}\r\n          {autoFlowState === 'recording' && `녹음 진행 중입니다. ${speechTimer.toFixed(1)}초가 경과되었습니다.`}\r\n        </div>\r\n        \r\n        {/* 녹음 중지 버튼 */}\r\n        {autoFlowState === 'recording' && (\r\n          <button\r\n            onClick={() => {\r\n              clearAllTimers();\r\n              updateAutoFlowState('idle');\r\n              setIsAutoRecording(false);\r\n              setSpeechTimer(0);\r\n              if (onError) {\r\n                onError('사용자가 녹음을 중지했습니다.');\r\n              }\r\n            }}\r\n            className=\"min-h-[44px] min-w-[44px] px-6 py-3 bg-red-600 text-white font-bold rounded-lg hover:bg-red-700 transition-colors touch-manipulation\"\r\n            aria-label=\"녹음 중지하기\"\r\n          >\r\n            ⏹️ 녹음 중지\r\n          </button>\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Manual mode UI\r\n  return (\r\n    <div className={`text-center ${className}`}>\r\n      <div className=\"mb-4\">\r\n        <button\r\n          onMouseDown={handleManualStart}\r\n          onMouseUp={handleManualStop}\r\n          onTouchStart={handleManualStart}\r\n          onTouchEnd={handleManualStop}\r\n          disabled={disabled}\r\n          className={`min-h-[60px] min-w-[60px] px-8 py-4 font-bold rounded-lg transition-all duration-200 text-lg touch-manipulation ${\r\n            isPressed \r\n              ? 'bg-red-600 text-white transform scale-105' \r\n              : 'bg-blue-600 text-white hover:bg-blue-700'\r\n          } disabled:bg-gray-400 disabled:cursor-not-allowed`}\r\n          aria-label={isPressed ? '녹음 중입니다. 버튼에서 손을 떼면 중지됩니다.' : '눌러서 음성 녹음을 시작하세요'}\r\n          aria-pressed={isPressed}\r\n        >\r\n          {isPressed ? '🔴 녹음 중... (버튼을 떼세요)' : '🎤 눌러서 말하기'}\r\n        </button>\r\n      </div>\r\n\r\n      {speech.isRecording && (\r\n        <div className=\"text-sm text-gray-600\">\r\n          <div className=\"flex items-center justify-center space-x-2 mb-2\">\r\n            <div className=\"w-2 h-2 bg-red-500 rounded-full animate-pulse\"></div>\r\n            <span>음성을 인식하고 있습니다...</span>\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {speech.transcript && (\r\n        <div className=\"mt-4 p-4 bg-green-50 border border-green-200 rounded-lg\">\r\n          <div className=\"text-sm text-green-600 mb-1\">인식된 음성:</div>\r\n          <div className=\"font-medium text-green-800\">\"{speech.transcript}\"</div>\r\n          <div className=\"text-xs text-green-500 mt-1\">\r\n            정확도: {Math.round(speech.confidence * 100)}%\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      <div className=\"mt-4 text-xs text-gray-500\">\r\n        <p>버튼을 누르고 있는 동안 음성이 녹음됩니다</p>\r\n        <p>명확하고 천천히 말해주세요</p>\r\n      </div>\r\n    </div>\r\n  );\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\SpeedModeSession.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\StageFocusSession.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\StageSelectionModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\StageSelector.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useMemo' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":51,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback, useMemo, memo } from 'react';\r\nimport { stageFocusService } from '@/services/stageFocusMode';\r\n\r\ninterface StageSelectorProps {\r\n  level: number;\r\n  onStageSelect: (stage: number) => void;\r\n  onClose: () => void;\r\n}\r\n\r\ninterface StageInfo {\r\n  stage: number;\r\n  title: string;\r\n  difficulty: string;\r\n  questionCount: number;\r\n  completed: boolean;\r\n  lastPracticed?: Date;\r\n}\r\n\r\nexport const StageSelector: React.FC<StageSelectorProps> = memo(({\r\n  level,\r\n  onStageSelect,\r\n  onClose\r\n}) => {\r\n  const [stages, setStages] = useState<StageInfo[]>([]);\r\n  const [loading, setLoading] = useState(true);\r\n  const [selectedStage, setSelectedStage] = useState<number | null>(null);\r\n\r\n  useEffect(() => {\r\n    loadStages();\r\n  }, [level, loadStages]);\r\n\r\n  const loadStages = useCallback(async () => {\r\n    try {\r\n      setLoading(true);\r\n      const response = await stageFocusService.getAvailableStages(level);\r\n      setStages(response.stages);\r\n    } catch (error) {\r\n      console.error('스테이지 로딩 실패:', error);\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [level]);\r\n\r\n  const handleStageClick = useCallback((stage: number) => {\r\n    setSelectedStage(stage);\r\n  }, []);\r\n\r\n  const handleStartPractice = useCallback(() => {\r\n    if (selectedStage) {\r\n      onStageSelect(selectedStage);\r\n    }\r\n  }, [selectedStage, onStageSelect]);\r\n\r\n  const getDifficultyColor = useCallback((difficulty: string) => {\r\n    switch (difficulty) {\r\n      case 'easy': return 'bg-green-100 text-green-800 border-green-200';\r\n      case 'medium': return 'bg-yellow-100 text-yellow-800 border-yellow-200';\r\n      case 'hard': return 'bg-red-100 text-red-800 border-red-200';\r\n      default: return 'bg-gray-100 text-gray-800 border-gray-200';\r\n    }\r\n  }, []);\r\n\r\n  const formatLastPracticed = useCallback((date?: Date) => {\r\n    if (!date) return '미학습';\r\n    \r\n    const now = new Date();\r\n    const diffMs = now.getTime() - date.getTime();\r\n    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\r\n    \r\n    if (diffDays === 0) return '오늘';\r\n    if (diffDays === 1) return '1일 전';\r\n    if (diffDays <= 7) return `${diffDays}일 전`;\r\n    if (diffDays <= 30) return `${Math.floor(diffDays / 7)}주 전`;\r\n    return `${Math.floor(diffDays / 30)}개월 전`;\r\n  }, []);\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n        <div className=\"bg-white rounded-lg p-8 max-w-2xl w-full mx-4\">\r\n          <div className=\"text-center\">\r\n            <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4\"></div>\r\n            <div className=\"text-gray-600\">스테이지를 불러오는 중...</div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n      <div className=\"bg-white rounded-lg max-w-4xl w-full mx-4 max-h-[90vh] overflow-hidden\">\r\n        {/* 헤더 */}\r\n        <div className=\"bg-gradient-to-r from-blue-600 to-purple-600 text-white p-6\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <div>\r\n              <h2 className=\"text-2xl font-bold mb-2\">🎯 Stage 집중 모드</h2>\r\n              <p className=\"text-blue-100\">Level {level} - 원하는 스테이지를 선택하세요</p>\r\n            </div>\r\n            <button\r\n              onClick={onClose}\r\n              className=\"text-white hover:text-gray-200 transition-colors\"\r\n            >\r\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\r\n              </svg>\r\n            </button>\r\n          </div>\r\n        </div>\r\n\r\n        {/* 스테이지 목록 */}\r\n        <div className=\"p-6 overflow-y-auto\" style={{ maxHeight: 'calc(90vh - 200px)' }}>\r\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\r\n            {stages.map((stage) => (\r\n              <div\r\n                key={stage.stage}\r\n                onClick={() => handleStageClick(stage.stage)}\r\n                className={`cursor-pointer rounded-lg border-2 p-4 transition-all duration-200 hover:shadow-md ${\r\n                  selectedStage === stage.stage\r\n                    ? 'border-blue-500 bg-blue-50'\r\n                    : 'border-gray-200 hover:border-gray-300'\r\n                }`}\r\n              >\r\n                {/* 스테이지 헤더 */}\r\n                <div className=\"flex items-center justify-between mb-3\">\r\n                  <div className=\"flex items-center gap-2\">\r\n                    <span className=\"text-lg font-bold text-gray-800\">\r\n                      Stage {stage.stage}\r\n                    </span>\r\n                    {stage.completed && (\r\n                      <span className=\"text-green-500\">\r\n                        <svg className=\"w-5 h-5\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\r\n                          <path fillRule=\"evenodd\" d=\"M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z\" clipRule=\"evenodd\" />\r\n                        </svg>\r\n                      </span>\r\n                    )}\r\n                  </div>\r\n                  <span className={`text-xs px-2 py-1 rounded border ${getDifficultyColor(stage.difficulty)}`}>\r\n                    {stage.difficulty}\r\n                  </span>\r\n                </div>\r\n\r\n                {/* 스테이지 정보 */}\r\n                <h3 className=\"font-medium text-gray-900 mb-2 text-sm\">\r\n                  {stage.title}\r\n                </h3>\r\n\r\n                {/* 상태 정보 */}\r\n                <div className=\"space-y-1 text-xs text-gray-600\">\r\n                  <div className=\"flex justify-between\">\r\n                    <span>문장 수:</span>\r\n                    <span className=\"font-medium\">{stage.questionCount}개</span>\r\n                  </div>\r\n                  <div className=\"flex justify-between\">\r\n                    <span>마지막 학습:</span>\r\n                    <span className=\"font-medium\">{formatLastPracticed(stage.lastPracticed)}</span>\r\n                  </div>\r\n                </div>\r\n\r\n                {/* 선택 표시 */}\r\n                {selectedStage === stage.stage && (\r\n                  <div className=\"mt-3 text-center\">\r\n                    <span className=\"text-blue-600 font-medium text-sm\">✓ 선택됨</span>\r\n                  </div>\r\n                )}\r\n              </div>\r\n            ))}\r\n          </div>\r\n        </div>\r\n\r\n        {/* 하단 액션 */}\r\n        <div className=\"bg-gray-50 px-6 py-4 flex justify-between\">\r\n          <button\r\n            onClick={onClose}\r\n            className=\"px-6 py-2 text-gray-600 hover:text-gray-800 transition-colors\"\r\n          >\r\n            취소\r\n          </button>\r\n          \r\n          <div className=\"flex gap-3\">\r\n            <div className=\"text-sm text-gray-600 flex items-center\">\r\n              {selectedStage ? (\r\n                <>\r\n                  <span className=\"text-blue-600 font-medium\">Stage {selectedStage}</span>\r\n                  <span className=\"ml-2\">선택됨</span>\r\n                </>\r\n              ) : (\r\n                '스테이지를 선택해주세요'\r\n              )}\r\n            </div>\r\n            \r\n            <button\r\n              onClick={handleStartPractice}\r\n              disabled={!selectedStage}\r\n              className=\"bg-blue-600 hover:bg-blue-700 disabled:bg-gray-400 text-white px-6 py-2 rounded-lg transition-colors font-medium\"\r\n            >\r\n              집중 연습 시작\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\StatisticsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\TrainingHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\UserProfile.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AuthModal' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useCallback, useMemo, memo } from 'react';\r\nimport { useAuth } from '../hooks/useAuth';\r\nimport AuthModal from './AuthModal';\r\n\r\nexport const UserProfile: React.FC = memo(() => {\r\n  const { user, userProgress, logout, isLoading, isAuthenticated, isAnonymous } = useAuth();\r\n  const [showDropdown, setShowDropdown] = useState(false);\r\n\r\n  const handleLogout = useCallback(async () => {\r\n    try {\r\n      await logout();\r\n      setShowDropdown(false);\r\n    } catch (error) {\r\n      console.error('로그아웃 실패:', error);\r\n    }\r\n  }, [logout]);\r\n\r\n  // All hooks must be called before any conditional returns\r\n  const displayName = useMemo(() => {\r\n    if (user?.displayName) return user.displayName;\r\n    if (user?.email) return user.email.split('@')[0];\r\n    if (isAnonymous) return '익명 사용자';\r\n    return '사용자';\r\n  }, [user?.displayName, user?.email, isAnonymous]);\r\n\r\n  const levelProgress = useMemo(() => {\r\n    if (!userProgress) return 0;\r\n    const currentLevelExp = userProgress.exp % 100;\r\n    return currentLevelExp;\r\n  }, [userProgress]);\r\n\r\n  // Conditional renders after all hooks\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"flex items-center space-x-2\">\r\n        <div className=\"w-8 h-8 bg-gray-200 rounded-full animate-pulse\"></div>\r\n        <div className=\"w-16 h-4 bg-gray-200 rounded animate-pulse\"></div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!isAuthenticated) {\r\n    return (\r\n      <div className=\"flex items-center space-x-2 text-gray-500\">\r\n        <div className=\"w-8 h-8 bg-gray-300 rounded-full flex items-center justify-center\">\r\n          <span className=\"text-xs\">👤</span>\r\n        </div>\r\n        <span className=\"text-sm\">체험 모드</span>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"relative\">\r\n      <button\r\n        onClick={() => setShowDropdown(!showDropdown)}\r\n        className=\"flex items-center space-x-3 px-3 py-2 rounded-lg hover:bg-gray-100 transition-colors\"\r\n      >\r\n        <div className=\"w-10 h-10 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center text-white font-bold\">\r\n          {displayName.charAt(0).toUpperCase()}\r\n        </div>\r\n        \r\n        <div className=\"text-left\">\r\n          <div className=\"text-sm font-medium text-gray-900\">\r\n            {displayName}\r\n            {isAnonymous && <span className=\"text-xs text-gray-500 ml-1\">(체험)</span>}\r\n          </div>\r\n          <div className=\"text-xs text-gray-600\">\r\n            Level {userProgress?.level || 1} • Stage {userProgress?.stage || 1}\r\n          </div>\r\n        </div>\r\n        \r\n        <svg className={`w-4 h-4 text-gray-500 transform transition-transform ${showDropdown ? 'rotate-180' : ''}`} fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M19 9l-7 7-7-7\" />\r\n        </svg>\r\n      </button>\r\n\r\n      {showDropdown && (\r\n        <div className=\"absolute right-0 mt-2 w-80 bg-white rounded-lg shadow-lg border z-50\">\r\n          <div className=\"p-4 border-b\">\r\n            <div className=\"flex items-center space-x-3 mb-3\">\r\n              <div className=\"w-12 h-12 bg-gradient-to-br from-blue-500 to-purple-600 rounded-full flex items-center justify-center text-white font-bold text-lg\">\r\n                {displayName.charAt(0).toUpperCase()}\r\n              </div>\r\n              <div>\r\n                <div className=\"font-medium text-gray-900\">{displayName}</div>\r\n                <div className=\"text-sm text-gray-600\">{user?.email}</div>\r\n                {isAnonymous && (\r\n                  <div className=\"text-xs text-orange-600\">체험 계정 (데이터가 저장되지 않을 수 있습니다)</div>\r\n                )}\r\n              </div>\r\n            </div>\r\n\r\n            {userProgress && (\r\n              <div className=\"space-y-3\">\r\n                <div className=\"grid grid-cols-3 gap-3 text-center\">\r\n                  <div className=\"bg-blue-50 p-2 rounded\">\r\n                    <div className=\"text-lg font-bold text-blue-600\">{userProgress.level}</div>\r\n                    <div className=\"text-xs text-blue-500\">Level</div>\r\n                  </div>\r\n                  <div className=\"bg-green-50 p-2 rounded\">\r\n                    <div className=\"text-lg font-bold text-green-600\">{userProgress.exp}</div>\r\n                    <div className=\"text-xs text-green-500\">EXP</div>\r\n                  </div>\r\n                  <div className=\"bg-orange-50 p-2 rounded\">\r\n                    <div className=\"text-lg font-bold text-orange-600\">{userProgress.streak}</div>\r\n                    <div className=\"text-xs text-orange-500\">연속</div>\r\n                  </div>\r\n                </div>\r\n\r\n                <div>\r\n                  <div className=\"flex justify-between text-sm mb-1\">\r\n                    <span>다음 레벨까지</span>\r\n                    <span>{levelProgress}/100 EXP</span>\r\n                  </div>\r\n                  <div className=\"w-full bg-gray-200 rounded-full h-2\">\r\n                    <div \r\n                      className=\"bg-blue-500 h-2 rounded-full transition-all duration-300\"\r\n                      style={{ width: `${levelProgress}%` }}\r\n                    />\r\n                  </div>\r\n                </div>\r\n\r\n                <div className=\"text-xs text-gray-500 space-y-1\">\r\n                  <div>총 학습 세션: {userProgress.totalSessions}회</div>\r\n                  {userProgress.lastStudyDate && (\r\n                    <div>마지막 학습: {new Date(userProgress.lastStudyDate).toLocaleDateString()}</div>\r\n                  )}\r\n                </div>\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          <div className=\"p-2\">\r\n            {isAnonymous && (\r\n              <div className=\"px-3 py-2 text-xs text-orange-600 bg-orange-50 rounded-md mb-2\">\r\n                💡 계정을 생성하면 진행도가 영구적으로 저장됩니다.\r\n              </div>\r\n            )}\r\n            \r\n            <button\r\n              onClick={handleLogout}\r\n              className=\"w-full text-left px-3 py-2 text-sm text-red-600 hover:bg-red-50 rounded-md\"\r\n            >\r\n              🚪 로그아웃\r\n            </button>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});\r\n\r\nexport default UserProfile;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\VoiceControls.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\VoiceGuidanceSettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\WordBank.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\WritingModeFeedback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\WritingModeInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\srs\\MemoryStrengthChart.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\srs\\ReviewDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\srs\\ReviewSessionCard.tsx","messages":[{"ruleId":"no-undef","severity":1,"message":"'results' is not defined.","line":110,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":110,"endColumn":37},{"ruleId":"no-undef","severity":1,"message":"'results' is not defined.","line":111,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":111,"endColumn":49},{"ruleId":"no-undef","severity":1,"message":"'results' is not defined.","line":112,"column":37,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":44},{"ruleId":"no-undef","severity":1,"message":"'results' is not defined.","line":112,"column":91,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":98},{"ruleId":"no-undef","severity":1,"message":"'results' is not defined.","line":118,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":118,"endColumn":33},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'results'. Either exclude it or remove the dependency array. Outer scope values like 'results' aren't valid dependencies because mutating them doesn't re-render the component.","line":124,"column":6,"nodeType":"ArrayExpression","endLine":124,"endColumn":116,"suggestions":[{"desc":"Update the dependencies array to be: [currentCard, userAnswer, questionStartTime, currentIndex, cards.length, srsEngine, sessionStartTime]","fix":{"range":[3797,3907],"text":"[currentCard, userAnswer, questionStartTime, currentIndex, cards.length, srsEngine, sessionStartTime]"}}]},{"ruleId":"no-undef","severity":1,"message":"'results' is not defined.","line":124,"column":108,"nodeType":"Identifier","messageId":"undef","endLine":124,"endColumn":115}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Review Session Card Component\r\n * \r\n * 기능:\r\n * - 복습 세션 진행 UI\r\n * - 카드별 복습 인터페이스\r\n * - 실시간 기억 강도 업데이트\r\n * - 세션 완료 처리\r\n */\r\n\r\nimport React, { useState, useCallback, useEffect } from 'react';\r\nimport { ReviewCard } from '@/services/srs/SRSEngine';\r\nimport { useSRSEngine } from '@/hooks/useSRSEngine';\r\n\r\nexport interface ReviewSessionCardProps {\r\n  userId: string;\r\n  cards: ReviewCard[];\r\n  onComplete: (results: Array<{ cardId: string; isCorrect: boolean; responseTime: number; confidence: number }>) => void;\r\n  onCancel: () => void;\r\n  className?: string;\r\n}\r\n\r\ntype SessionPhase = 'ready' | 'reviewing' | 'feedback' | 'completed';\r\n\r\nexport const ReviewSessionCard: React.FC<ReviewSessionCardProps> = ({\r\n  userId,\r\n  cards,\r\n  onComplete,\r\n  onCancel,\r\n  className = ''\r\n}) => {\r\n  const srsEngine = useSRSEngine({ userId });\r\n  \r\n  // 세션 상태\r\n  const [phase, setPhase] = useState<SessionPhase>('ready');\r\n  const [currentIndex, setCurrentIndex] = useState(0);\r\n  const [userAnswer, setUserAnswer] = useState('');\r\n  const [sessionResults, setSessionResults] = useState<Array<{\r\n    cardId: string;\r\n    isCorrect: boolean;\r\n    responseTime: number;\r\n    confidence: number;\r\n    userAnswer: string;\r\n    correctAnswer: string;\r\n  }>>([]);\r\n  \r\n  // 타이밍 관련\r\n  const [questionStartTime, setQuestionStartTime] = useState<number>(0);\r\n  const [sessionStartTime, setSessionStartTime] = useState<number>(0);\r\n\r\n  // 현재 카드\r\n  const currentCard = cards[currentIndex];\r\n  \r\n  // 진행률\r\n  const progress = ((currentIndex + (phase === 'completed' ? 1 : 0)) / cards.length) * 100;\r\n\r\n  // 세션 시작\r\n  const startSession = useCallback(() => {\r\n    setPhase('reviewing');\r\n    setSessionStartTime(Date.now());\r\n    setQuestionStartTime(Date.now());\r\n  }, []);\r\n\r\n  // 답변 제출\r\n  const submitAnswer = useCallback(() => {\r\n    if (!currentCard || userAnswer.trim() === '') return;\r\n\r\n    const responseTime = Date.now() - questionStartTime;\r\n    const isCorrect = userAnswer.trim().toLowerCase() === currentCard.content.english.trim().toLowerCase();\r\n    \r\n    // 사용자에게 신뢰도 확인 (간단한 구현)\r\n    const confidence = isCorrect ? 0.8 : 0.3;\r\n\r\n    // 결과 기록\r\n    const result = {\r\n      cardId: currentCard.id,\r\n      isCorrect,\r\n      responseTime,\r\n      confidence,\r\n      userAnswer: userAnswer.trim(),\r\n      correctAnswer: currentCard.content.english\r\n    };\r\n\r\n    setSessionResults(prev => [...prev, result]);\r\n\r\n    // 즉시 SRS 엔진에 반영\r\n    srsEngine.processReviewSession(currentCard.id, {\r\n      cardId: currentCard.id,\r\n      userAnswer: userAnswer.trim(),\r\n      correctAnswer: currentCard.content.english,\r\n      isCorrect,\r\n      responseTime,\r\n      difficulty: responseTime > 10000 ? 'hard' : responseTime > 5000 ? 'medium' : 'easy',\r\n      confidence\r\n    });\r\n\r\n    setPhase('feedback');\r\n\r\n    // 피드백 표시 후 다음 카드 또는 완료\r\n    setTimeout(() => {\r\n      if (currentIndex + 1 < cards.length) {\r\n        // 다음 카드로\r\n        setCurrentIndex(prev => prev + 1);\r\n        setUserAnswer('');\r\n        setPhase('reviewing');\r\n        setQuestionStartTime(Date.now());\r\n      } else {\r\n        // 세션 완료 - sessionStartTime 활용한 통계 생성\r\n        const totalSessionTime = Date.now() - sessionStartTime;\r\n        const correctCount = results.filter(r => r.isCorrect).length;\r\n        const accuracy = (correctCount / results.length) * 100;\r\n        const averageResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;\r\n        \r\n        console.log('🎯 SRS Session completed:', {\r\n          totalTime: `${Math.round(totalSessionTime / 1000)}s`,\r\n          accuracy: `${accuracy.toFixed(1)}%`,\r\n          avgResponseTime: `${Math.round(averageResponseTime / 1000)}s`,\r\n          cardsReviewed: results.length\r\n        });\r\n        \r\n        setPhase('completed');\r\n      }\r\n    }, 2000);\r\n  }, [currentCard, userAnswer, questionStartTime, currentIndex, cards.length, srsEngine, sessionStartTime, results]);\r\n\r\n  // 건너뛰기\r\n  const skipCard = useCallback(() => {\r\n    if (!currentCard) return;\r\n\r\n    const responseTime = Date.now() - questionStartTime;\r\n    const result = {\r\n      cardId: currentCard.id,\r\n      isCorrect: false,\r\n      responseTime,\r\n      confidence: 0.1,\r\n      userAnswer: '(건너뜀)',\r\n      correctAnswer: currentCard.content.english\r\n    };\r\n\r\n    setSessionResults(prev => [...prev, result]);\r\n\r\n    // SRS 엔진에 반영\r\n    srsEngine.processReviewSession(currentCard.id, {\r\n      cardId: currentCard.id,\r\n      userAnswer: '',\r\n      correctAnswer: currentCard.content.english,\r\n      isCorrect: false,\r\n      responseTime,\r\n      difficulty: 'hard',\r\n      confidence: 0.1\r\n    });\r\n\r\n    if (currentIndex + 1 < cards.length) {\r\n      setCurrentIndex(prev => prev + 1);\r\n      setUserAnswer('');\r\n      setQuestionStartTime(Date.now());\r\n    } else {\r\n      setPhase('completed');\r\n    }\r\n  }, [currentCard, questionStartTime, currentIndex, cards.length, srsEngine]);\r\n\r\n  // 세션 완료 처리\r\n  const handleComplete = useCallback(() => {\r\n    const finalResults = sessionResults.map(result => ({\r\n      cardId: result.cardId,\r\n      isCorrect: result.isCorrect,\r\n      responseTime: result.responseTime,\r\n      confidence: result.confidence\r\n    }));\r\n\r\n    onComplete(finalResults);\r\n  }, [sessionResults, onComplete]);\r\n\r\n  // 키보드 이벤트 처리\r\n  useEffect(() => {\r\n    const handleKeyPress = (event: KeyboardEvent) => {\r\n      if (phase === 'reviewing' && event.key === 'Enter' && userAnswer.trim() !== '') {\r\n        submitAnswer();\r\n      } else if (phase === 'reviewing' && event.key === 'Escape') {\r\n        skipCard();\r\n      }\r\n    };\r\n\r\n    window.addEventListener('keydown', handleKeyPress);\r\n    return () => window.removeEventListener('keydown', handleKeyPress);\r\n  }, [phase, userAnswer, submitAnswer, skipCard]);\r\n\r\n  // 세션 통계 계산\r\n  const sessionStats = {\r\n    correct: sessionResults.filter(r => r.isCorrect).length,\r\n    total: sessionResults.length,\r\n    averageTime: sessionResults.length > 0 ? \r\n      sessionResults.reduce((sum, r) => sum + r.responseTime, 0) / sessionResults.length : 0,\r\n    accuracy: sessionResults.length > 0 ? \r\n      sessionResults.filter(r => r.isCorrect).length / sessionResults.length : 0\r\n  };\r\n\r\n  if (cards.length === 0) {\r\n    return (\r\n      <div className={`bg-white rounded-xl shadow-lg p-6 text-center ${className}`}>\r\n        <h2 className=\"text-xl font-bold text-gray-800 mb-4\">복습할 카드가 없습니다</h2>\r\n        <p className=\"text-gray-600 mb-6\">새로운 카드를 추가하거나 나중에 다시 시도해보세요.</p>\r\n        <button\r\n          onClick={onCancel}\r\n          className=\"px-6 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors\"\r\n        >\r\n          돌아가기\r\n        </button>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className={`bg-white rounded-xl shadow-lg p-6 ${className}`}>\r\n      {/* 헤더 */}\r\n      <div className=\"mb-6\">\r\n        <div className=\"flex items-center justify-between mb-2\">\r\n          <h2 className=\"text-xl font-bold text-gray-800\">복습 세션</h2>\r\n          <button\r\n            onClick={onCancel}\r\n            className=\"text-gray-500 hover:text-gray-700\"\r\n            title=\"세션 종료\"\r\n          >\r\n            ✕\r\n          </button>\r\n        </div>\r\n        \r\n        {/* 진행률 */}\r\n        <div className=\"w-full bg-gray-200 rounded-full h-2 mb-2\">\r\n          <div \r\n            className=\"bg-blue-600 h-2 rounded-full transition-all duration-300\"\r\n            style={{ width: `${progress}%` }}\r\n          ></div>\r\n        </div>\r\n        \r\n        <div className=\"flex items-center justify-between text-sm text-gray-600\">\r\n          <span>{currentIndex + 1} / {cards.length}</span>\r\n          <span>{sessionStats.total > 0 && `정답률: ${(sessionStats.accuracy * 100).toFixed(0)}%`}</span>\r\n        </div>\r\n      </div>\r\n\r\n      {/* 세션 시작 화면 */}\r\n      {phase === 'ready' && (\r\n        <div className=\"text-center py-8\">\r\n          <h3 className=\"text-lg font-semibold text-gray-800 mb-4\">복습 세션을 시작하시겠습니까?</h3>\r\n          <p className=\"text-gray-600 mb-6\">총 {cards.length}개의 카드를 복습합니다.</p>\r\n          <div className=\"flex items-center justify-center space-x-4\">\r\n            <button\r\n              onClick={startSession}\r\n              className=\"px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors\"\r\n            >\r\n              시작하기\r\n            </button>\r\n            <button\r\n              onClick={onCancel}\r\n              className=\"px-6 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors\"\r\n            >\r\n              취소\r\n            </button>\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {/* 복습 진행 화면 */}\r\n      {phase === 'reviewing' && currentCard && (\r\n        <div className=\"space-y-6\">\r\n          {/* 문제 카드 */}\r\n          <div className=\"bg-blue-50 rounded-lg p-6 border border-blue-100 text-center\">\r\n            <h3 className=\"text-2xl font-bold text-blue-900 mb-2\">{currentCard.content.korean}</h3>\r\n            {currentCard.content.pattern && (\r\n              <p className=\"text-sm text-blue-600\">패턴: {currentCard.content.pattern}</p>\r\n            )}\r\n          </div>\r\n\r\n          {/* 답변 입력 */}\r\n          <div className=\"space-y-4\">\r\n            <label className=\"block text-sm font-medium text-gray-700\">\r\n              영어로 번역하세요:\r\n            </label>\r\n            <input\r\n              type=\"text\"\r\n              value={userAnswer}\r\n              onChange={(e) => setUserAnswer(e.target.value)}\r\n              onKeyDown={(e) => e.key === 'Enter' && userAnswer.trim() && submitAnswer()}\r\n              placeholder=\"영어 번역을 입력하세요...\"\r\n              className=\"w-full px-4 py-3 text-lg border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent\"\r\n              autoFocus\r\n            />\r\n          </div>\r\n\r\n          {/* 컨트롤 버튼 */}\r\n          <div className=\"flex items-center justify-between\">\r\n            <button\r\n              onClick={skipCard}\r\n              className=\"px-4 py-2 text-gray-600 hover:text-gray-800 underline\"\r\n            >\r\n              건너뛰기 (ESC)\r\n            </button>\r\n            <button\r\n              onClick={submitAnswer}\r\n              disabled={userAnswer.trim() === ''}\r\n              className=\"px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed transition-colors\"\r\n            >\r\n              제출 (Enter)\r\n            </button>\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {/* 피드백 화면 */}\r\n      {phase === 'feedback' && currentCard && (\r\n        <div className=\"space-y-6 text-center\">\r\n          {/* 정답/오답 표시 */}\r\n          <div className={`rounded-lg p-6 border ${\r\n            sessionResults[sessionResults.length - 1]?.isCorrect\r\n              ? 'bg-green-50 border-green-100'\r\n              : 'bg-red-50 border-red-100'\r\n          }`}>\r\n            <div className={`text-6xl mb-4 ${\r\n              sessionResults[sessionResults.length - 1]?.isCorrect ? 'text-green-600' : 'text-red-600'\r\n            }`}>\r\n              {sessionResults[sessionResults.length - 1]?.isCorrect ? '✅' : '❌'}\r\n            </div>\r\n            \r\n            <h3 className={`text-xl font-bold mb-2 ${\r\n              sessionResults[sessionResults.length - 1]?.isCorrect ? 'text-green-800' : 'text-red-800'\r\n            }`}>\r\n              {sessionResults[sessionResults.length - 1]?.isCorrect ? '정답!' : '틀렸습니다'}\r\n            </h3>\r\n\r\n            <div className=\"space-y-2 text-lg\">\r\n              <p><strong>정답:</strong> {currentCard.content.english}</p>\r\n              {!sessionResults[sessionResults.length - 1]?.isCorrect && (\r\n                <p><strong>입력:</strong> {sessionResults[sessionResults.length - 1]?.userAnswer}</p>\r\n              )}\r\n            </div>\r\n          </div>\r\n\r\n          {/* 기억 강도 업데이트 정보 */}\r\n          <div className=\"bg-gray-50 rounded-lg p-4\">\r\n            <p className=\"text-sm text-gray-600\">\r\n              기억 강도가 업데이트되었습니다: {(currentCard.memory.strength * 100).toFixed(0)}% \r\n              {sessionResults[sessionResults.length - 1]?.isCorrect ? ' ↗️' : ' ↘️'}\r\n            </p>\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {/* 완료 화면 */}\r\n      {phase === 'completed' && (\r\n        <div className=\"text-center py-8\">\r\n          <div className=\"text-6xl mb-4\">🎉</div>\r\n          <h3 className=\"text-2xl font-bold text-gray-800 mb-4\">복습 완료!</h3>\r\n          \r\n          {/* 세션 통계 */}\r\n          <div className=\"bg-gray-50 rounded-lg p-6 mb-6\">\r\n            <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 text-center\">\r\n              <div>\r\n                <p className=\"text-2xl font-bold text-green-600\">{sessionStats.correct}</p>\r\n                <p className=\"text-sm text-gray-600\">정답</p>\r\n              </div>\r\n              <div>\r\n                <p className=\"text-2xl font-bold text-red-600\">{sessionStats.total - sessionStats.correct}</p>\r\n                <p className=\"text-sm text-gray-600\">오답</p>\r\n              </div>\r\n              <div>\r\n                <p className=\"text-2xl font-bold text-blue-600\">{(sessionStats.accuracy * 100).toFixed(0)}%</p>\r\n                <p className=\"text-sm text-gray-600\">정답률</p>\r\n              </div>\r\n              <div>\r\n                <p className=\"text-2xl font-bold text-purple-600\">{(sessionStats.averageTime / 1000).toFixed(1)}s</p>\r\n                <p className=\"text-sm text-gray-600\">평균 시간</p>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          <button\r\n            onClick={handleComplete}\r\n            className=\"px-8 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-lg font-semibold\"\r\n          >\r\n            완료\r\n          </button>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ReviewSessionCard;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ui\\StageGrid.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ui\\StageInfoPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\components\\ui\\ThemeToggle.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\config\\curriculum.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\config\\stageConfig.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\container\\ServiceContainer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\data\\patternData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\factories\\AdapterFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useAccessibility.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useRef' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":50}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'react';\n\n/**\n * 접근성 관련 유틸리티 훅\n * \n * Note: 복잡한 custom hook들은 hooks-in-callback 에러로 인해 제거됨\n * 필요시 별도의 custom hook 파일로 분리하여 구현 필요\n */\nexport const useAccessibility = () => {\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [highContrast, setHighContrast] = useState(false);\n  const [fontSize, setFontSize] = useState('medium');\n\n  // 접근성 설정 감지\n  useEffect(() => {\n    // Reduced motion 감지\n    const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(motionQuery.matches);\n\n    // High contrast 감지\n    const contrastQuery = window.matchMedia('(prefers-contrast: high)');\n    setHighContrast(contrastQuery.matches);\n\n    const handleMotionChange = (e: MediaQueryListEvent) => {\n      setPrefersReducedMotion(e.matches);\n    };\n\n    const handleContrastChange = (e: MediaQueryListEvent) => {\n      setHighContrast(e.matches);\n    };\n\n    if (motionQuery.addEventListener) {\n      motionQuery.addEventListener('change', handleMotionChange);\n      contrastQuery.addEventListener('change', handleContrastChange);\n      \n      return () => {\n        motionQuery.removeEventListener('change', handleMotionChange);\n        contrastQuery.removeEventListener('change', handleContrastChange);\n      };\n    }\n  }, []);\n\n  /**\n   * ARIA 레이블 생성 헬퍼\n   */\n  const createAriaLabel = useCallback((\n    label: string, \n    description?: string\n  ): { 'aria-label': string; 'aria-describedby'?: string } => {\n    const result: { 'aria-label': string; 'aria-describedby'?: string } = {\n      'aria-label': label\n    };\n\n    if (description) {\n      const descriptionId = `desc-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n      result['aria-describedby'] = descriptionId;\n    }\n\n    return result;\n  }, []);\n\n  /**\n   * 포커스 관리 유틸리티\n   */\n  const focusElement = useCallback((element: HTMLElement | null) => {\n    if (element && element.focus) {\n      element.focus();\n    }\n  }, []);\n\n  /**\n   * 키보드 네비게이션 헬퍼\n   */\n  const isNavigationKey = useCallback((key: string): boolean => {\n    return ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Tab', 'Enter', 'Space', 'Escape'].includes(key);\n  }, []);\n\n  return {\n    // 접근성 상태\n    prefersReducedMotion,\n    highContrast,\n    fontSize,\n    \n    // 유틸리티 함수\n    createAriaLabel,\n    focusElement,\n    isNavigationKey,\n    \n    // 설정 변경\n    setFontSize\n  };\n};\n\nexport default useAccessibility;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useAnimations.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'animationTimeouts.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'animationTimeouts.current' to a variable inside the effect, and use that variable in the cleanup function.","line":33,"column":25,"nodeType":"Identifier","endLine":33,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState, useCallback, useRef } from 'react';\n\n/**\n * 종합 애니메이션 유틸리티 훅\n * 애니메이션 관련 기능들을 통합 제공\n * \n * Note: 복잡한 custom hook들은 hooks-in-callback 에러로 인해 제거됨\n * 필요시 별도의 custom hook 파일로 분리하여 구현 필요\n */\nexport const useAnimations = () => {\n  const animationTimeouts = useRef<Set<NodeJS.Timeout>>(new Set());\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n\n  // Reduced motion 감지\n  useEffect(() => {\n    const mediaQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    setPrefersReducedMotion(mediaQuery.matches);\n\n    const handleChange = (e: MediaQueryListEvent) => {\n      setPrefersReducedMotion(e.matches);\n    };\n\n    if (mediaQuery.addEventListener) {\n      mediaQuery.addEventListener('change', handleChange);\n      return () => mediaQuery.removeEventListener('change', handleChange);\n    }\n  }, []);\n\n  // 컴포넌트 언마운트 시 모든 애니메이션 타이머 정리\n  useEffect(() => {\n    return () => {\n      animationTimeouts.current.forEach(clearTimeout);\n      animationTimeouts.current.clear();\n    };\n  }, []);\n\n  /**\n   * 기본 애니메이션 클래스 생성\n   */\n  const getAnimationClasses = useCallback((animationClass: string, fallbackClass = '') => {\n    return prefersReducedMotion ? fallbackClass : animationClass;\n  }, [prefersReducedMotion]);\n\n  /**\n   * 애니메이션 클래스 헬퍼\n   */\n  const getFadeInClasses = useCallback((isVisible: boolean) => {\n    return getAnimationClasses(\n      isVisible ? 'opacity-100 transition-opacity duration-300' : 'opacity-0',\n      'opacity-100'\n    );\n  }, [getAnimationClasses]);\n\n  return {\n    // 상태\n    prefersReducedMotion,\n    \n    // 유틸리티\n    getAnimationClasses,\n    getFadeInClasses,\n    \n    // 애니메이션 타이머 관리\n    animationTimeouts: animationTimeouts.current\n  };\n};\n\nexport default useAnimations;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useAnswerEvaluation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useAsyncStatus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useAudioFlowController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useAudioManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'VoiceSettings' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * useAudioManager - TTS 및 오디오 관리 훅 (플러그인 기반)\r\n * - 플러그인 아키텍처를 통한 TTS 관리\r\n * - 고급 TTS 설정 지원  \r\n * - 자연스러운 음성 출력\r\n * - 개인화된 음성 설정 적용\r\n */\r\n\r\nimport { useCallback, useEffect, useState } from 'react';\r\nimport { useLocalStorage, STORAGE_KEYS, type VoiceSettings } from './useLocalStorage';\r\nimport { getSpeechPlugin, type ISpeechPlugin } from '@/plugins';\r\nimport { NonEmptyString } from '@/types/core';\r\n\r\ninterface UseAudioManagerReturn {\r\n  playKoreanTTS: (text: string) => Promise<void>;\r\n  playEnglishTTS: (text: string) => Promise<void>;\r\n  playBeepSound: (type?: 'start' | 'countdown' | 'recognition') => Promise<void>;\r\n  stopAllAudio: () => void;\r\n  isPlaying: boolean;\r\n}\r\n\r\nexport const useAudioManager = (): UseAudioManagerReturn => {\r\n  const { value: voiceSettings } = useLocalStorage(STORAGE_KEYS.VOICE_SETTINGS);\r\n  const [speechPlugin, setSpeechPlugin] = useState<ISpeechPlugin | null>(null);\r\n  const [isPlayingState, setIsPlayingState] = useState(false);\r\n\r\n  // 플러그인 초기화\r\n  useEffect(() => {\r\n    const initializePlugin = async () => {\r\n      try {\r\n        const plugin = await getSpeechPlugin();\r\n        if (plugin) {\r\n          setSpeechPlugin(plugin);\r\n          console.log('🔊 SpeechPlugin 초기화 완료');\r\n        }\r\n      } catch (error) {\r\n        console.error('❌ SpeechPlugin 초기화 실패:', error);\r\n      }\r\n    };\r\n\r\n    initializePlugin();\r\n  }, []);\r\n\r\n\r\n  /**\r\n   * 한국어 TTS 재생 - 100% 플러그인 기반\r\n   */\r\n  const playKoreanTTS = useCallback(async (text: string): Promise<void> => {\r\n    if (!voiceSettings.koreanEnabled) {\r\n      console.log('🔇 한국어 음성이 비활성화됨');\r\n      return;\r\n    }\r\n\r\n    if (!speechPlugin) {\r\n      console.warn('⚠️ SpeechPlugin 미초기화 - 한국어 TTS 스킵');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // 기존 음성 중단\r\n      speechPlugin.stopAll();\r\n      \r\n      // 플러그인을 통한 TTS 실행\r\n      const result = await speechPlugin.speakText(text as NonEmptyString, {\r\n        language: 'ko-KR' as NonEmptyString,\r\n        rate: voiceSettings.speed,\r\n        volume: voiceSettings.volume,\r\n        pitch: voiceSettings.pitch\r\n      });\r\n\r\n      if (result.isErr) {\r\n        console.error('❌ 한국어 TTS 플러그인 오류:', result.error);\r\n        // 플러그인 실패 시에도 폴백하지 않음 (100% 플러그인 원칙)\r\n        return;\r\n      }\r\n\r\n      console.log('🔊 한국어 TTS 완료 (플러그인)');\r\n    } catch (error) {\r\n      console.error('❌ 한국어 TTS 예외:', error);\r\n    }\r\n  }, [speechPlugin, voiceSettings]);\r\n\r\n  /**\r\n   * 영어 TTS 재생 - 100% 플러그인 기반\r\n   */\r\n  const playEnglishTTS = useCallback(async (text: string): Promise<void> => {\r\n    if (!voiceSettings.englishEnabled) {\r\n      console.log('🔇 영어 음성이 비활성화됨');\r\n      return;\r\n    }\r\n\r\n    if (!speechPlugin) {\r\n      console.warn('⚠️ SpeechPlugin 미초기화 - 영어 TTS 스킵');\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // 기존 음성 중단\r\n      speechPlugin.stopAll();\r\n      \r\n      // 플러그인을 통한 TTS 실행\r\n      const result = await speechPlugin.speakText(text as NonEmptyString, {\r\n        language: 'en-US' as NonEmptyString,\r\n        rate: voiceSettings.speed,\r\n        volume: voiceSettings.volume,\r\n        pitch: voiceSettings.pitch\r\n      });\r\n\r\n      if (result.isErr) {\r\n        console.error('❌ 영어 TTS 플러그인 오류:', result.error);\r\n        // 플러그인 실패 시에도 폴백하지 않음 (100% 플러그인 원칙)\r\n        return;\r\n      }\r\n\r\n      console.log('🔊 영어 TTS 완료 (플러그인)');\r\n    } catch (error) {\r\n      console.error('❌ 영어 TTS 예외:', error);\r\n    }\r\n  }, [speechPlugin, voiceSettings]);\r\n\r\n  /**\r\n   * 모든 음성 재생 중단 - 100% 플러그인 기반\r\n   */\r\n  const stopAllAudio = useCallback((): void => {\r\n    if (!speechPlugin) {\r\n      console.warn('⚠️ SpeechPlugin 미초기화 - 음성 중단 불가');\r\n      return;\r\n    }\r\n\r\n    const result = speechPlugin.stopAll();\r\n    if (result.isErr) {\r\n      console.error('❌ 플러그인 음성 중단 오류:', result.error);\r\n    }\r\n  }, [speechPlugin]);\r\n\r\n  // 음성 재생 상태를 실시간으로 업데이트\r\n  useEffect(() => {\r\n    if (!speechPlugin) return;\r\n    \r\n    const checkPlayingStatus = () => {\r\n      const currentlyPlaying = speechPlugin.isProcessing();\r\n      setIsPlayingState(currentlyPlaying);\r\n    };\r\n    \r\n    // 100ms마다 재생 상태 확인\r\n    const interval = setInterval(checkPlayingStatus, 100);\r\n    return () => clearInterval(interval);\r\n  }, [speechPlugin]);\r\n\r\n  /**\r\n   * 삐소리 재생 함수 - 100% 플러그인 기반\r\n   */\r\n  const playBeepSound = useCallback(async (type: 'start' | 'countdown' | 'recognition' = 'start'): Promise<void> => {\r\n    if (!speechPlugin) {\r\n      console.warn('⚠️ SpeechPlugin 미초기화 - 삐소리 재생 불가');\r\n      return;\r\n    }\r\n\r\n    const frequencies = {\r\n      start: 800,\r\n      countdown: 600,\r\n      recognition: 1000\r\n    };\r\n    \r\n    const result = await speechPlugin.playBeep({\r\n      frequency: frequencies[type],\r\n      duration: 200,\r\n      volume: 0.1\r\n    });\r\n    \r\n    if (result.isErr) {\r\n      console.error('❌ 플러그인 삐소리 재생 오류:', result.error);\r\n    }\r\n  }, [speechPlugin]);\r\n\r\n  return {\r\n    playKoreanTTS,\r\n    playEnglishTTS,\r\n    playBeepSound,\r\n    stopAllAudio,\r\n    isPlaying: isPlayingState\r\n  };\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useAudioService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'serviceContainer' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":190,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":190,"endColumn":31},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'options.config' and 'options.serviceContainer'. Either include them or remove the dependency array.","line":210,"column":6,"nodeType":"ArrayExpression","endLine":210,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [options.config, options.serviceContainer]","fix":{"range":[5878,5880],"text":"[options.config, options.serviceContainer]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useRef, useEffect } from 'react';\r\nimport { ServiceContainer } from '@/container/ServiceContainer';\r\n\r\ninterface AudioConfig {\r\n  volume?: number;\r\n  autoCleanup?: boolean;\r\n  maxInstances?: number;\r\n}\r\n\r\ninterface UseAudioServiceOptions {\r\n  config?: AudioConfig;\r\n  serviceContainer?: ServiceContainer;\r\n}\r\n\r\ninterface AudioInstance {\r\n  id: string;\r\n  element: HTMLAudioElement;\r\n  isPlaying: boolean;\r\n  createdAt: number;\r\n}\r\n\r\nclass AudioService {\r\n  private instances = new Map<string, AudioInstance>();\r\n  private maxInstances = 10;\r\n  private cleanupInterval: NodeJS.Timeout | null = null;\r\n\r\n  constructor(config?: AudioConfig) {\r\n    this.maxInstances = config?.maxInstances || 10;\r\n    \r\n    if (config?.autoCleanup !== false) {\r\n      this.startCleanupInterval();\r\n    }\r\n  }\r\n\r\n  private startCleanupInterval() {\r\n    this.cleanupInterval = setInterval(() => {\r\n      this.cleanup();\r\n    }, 30000); // Clean up every 30 seconds\r\n  }\r\n\r\n  private cleanup() {\r\n    const now = Date.now();\r\n    const fiveMinutes = 5 * 60 * 1000;\r\n\r\n    for (const [id, instance] of this.instances.entries()) {\r\n      if (!instance.isPlaying && (now - instance.createdAt) > fiveMinutes) {\r\n        this.destroy(id);\r\n      }\r\n    }\r\n\r\n    // If we still have too many instances, remove the oldest inactive ones\r\n    const inactiveInstances = Array.from(this.instances.entries())\r\n      .filter(([, instance]) => !instance.isPlaying)\r\n      .sort(([, a], [, b]) => a.createdAt - b.createdAt);\r\n\r\n    while (this.instances.size > this.maxInstances && inactiveInstances.length > 0) {\r\n      const [id] = inactiveInstances.shift()!;\r\n      this.destroy(id);\r\n    }\r\n  }\r\n\r\n  create(src: string, config?: AudioConfig): string {\r\n    const id = `audio_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n    \r\n    // Clean up if we have too many instances\r\n    if (this.instances.size >= this.maxInstances) {\r\n      this.cleanup();\r\n    }\r\n\r\n    const audio = new Audio(src);\r\n    audio.volume = config?.volume || 1;\r\n    \r\n    // Preload the audio\r\n    audio.preload = 'auto';\r\n\r\n    const instance: AudioInstance = {\r\n      id,\r\n      element: audio,\r\n      isPlaying: false,\r\n      createdAt: Date.now()\r\n    };\r\n\r\n    // Set up event listeners\r\n    audio.addEventListener('play', () => {\r\n      instance.isPlaying = true;\r\n    });\r\n\r\n    audio.addEventListener('pause', () => {\r\n      instance.isPlaying = false;\r\n    });\r\n\r\n    audio.addEventListener('ended', () => {\r\n      instance.isPlaying = false;\r\n    });\r\n\r\n    audio.addEventListener('error', (error) => {\r\n      console.warn(`Audio error for instance ${id}:`, error);\r\n      instance.isPlaying = false;\r\n    });\r\n\r\n    this.instances.set(id, instance);\r\n    return id;\r\n  }\r\n\r\n  async play(id: string): Promise<void> {\r\n    const instance = this.instances.get(id);\r\n    if (!instance) {\r\n      throw new Error(`Audio instance ${id} not found`);\r\n    }\r\n\r\n    try {\r\n      await instance.element.play();\r\n    } catch (error) {\r\n      console.warn(`Failed to play audio ${id}:`, error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  pause(id: string): void {\r\n    const instance = this.instances.get(id);\r\n    if (instance) {\r\n      instance.element.pause();\r\n    }\r\n  }\r\n\r\n  stop(id: string): void {\r\n    const instance = this.instances.get(id);\r\n    if (instance) {\r\n      instance.element.pause();\r\n      instance.element.currentTime = 0;\r\n    }\r\n  }\r\n\r\n  setVolume(id: string, volume: number): void {\r\n    const instance = this.instances.get(id);\r\n    if (instance) {\r\n      instance.element.volume = Math.max(0, Math.min(1, volume));\r\n    }\r\n  }\r\n\r\n  isPlaying(id: string): boolean {\r\n    const instance = this.instances.get(id);\r\n    return instance ? instance.isPlaying : false;\r\n  }\r\n\r\n  destroy(id: string): void {\r\n    const instance = this.instances.get(id);\r\n    if (instance) {\r\n      instance.element.pause();\r\n      instance.element.src = '';\r\n      instance.element.load(); // Reset the element\r\n      this.instances.delete(id);\r\n    }\r\n  }\r\n\r\n  destroyAll(): void {\r\n    for (const id of this.instances.keys()) {\r\n      this.destroy(id);\r\n    }\r\n  }\r\n\r\n  getActiveCount(): number {\r\n    return Array.from(this.instances.values()).filter(instance => instance.isPlaying).length;\r\n  }\r\n\r\n  getTotalCount(): number {\r\n    return this.instances.size;\r\n  }\r\n\r\n  dispose(): void {\r\n    if (this.cleanupInterval) {\r\n      clearInterval(this.cleanupInterval);\r\n      this.cleanupInterval = null;\r\n    }\r\n    this.destroyAll();\r\n  }\r\n}\r\n\r\n// Global audio service instance\r\nlet globalAudioService: AudioService | null = null;\r\n\r\nexport function useAudioService(options: UseAudioServiceOptions = {}) {\r\n  const serviceRef = useRef<AudioService | null>(null);\r\n\r\n  // 🔧 의존성 주입: ServiceContainer를 통한 AudioService 획득\r\n  useEffect(() => {\r\n    if (!globalAudioService) {\r\n      try {\r\n        // 🔧 Direct 생성 제거: ServiceContainer를 통해 AudioService 획득 시도\r\n        const serviceContainer = options.serviceContainer || ServiceContainer.getInstance();\r\n        \r\n        // TODO: ServiceContainer에 AudioService 등록 메서드 구현 필요\r\n        // globalAudioService = await serviceContainer.getAudioService(options.config);\r\n        \r\n        // 🔧 Fallback: ServiceContainer에 AudioService가 없으면 직접 생성\r\n        console.warn('[useAudioService] AudioService not available in ServiceContainer, creating instance directly');\r\n        globalAudioService = new AudioService(options.config);\r\n      } catch (error) {\r\n        console.error('[useAudioService] Failed to get AudioService from container:', error);\r\n        // 🔧 Final Fallback: 에러 시 직접 생성\r\n        globalAudioService = new AudioService(options.config);\r\n      }\r\n    }\r\n    serviceRef.current = globalAudioService;\r\n\r\n    return () => {\r\n      // Only dispose when the last component unmounts\r\n      // This is handled by the global service cleanup\r\n    };\r\n  }, []);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      // Individual components don't dispose the global service\r\n      // The service manages its own cleanup\r\n    };\r\n  }, []);\r\n\r\n  const createAudio = useCallback((src: string, audioConfig?: AudioConfig) => {\r\n    return serviceRef.current?.create(src, audioConfig) || '';\r\n  }, []);\r\n\r\n  const playAudio = useCallback(async (id: string) => {\r\n    return serviceRef.current?.play(id);\r\n  }, []);\r\n\r\n  const pauseAudio = useCallback((id: string) => {\r\n    serviceRef.current?.pause(id);\r\n  }, []);\r\n\r\n  const stopAudio = useCallback((id: string) => {\r\n    serviceRef.current?.stop(id);\r\n  }, []);\r\n\r\n  const setAudioVolume = useCallback((id: string, volume: number) => {\r\n    serviceRef.current?.setVolume(id, volume);\r\n  }, []);\r\n\r\n  const isAudioPlaying = useCallback((id: string) => {\r\n    return serviceRef.current?.isPlaying(id) || false;\r\n  }, []);\r\n\r\n  const destroyAudio = useCallback((id: string) => {\r\n    serviceRef.current?.destroy(id);\r\n  }, []);\r\n\r\n  const getStats = useCallback(() => {\r\n    if (!serviceRef.current) return { active: 0, total: 0 };\r\n    return {\r\n      active: serviceRef.current.getActiveCount(),\r\n      total: serviceRef.current.getTotalCount()\r\n    };\r\n  }, []);\r\n\r\n  return {\r\n    createAudio,\r\n    playAudio,\r\n    pauseAudio,\r\n    stopAudio,\r\n    setAudioVolume,\r\n    isAudioPlaying,\r\n    destroyAudio,\r\n    getStats\r\n  };\r\n}\r\n\r\n// Export function to manually dispose the global service (for app cleanup)\r\nexport function disposeGlobalAudioService() {\r\n  if (globalAudioService) {\r\n    globalAudioService.dispose();\r\n    globalAudioService = null;\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useAuth.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'userProgress?.level' and 'userProgress?.stage'. Either include them or remove the dependency array.","line":66,"column":6,"nodeType":"ArrayExpression","endLine":66,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [setAppUser, userProgress?.level, userProgress?.stage]","fix":{"range":[1900,1912],"text":"[setAppUser, userProgress?.level, userProgress?.stage]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect } from 'react';\r\nimport { getAuthService, getFirestoreService } from '../lib/firebase';\r\nimport { useAppStore } from '../store/useAppStore';\r\n\r\ninterface UserProgress {\r\n  level: number;\r\n  stage: number;\r\n  exp: number;\r\n  streak: number;\r\n  lastStudyDate: string;\r\n  totalSessions: number;\r\n  createdAt: string;\r\n  updatedAt: string;\r\n}\r\n\r\nexport const useAuth = () => {\r\n  const [user, setUser] = useState<any | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [userProgress, setUserProgress] = useState<UserProgress | null>(null);\r\n  const { setUser: setAppUser } = useAppStore();\r\n\r\n  useEffect(() => {\r\n    console.log('[DEBUG] 🔐 Auth state 리스너 설정');\r\n    \r\n    const setupAuthListener = async () => {\r\n      const auth = await getAuthService();\r\n      const { onAuthStateChanged } = await import('firebase/auth');\r\n      \r\n      const unsubscribe = onAuthStateChanged(auth, async (firebaseUser) => {\r\n      console.log('[DEBUG] 🔄 Auth state 변경:', firebaseUser?.uid || 'null');\r\n      \r\n      setUser(firebaseUser);\r\n      \r\n      if (firebaseUser) {\r\n        // Firebase 사용자가 로그인했을 때 진행도 로드\r\n        await loadUserProgress(firebaseUser.uid);\r\n        \r\n        // App Store 업데이트\r\n        setAppUser({\r\n          id: firebaseUser.uid,\r\n          level: userProgress?.level || 1,\r\n          stage: userProgress?.stage || 1,\r\n          isAuthenticated: true,\r\n          displayName: firebaseUser.displayName,\r\n          email: firebaseUser.email,\r\n          isAnonymous: firebaseUser.isAnonymous\r\n        });\r\n      } else {\r\n        // 로그아웃 시 초기화\r\n        setUserProgress(null);\r\n        setAppUser({\r\n          id: '',\r\n          level: 1,\r\n          stage: 1,\r\n          isAuthenticated: false\r\n        });\r\n      }\r\n      \r\n        setIsLoading(false);\r\n      });\r\n\r\n      return unsubscribe;\r\n    };\r\n\r\n    setupAuthListener();\r\n  }, [setAppUser]);\r\n\r\n  const loadUserProgress = async (userId: string): Promise<UserProgress | null> => {\r\n    try {\r\n      console.log('[DEBUG] 📊 사용자 진행도 로드 시도:', userId);\r\n      \r\n      const db = await getFirestoreService();\r\n      const { doc, getDoc, setDoc } = await import('firebase/firestore');\r\n      const userRef = doc(db, 'userProgress', userId);\r\n      const userSnap = await getDoc(userRef);\r\n      \r\n      if (userSnap.exists()) {\r\n        const progress = userSnap.data() as UserProgress;\r\n        console.log('[DEBUG] ✅ 기존 진행도 로드:', progress);\r\n        setUserProgress(progress);\r\n        return progress;\r\n      } else {\r\n        // 새 사용자 - 기본 진행도 생성\r\n        const newProgress: UserProgress = {\r\n          level: 1,\r\n          stage: 1,\r\n          exp: 0,\r\n          streak: 0,\r\n          lastStudyDate: '',\r\n          totalSessions: 0,\r\n          createdAt: new Date().toISOString(),\r\n          updatedAt: new Date().toISOString()\r\n        };\r\n        \r\n        await setDoc(userRef, newProgress);\r\n        console.log('[DEBUG] 🆕 새 사용자 진행도 생성:', newProgress);\r\n        setUserProgress(newProgress);\r\n        return newProgress;\r\n      }\r\n    } catch (error) {\r\n      console.error('[DEBUG] ❌ 진행도 로드 실패:', error);\r\n      return null;\r\n    }\r\n  };\r\n\r\n  const updateUserProgress = async (updates: Partial<UserProgress>): Promise<boolean> => {\r\n    if (!user) {\r\n      console.warn('[DEBUG] ⚠️ 로그인되지 않은 상태에서 진행도 업데이트 시도');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      console.log('[DEBUG] 📈 진행도 업데이트:', updates);\r\n      \r\n      const db = await getFirestoreService();\r\n      const { doc, updateDoc } = await import('firebase/firestore');\r\n      const userRef = doc(db, 'userProgress', user.uid);\r\n      const updatedData = {\r\n        ...updates,\r\n        updatedAt: new Date().toISOString()\r\n      };\r\n      \r\n      await updateDoc(userRef, updatedData);\r\n      \r\n      // 로컬 상태 업데이트\r\n      setUserProgress(prev => prev ? { ...prev, ...updatedData } : null);\r\n      \r\n      // App Store 업데이트\r\n      if (updates.level !== undefined || updates.stage !== undefined) {\r\n        setAppUser({\r\n          id: user.uid,\r\n          level: updates.level ?? userProgress?.level ?? 1,\r\n          stage: updates.stage ?? userProgress?.stage ?? 1,\r\n          isAuthenticated: true,\r\n          displayName: user.displayName,\r\n          email: user.email,\r\n          isAnonymous: user.isAnonymous\r\n        });\r\n      }\r\n      \r\n      console.log('[DEBUG] ✅ 진행도 업데이트 성공');\r\n      return true;\r\n    } catch (error) {\r\n      console.error('[DEBUG] ❌ 진행도 업데이트 실패:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  const logout = async (): Promise<void> => {\r\n    try {\r\n      console.log('[DEBUG] 🚪 로그아웃 시도');\r\n      const auth = await getAuthService();\r\n      const { signOut } = await import('firebase/auth');\r\n      await signOut(auth);\r\n      console.log('[DEBUG] ✅ 로그아웃 성공');\r\n    } catch (error) {\r\n      console.error('[DEBUG] ❌ 로그아웃 실패:', error);\r\n      throw error;\r\n    }\r\n  };\r\n\r\n  const addExp = async (expGain: number): Promise<boolean> => {\r\n    if (!userProgress) return false;\r\n\r\n    const newExp = userProgress.exp + expGain;\r\n    const newLevel = Math.floor(newExp / 100) + 1; // 100 exp per level\r\n    \r\n    const updates: Partial<UserProgress> = {\r\n      exp: newExp,\r\n      level: Math.max(userProgress.level, newLevel),\r\n      totalSessions: userProgress.totalSessions + 1\r\n    };\r\n\r\n    // 연속 학습 처리\r\n    const today = new Date().toISOString().split('T')[0];\r\n    const lastStudy = userProgress.lastStudyDate?.split('T')[0];\r\n    \r\n    if (lastStudy === today) {\r\n      // 같은 날 - streak 유지\r\n    } else {\r\n      const yesterday = new Date();\r\n      yesterday.setDate(yesterday.getDate() - 1);\r\n      const yesterdayStr = yesterday.toISOString().split('T')[0];\r\n      \r\n      if (lastStudy === yesterdayStr) {\r\n        // 연속 학습\r\n        updates.streak = userProgress.streak + 1;\r\n      } else {\r\n        // 연속 끊김\r\n        updates.streak = 1;\r\n      }\r\n    }\r\n    \r\n    updates.lastStudyDate = new Date().toISOString();\r\n    \r\n    return await updateUserProgress(updates);\r\n  };\r\n\r\n  return {\r\n    user,\r\n    userProgress,\r\n    isLoading,\r\n    loadUserProgress,\r\n    updateUserProgress,\r\n    logout,\r\n    addExp,\r\n    isAuthenticated: !!user,\r\n    isAnonymous: user?.isAnonymous || false\r\n  };\r\n};\r\n\r\nexport default useAuth;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useCountdown.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useCountdownTimer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useInterview.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'maxRetries' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":117,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":15},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'debugMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":119,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":14},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'setError' and 'speakQuestion'. Either include them or remove the dependency array.","line":346,"column":6,"nodeType":"ArrayExpression","endLine":346,"endColumn":82,"suggestions":[{"desc":"Update the dependencies array to be: [measureRender, updateState, clearError, startSessionTimer, autoStartSpeech, speakQuestion, setError]","fix":{"range":[10099,10175],"text":"[measureRender, updateState, clearError, startSessionTimer, autoStartSpeech, speakQuestion, setError]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'speakQuestion'. Either include it or remove the dependency array.","line":431,"column":6,"nodeType":"ArrayExpression","endLine":431,"endColumn":120,"suggestions":[{"desc":"Update the dependencies array to be: [state.interviewId, state.questionCount, setError, updateState, autoStartSpeech, updateMetrics, clearSessionTimer, speakQuestion]","fix":{"range":[12534,12648],"text":"[state.interviewId, state.questionCount, setError, updateState, autoStartSpeech, updateMetrics, clearSessionTimer, speakQuestion]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview 면접 세션 관리 Hook - 전문적인 에러 처리 및 성능 모니터링 포함\r\n * @description AI 면접 시뮬레이터의 면접 상태와 로직을 관리하는 커스텀 Hook\r\n * @author DaSiStart Team\r\n * @version 2.0.0\r\n */\r\n\r\nimport { useState, useCallback, useRef, useEffect } from 'react';\r\nimport { \r\n  interviewAPI, \r\n  webSpeechAPI,\r\n  type InterviewConfig,\r\n  type InterviewStartResponse,\r\n  type EvaluationResponse,\r\n  type QuestionResponse,\r\n  type SessionInfo\r\n} from '../services/api';\r\nimport { \r\n  handleError,\r\n  handleApiError,\r\n  ErrorType,\r\n  LogCategory,\r\n  logInfo,\r\n  logError,\r\n  logWarn,\r\n  interviewLogger,\r\n  type StructuredError\r\n} from '../utils/index.ts';\r\nimport { usePerformanceMonitoring } from './usePerformanceMonitoring';\r\n\r\n// ====== 타입 정의 ======\r\n\r\nexport interface InterviewState {\r\n  // 기본 상태\r\n  isActive: boolean;\r\n  isLoading: boolean;\r\n  isPaused: boolean;\r\n  \r\n  // 세션 정보\r\n  interviewId: string | null;\r\n  sessionToken: string | null;\r\n  \r\n  // 진행 상태\r\n  currentQuestion: string;\r\n  questionCount: number;\r\n  totalQuestions: number;\r\n  \r\n  // 에러 및 성능\r\n  error: StructuredError | null;\r\n  lastUpdateTime: number;\r\n}\r\n\r\nexport interface InterviewActions {\r\n  // 면접 관리\r\n  startInterview: (config: InterviewConfig) => Promise<InterviewStartResponse>;\r\n  pauseInterview: () => void;\r\n  resumeInterview: () => void;\r\n  endInterview: () => Promise<void>;\r\n  \r\n  // 질문 및 답변\r\n  getNextQuestion: () => Promise<QuestionResponse | null>;\r\n  evaluateAnswer: (answer: string) => Promise<EvaluationResponse>;\r\n  \r\n  // 음성 처리\r\n  speakQuestion: (question?: string) => Promise<void>;\r\n  stopSpeaking: () => void;\r\n  \r\n  // 상태 관리\r\n  clearError: () => void;\r\n  refreshSession: () => Promise<SessionInfo | null>;\r\n  \r\n  // 디버그 및 유틸리티\r\n  exportSessionData: () => any;\r\n  getSessionStatistics: () => any;\r\n}\r\n\r\nexport interface InterviewMetrics {\r\n  sessionDuration: number;\r\n  averageQuestionTime: number;\r\n  totalQuestions: number;\r\n  completedQuestions: number;\r\n  averageScore: number;\r\n  errorCount: number;\r\n  performanceScore: number;\r\n}\r\n\r\nexport interface InterviewHookOptions {\r\n  autoStartSpeech?: boolean;\r\n  enablePerformanceTracking?: boolean;\r\n  maxRetries?: number;\r\n  sessionTimeout?: number;\r\n  debugMode?: boolean;\r\n}\r\n\r\nexport interface InterviewHookResult extends InterviewState, InterviewActions {\r\n  // 추가 상태\r\n  lastEvaluation: EvaluationResponse | null;\r\n  currentConfig: InterviewConfig | null;\r\n  metrics: InterviewMetrics;\r\n  \r\n  // 유틸리티\r\n  isComplete: boolean;\r\n  progress: number;\r\n  canProceed: boolean;\r\n  \r\n  // 브라우저 지원\r\n  isSpeechSupported: boolean;\r\n  isTTSSupported: boolean;\r\n}\r\n\r\n// ====== 메인 Hook ======\r\n\r\nexport const useInterview = (options: InterviewHookOptions = {}): InterviewHookResult => {\r\n  const {\r\n    autoStartSpeech = true,\r\n    enablePerformanceTracking = true,\r\n    maxRetries = 3,\r\n    sessionTimeout = 30 * 60 * 1000, // 30분\r\n    debugMode = process.env.NODE_ENV === 'development'\r\n  } = options;\r\n\r\n  // ✅ CLAUDE.local 준수: 플러그인 기반 성능 모니터링\r\n  const { \r\n    measureRender, \r\n    measureAudio,\r\n    measureAudioLatency, \r\n    endAudioLatency \r\n  } = usePerformanceMonitoring('useInterview');\r\n\r\n  // ====== 상태 관리 ======\r\n\r\n  const [state, setState] = useState<InterviewState>({\r\n    isActive: false,\r\n    isLoading: false,\r\n    isPaused: false,\r\n    interviewId: null,\r\n    sessionToken: null,\r\n    currentQuestion: '',\r\n    questionCount: 0,\r\n    totalQuestions: 5,\r\n    error: null,\r\n    lastUpdateTime: Date.now()\r\n  });\r\n\r\n  const [lastEvaluation, setLastEvaluation] = useState<EvaluationResponse | null>(null);\r\n  const [metrics, setMetrics] = useState<InterviewMetrics>({\r\n    sessionDuration: 0,\r\n    averageQuestionTime: 0,\r\n    totalQuestions: 5,\r\n    completedQuestions: 0,\r\n    averageScore: 0,\r\n    errorCount: 0,\r\n    performanceScore: 100\r\n  });\r\n\r\n  // ====== Refs ======\r\n\r\n  const currentConfig = useRef<InterviewConfig | null>(null);\r\n  const sessionStartTime = useRef<number>(0);\r\n  const questionStartTime = useRef<number>(0);\r\n  const retryCount = useRef<number>(0);\r\n  const sessionTimeoutRef = useRef<NodeJS.Timeout | null>(null);\r\n  const evaluationScores = useRef<number[]>([]);\r\n  const questionTimes = useRef<number[]>([]);\r\n\r\n  // ====== 유틸리티 함수 ======\r\n\r\n  const updateState = useCallback((updates: Partial<InterviewState>) => {\r\n    setState(prev => ({\r\n      ...prev,\r\n      ...updates,\r\n      lastUpdateTime: Date.now()\r\n    }));\r\n  }, []);\r\n\r\n  const setError = useCallback((error: StructuredError | null) => {\r\n    updateState({ error });\r\n    \r\n    if (error) {\r\n      logError(LogCategory.INTERVIEW, error.message, error.originalError, {\r\n        component: 'useInterview',\r\n        interviewId: state.interviewId,\r\n        questionCount: state.questionCount\r\n      });\r\n      \r\n      setMetrics(prev => ({\r\n        ...prev,\r\n        errorCount: prev.errorCount + 1\r\n      }));\r\n    }\r\n  }, [state.interviewId, state.questionCount, updateState]);\r\n\r\n  const clearError = useCallback(() => {\r\n    setError(null);\r\n  }, [setError]);\r\n\r\n  // ====== 세션 타이머 관리 ======\r\n\r\n  const startSessionTimer = useCallback(() => {\r\n    if (sessionTimeoutRef.current) {\r\n      clearTimeout(sessionTimeoutRef.current);\r\n    }\r\n    \r\n    sessionTimeoutRef.current = setTimeout(() => {\r\n      logWarn(LogCategory.INTERVIEW, '세션 타임아웃', {\r\n        sessionDuration: Date.now() - sessionStartTime.current,\r\n        interviewId: state.interviewId\r\n      });\r\n      \r\n      setError(handleError(\r\n        ErrorType.INTERVIEW_SESSION_EXPIRED,\r\n        '면접 세션이 시간 초과되었습니다.',\r\n        { component: 'useInterview', action: 'sessionTimeout' }\r\n      ));\r\n    }, sessionTimeout);\r\n  }, [sessionTimeout, state.interviewId, setError]);\r\n\r\n  const clearSessionTimer = useCallback(() => {\r\n    if (sessionTimeoutRef.current) {\r\n      clearTimeout(sessionTimeoutRef.current);\r\n      sessionTimeoutRef.current = null;\r\n    }\r\n  }, []);\r\n\r\n  // ====== 메트릭스 업데이트 ======\r\n\r\n  const updateMetrics = useCallback(() => {\r\n    const now = Date.now();\r\n    const sessionDuration = sessionStartTime.current ? now - sessionStartTime.current : 0;\r\n    const averageQuestionTime = questionTimes.current.length > 0 \r\n      ? questionTimes.current.reduce((sum, time) => sum + time, 0) / questionTimes.current.length \r\n      : 0;\r\n    const averageScore = evaluationScores.current.length > 0\r\n      ? evaluationScores.current.reduce((sum, score) => sum + score, 0) / evaluationScores.current.length\r\n      : 0;\r\n\r\n    // ✅ measureAudio 활용 - 오디오 성능 통계 수집\r\n    let audioPerformanceScore = 100;\r\n    if (enablePerformanceTracking) {\r\n      const audioLatencyData = measureAudio('interview-session-audio');\r\n      if (audioLatencyData) {\r\n        // 평균 오디오 지연시간이 1초 미만이면 100점, 3초 이상이면 0점\r\n        const avgLatency = audioLatencyData.averageLatency || 0;\r\n        audioPerformanceScore = Math.max(0, Math.min(100, 100 - ((avgLatency - 1000) / 20)));\r\n        \r\n        logInfo(LogCategory.PERFORMANCE, '오디오 성능 통계 업데이트', {\r\n          averageLatency: avgLatency,\r\n          audioPerformanceScore,\r\n          totalMeasurements: audioLatencyData.measurementCount || 0\r\n        });\r\n      }\r\n    }\r\n\r\n    setMetrics({\r\n      sessionDuration,\r\n      averageQuestionTime,\r\n      totalQuestions: state.totalQuestions,\r\n      completedQuestions: state.questionCount,\r\n      averageScore,\r\n      errorCount: metrics.errorCount,\r\n      performanceScore: Math.max(0, 100 - metrics.errorCount * 10),\r\n      // ✅ 오디오 성능 점수 추가\r\n      audioPerformanceScore: Math.round(audioPerformanceScore)\r\n    });\r\n  }, [state.totalQuestions, state.questionCount, metrics.errorCount, enablePerformanceTracking, measureAudio]);\r\n\r\n  // ====== 면접 관리 함수들 ======\r\n\r\n  const startInterview = useCallback(async (config: InterviewConfig): Promise<InterviewStartResponse> => {\r\n    const endRenderMeasure = measureRender(Object.keys(config).length, 'startInterview');\r\n    \r\n    try {\r\n      updateState({ isLoading: true, error: null });\r\n      clearError();\r\n      retryCount.current = 0;\r\n\r\n      // 설정 검증\r\n      if (!config.position || !config.company || !config.jobDescription) {\r\n        throw handleError(\r\n          ErrorType.INTERVIEW_CONFIG_INVALID,\r\n          '면접 설정이 완전하지 않습니다.',\r\n          { component: 'useInterview', action: 'startInterview', additionalData: config }\r\n        );\r\n      }\r\n\r\n      interviewLogger.start(config);\r\n      \r\n      const response = await interviewAPI.start(config);\r\n      \r\n      if (!response.success || !response.data) {\r\n        throw handleError(\r\n          ErrorType.API_SERVER_ERROR,\r\n          response.error || '면접 시작에 실패했습니다.',\r\n          { component: 'useInterview', action: 'startInterview' }\r\n        );\r\n      }\r\n\r\n      // 상태 업데이트\r\n      currentConfig.current = config;\r\n      sessionStartTime.current = Date.now();\r\n      questionStartTime.current = Date.now();\r\n      \r\n      updateState({\r\n        isActive: true,\r\n        isLoading: false,\r\n        interviewId: response.data.interviewId,\r\n        sessionToken: response.data.sessionToken,\r\n        currentQuestion: response.data.question,\r\n        questionCount: response.data.questionCount,\r\n        totalQuestions: response.data.totalQuestions,\r\n        error: null\r\n      });\r\n\r\n      // 세션 타이머 시작\r\n      startSessionTimer();\r\n      \r\n      // 자동 음성 재생\r\n      if (autoStartSpeech && response.data.question) {\r\n        try {\r\n          await speakQuestion(response.data.question);\r\n        } catch (speechError) {\r\n          logWarn(LogCategory.SPEECH, '초기 질문 음성 재생 실패', speechError);\r\n        }\r\n      }\r\n\r\n      logInfo(LogCategory.INTERVIEW, '면접 시작됨', {\r\n        interviewId: response.data.interviewId,\r\n        position: config.position,\r\n        company: config.company,\r\n        totalQuestions: response.data.totalQuestions\r\n      });\r\n\r\n      return response.data;\r\n    } catch (error: any) {\r\n      const structuredError = error.type ? error : handleApiError(error, {\r\n        component: 'useInterview',\r\n        action: 'startInterview'\r\n      });\r\n      \r\n      setError(structuredError);\r\n      updateState({ isLoading: false });\r\n      throw structuredError;\r\n    } finally {\r\n      endRenderMeasure();\r\n    }\r\n  }, [updateState, clearError, startSessionTimer, autoStartSpeech, measureRender]);\r\n\r\n  const getNextQuestion = useCallback(async (): Promise<QuestionResponse | null> => {\r\n    if (!state.interviewId || !currentConfig.current) {\r\n      const error = handleError(\r\n        ErrorType.INTERVIEW_SESSION_INVALID,\r\n        '유효하지 않은 면접 세션입니다.',\r\n        { component: 'useInterview', action: 'getNextQuestion' }\r\n      );\r\n      setError(error);\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      updateState({ isLoading: true });\r\n      \r\n      // 이전 질문 시간 기록\r\n      if (questionStartTime.current) {\r\n        const questionTime = Date.now() - questionStartTime.current;\r\n        questionTimes.current.push(questionTime);\r\n      }\r\n\r\n      const response = await interviewAPI.getNextQuestion({\r\n        interviewId: state.interviewId,\r\n        position: currentConfig.current.position\r\n      });\r\n\r\n      if (!response.success) {\r\n        throw handleApiError(new Error(response.error), {\r\n          component: 'useInterview',\r\n          action: 'getNextQuestion'\r\n        });\r\n      }\r\n\r\n      const data = response.data!;\r\n      \r\n      if (data.isComplete) {\r\n        // 면접 완료\r\n        interviewLogger.end(\r\n          Date.now() - sessionStartTime.current,\r\n          state.questionCount\r\n        );\r\n        \r\n        updateState({\r\n          isActive: false,\r\n          isLoading: false,\r\n          currentQuestion: ''\r\n        });\r\n        \r\n        clearSessionTimer();\r\n        return data;\r\n      }\r\n\r\n      // 다음 질문 설정\r\n      questionStartTime.current = Date.now();\r\n      \r\n      updateState({\r\n        currentQuestion: data.question || '',\r\n        questionCount: data.questionCount || state.questionCount + 1,\r\n        isLoading: false\r\n      });\r\n\r\n      interviewLogger.questionGenerated(data.question || '', data.questionCount || 0);\r\n\r\n      // 자동 음성 재생\r\n      if (autoStartSpeech && data.question) {\r\n        try {\r\n          await speakQuestion(data.question);\r\n        } catch (speechError) {\r\n          logWarn(LogCategory.SPEECH, '질문 음성 재생 실패', speechError);\r\n        }\r\n      }\r\n\r\n      updateMetrics();\r\n      return data;\r\n    } catch (error: any) {\r\n      const structuredError = error.type ? error : handleApiError(error, {\r\n        component: 'useInterview',\r\n        action: 'getNextQuestion'\r\n      });\r\n      \r\n      setError(structuredError);\r\n      updateState({ isLoading: false });\r\n      return null;\r\n    }\r\n  }, [state.interviewId, state.questionCount, updateState, setError, clearSessionTimer, autoStartSpeech, updateMetrics]);\r\n\r\n  const evaluateAnswer = useCallback(async (answer: string): Promise<EvaluationResponse> => {\r\n    if (!state.interviewId || !state.currentQuestion || !currentConfig.current) {\r\n      throw handleError(\r\n        ErrorType.INTERVIEW_SESSION_INVALID,\r\n        '면접 세션 정보가 없습니다.',\r\n        { component: 'useInterview', action: 'evaluateAnswer' }\r\n      );\r\n    }\r\n\r\n    if (!answer.trim()) {\r\n      throw handleError(\r\n        ErrorType.VALIDATION_ERROR,\r\n        '답변 내용이 없습니다.',\r\n        { component: 'useInterview', action: 'evaluateAnswer' }\r\n      );\r\n    }\r\n\r\n    try {\r\n      updateState({ isLoading: true });\r\n\r\n      const response = await interviewAPI.evaluate({\r\n        question: state.currentQuestion,\r\n        answer: answer.trim(),\r\n        position: currentConfig.current.position,\r\n        company: currentConfig.current.company,\r\n        interviewId: state.interviewId\r\n      });\r\n\r\n      if (!response.success || !response.data) {\r\n        throw handleApiError(new Error(response.error), {\r\n          component: 'useInterview',\r\n          action: 'evaluateAnswer'\r\n        });\r\n      }\r\n\r\n      const evaluation = response.data;\r\n      setLastEvaluation(evaluation);\r\n      evaluationScores.current.push(evaluation.score);\r\n\r\n      interviewLogger.answerEvaluated(evaluation.score, evaluation.feedback);\r\n      \r\n      logInfo(LogCategory.INTERVIEW, '답변 평가 완료', {\r\n        score: evaluation.score,\r\n        answerLength: answer.length,\r\n        interviewId: state.interviewId\r\n      });\r\n\r\n      updateState({ isLoading: false });\r\n      updateMetrics();\r\n      \r\n      return evaluation;\r\n    } catch (error: any) {\r\n      const structuredError = error.type ? error : handleApiError(error, {\r\n        component: 'useInterview',\r\n        action: 'evaluateAnswer'\r\n      });\r\n      \r\n      setError(structuredError);\r\n      updateState({ isLoading: false });\r\n      throw structuredError;\r\n    }\r\n  }, [state.interviewId, state.currentQuestion, updateState, setError, updateMetrics]);\r\n\r\n  const pauseInterview = useCallback(() => {\r\n    if (!state.isActive) return;\r\n    \r\n    updateState({ isPaused: true });\r\n    clearSessionTimer();\r\n    webSpeechAPI.stopSpeaking();\r\n    \r\n    logInfo(LogCategory.INTERVIEW, '면접 일시정지', {\r\n      interviewId: state.interviewId,\r\n      questionCount: state.questionCount\r\n    });\r\n  }, [state.isActive, state.interviewId, state.questionCount, updateState, clearSessionTimer]);\r\n\r\n  const resumeInterview = useCallback(() => {\r\n    if (!state.isPaused) return;\r\n    \r\n    updateState({ isPaused: false });\r\n    startSessionTimer();\r\n    \r\n    logInfo(LogCategory.INTERVIEW, '면접 재개', {\r\n      interviewId: state.interviewId,\r\n      questionCount: state.questionCount\r\n    });\r\n  }, [state.isPaused, state.interviewId, state.questionCount, updateState, startSessionTimer]);\r\n\r\n  const endInterview = useCallback(async (): Promise<void> => {\r\n    try {\r\n      if (state.interviewId) {\r\n        await interviewAPI.end(state.interviewId);\r\n      }\r\n    } catch (error) {\r\n      logWarn(LogCategory.INTERVIEW, '면접 종료 API 호출 실패', error);\r\n    } finally {\r\n      // 로컬 상태는 항상 초기화\r\n      setState({\r\n        isActive: false,\r\n        isLoading: false,\r\n        isPaused: false,\r\n        interviewId: null,\r\n        sessionToken: null,\r\n        currentQuestion: '',\r\n        questionCount: 0,\r\n        totalQuestions: 5,\r\n        error: null,\r\n        lastUpdateTime: Date.now()\r\n      });\r\n      \r\n      currentConfig.current = null;\r\n      setLastEvaluation(null);\r\n      clearSessionTimer();\r\n      webSpeechAPI.stopSpeaking();\r\n      \r\n      const sessionDuration = sessionStartTime.current ? Date.now() - sessionStartTime.current : 0;\r\n      \r\n      interviewLogger.end(sessionDuration, state.questionCount);\r\n      \r\n      logInfo(LogCategory.INTERVIEW, '면접 종료', {\r\n        sessionDuration,\r\n        completedQuestions: state.questionCount,\r\n        averageScore: evaluationScores.current.length > 0 \r\n          ? evaluationScores.current.reduce((sum, score) => sum + score, 0) / evaluationScores.current.length \r\n          : 0\r\n      });\r\n      \r\n      // 메트릭스 리셋\r\n      evaluationScores.current = [];\r\n      questionTimes.current = [];\r\n      sessionStartTime.current = 0;\r\n      questionStartTime.current = 0;\r\n    }\r\n  }, [state.interviewId, state.questionCount, clearSessionTimer]);\r\n\r\n  // ====== 음성 처리 함수들 ======\r\n\r\n  const speakQuestion = useCallback(async (question?: string): Promise<void> => {\r\n    const textToSpeak = question || state.currentQuestion;\r\n    if (!textToSpeak) {\r\n      throw handleError(\r\n        ErrorType.VALIDATION_ERROR,\r\n        '재생할 질문이 없습니다.',\r\n        { component: 'useInterview', action: 'speakQuestion' }\r\n      );\r\n    }\r\n\r\n    if (!webSpeechAPI.isTTSSupported()) {\r\n      throw handleError(\r\n        ErrorType.TTS_NOT_SUPPORTED,\r\n        '이 브라우저에서는 음성 합성을 지원하지 않습니다.',\r\n        { component: 'useInterview', action: 'speakQuestion' }\r\n      );\r\n    }\r\n\r\n    // ✅ CLAUDE.local 준수: 플러그인을 통한 오디오 지연 측정 시작\r\n    const latencyMeasurementId = await measureAudioLatency();\r\n    \r\n    try {\r\n      await webSpeechAPI.speak(textToSpeak, 'ko-KR');\r\n      \r\n      // ✅ CLAUDE.local 준수: 플러그인을 통한 TTS 지연 측정 종료 \r\n      if (latencyMeasurementId) {\r\n        const performanceScore = await endAudioLatency(latencyMeasurementId, textToSpeak);\r\n        \r\n        // 성능 추적이 활성화된 경우 로깅\r\n        if (enablePerformanceTracking) {\r\n          logInfo(LogCategory.PERFORMANCE, 'TTS 지연시간 측정 완료 (플러그인)', {\r\n            measurementId: latencyMeasurementId,\r\n            performanceScore,\r\n            textLength: textToSpeak.length,\r\n            text: textToSpeak.substring(0, 50) + (textToSpeak.length > 50 ? '...' : '')\r\n          });\r\n        }\r\n      }\r\n    } catch (error: any) {\r\n      // ✅ 에러 발생 시에도 측정 종료 (실패로 기록)\r\n      if (latencyMeasurementId) {\r\n        await endAudioLatency(latencyMeasurementId, `ERROR: ${error.message}`);\r\n      }\r\n      \r\n      const structuredError = error.type ? error : handleError(\r\n        ErrorType.TTS_SYNTHESIS_ERROR,\r\n        error,\r\n        { component: 'useInterview', action: 'speakQuestion' }\r\n      );\r\n      setError(structuredError);\r\n      throw structuredError;\r\n    }\r\n  }, [state.currentQuestion, setError, measureAudioLatency, endAudioLatency, enablePerformanceTracking]);\r\n\r\n  const stopSpeaking = useCallback(() => {\r\n    try {\r\n      webSpeechAPI.stopSpeaking();\r\n    } catch (error: any) {\r\n      logWarn(LogCategory.SPEECH, '음성 재생 중지 실패', error);\r\n    }\r\n  }, []);\r\n\r\n  // ====== 세션 관리 함수들 ======\r\n\r\n  const refreshSession = useCallback(async (): Promise<SessionInfo | null> => {\r\n    if (!state.interviewId) return null;\r\n\r\n    try {\r\n      const response = await interviewAPI.getSession(state.interviewId);\r\n      \r\n      if (response.success && response.data) {\r\n        return response.data;\r\n      }\r\n      \r\n      return null;\r\n    } catch (error: any) {\r\n      logError(LogCategory.INTERVIEW, '세션 정보 조회 실패', error);\r\n      return null;\r\n    }\r\n  }, [state.interviewId]);\r\n\r\n  // ====== 유틸리티 함수들 ======\r\n\r\n  const exportSessionData = useCallback(() => {\r\n    return {\r\n      state,\r\n      config: currentConfig.current,\r\n      metrics,\r\n      lastEvaluation,\r\n      evaluationHistory: evaluationScores.current,\r\n      questionTimeHistory: questionTimes.current,\r\n      sessionDuration: sessionStartTime.current ? Date.now() - sessionStartTime.current : 0,\r\n      exportTime: new Date().toISOString()\r\n    };\r\n  }, [state, metrics, lastEvaluation]);\r\n\r\n  const getSessionStatistics = useCallback(() => {\r\n    const sessionDuration = sessionStartTime.current ? Date.now() - sessionStartTime.current : 0;\r\n    \r\n    return {\r\n      ...metrics,\r\n      sessionDuration,\r\n      isActive: state.isActive,\r\n      progress: state.totalQuestions > 0 ? (state.questionCount / state.totalQuestions) * 100 : 0,\r\n      timePerQuestion: questionTimes.current.length > 0 \r\n        ? questionTimes.current.reduce((sum, time) => sum + time, 0) / questionTimes.current.length \r\n        : 0\r\n    };\r\n  }, [metrics, state.isActive, state.questionCount, state.totalQuestions]);\r\n\r\n  // ====== 계산된 값들 ======\r\n\r\n  const isComplete = state.questionCount >= state.totalQuestions;\r\n  const progress = state.totalQuestions > 0 ? (state.questionCount / state.totalQuestions) * 100 : 0;\r\n  const canProceed = state.isActive && !state.isLoading && !state.isPaused && state.currentQuestion.trim().length > 0;\r\n  const isSpeechSupported = webSpeechAPI.isSupported();\r\n  const isTTSSupported = webSpeechAPI.isTTSSupported();\r\n\r\n  // ====== 클린업 Effect ======\r\n\r\n  useEffect(() => {\r\n    return () => {\r\n      clearSessionTimer();\r\n      webSpeechAPI.stopSpeaking();\r\n    };\r\n  }, [clearSessionTimer]);\r\n\r\n  // ====== 메트릭스 업데이트 Effect ======\r\n\r\n  useEffect(() => {\r\n    if (state.isActive) {\r\n      const interval = setInterval(updateMetrics, 5000); // 5초마다 메트릭스 업데이트\r\n      return () => clearInterval(interval);\r\n    }\r\n  }, [state.isActive, updateMetrics]);\r\n\r\n  // ====== 반환 값 ======\r\n\r\n  return {\r\n    // 상태\r\n    ...state,\r\n    lastEvaluation,\r\n    currentConfig: currentConfig.current,\r\n    metrics,\r\n\r\n    // 계산된 값들\r\n    isComplete,\r\n    progress,\r\n    canProceed,\r\n    isSpeechSupported,\r\n    isTTSSupported,\r\n\r\n    // 액션들\r\n    startInterview,\r\n    pauseInterview,\r\n    resumeInterview,\r\n    endInterview,\r\n    getNextQuestion,\r\n    evaluateAnswer,\r\n    speakQuestion,\r\n    stopSpeaking,\r\n    clearError,\r\n    refreshSession,\r\n    exportSessionData,\r\n    getSessionStatistics\r\n  };\r\n};\r\n\r\nexport default useInterview;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useLocalStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\usePatternData.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LevelServiceFactory' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":29},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isLoading' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":46,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useMemo, useEffect } from 'react';\nimport { QuestionItem, LevelSystemData, PatternDataManager } from '@/data/patternData';\nimport { LevelServiceFactory } from '@/services/curriculum/LevelServiceFactory';\n\nexport interface UsePatternDataProps {\n  levelSystemData?: LevelSystemData | null;\n  reviewQuestions?: QuestionItem[];\n  initialStage?: number;\n}\n\nexport interface UsePatternDataReturn {\n  // Current state\n  currentQuestions: QuestionItem[];\n  currentIndex: number;\n  currentQuestion: QuestionItem | null;\n  currentStage: number;\n  \n  // Progress tracking\n  totalQuestions: number;\n  progress: number;\n  isCompleted: boolean;\n  \n  // Navigation\n  nextQuestion: () => void;\n  previousQuestion: () => void;\n  goToQuestion: (index: number) => void;\n  resetQuestions: () => void;\n  \n  // Stage management\n  setStage: (stage: number) => void;\n  regenerateQuestions: () => void;\n  \n  // Utilities\n  isLastQuestion: boolean;\n  hasQuestions: boolean;\n}\n\nexport const usePatternData = ({\n  levelSystemData = null,\n  reviewQuestions = [],\n  initialStage = 1\n}: UsePatternDataProps = {}): UsePatternDataReturn => {\n  const [currentStage, setCurrentStage] = useState(initialStage);\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [currentQuestions, setCurrentQuestions] = useState<QuestionItem[]>([]);\n  const [isLoading, setIsLoading] = useState(false);\n\n  // Generate questions with useEffect for async handling\n  useEffect(() => {\n    const generateQuestions = async () => {\n      if (reviewQuestions.length > 0) {\n        console.log('복습 모드: 복습 문제 사용', reviewQuestions.length);\n        setCurrentQuestions(reviewQuestions);\n        return;\n      }\n\n      if (!levelSystemData) {\n        setCurrentQuestions([]);\n        return;\n      }\n\n      setIsLoading(true);\n      \n      try {\n        // 백엔드 API에서 올바른 JSON 데이터를 가져오므로 클라이언트 생성 불필요\n        console.log(`📋 데이터는 백엔드 API에서 제공: Level ${levelSystemData.level}, Stage ${currentStage}`);\n        // StudyPage는 api.getCards()를 통해 백엔드에서 데이터를 가져옴\n        setCurrentQuestions([]); // 이 hook은 StudyPage에서 사용되지 않음\n      } catch (error) {\n        console.error('❌ 문제 생성 오류:', error);\n        // 오류 시 기존 방식으로 폴백\n        const generated = PatternDataManager.generateQuestions(levelSystemData, currentStage);\n        console.log('🔄 폴백: 기존 방식 사용', generated.length);\n        setCurrentQuestions(generated);\n      } finally {\n        setIsLoading(false);\n      }\n    };\n\n    generateQuestions();\n  }, [levelSystemData, currentStage, reviewQuestions]);\n\n  // Current question\n  const currentQuestion = useMemo(() => {\n    if (currentIndex >= 0 && currentIndex < currentQuestions.length) {\n      return currentQuestions[currentIndex];\n    }\n    return null;\n  }, [currentQuestions, currentIndex]);\n\n  // Progress calculations\n  const totalQuestions = currentQuestions.length;\n  const progress = totalQuestions > 0 ? (currentIndex / totalQuestions) * 100 : 0;\n  const isCompleted = currentIndex >= totalQuestions;\n  const isLastQuestion = currentIndex === totalQuestions - 1;\n  const hasQuestions = totalQuestions > 0;\n\n  // Navigation functions\n  const nextQuestion = useCallback(() => {\n    setCurrentIndex(prev => Math.min(prev + 1, totalQuestions));\n  }, [totalQuestions]);\n\n  const previousQuestion = useCallback(() => {\n    setCurrentIndex(prev => Math.max(prev - 1, 0));\n  }, []);\n\n  const goToQuestion = useCallback((index: number) => {\n    if (index >= 0 && index < totalQuestions) {\n      setCurrentIndex(index);\n    }\n  }, [totalQuestions]);\n\n  const resetQuestions = useCallback(() => {\n    setCurrentIndex(0);\n  }, []);\n\n  // Stage management\n  const setStage = useCallback((stage: number) => {\n    setCurrentStage(stage);\n    setCurrentIndex(0); // Reset to first question when stage changes\n  }, []);\n\n  const regenerateQuestions = useCallback(() => {\n    // Force regeneration by updating stage (this will trigger useMemo dependency)\n    setCurrentIndex(0);\n    // Questions will automatically regenerate due to useMemo dependency on currentStage\n  }, []);\n\n  return {\n    // Current state\n    currentQuestions,\n    currentIndex,\n    currentQuestion,\n    currentStage,\n    \n    // Progress tracking\n    totalQuestions,\n    progress,\n    isCompleted,\n    \n    // Navigation\n    nextQuestion,\n    previousQuestion,\n    goToQuestion,\n    resetQuestions,\n    \n    // Stage management\n    setStage,\n    regenerateQuestions,\n    \n    // Utilities\n    isLastQuestion,\n    hasQuestions\n  };\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\usePatternTrainingManager.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'timerManagerRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'timerManagerRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":62,"column":23,"nodeType":"Identifier","endLine":62,"endColumn":30},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'eventManagerRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'eventManagerRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":63,"column":23,"nodeType":"Identifier","endLine":63,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * usePatternTrainingManager - 패턴 트레이닝 통합 관리 훅\r\n * \r\n * 역할:\r\n * - TimerManager와 EventLifecycleManager 통합\r\n * - 타이머/이벤트 라이프사이클 자동 관리\r\n * - 일시정지/재개 기능 통합 제공\r\n */\r\n\r\nimport { useRef, useCallback, useEffect } from 'react';\r\nimport TimerManager, { type TimerConfig } from '@/services/timers/TimerManager';\r\nimport EventLifecycleManager from '@/services/events/EventLifecycleManager';\r\n\r\nexport interface PatternTrainingManagerConfig {\r\n  onCountdownTick?: (remainingTime: number) => void;\r\n  onCountdownComplete?: () => void;\r\n  onRecognitionTick?: (remainingTime: number) => void;\r\n  onRecognitionComplete?: () => void;\r\n  onWaitingTick?: (remainingTime: number) => void;\r\n  onWaitingComplete?: () => void;\r\n  onCompletionEvent?: (stageId: string) => void;\r\n}\r\n\r\nexport interface PatternTrainingManager {\r\n  // 타이머 관리\r\n  startCountdown: (duration: number) => void;\r\n  startRecognition: (duration: number) => void;\r\n  startWaiting: (duration: number) => void;\r\n  stopAllTimers: () => void;\r\n  pauseAllTimers: () => void;\r\n  resumeAllTimers: () => void;\r\n  \r\n  // 완료 이벤트 관리\r\n  handleStageCompletion: (stageId: string) => boolean;\r\n  \r\n  // TTS 이벤트 관리\r\n  manageTTSEvents: (utterance: SpeechSynthesisUtterance) => void;\r\n  \r\n  // 음성인식 이벤트 관리\r\n  manageRecognitionEvents: (recognition: any) => void;\r\n  \r\n  // 타이머 상태 조회\r\n  getTimerState: () => { remainingTime?: number } | null;\r\n  \r\n  // 정리\r\n  cleanup: () => void;\r\n  \r\n  // 디버그\r\n  debug: () => void;\r\n}\r\n\r\nexport const usePatternTrainingManager = (\r\n  config: PatternTrainingManagerConfig\r\n): PatternTrainingManager => {\r\n  const timerManagerRef = useRef<TimerManager>(TimerManager.getInstance());\r\n  const eventManagerRef = useRef<EventLifecycleManager>(EventLifecycleManager.getInstance());\r\n  const timerConfigsRef = useRef<Map<string, TimerConfig>>(new Map());\r\n\r\n  // 컴포넌트 언마운트시 자동 정리\r\n  useEffect(() => {\r\n    return () => {\r\n      timerManagerRef.current.clearAllTimers();\r\n      eventManagerRef.current.clearAllEvents();\r\n    };\r\n  }, []);\r\n\r\n  // 정기적으로 오래된 이벤트 정리\r\n  useEffect(() => {\r\n    const cleanupInterval = setInterval(() => {\r\n      eventManagerRef.current.cleanupOldEvents();\r\n    }, 30000); // 30초마다\r\n\r\n    return () => clearInterval(cleanupInterval);\r\n  }, []);\r\n\r\n  /**\r\n   * 카운트다운 타이머 시작\r\n   */\r\n  const startCountdown = useCallback((duration: number): void => {\r\n    const timerConfig: TimerConfig = {\r\n      id: 'countdown',\r\n      type: 'countdown',\r\n      interval: 1000,\r\n      callback: (remainingTime: number) => {\r\n        config.onCountdownTick?.(remainingTime);\r\n      },\r\n      onComplete: () => {\r\n        config.onCountdownComplete?.(\r\n);\r\n      }\r\n    };\r\n\r\n    timerConfigsRef.current.set('countdown', timerConfig);\r\n    timerManagerRef.current.startTimer(timerConfig, duration);\r\n  }, [config]);\r\n\r\n  /**\r\n   * 음성인식 타이머 시작\r\n   */\r\n  const startRecognition = useCallback((duration: number): void => {\r\n    const timerConfig: TimerConfig = {\r\n      id: 'recognition',\r\n      type: 'recognition',\r\n      interval: 1000,\r\n      callback: (remainingTime: number) => {\r\n        config.onRecognitionTick?.(remainingTime);\r\n      },\r\n      onComplete: () => {\r\n        config.onRecognitionComplete?.();\r\n      }\r\n    };\r\n\r\n    timerConfigsRef.current.set('recognition', timerConfig);\r\n    timerManagerRef.current.startTimer(timerConfig, duration);\r\n  }, [config]);\r\n\r\n  /**\r\n   * 대기 타이머 시작\r\n   */\r\n  const startWaiting = useCallback((duration: number): void => {\r\n    const timerConfig: TimerConfig = {\r\n      id: 'waiting',\r\n      type: 'waiting',\r\n      interval: 1000,\r\n      callback: (remainingTime: number) => {\r\n        config.onWaitingTick?.(remainingTime);\r\n      },\r\n      onComplete: () => {\r\n        config.onWaitingComplete?.();\r\n      }\r\n    };\r\n\r\n    timerConfigsRef.current.set('waiting', timerConfig);\r\n    timerManagerRef.current.startTimer(timerConfig, duration);\r\n  }, [config]);\r\n\r\n  /**\r\n   * 모든 타이머 중지\r\n   */\r\n  const stopAllTimers = useCallback((): void => {\r\n    timerManagerRef.current.clearAllTimers();\r\n  }, []);\r\n\r\n  /**\r\n   * 모든 타이머 일시정지\r\n   */\r\n  const pauseAllTimers = useCallback((): void => {\r\n    timerManagerRef.current.pauseAllTimers();\r\n  }, []);\r\n\r\n  /**\r\n   * 모든 타이머 재개\r\n   */\r\n  const resumeAllTimers = useCallback((): void => {\r\n    timerManagerRef.current.resumeAllTimers(undefined, timerConfigsRef.current);\r\n  }, []);\r\n\r\n  /**\r\n   * 스테이지 완료 이벤트 처리 (중복 방지)\r\n   */\r\n  const handleStageCompletion = useCallback((stageId: string): boolean => {\r\n    const completionId = `stage-completion-${stageId}-${Date.now()}`;\r\n    \r\n    return eventManagerRef.current.handleCompletion(completionId, () => {\r\n      config.onCompletionEvent?.(stageId);\r\n      \r\n      // 완료 알림은 onCompletionEvent에서 처리되므로 중복 제거\r\n    });\r\n  }, [config]);\r\n\r\n  /**\r\n   * TTS 이벤트 관리\r\n   */\r\n  const manageTTSEvents = useCallback((utterance: SpeechSynthesisUtterance): void => {\r\n    // TTS 시작 이벤트\r\n    eventManagerRef.current.manageTTSEvent(\r\n      utterance,\r\n      'start',\r\n      () => console.log('🔊 [Manager] TTS 시작')\r\n    );\r\n\r\n    // TTS 완료 이벤트\r\n    eventManagerRef.current.manageTTSEvent(\r\n      utterance,\r\n      'end',\r\n      () => console.log('🔊 [Manager] TTS 완료')\r\n    );\r\n\r\n    // TTS 오류 이벤트\r\n    eventManagerRef.current.manageTTSEvent(\r\n      utterance,\r\n      'error',\r\n      (e: any) => console.error('❌ [Manager] TTS 오류:', e)\r\n    );\r\n  }, []);\r\n\r\n  /**\r\n   * 음성인식 이벤트 관리\r\n   */\r\n  const manageRecognitionEvents = useCallback((recognition: any): void => {\r\n    // 음성인식 결과 이벤트\r\n    eventManagerRef.current.manageRecognitionEvent(\r\n      recognition,\r\n      'result',\r\n      (event: any) => {\r\n        console.log('🎤 [Manager] 음성인식 결과:', event.results[0][0].transcript);\r\n      }\r\n    );\r\n\r\n    // 음성인식 종료 이벤트\r\n    eventManagerRef.current.manageRecognitionEvent(\r\n      recognition,\r\n      'end',\r\n      () => console.log('🎤 [Manager] 음성인식 종료')\r\n    );\r\n\r\n    // 음성인식 오류 이벤트\r\n    eventManagerRef.current.manageRecognitionEvent(\r\n      recognition,\r\n      'error',\r\n      (e: any) => console.error('❌ [Manager] 음성인식 오류:', e)\r\n    );\r\n  }, []);\r\n\r\n  /**\r\n   * 모든 리소스 정리\r\n   */\r\n  const cleanup = useCallback((): void => {\r\n    timerManagerRef.current.clearAllTimers();\r\n    eventManagerRef.current.clearAllEvents();\r\n    timerConfigsRef.current.clear();\r\n  }, []);\r\n\r\n  /**\r\n   * 현재 활성 타이머 상태 조회\r\n   */\r\n  const getTimerState = useCallback(() => {\r\n    const activeTimers = timerManagerRef.current.getActiveTimers();\r\n    if (activeTimers.length > 0) {\r\n      return { remainingTime: activeTimers[0].remainingTime };\r\n    }\r\n    return null;\r\n  }, []);\r\n\r\n  /**\r\n   * 디버그 정보 출력\r\n   */\r\n  const debug = useCallback((): void => {\r\n    console.log('🔍 [PatternTrainingManager] 디버그 정보:');\r\n    timerManagerRef.current.debug();\r\n    eventManagerRef.current.debug();\r\n  }, []);\r\n\r\n  return {\r\n    startCountdown,\r\n    startRecognition,\r\n    startWaiting,\r\n    stopAllTimers,\r\n    pauseAllTimers,\r\n    resumeAllTimers,\r\n    handleStageCompletion,\r\n    manageTTSEvents,\r\n    manageRecognitionEvents,\r\n    getTimerState,\r\n    cleanup,\r\n    debug\r\n  };\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\usePerformanceMonitoring.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'eventHandlersRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'eventHandlersRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":87,"column":26,"nodeType":"Identifier","endLine":87,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Performance Monitoring Hook\r\n * @description IPerformancePlugin을 사용한 성능 모니터링 React Hook\r\n * CLAUDE.local 규칙 준수: 플러그인 우선 아키텍처 + 인터페이스 우선 설계\r\n */\r\n\r\nimport { useState, useEffect, useCallback, useRef } from 'react';\r\nimport { getPerformancePlugin } from '@/plugins/PluginManager';\r\nimport {\r\n  IPerformancePlugin,\r\n  PerformanceStats,\r\n  PerformanceEvent,\r\n  PerformanceEventHandler\r\n} from '@/plugins/performance/IPerformancePlugin';\r\nimport { logInfo, logError, LogCategory } from '@/utils/index';\r\n\r\n// Hook 상태 타입\r\nexport interface UsePerformanceMonitoringState {\r\n  plugin: IPerformancePlugin | null;\r\n  isPluginReady: boolean;\r\n  pluginError: string | null;\r\n  isMonitoring: boolean;\r\n  stats: PerformanceStats | null;\r\n}\r\n\r\n// Hook 액션 타입\r\nexport interface UsePerformanceMonitoringActions {\r\n  // ✅ CLAUDE.local 준수: 플러그인을 통한 오디오 지연 측정\r\n  measureAudioLatency: () => Promise<string | null>;\r\n  endAudioLatency: (measurementId: string, transcription?: string) => Promise<number>;\r\n  \r\n  // ✅ CLAUDE.local 준수: measureAudio 기능 (오디오 성능 점수)\r\n  measureAudio: (latencyMs: number, transcription?: string) => Promise<number>;\r\n  \r\n  // API 및 렌더링 측정\r\n  measureRender: (componentName: string, propsCount: number, reason?: string) => () => void;\r\n  measureAPI: <T>(endpoint: string, method: string, apiCall: () => Promise<T>) => Promise<T>;\r\n  \r\n  // 성능 보고서\r\n  generateReport: () => Promise<any>;\r\n  getStats: () => Promise<PerformanceStats | null>;\r\n  \r\n  // 모니터링 제어\r\n  startMonitoring: () => Promise<boolean>;\r\n  stopMonitoring: () => void;\r\n  \r\n  // 설정 관리\r\n  updateThresholds: (thresholds: {\r\n    audioLatency?: number;\r\n    apiResponseTime?: number;\r\n    renderTime?: number;\r\n    memoryUsage?: number;\r\n  }) => Promise<boolean>;\r\n}\r\n\r\n// Hook 반환 타입\r\nexport type UsePerformanceMonitoringReturn = UsePerformanceMonitoringState & UsePerformanceMonitoringActions;\r\n\r\n/**\r\n * Performance Monitoring Hook\r\n * ✅ CLAUDE.local 준수: 플러그인 우선 아키텍처\r\n * @param componentName 컴포넌트 이름 (렌더링 측정용)\r\n */\r\nexport const usePerformanceMonitoring = (componentName?: string): UsePerformanceMonitoringReturn => {\r\n  // State\r\n  const [state, setState] = useState<UsePerformanceMonitoringState>({\r\n    plugin: null,\r\n    isPluginReady: false,\r\n    pluginError: null,\r\n    isMonitoring: false,\r\n    stats: null\r\n  });\r\n  \r\n  // Refs\r\n  const eventHandlersRef = useRef<Set<PerformanceEventHandler>>(new Set());\r\n  const isMountedRef = useRef(true);\r\n\r\n  // 컴포넌트 언마운트 시 정리\r\n  useEffect(() => {\r\n    return () => {\r\n      isMountedRef.current = false;\r\n      // 이벤트 핸들러 정리\r\n      if (state.plugin) {\r\n        eventHandlersRef.current.forEach(handler => {\r\n          state.plugin!.offPerformanceEvent(handler);\r\n        });\r\n        eventHandlersRef.current.clear();\r\n      }\r\n    };\r\n  }, [state.plugin]);\r\n\r\n  // Safe state update\r\n  const safeSetState = useCallback((updater: Partial<UsePerformanceMonitoringState>) => {\r\n    if (isMountedRef.current) {\r\n      setState(prev => ({ ...prev, ...updater }));\r\n    }\r\n  }, []);\r\n\r\n  // 플러그인 초기화\r\n  const initializePlugin = useCallback(async (): Promise<boolean> => {\r\n    if (state.plugin && state.isPluginReady) {\r\n      return true;\r\n    }\r\n\r\n    try {\r\n      logInfo(LogCategory.PERFORMANCE, 'Initializing Performance Plugin...');\r\n      \r\n      const pluginResult = await getPerformancePlugin();\r\n      if (!pluginResult.success) {\r\n        throw pluginResult.error;\r\n      }\r\n\r\n      const plugin = pluginResult.data;\r\n      \r\n      // 이벤트 핸들러 설정\r\n      const eventHandler: PerformanceEventHandler = (event: PerformanceEvent) => {\r\n        if (event.type === 'threshold_exceeded' || event.type === 'warning') {\r\n          logInfo(LogCategory.PERFORMANCE, 'Performance alert', event.data);\r\n        }\r\n      };\r\n      \r\n      plugin.onPerformanceEvent(eventHandler);\r\n      eventHandlersRef.current.add(eventHandler);\r\n      \r\n      // 모니터링 시작\r\n      const startResult = plugin.startMonitoring();\r\n      if (!startResult.success) {\r\n        throw startResult.error;\r\n      }\r\n\r\n      safeSetState({\r\n        plugin,\r\n        isPluginReady: true,\r\n        pluginError: null,\r\n        isMonitoring: plugin.isMonitoring()\r\n      });\r\n\r\n      logInfo(LogCategory.PERFORMANCE, 'Performance Plugin initialized successfully');\r\n      return true;\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to initialize plugin';\r\n      logError(LogCategory.PERFORMANCE, 'Performance Plugin initialization failed', error);\r\n      \r\n      safeSetState({\r\n        plugin: null,\r\n        isPluginReady: false,\r\n        pluginError: errorMessage\r\n      });\r\n      \r\n      return false;\r\n    }\r\n  }, [state.plugin, state.isPluginReady, safeSetState]);\r\n\r\n  // 플러그인 자동 초기화\r\n  useEffect(() => {\r\n    if (!state.plugin && !state.pluginError) {\r\n      initializePlugin();\r\n    }\r\n  }, [state.plugin, state.pluginError, initializePlugin]);\r\n\r\n  // ✅ CLAUDE.local 준수: 플러그인을 통한 오디오 지연 측정\r\n  const measureAudioLatency = useCallback(async (): Promise<string | null> => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      logError(LogCategory.PERFORMANCE, 'Performance plugin not ready for audio measurement');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const result = await state.plugin.measureAudioLatency();\r\n      if (result.success) {\r\n        return result.data;\r\n      } else {\r\n        logError(LogCategory.PERFORMANCE, 'Failed to start audio latency measurement', result.error);\r\n        return null;\r\n      }\r\n    } catch (error) {\r\n      logError(LogCategory.PERFORMANCE, 'Audio latency measurement error', error);\r\n      return null;\r\n    }\r\n  }, [state.plugin, state.isPluginReady]);\r\n\r\n  const endAudioLatency = useCallback(async (measurementId: string, transcription?: string): Promise<number> => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      logError(LogCategory.PERFORMANCE, 'Performance plugin not ready for ending audio measurement');\r\n      return 0;\r\n    }\r\n\r\n    try {\r\n      const result = await state.plugin.endAudioLatency(measurementId, transcription);\r\n      if (result.success) {\r\n        logInfo(LogCategory.PERFORMANCE, 'Audio latency measurement completed', {\r\n          measurementId,\r\n          latency: result.data.totalLatency,\r\n          score: result.data.performanceScore\r\n        });\r\n        return result.data.performanceScore;\r\n      } else {\r\n        logError(LogCategory.PERFORMANCE, 'Failed to end audio latency measurement', result.error);\r\n        return 0;\r\n      }\r\n    } catch (error) {\r\n      logError(LogCategory.PERFORMANCE, 'End audio latency measurement error', error);\r\n      return 0;\r\n    }\r\n  }, [state.plugin, state.isPluginReady]);\r\n\r\n  // ✅ CLAUDE.local 준수: measureAudio 기능 (오디오 성능 점수 계산)\r\n  const measureAudio = useCallback(async (latencyMs: number, transcription?: string): Promise<number> => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      return 0;\r\n    }\r\n\r\n    try {\r\n      const result = await state.plugin.calculateAudioScore(latencyMs, transcription);\r\n      if (result.success) {\r\n        return result.data;\r\n      } else {\r\n        logError(LogCategory.PERFORMANCE, 'Failed to calculate audio score', result.error);\r\n        return 0;\r\n      }\r\n    } catch (error) {\r\n      logError(LogCategory.PERFORMANCE, 'Audio score calculation error', error);\r\n      return 0;\r\n    }\r\n  }, [state.plugin, state.isPluginReady]);\r\n\r\n  // 렌더링 측정\r\n  const measureRender = useCallback((\r\n    compName: string, \r\n    propsCount: number, \r\n    reason?: string\r\n  ): (() => void) => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      return () => {}; // no-op\r\n    }\r\n\r\n    const name = compName || componentName || 'Unknown';\r\n    const result = state.plugin.measureComponentRender(name, propsCount, reason);\r\n    \r\n    if (result.success) {\r\n      return result.data;\r\n    } else {\r\n      logError(LogCategory.PERFORMANCE, 'Failed to start render measurement', result.error);\r\n      return () => {};\r\n    }\r\n  }, [state.plugin, state.isPluginReady, componentName]);\r\n\r\n  // API 측정\r\n  const measureAPI = useCallback(async <T>(\r\n    endpoint: string,\r\n    method: string,\r\n    apiCall: () => Promise<T>\r\n  ): Promise<T> => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      // 플러그인이 준비되지 않은 경우 그냥 API 호출 실행\r\n      return apiCall();\r\n    }\r\n\r\n    try {\r\n      const result = await state.plugin.measureAPICall(endpoint, method, apiCall);\r\n      if (result.success) {\r\n        return result.data;\r\n      } else {\r\n        throw result.error;\r\n      }\r\n    } catch (error) {\r\n      logError(LogCategory.PERFORMANCE, 'API measurement error', error);\r\n      throw error;\r\n    }\r\n  }, [state.plugin, state.isPluginReady]);\r\n\r\n  // 성능 보고서 생성\r\n  const generateReport = useCallback(async () => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const result = await state.plugin.generatePerformanceReport();\r\n      if (result.success) {\r\n        return result.data;\r\n      } else {\r\n        logError(LogCategory.PERFORMANCE, 'Failed to generate performance report', result.error);\r\n        return null;\r\n      }\r\n    } catch (error) {\r\n      logError(LogCategory.PERFORMANCE, 'Performance report generation error', error);\r\n      return null;\r\n    }\r\n  }, [state.plugin, state.isPluginReady]);\r\n\r\n  // 성능 통계 조회\r\n  const getStats = useCallback(async (): Promise<PerformanceStats | null> => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const result = await state.plugin.getPerformanceStats();\r\n      if (result.success) {\r\n        safeSetState({ stats: result.data });\r\n        return result.data;\r\n      } else {\r\n        logError(LogCategory.PERFORMANCE, 'Failed to get performance stats', result.error);\r\n        return null;\r\n      }\r\n    } catch (error) {\r\n      logError(LogCategory.PERFORMANCE, 'Performance stats retrieval error', error);\r\n      return null;\r\n    }\r\n  }, [state.plugin, state.isPluginReady, safeSetState]);\r\n\r\n  // 모니터링 시작\r\n  const startMonitoring = useCallback(async (): Promise<boolean> => {\r\n    if (!state.plugin) {\r\n      const initSuccess = await initializePlugin();\r\n      if (!initSuccess) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const result = state.plugin.startMonitoring();\r\n      if (result.success) {\r\n        safeSetState({ isMonitoring: true });\r\n        return true;\r\n      } else {\r\n        logError(LogCategory.PERFORMANCE, 'Failed to start monitoring', result.error);\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      logError(LogCategory.PERFORMANCE, 'Start monitoring error', error);\r\n      return false;\r\n    }\r\n  }, [state.plugin, state.isPluginReady, initializePlugin, safeSetState]);\r\n\r\n  // 모니터링 중지\r\n  const stopMonitoring = useCallback(() => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const result = state.plugin.stopMonitoring();\r\n      if (result.success) {\r\n        safeSetState({ isMonitoring: false });\r\n      } else {\r\n        logError(LogCategory.PERFORMANCE, 'Failed to stop monitoring', result.error);\r\n      }\r\n    } catch (error) {\r\n      logError(LogCategory.PERFORMANCE, 'Stop monitoring error', error);\r\n    }\r\n  }, [state.plugin, state.isPluginReady, safeSetState]);\r\n\r\n  // ✅ CLAUDE.local 준수: 설정 기반 임계값 동적 변경\r\n  const updateThresholds = useCallback(async (thresholds: {\r\n    audioLatency?: number;\r\n    apiResponseTime?: number;\r\n    renderTime?: number;\r\n    memoryUsage?: number;\r\n  }): Promise<boolean> => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const result = state.plugin.updateThresholds(thresholds);\r\n      if (result.success) {\r\n        logInfo(LogCategory.PERFORMANCE, 'Performance thresholds updated', thresholds);\r\n        return true;\r\n      } else {\r\n        logError(LogCategory.PERFORMANCE, 'Failed to update thresholds', result.error);\r\n        return false;\r\n      }\r\n    } catch (error) {\r\n      logError(LogCategory.PERFORMANCE, 'Threshold update error', error);\r\n      return false;\r\n    }\r\n  }, [state.plugin, state.isPluginReady]);\r\n\r\n  return {\r\n    // State\r\n    ...state,\r\n    \r\n    // Actions\r\n    measureAudioLatency,\r\n    endAudioLatency,\r\n    measureAudio,\r\n    measureRender,\r\n    measureAPI,\r\n    generateReport,\r\n    getStats,\r\n    startMonitoring,\r\n    stopMonitoring,\r\n    updateThresholds\r\n  };\r\n};\r\n\r\nexport default usePerformanceMonitoring;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\usePerformanceOptimization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\usePluginSpeech.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Result' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fallbackToWebAPI' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":79,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":79,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Speech 플러그인 사용을 위한 React Hook\r\n * @description 기존 하드코딩된 webSpeechAPI 대신 플러그인 시스템 사용\r\n */\r\n\r\nimport { useState, useEffect, useCallback, useRef } from 'react';\r\nimport { getSpeechPlugin, isPluginAvailable } from '@/plugins';\r\nimport type { ISpeechPlugin, SpeechProcessingState } from '@/plugins/speech/ISpeechPlugin';\r\nimport { NonEmptyString, PositiveNumber, Result } from '@/types/core';\r\n\r\n// Hook 옵션\r\nexport interface UsePluginSpeechOptions {\r\n  readonly autoInitialize?: boolean;\r\n  readonly fallbackToWebAPI?: boolean;\r\n  readonly onStateChange?: (state: SpeechProcessingState) => void;\r\n  readonly onError?: (error: string) => void;\r\n}\r\n\r\n// Hook 반환 타입\r\nexport interface UsePluginSpeechReturn {\r\n  // 플러그인 상태\r\n  readonly isAvailable: boolean;\r\n  readonly isLoading: boolean;\r\n  readonly processingState: SpeechProcessingState;\r\n  readonly error: string | null;\r\n  \r\n  // TTS 기능\r\n  readonly speakText: (\r\n    text: string,\r\n    options?: {\r\n      language?: string;\r\n      rate?: number;\r\n      volume?: number;\r\n    }\r\n  ) => Promise<boolean>;\r\n  \r\n  // 음성 인식 기능\r\n  readonly recognizeSpeech: (\r\n    options?: {\r\n      language?: string;\r\n      maxDuration?: number;\r\n      continuous?: boolean;\r\n    }\r\n  ) => Promise<{ success: boolean; transcript?: string; confidence?: number }>;\r\n  \r\n  readonly startListening: (\r\n    onResult: (transcript: string, confidence: number) => void,\r\n    options?: {\r\n      language?: string;\r\n      continuous?: boolean;\r\n    }\r\n  ) => boolean;\r\n  \r\n  readonly stopListening: () => boolean;\r\n  \r\n  // 신호음\r\n  readonly playBeep: (\r\n    options?: {\r\n      frequency?: number;\r\n      duration?: number;\r\n    }\r\n  ) => Promise<boolean>;\r\n  \r\n  // 제어\r\n  readonly stopAll: () => boolean;\r\n  readonly isProcessing: () => boolean;\r\n  \r\n  // 기능 확인\r\n  readonly getSupportedLanguages: () => Promise<string[]>;\r\n  readonly getAvailableVoices: () => Promise<SpeechSynthesisVoice[]>;\r\n}\r\n\r\n/**\r\n * Speech 플러그인 사용 Hook\r\n */\r\nexport function usePluginSpeech(options: UsePluginSpeechOptions = {}): UsePluginSpeechReturn {\r\n  const {\r\n    autoInitialize = true,\r\n    fallbackToWebAPI = true,\r\n    onStateChange,\r\n    onError\r\n  } = options;\r\n\r\n  // 상태\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [processingState, setProcessingState] = useState<SpeechProcessingState>('idle');\r\n  const [error, setError] = useState<string | null>(null);\r\n  \r\n  // 플러그인 인스턴스\r\n  const speechPluginRef = useRef<ISpeechPlugin | null>(null);\r\n  const isAvailable = isPluginAvailable('speech');\r\n\r\n  // 플러그인 초기화\r\n  useEffect(() => {\r\n    if (!autoInitialize) return;\r\n\r\n    const initializePlugin = async () => {\r\n      try {\r\n        setIsLoading(true);\r\n        setError(null);\r\n\r\n        const result = await getSpeechPlugin();\r\n        if (result.success) {\r\n          speechPluginRef.current = result.data;\r\n          \r\n          // 상태 변경 리스너 등록\r\n          result.data.onSpeechEvent((event) => {\r\n            if (event.type === 'stateChange' && event.data?.state) {\r\n              setProcessingState(event.data.state);\r\n              onStateChange?.(event.data.state);\r\n            }\r\n            if (event.type === 'error' && event.data?.error) {\r\n              const errorMsg = typeof event.data.error === 'string' \r\n                ? event.data.error \r\n                : 'Unknown plugin error';\r\n              setError(errorMsg);\r\n              onError?.(errorMsg);\r\n            }\r\n          });\r\n\r\n          console.log('✅ Speech plugin initialized successfully');\r\n        } else {\r\n          throw new Error(`Failed to initialize speech plugin: ${result.error}`);\r\n        }\r\n      } catch (err) {\r\n        const errorMsg = err instanceof Error ? err.message : 'Plugin initialization failed';\r\n        setError(errorMsg);\r\n        onError?.(errorMsg);\r\n        console.error('❌ Speech plugin initialization failed:', err);\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    initializePlugin();\r\n  }, [autoInitialize, onStateChange, onError]);\r\n\r\n  // TTS 함수\r\n  const speakText = useCallback(async (\r\n    text: string,\r\n    options: {\r\n      language?: string;\r\n      rate?: number;\r\n      volume?: number;\r\n    } = {}\r\n  ): Promise<boolean> => {\r\n    const plugin = speechPluginRef.current;\r\n    if (!plugin) {\r\n      console.warn('Speech plugin not available');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const result = await plugin.speakText(\r\n        text as NonEmptyString,\r\n        {\r\n          language: options.language as NonEmptyString | undefined,\r\n          rate: options.rate as PositiveNumber | undefined,\r\n          volume: options.volume\r\n        }\r\n      );\r\n      return result.success;\r\n    } catch (error) {\r\n      console.error('TTS error:', error);\r\n      return false;\r\n    }\r\n  }, []);\r\n\r\n  // 음성 인식 함수\r\n  const recognizeSpeech = useCallback(async (\r\n    options: {\r\n      language?: string;\r\n      maxDuration?: number;\r\n      continuous?: boolean;\r\n    } = {}\r\n  ): Promise<{ success: boolean; transcript?: string; confidence?: number }> => {\r\n    const plugin = speechPluginRef.current;\r\n    if (!plugin) {\r\n      console.warn('Speech plugin not available');\r\n      return { success: false };\r\n    }\r\n\r\n    try {\r\n      const result = await plugin.recognizeSpeech({\r\n        language: options.language as NonEmptyString | undefined,\r\n        maxDuration: options.maxDuration as PositiveNumber | undefined,\r\n        continuous: options.continuous\r\n      });\r\n\r\n      if (result.success && result.data.success) {\r\n        return {\r\n          success: true,\r\n          transcript: result.data.transcript,\r\n          confidence: result.data.confidence\r\n        };\r\n      } else {\r\n        return { \r\n          success: false,\r\n          transcript: undefined,\r\n          confidence: undefined\r\n        };\r\n      }\r\n    } catch (error) {\r\n      console.error('Speech recognition error:', error);\r\n      return { success: false };\r\n    }\r\n  }, []);\r\n\r\n  // 실시간 음성 인식 시작\r\n  const startListening = useCallback((\r\n    onResult: (transcript: string, confidence: number) => void,\r\n    options: {\r\n      language?: string;\r\n      continuous?: boolean;\r\n    } = {}\r\n  ): boolean => {\r\n    const plugin = speechPluginRef.current;\r\n    if (!plugin) {\r\n      console.warn('Speech plugin not available');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const result = plugin.startListening(\r\n        onResult,\r\n        {\r\n          language: options.language as NonEmptyString | undefined,\r\n          continuous: options.continuous\r\n        }\r\n      );\r\n      return result.success;\r\n    } catch (error) {\r\n      console.error('Start listening error:', error);\r\n      return false;\r\n    }\r\n  }, []);\r\n\r\n  // 음성 인식 중지\r\n  const stopListening = useCallback((): boolean => {\r\n    const plugin = speechPluginRef.current;\r\n    if (!plugin) return false;\r\n\r\n    try {\r\n      const result = plugin.stopListening();\r\n      return result.success;\r\n    } catch (error) {\r\n      console.error('Stop listening error:', error);\r\n      return false;\r\n    }\r\n  }, []);\r\n\r\n  // 신호음 재생\r\n  const playBeep = useCallback(async (\r\n    options: {\r\n      frequency?: number;\r\n      duration?: number;\r\n    } = {}\r\n  ): Promise<boolean> => {\r\n    const plugin = speechPluginRef.current;\r\n    if (!plugin) {\r\n      console.warn('Speech plugin not available');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const result = await plugin.playBeep({\r\n        frequency: options.frequency as PositiveNumber | undefined,\r\n        duration: options.duration as PositiveNumber | undefined\r\n      });\r\n      return result.success;\r\n    } catch (error) {\r\n      console.error('Play beep error:', error);\r\n      return false;\r\n    }\r\n  }, []);\r\n\r\n  // 모든 처리 중지\r\n  const stopAll = useCallback((): boolean => {\r\n    const plugin = speechPluginRef.current;\r\n    if (!plugin) return false;\r\n\r\n    try {\r\n      const result = plugin.stopAll();\r\n      return result.success;\r\n    } catch (error) {\r\n      console.error('Stop all error:', error);\r\n      return false;\r\n    }\r\n  }, []);\r\n\r\n  // 처리 상태 확인\r\n  const isProcessing = useCallback((): boolean => {\r\n    const plugin = speechPluginRef.current;\r\n    return plugin?.isProcessing() ?? false;\r\n  }, []);\r\n\r\n  // 지원 언어 조회\r\n  const getSupportedLanguages = useCallback(async (): Promise<string[]> => {\r\n    const plugin = speechPluginRef.current;\r\n    if (!plugin) return [];\r\n\r\n    try {\r\n      const result = await plugin.getSupportedLanguages();\r\n      return result.success ? result.data : [];\r\n    } catch (error) {\r\n      console.error('Get supported languages error:', error);\r\n      return [];\r\n    }\r\n  }, []);\r\n\r\n  // 사용 가능한 음성 조회\r\n  const getAvailableVoices = useCallback(async (): Promise<SpeechSynthesisVoice[]> => {\r\n    const plugin = speechPluginRef.current;\r\n    if (!plugin) return [];\r\n\r\n    try {\r\n      const result = await plugin.getAvailableVoices();\r\n      return result.success ? result.data : [];\r\n    } catch (error) {\r\n      console.error('Get available voices error:', error);\r\n      return [];\r\n    }\r\n  }, []);\r\n\r\n  return {\r\n    // 상태\r\n    isAvailable,\r\n    isLoading,\r\n    processingState,\r\n    error,\r\n    \r\n    // 메서드\r\n    speakText,\r\n    recognizeSpeech,\r\n    startListening,\r\n    stopListening,\r\n    playBeep,\r\n    stopAll,\r\n    isProcessing,\r\n    getSupportedLanguages,\r\n    getAvailableVoices\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useQuestionProgress.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":111,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":111,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 문제 진행 관리 훅\r\n * 하드코딩 방지 원칙에 따라 모듈화된 문제 진행 로직\r\n * \r\n * @architecture Plugin-style question progression for Pattern Training\r\n */\r\n\r\nimport { useState, useCallback } from 'react';\r\n\r\nexport interface Question {\r\n  ko: string;\r\n  en: string;\r\n  id?: string;\r\n}\r\n\r\nexport interface QuestionProgressConfig {\r\n  questions: Question[];\r\n  onQuestionStart?: (question: Question, index: number) => void;\r\n  onQuestionComplete?: (question: Question, index: number) => void;\r\n  onAllComplete?: () => void;\r\n}\r\n\r\nexport interface QuestionProgressState {\r\n  currentIndex: number;\r\n  currentQuestion: Question | null;\r\n  isComplete: boolean;\r\n  progress: number; // 0-100%\r\n  totalQuestions: number;\r\n}\r\n\r\n/**\r\n * 문제 진행 관리 훅\r\n * 완전히 모듈화되어 재사용 가능\r\n */\r\nexport function useQuestionProgress(config: QuestionProgressConfig): QuestionProgressState & {\r\n  nextQuestion: () => void;\r\n  resetProgress: () => void;\r\n  jumpToQuestion: (index: number) => void;\r\n} {\r\n  const { questions, onQuestionStart, onQuestionComplete, onAllComplete } = config;\r\n  \r\n  const [currentIndex, setCurrentIndex] = useState(0);\r\n  \r\n  const currentQuestion = questions[currentIndex] || null;\r\n  const isComplete = currentIndex >= questions.length;\r\n  const progress = questions.length > 0 ? (currentIndex / questions.length) * 100 : 0;\r\n  \r\n  const nextQuestion = useCallback(() => {\r\n    console.log(`🎯 [${new Date().toLocaleTimeString()}] nextQuestion 호출: ${currentIndex} -> ${currentIndex + 1}`);\r\n    \r\n    if (currentIndex < questions.length) {\r\n      // 현재 문제 완료 콜백\r\n      onQuestionComplete?.(questions[currentIndex], currentIndex);\r\n    }\r\n    \r\n    const nextIndex = currentIndex + 1;\r\n    \r\n    if (nextIndex >= questions.length) {\r\n      console.log(`🎉 [${new Date().toLocaleTimeString()}] 모든 문제 완료!`);\r\n      onAllComplete?.();\r\n      return;\r\n    }\r\n    \r\n    setCurrentIndex(nextIndex);\r\n    \r\n    // 다음 문제 시작 콜백\r\n    const nextQuestion = questions[nextIndex];\r\n    if (nextQuestion) {\r\n      console.log(`📝 [${new Date().toLocaleTimeString()}] 문제 ${nextIndex + 1}: \"${nextQuestion.ko}\" → \"${nextQuestion.en}\"`);\r\n      onQuestionStart?.(nextQuestion, nextIndex);\r\n    }\r\n  }, [currentIndex, questions, onQuestionStart, onQuestionComplete, onAllComplete]);\r\n\r\n  const resetProgress = useCallback(() => {\r\n    setCurrentIndex(0);\r\n    if (questions.length > 0) {\r\n      onQuestionStart?.(questions[0], 0);\r\n    }\r\n  }, [questions, onQuestionStart]);\r\n\r\n  const jumpToQuestion = useCallback((index: number) => {\r\n    if (index >= 0 && index < questions.length) {\r\n      setCurrentIndex(index);\r\n      onQuestionStart?.(questions[index], index);\r\n    }\r\n  }, [questions, onQuestionStart]);\r\n\r\n  return {\r\n    currentIndex,\r\n    currentQuestion,\r\n    isComplete,\r\n    progress,\r\n    totalQuestions: questions.length,\r\n    nextQuestion,\r\n    resetProgress,\r\n    jumpToQuestion\r\n  };\r\n}\r\n\r\n/**\r\n * 패턴 트레이닝 전용 문제 진행 훅\r\n * TTS + 타이머 통합\r\n */\r\nexport function usePatternTrainingProgress(\r\n  questions: Question[],\r\n  onTTSComplete: (question: Question) => void,\r\n  onTrainingComplete: () => void\r\n) {\r\n  return useQuestionProgress({\r\n    questions,\r\n    onQuestionStart: (question, index) => {\r\n      console.log(`🎤 [${new Date().toLocaleTimeString()}] TTS 재생 시작: \"${question.ko}\"`);\r\n      // TTS 재생 로직은 컴포넌트에서 처리\r\n      onTTSComplete(question);\r\n    },\r\n    onAllComplete: () => {\r\n      console.log(`🎉 [${new Date().toLocaleTimeString()}] 패턴 트레이닝 완료!`);\r\n      onTrainingComplete();\r\n    }\r\n  });\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useResponsiveDesign.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useReviewSchedule.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useSRSEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useSimpleSpeechRecognition.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useSpacedRepetition.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ReviewCard' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'accuracy' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":268,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":268,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useMemo } from 'react';\nimport { QuestionItem } from '@/data/patternData';\nimport { \n  useLocalStorage, \n  STORAGE_KEYS, \n  MistakeItem, \n  UserStats,\n  StorageManager \n} from './useLocalStorage';\n\n// 🔄 LEGACY ADAPTER: 새 SRS 시스템으로 점진적 마이그레이션 중\n// 2025-01-12: useSRSEngine.ts를 사용하는 것을 권장합니다\nimport { useSRSEngine } from './useSRSEngine';\nimport { ReviewCard } from '@/services/srs/SRSEngine';\n\n/**\n * @deprecated 이 훅은 완전히 레거시입니다.\n * ⚠️  더 이상 사용하지 마세요.\n * ✅  대신 useSRSEngine.ts를 사용하세요.\n *\n * 마이그레이션 가이드:\n * 1. import { useSpacedRepetition } → import { useSRSEngine }\n * 2. const { dueReviews } = useSpacedRepetition() → const srs = useSRSEngine({ userId })\n * 3. srs.cards.filter(card => card.isDue) 사용\n *\n * 2025-01-12: 이 파일은 다음 버전에서 제거될 예정입니다.\n */\n\n// 망각곡선 복습 간격 (밀리초)\nexport const REVIEW_INTERVALS = {\n  FIRST: 1 * 24 * 60 * 60 * 1000,    // 1일\n  SECOND: 3 * 24 * 60 * 60 * 1000,   // 3일\n  THIRD: 7 * 24 * 60 * 60 * 1000,    // 7일\n  FOURTH: 14 * 24 * 60 * 60 * 1000   // 14일\n};\n\nexport interface MistakeData {\n  level: number;\n  stage: number;\n  korean: string;\n  english: string;\n  pattern: string;\n  verb?: string;\n  userAnswer: string;\n  responseTime: number;\n  difficulty: number;\n}\n\nexport interface UseSpacedRepetitionReturn {\n  // Mistakes management\n  mistakes: MistakeItem[];\n  addMistake: (mistake: MistakeData) => void;\n  \n  // Review system\n  dueReviews: MistakeItem[];\n  completedReview: (mistakeId: string, isCorrect: boolean) => void;\n  \n  // Statistics\n  stats: UserStats;\n  updateStats: (sessionData: {\n    totalQuestions: number;\n    correctAnswers: number;\n    totalMistakes: number;\n    studyTime: number;\n  }) => void;\n  \n  // Review questions generation\n  getReviewQuestions: (mode: 'all' | 'pattern' | 'weak-patterns', patternName?: string) => QuestionItem[];\n  \n  // Utilities\n  mistakeCount: number;\n  reviewCount: number;\n  masteredCount: number;\n  clearAllData: () => void;\n  debugPrint: () => void;\n}\n\nexport const useSpacedRepetition = (): UseSpacedRepetitionReturn => {\n  \n  // 🔄 ADAPTER PATTERN: SSOT SRS 시스템 사용\n  const srsEngine = useSRSEngine({ \n    userId: 'legacy-user', \n    storageKey: 'legacy-srs-cards'\n  });\n  \n  // 기존 로컬스토리지 시스템 (점진적 이전 중)\n  const { \n    value: mistakes, \n    updateValue: updateMistakes \n  } = useLocalStorage(STORAGE_KEYS.MISTAKES);\n\n  const { \n    value: stats, \n    updateValue: updateStatsValue \n  } = useLocalStorage(STORAGE_KEYS.USER_STATS);\n\n  // Get due reviews (SSOT 시스템 + 레거시 호환)\n  const dueReviews = useMemo(() => {\n    // 🔄 NEW: SSOT 시스템에서 복습 예정 카드들 가져오기\n    const newDueCards = srsEngine.dueCards;\n    \n    // 🔄 LEGACY: 기존 mistakes 시스템 (점진적 제거 예정)\n    const now = Date.now();\n    const legacyDueReviews = mistakes.filter(mistake => \n      !mistake.mastered && mistake.nextReview <= now\n    );\n\n    // 🔗 ADAPTER: 레거시 형태로 변환하여 반환\n    const adaptedNewCards = newDueCards.map(card => ({\n      id: card.id,\n      korean: card.content.korean,\n      english: card.content.english,\n      pattern: card.content.pattern || 'unknown',\n      level: card.content.level,\n      stage: card.content.stage,\n      nextReview: card.memory.nextReview.getTime(),\n      mastered: card.memory.strength > 0.9, // 높은 기억력 = 마스터\n      reviewCount: card.memory.reviewCount,\n      mistakeCount: card.performance.mistakes\n    } as MistakeItem));\n\n    // 우선: SSOT 시스템, 대체: 레거시 시스템\n    return adaptedNewCards.length > 0 ? adaptedNewCards : legacyDueReviews;\n  }, [srsEngine.dueCards, mistakes]);\n\n  // Statistics\n  const mistakeCount = mistakes.length;\n  const reviewCount = mistakes.filter(m => m.reviewCount > 0).length;\n  const masteredCount = mistakes.filter(m => m.mastered).length;\n\n  // Add a new mistake (SSOT 어댑터)\n  const addMistake = useCallback((mistake: MistakeData) => {\n    console.warn('⚠️ [DEPRECATED] useSpacedRepetition.addMistake는 deprecated입니다. useSRSEngine을 사용하세요.');\n    \n    // 🔄 NEW: SSOT 시스템에 추가\n    try {\n      const newCard = srsEngine.addCard({\n        korean: mistake.korean,\n        english: mistake.english,\n        level: mistake.level,\n        stage: mistake.stage,\n        pattern: mistake.pattern\n      });\n      \n      // 틀린 답안을 반영한 리뷰 세션 처리\n      srsEngine.processReviewSession(newCard.id, {\n        userAnswer: mistake.userAnswer,\n        correctAnswer: mistake.english,\n        isCorrect: false,\n        responseTime: mistake.responseTime,\n        difficulty: 'medium',\n        confidence: 0.3\n      });\n      \n      console.log(`✅ [NEW SRS] 새 틀린 문제 추가: ${mistake.korean}`);\n      \n    } catch (error) {\n      console.error('NEW SRS 시스템에 추가 실패, 레거시 시스템 사용:', error);\n      \n      // 🔄 FALLBACK: 레거시 시스템에 추가\n      updateMistakes(prevMistakes => {\n        const now = Date.now();\n        const newMistakes = [...prevMistakes];\n        \n        const existingIndex = newMistakes.findIndex(m => \n          m.korean === mistake.korean && \n          m.english === mistake.english &&\n          m.pattern === mistake.pattern\n        );\n\n        if (existingIndex >= 0) {\n          // Update existing mistake\n          const existing = newMistakes[existingIndex];\n          newMistakes[existingIndex] = {\n            ...existing,\n            mistakeCount: existing.mistakeCount + 1,\n            lastMistake: now,\n            totalResponseTime: existing.totalResponseTime + mistake.responseTime,\n            averageResponseTime: (existing.totalResponseTime + mistake.responseTime) / (existing.mistakeCount + 1),\n            nextReview: now + REVIEW_INTERVALS.FIRST,\n            reviewStage: 0,\n            lastUserAnswer: mistake.userAnswer\n          };\n          \n          console.log(`📦 [LEGACY] 기존 틀린 문제 업데이트: ${mistake.korean}`);\n        } else {\n          // Add new mistake\n          const newMistake: MistakeItem = {\n            id: `mistake_${now}_${Math.random().toString(36).substr(2, 9)}`,\n            level: mistake.level,\n            stage: mistake.stage,\n            korean: mistake.korean,\n            english: mistake.english,\n            pattern: mistake.pattern,\n            verb: mistake.verb,\n            userAnswer: mistake.userAnswer,\n            mistakeCount: 1,\n            firstMistake: now,\n            lastMistake: now,\n            nextReview: now + REVIEW_INTERVALS.FIRST,\n            reviewStage: 0,\n            reviewCount: 0,\n            difficulty: mistake.difficulty,\n            totalResponseTime: mistake.responseTime,\n            averageResponseTime: mistake.responseTime,\n            mastered: false\n          };\n          \n          newMistakes.push(newMistake);\n          console.log(`📦 [LEGACY] 새 틀린 문제 추가: ${mistake.korean}`);\n        }\n\n        return newMistakes;\n      });\n    }\n  }, [srsEngine, updateMistakes]);\n\n  // Complete a review (mark as correct or incorrect)\n  const completedReview = useCallback((mistakeId: string, isCorrect: boolean) => {\n    updateMistakes(prevMistakes => {\n      const newMistakes = [...prevMistakes];\n      const mistakeIndex = newMistakes.findIndex(m => m.id === mistakeId);\n      \n      if (mistakeIndex >= 0) {\n        const mistake = newMistakes[mistakeIndex];\n        mistake.reviewCount += 1;\n        mistake.lastReview = Date.now();\n\n        if (isCorrect) {\n          // Correct answer: move to next review stage\n          mistake.reviewStage += 1;\n          \n          if (mistake.reviewStage >= 4) {\n            // All 4 stages completed: mark as mastered\n            mistake.mastered = true;\n            mistake.masteredDate = Date.now();\n            console.log(`마스터 완료: ${mistake.korean}`);\n          } else {\n            // Set next review time based on current stage\n            const intervals = [\n              REVIEW_INTERVALS.FIRST,\n              REVIEW_INTERVALS.SECOND, \n              REVIEW_INTERVALS.THIRD,\n              REVIEW_INTERVALS.FOURTH\n            ];\n            mistake.nextReview = Date.now() + intervals[mistake.reviewStage];\n          }\n        } else {\n          // Incorrect answer: restart from stage 0\n          mistake.reviewStage = 0;\n          mistake.nextReview = Date.now() + REVIEW_INTERVALS.FIRST;\n          mistake.mistakeCount += 1;\n        }\n      }\n      \n      return newMistakes;\n    });\n  }, [updateMistakes]);\n\n  // Update user statistics\n  const updateStats = useCallback((sessionData: {\n    totalQuestions: number;\n    correctAnswers: number;\n    totalMistakes: number;\n    studyTime: number;\n  }) => {\n    updateStatsValue(prevStats => {\n      const accuracy = sessionData.totalQuestions > 0 \n        ? (sessionData.correctAnswers / sessionData.totalQuestions) * 100 \n        : 0;\n\n      const newTotalQuestions = prevStats.totalQuestions + sessionData.totalQuestions;\n      const newTotalCorrect = prevStats.totalCorrect + sessionData.correctAnswers;\n      const newAverageAccuracy = newTotalQuestions > 0 \n        ? (newTotalCorrect / newTotalQuestions) * 100 \n        : 0;\n\n      return {\n        ...prevStats,\n        totalSessions: prevStats.totalSessions + 1,\n        totalQuestions: newTotalQuestions,\n        totalCorrect: newTotalCorrect,\n        totalMistakes: prevStats.totalMistakes + sessionData.totalMistakes,\n        averageAccuracy: newAverageAccuracy,\n        totalStudyTime: prevStats.totalStudyTime + sessionData.studyTime,\n        lastUpdated: Date.now()\n      };\n    });\n  }, [updateStatsValue]);\n\n  // Generate review questions based on mode\n  const getReviewQuestions = useCallback((\n    mode: 'all' | 'pattern' | 'weak-patterns', \n    patternName?: string\n  ): QuestionItem[] => {\n    const now = Date.now();\n    let targetMistakes: MistakeItem[] = [];\n\n    if (mode === 'all') {\n      // All due reviews\n      targetMistakes = mistakes.filter(m => !m.mastered && m.nextReview <= now);\n    } else if (mode === 'pattern' && patternName) {\n      // Specific pattern reviews\n      targetMistakes = mistakes.filter(m => \n        !m.mastered && \n        m.nextReview <= now && \n        m.pattern === patternName\n      );\n    } else if (mode === 'weak-patterns') {\n      // Weak patterns (low mastery rate or high mistake count)\n      const patternStats = new Map<string, { total: number; mastered: number }>();\n      \n      mistakes.forEach(m => {\n        const current = patternStats.get(m.pattern) || { total: 0, mastered: 0 };\n        current.total += 1;\n        if (m.mastered) current.mastered += 1;\n        patternStats.set(m.pattern, current);\n      });\n      \n      const weakPatterns = Array.from(patternStats.entries())\n        .filter(([_, stats]) => stats.total >= 3 && (stats.mastered / stats.total) < 0.5)\n        .map(([pattern]) => pattern);\n      \n      targetMistakes = mistakes.filter(m => \n        !m.mastered && \n        m.nextReview <= now && \n        weakPatterns.includes(m.pattern)\n      );\n    }\n\n    // Convert to QuestionItem format\n    return targetMistakes.map(mistake => ({\n      korean: mistake.korean,\n      english: mistake.english,\n      pattern: mistake.pattern,\n      verb: mistake.verb,\n      level: mistake.level,\n      stage: mistake.stage,\n      mistakeId: mistake.id // Add for tracking\n    } as QuestionItem & { mistakeId: string }));\n  }, [mistakes]);\n\n  // Clear all data\n  const clearAllData = useCallback(() => {\n    StorageManager.clearAllData();\n  }, []);\n\n  // Debug print\n  const debugPrint = useCallback(() => {\n    StorageManager.debugPrint();\n  }, []);\n\n  return {\n    // Mistakes management\n    mistakes,\n    addMistake,\n    \n    // Review system\n    dueReviews,\n    completedReview,\n    \n    // Statistics\n    stats,\n    updateStats,\n    \n    // Review questions generation\n    getReviewQuestions,\n    \n    // Utilities\n    mistakeCount,\n    reviewCount,\n    masteredCount,\n    clearAllData,\n    debugPrint\n  };\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useSpeech.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'phraseHints' is assigned a value but never used. Allowed unused args must match /^_/u.","line":47,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":56},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'phraseHints' is assigned a value but never used. Allowed unused args must match /^_/u.","line":71,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":71,"endColumn":55},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'speech'. Either include it or remove the dependency array.","line":129,"column":6,"nodeType":"ArrayExpression","endLine":129,"endColumn":80,"suggestions":[{"desc":"Update the dependencies array to be: [speech, options.language]","fix":{"range":[3525,3599],"text":"[speech, options.language]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'speech'. Either include it or remove the dependency array.","line":178,"column":6,"nodeType":"ArrayExpression","endLine":178,"endColumn":88,"suggestions":[{"desc":"Update the dependencies array to be: [speech, options.language]","fix":{"range":[4927,5009],"text":"[speech, options.language]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frequency' is assigned a value but never used. Allowed unused args must match /^_/u.","line":181,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":181,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'duration' is assigned a value but never used. Allowed unused args must match /^_/u.","line":181,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":181,"endColumn":72},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'speech'. Either include it or remove the dependency array.","line":198,"column":6,"nodeType":"ArrayExpression","endLine":198,"endColumn":55,"suggestions":[{"desc":"Update the dependencies array to be: [speech]","fix":{"range":[5710,5759],"text":"[speech]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'speech'. Either include it or remove the dependency array.","line":204,"column":6,"nodeType":"ArrayExpression","endLine":204,"endColumn":22,"suggestions":[{"desc":"Update the dependencies array to be: [speech]","fix":{"range":[5924,5940],"text":"[speech]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'speech'. Either include it or remove the dependency array.","line":252,"column":6,"nodeType":"ArrayExpression","endLine":252,"endColumn":22,"suggestions":[{"desc":"Update the dependencies array to be: [speech]","fix":{"range":[7680,7696],"text":"[speech]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'speech'. Either include it or remove the dependency array.","line":287,"column":6,"nodeType":"ArrayExpression","endLine":287,"endColumn":22,"suggestions":[{"desc":"Update the dependencies array to be: [speech]","fix":{"range":[8613,8629],"text":"[speech]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useRef } from 'react';\r\nimport { useSimpleSpeech } from '@/plugins/simple/SimpleSpeechPlugin';\r\n\r\n// Helper function to detect Korean text\r\nconst isKorean = (text: string): boolean => {\r\n  const koreanRegex = /[\\u3131-\\u318E\\uAC00-\\uD7A3]/;\r\n  return koreanRegex.test(text);\r\n};\r\n\r\nexport interface UseSpeechOptions {\r\n  apiBaseUrl?: string;\r\n  preferCloudSTT?: boolean;\r\n  language?: string;\r\n}\r\n\r\nexport interface STTResult {\r\n  transcript: string;\r\n  confidence: number;\r\n  isFinal: boolean;\r\n}\r\n\r\nexport interface SpeechState {\r\n  isRecording: boolean;\r\n  isProcessing: boolean;\r\n  error: string | null;\r\n  lastResult: STTResult | null;\r\n}\r\n\r\nexport const useSpeech = (options: UseSpeechOptions = {}) => {\r\n  const [state, setState] = useState<SpeechState>({\r\n    isRecording: false,\r\n    isProcessing: false,\r\n    error: null,\r\n    lastResult: null,\r\n  });\r\n\r\n  // Use simplified speech plugin\r\n  const speech = useSimpleSpeech();\r\n  const activeRecognitionRef = useRef<AbortController | null>(null);\r\n  const activeTTSRef = useRef<AbortController | null>(null);\r\n\r\n  // Check if speech services are available\r\n  const isSTTAvailable = !speech.isLoading && !speech.error;\r\n  const isTTSAvailable = !speech.isLoading && !speech.error;\r\n\r\n  // Start recording and transcription\r\n  const startRecording = useCallback(async (phraseHints: string[] = []) => {\r\n    if (speech.isLoading || speech.error) {\r\n      setState(prev => ({\r\n        ...prev,\r\n        error: speech.error || 'Speech plugin not ready'\r\n      }));\r\n      return;\r\n    }\r\n\r\n    setState(prev => ({ \r\n      ...prev, \r\n      isRecording: true, \r\n      error: null,\r\n      lastResult: null \r\n    }));\r\n\r\n    // Cancel any existing recognition\r\n    if (activeRecognitionRef.current) {\r\n      activeRecognitionRef.current.abort();\r\n    }\r\n    activeRecognitionRef.current = new AbortController();\r\n  }, [speech.isLoading, speech.error]);\r\n\r\n  // Stop recording and get transcription\r\n  const stopRecording = useCallback(async (phraseHints: string[] = []): Promise<STTResult | null> => {\r\n    if (speech.isLoading || speech.error) {\r\n      setState(prev => ({\r\n        ...prev,\r\n        isRecording: false,\r\n        error: speech.error || 'Speech plugin not ready'\r\n      }));\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      setState(prev => ({ \r\n        ...prev, \r\n        isRecording: false, \r\n        isProcessing: true,\r\n        error: null \r\n      }));\r\n\r\n      const result = await speech.recognizeSpeech({\r\n        language: options.language || 'en-US',\r\n        maxDuration: 30000,\r\n        signal: activeRecognitionRef.current?.signal\r\n      });\r\n\r\n      if (result.success && result.transcript) {\r\n        const sttResult: STTResult = {\r\n          transcript: result.transcript,\r\n          confidence: result.confidence || 0.9,\r\n          isFinal: true\r\n        };\r\n\r\n        setState(prev => ({\r\n          ...prev,\r\n          isProcessing: false,\r\n          lastResult: sttResult,\r\n        }));\r\n\r\n        return sttResult;\r\n      } else {\r\n        setState(prev => ({\r\n          ...prev,\r\n          isProcessing: false,\r\n          error: '음성이 인식되지 않았습니다',\r\n        }));\r\n        return null;\r\n      }\r\n\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : '음성 인식 실패';\r\n      setState(prev => ({\r\n        ...prev,\r\n        isProcessing: false,\r\n        error: errorMessage,\r\n      }));\r\n      return null;\r\n    } finally {\r\n      activeRecognitionRef.current = null;\r\n    }\r\n  }, [speech.isLoading, speech.error, speech.recognizeSpeech, options.language]);\r\n\r\n  // Text-to-Speech with language detection\r\n  const speak = useCallback(async (text: string, voiceOptions: {\r\n    rate?: number;\r\n    pitch?: number;\r\n    volume?: number;\r\n    lang?: string;\r\n  } = {}) => {\r\n    if (speech.isLoading || speech.error) {\r\n      setState(prev => ({\r\n        ...prev,\r\n        error: speech.error || 'Speech plugin not ready'\r\n      }));\r\n      return;\r\n    }\r\n\r\n    try {\r\n      // Cancel any existing TTS\r\n      if (activeTTSRef.current) {\r\n        activeTTSRef.current.abort();\r\n      }\r\n      activeTTSRef.current = new AbortController();\r\n\r\n      // Auto-detect language if not specified\r\n      const detectedLang = voiceOptions.lang || \r\n        (isKorean(text) ? 'ko-KR' : options.language || 'en-US');\r\n\r\n      const success = await speech.speakText(text, {\r\n        language: detectedLang,\r\n        rate: voiceOptions.rate || (detectedLang === 'ko-KR' ? 0.8 : 0.9),\r\n        signal: activeTTSRef.current.signal\r\n      });\r\n\r\n      if (!success) {\r\n        setState(prev => ({\r\n          ...prev,\r\n          error: speech.error || '음성 재생 실패',\r\n        }));\r\n      }\r\n\r\n    } catch (error) {\r\n      setState(prev => ({\r\n        ...prev,\r\n        error: error instanceof Error ? error.message : '음성 재생 실패',\r\n      }));\r\n    } finally {\r\n      activeTTSRef.current = null;\r\n    }\r\n  }, [speech.isLoading, speech.error, speech.speakText, speech.error, options.language]);\r\n\r\n  // Play beep sound with control\r\n  const playBeep = useCallback(async (frequency: number = 800, duration: number = 500) => {\r\n    if (speech.isLoading || speech.error) {\r\n      // Fallback: create a brief pause\r\n      return new Promise<void>(resolve => setTimeout(resolve, 300));\r\n    }\r\n\r\n    try {\r\n      const success = await speech.playBeep();\r\n      if (!success) {\r\n        // Fallback: create a brief pause\r\n        return new Promise<void>(resolve => setTimeout(resolve, 300));\r\n      }\r\n    } catch (error) {\r\n      console.warn('Beep sound failed:', error);\r\n      // Fallback: create a brief pause\r\n      return new Promise<void>(resolve => setTimeout(resolve, 300));\r\n    }\r\n  }, [speech.isLoading, speech.error, speech.playBeep]);\r\n\r\n  // Stop beep sound immediately\r\n  const stopBeep = useCallback(() => {\r\n    // Simple plugin system handles stopping internally\r\n    speech.stopAll();\r\n  }, [speech.stopAll]);\r\n\r\n  // Auto-flow for speaking mode with better error handling\r\n  const startAutoFlow = useCallback(async (koreanText: string, onReadyForSpeech?: () => void) => {\r\n    if (speech.isLoading || speech.error) {\r\n      const error = new Error(speech.error || 'Speech plugin not ready');\r\n      setState(prev => ({ ...prev, error: error.message }));\r\n      throw error;\r\n    }\r\n\r\n    try {\r\n      setState(prev => ({ ...prev, error: null }));\r\n      \r\n      // Step 1: Play Korean TTS with timeout protection\r\n      const ttsPromise = speak(koreanText, { lang: 'ko-KR' });\r\n      const timeoutPromise = new Promise<void>((_, reject) => \r\n        setTimeout(() => reject(new Error('TTS 시간 초과')), 10000)\r\n      );\r\n      \r\n      await Promise.race([ttsPromise, timeoutPromise]);\r\n      \r\n      // Small delay to ensure TTS is completely finished\r\n      await new Promise(resolve => setTimeout(resolve, 200));\r\n      \r\n      // Step 2: Play beep sound\r\n      await playBeep();\r\n      \r\n      // Small delay after beep\r\n      await new Promise(resolve => setTimeout(resolve, 300));\r\n      \r\n      // Step 3: Callback to indicate ready for speech\r\n      if (onReadyForSpeech) {\r\n        onReadyForSpeech();\r\n      }\r\n      \r\n    } catch (error) {\r\n      setState(prev => ({\r\n        ...prev,\r\n        error: error instanceof Error ? error.message : '자동 플로우 실행 실패',\r\n      }));\r\n      throw error; // Re-throw to allow component to handle state reset\r\n    }\r\n  }, [speech.isLoading, speech.error, speak, playBeep]);\r\n\r\n  // TTS control methods (simplified - the simple plugin system handles these internally)\r\n  const pauseTTS = useCallback(() => {\r\n    // Simple plugin doesn't expose pause/resume, so we stop instead\r\n    speech.stopAll();\r\n  }, [speech.stopAll]);\r\n\r\n  const resumeTTS = useCallback(() => {\r\n    // Resume not directly supported in simple plugin\r\n    console.warn('Resume TTS not supported in simple plugin system');\r\n  }, []);\r\n\r\n  const isTTSPaused = useCallback(() => {\r\n    // Simple plugin doesn't track paused state\r\n    return false;\r\n  }, []);\r\n\r\n  const isTTSSpeaking = useCallback(() => {\r\n    return speech.isProcessing;\r\n  }, [speech.isProcessing]);\r\n\r\n  // Stop all speech activities\r\n  const stopAll = useCallback(() => {\r\n    speech.stopAll();\r\n    \r\n    // Cancel active operations\r\n    if (activeRecognitionRef.current) {\r\n      activeRecognitionRef.current.abort();\r\n      activeRecognitionRef.current = null;\r\n    }\r\n    if (activeTTSRef.current) {\r\n      activeTTSRef.current.abort();\r\n      activeTTSRef.current = null;\r\n    }\r\n\r\n    setState(prev => ({\r\n      ...prev,\r\n      isRecording: false,\r\n      isProcessing: false,\r\n    }));\r\n  }, [speech.stopAll]);\r\n\r\n  // Clear error\r\n  const clearError = useCallback(() => {\r\n    setState(prev => ({ ...prev, error: null }));\r\n  }, []);\r\n\r\n  // Get available TTS voices (not directly supported in simple plugin)\r\n  const getVoices = useCallback(() => {\r\n    return [];\r\n  }, []);\r\n\r\n  return {\r\n    // State\r\n    ...state,\r\n    \r\n    // Capabilities\r\n    isSTTAvailable,\r\n    isTTSAvailable,\r\n    \r\n    // Actions\r\n    startRecording,\r\n    stopRecording,\r\n    speak,\r\n    playBeep,\r\n    stopBeep,\r\n    startAutoFlow,\r\n    stopAll,\r\n    clearError,\r\n    getVoices,\r\n    \r\n    // TTS Control\r\n    pauseTTS,\r\n    resumeTTS,\r\n    isTTSPaused,\r\n    isTTSSpeaking,\r\n  };\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useSpeechRecognition.ts","messages":[{"ruleId":"no-undef","severity":1,"message":"'PermissionState' is not defined.","line":89,"column":44,"nodeType":"Identifier","messageId":"undef","endLine":89,"endColumn":59},{"ruleId":"no-undef","severity":1,"message":"'PermissionState' is not defined.","line":264,"column":67,"nodeType":"Identifier","messageId":"undef","endLine":264,"endColumn":82},{"ruleId":"no-undef","severity":1,"message":"'PermissionName' is not defined.","line":266,"column":80,"nodeType":"Identifier","messageId":"undef","endLine":266,"endColumn":94},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'setupEventHandlers'. Either include it or remove the dependency array.","line":364,"column":6,"nodeType":"ArrayExpression","endLine":364,"endColumn":114,"suggestions":[{"desc":"Update the dependencies array to be: [getBrowserSupport, setError, continuous, interimResults, language, maxAlternatives, setupEventHandlers, updateState, debugMode]","fix":{"range":[9817,9925],"text":"[getBrowserSupport, setError, continuous, interimResults, language, maxAlternatives, setupEventHandlers, updateState, debugMode]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has missing dependencies: 'endAudioLatency', 'maxAlternatives', 'measureAudioLatency', 'resetSilenceTimer', 'restartListening', and 'startSilenceTimer'. Either include them or remove the dependency array.","line":534,"column":6,"nodeType":"ArrayExpression","endLine":538,"endColumn":4,"suggestions":[{"desc":"Update the dependencies array to be: [measureAudioLatency, updateState, debugMode, onStart, language, continuous, state.totalRecognitionTime, autoRestart, maxRestarts, onEnd, restartDelay, restartListening, maxAlternatives, minConfidence, endAudioLatency, onResult, resetSilenceTimer, setError, onSpeechStart, startSilenceTimer, onSpeechEnd, onSoundStart, onSoundEnd]","fix":{"range":[15161,15402],"text":"[measureAudioLatency, updateState, debugMode, onStart, language, continuous, state.totalRecognitionTime, autoRestart, maxRestarts, onEnd, restartDelay, restartListening, maxAlternatives, minConfidence, endAudioLatency, onResult, resetSilenceTimer, setError, onSpeechStart, startSilenceTimer, onSpeechEnd, onSoundStart, onSoundEnd]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'stopListening'. Either include it or remove the dependency array.","line":560,"column":6,"nodeType":"ArrayExpression","endLine":560,"endColumn":52,"suggestions":[{"desc":"Update the dependencies array to be: [resetSilenceTimer, silenceTimeout, debugMode, stopListening]","fix":{"range":[15946,15992],"text":"[resetSilenceTimer, silenceTimeout, debugMode, stopListening]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'endAudioLatency'. Either include it or remove the dependency array.","line":648,"column":6,"nodeType":"ArrayExpression","endLine":648,"endColumn":36,"suggestions":[{"desc":"Update the dependencies array to be: [resetSilenceTimer, debugMode, endAudioLatency]","fix":{"range":[18342,18372],"text":"[resetSilenceTimer, debugMode, endAudioLatency]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":754,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":754,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @fileoverview 음성 인식 Hook - 전문적인 에러 처리 및 성능 모니터링 포함\r\n * @description Web Speech API를 사용한 음성 인식 기능을 관리하는 커스텀 Hook\r\n * @author DaSiStart Team\r\n * @version 2.0.0\r\n */\r\n\r\nimport { useState, useCallback, useRef, useEffect } from 'react';\r\nimport { \r\n  handleSpeechError,\r\n  handleError,\r\n  ErrorType,\r\n  LogCategory,\r\n  logInfo,\r\n  logError,\r\n  logWarn,\r\n  speechLogger,\r\n  type StructuredError\r\n} from '../utils/index.ts';\r\nimport { usePerformanceMonitoring } from './usePerformanceMonitoring';\r\n\r\n// ====== 타입 정의 ======\r\n\r\nexport interface SpeechRecognitionState {\r\n  // 인식 상태\r\n  isListening: boolean;\r\n  isSupported: boolean;\r\n  isInitialized: boolean;\r\n  \r\n  // 결과\r\n  transcript: string;\r\n  interimTranscript: string;\r\n  finalTranscript: string;\r\n  confidence: number;\r\n  \r\n  // 에러 및 성능\r\n  error: StructuredError | null;\r\n  lastRecognitionTime: number;\r\n  \r\n  // 통계\r\n  recognitionCount: number;\r\n  averageConfidence: number;\r\n  totalRecognitionTime: number;\r\n}\r\n\r\nexport interface SpeechRecognitionOptions {\r\n  // 기본 설정\r\n  continuous?: boolean;\r\n  interimResults?: boolean;\r\n  language?: string;\r\n  maxAlternatives?: number;\r\n  \r\n  // 성능 설정\r\n  autoRestart?: boolean;\r\n  restartDelay?: number;\r\n  maxRestarts?: number;\r\n  \r\n  // 필터링 설정\r\n  minConfidence?: number;\r\n  enableNoiseReduction?: boolean;\r\n  silenceTimeout?: number;\r\n  \r\n  // 콜백 함수들\r\n  onStart?: () => void;\r\n  onEnd?: () => void;\r\n  onResult?: (transcript: string, isFinal: boolean, confidence: number) => void;\r\n  onError?: (error: StructuredError) => void;\r\n  onSpeechStart?: () => void;\r\n  onSpeechEnd?: () => void;\r\n  onSoundStart?: () => void;\r\n  onSoundEnd?: () => void;\r\n  \r\n  // 디버그\r\n  debugMode?: boolean;\r\n}\r\n\r\nexport interface SpeechRecognitionActions {\r\n  // 기본 액션\r\n  startListening: () => Promise<boolean>;\r\n  stopListening: () => void;\r\n  restartListening: () => Promise<boolean>;\r\n  \r\n  // 상태 관리\r\n  resetTranscript: () => void;\r\n  clearError: () => void;\r\n  \r\n  // 권한 및 설정\r\n  requestMicrophonePermission: () => Promise<boolean>;\r\n  checkMicrophonePermission: () => Promise<PermissionState>;\r\n  \r\n  // 유틸리티\r\n  getBrowserSupport: () => BrowserSupportInfo;\r\n  getRecognitionStatistics: () => RecognitionStatistics;\r\n  exportRecognitionData: () => any;\r\n}\r\n\r\nexport interface BrowserSupportInfo {\r\n  isSupported: boolean;\r\n  isChrome: boolean;\r\n  isEdge: boolean;\r\n  isSafari: boolean;\r\n  isFirefox: boolean;\r\n  isMobile: boolean;\r\n  recommendation: string;\r\n  supportedFeatures: string[];\r\n  limitations: string[];\r\n}\r\n\r\nexport interface RecognitionStatistics {\r\n  totalRecognitions: number;\r\n  averageConfidence: number;\r\n  averageRecognitionTime: number;\r\n  successRate: number;\r\n  errorCount: number;\r\n  lastRecognitionTime: number;\r\n  totalListeningTime: number;\r\n}\r\n\r\nexport interface SpeechRecognitionHookResult extends SpeechRecognitionState, SpeechRecognitionActions {\r\n  // 계산된 값들\r\n  fullTranscript: string;\r\n  hasTranscript: boolean;\r\n  isSpeaking: boolean;\r\n  isProcessing: boolean;\r\n  canStart: boolean;\r\n  \r\n  // 설정 정보\r\n  config: Required<SpeechRecognitionOptions>;\r\n}\r\n\r\n// ====== 메인 Hook ======\r\n\r\nexport const useSpeechRecognition = (options: SpeechRecognitionOptions = {}): SpeechRecognitionHookResult => {\r\n  const {\r\n    continuous = true,\r\n    interimResults = true,\r\n    language = 'ko-KR',\r\n    maxAlternatives = 3,\r\n    autoRestart = true,\r\n    restartDelay = 1000,\r\n    maxRestarts = 5,\r\n    minConfidence = 0.3,\r\n    enableNoiseReduction = true,\r\n    silenceTimeout = 5000,\r\n    onStart,\r\n    onEnd,\r\n    onResult,\r\n    onError,\r\n    onSpeechStart,\r\n    onSpeechEnd,\r\n    onSoundStart,\r\n    onSoundEnd,\r\n    debugMode = process.env.NODE_ENV === 'development'\r\n  } = options;\r\n\r\n  // ✅ CLAUDE.local 준수: 플러그인 기반 성능 모니터링\r\n  const { measureRender, measureAudioLatency, endAudioLatency } = usePerformanceMonitoring('useSpeechRecognition');\r\n\r\n  // ====== 상태 관리 ======\r\n\r\n  const [state, setState] = useState<SpeechRecognitionState>({\r\n    isListening: false,\r\n    isSupported: false,\r\n    isInitialized: false,\r\n    transcript: '',\r\n    interimTranscript: '',\r\n    finalTranscript: '',\r\n    confidence: 0,\r\n    error: null,\r\n    lastRecognitionTime: 0,\r\n    recognitionCount: 0,\r\n    averageConfidence: 0,\r\n    totalRecognitionTime: 0\r\n  });\r\n\r\n  // ====== Refs ======\r\n\r\n  const recognitionRef = useRef<any>(null);\r\n  const isManualStop = useRef(false);\r\n  const restartCount = useRef(0);\r\n  const recognitionStartTime = useRef<number>(0);\r\n  const confidenceScores = useRef<number[]>([]);\r\n  const recognitionTimes = useRef<number[]>([]);\r\n  const silenceTimer = useRef<NodeJS.Timeout | null>(null);\r\n  const measurementId = useRef<string | null>(null);\r\n\r\n  // ====== 유틸리티 함수 ======\r\n\r\n  const updateState = useCallback((updates: Partial<SpeechRecognitionState>) => {\r\n    setState(prev => ({ ...prev, ...updates }));\r\n  }, []);\r\n\r\n  const setError = useCallback((error: StructuredError | null) => {\r\n    updateState({ error });\r\n    \r\n    if (error) {\r\n      logError(LogCategory.SPEECH, error.message, error.originalError, {\r\n        component: 'useSpeechRecognition',\r\n        action: error.context?.action || 'unknown'\r\n      });\r\n      onError?.(error);\r\n    }\r\n  }, [updateState, onError]);\r\n\r\n  const clearError = useCallback(() => {\r\n    setError(null);\r\n  }, [setError]);\r\n\r\n  // ====== 브라우저 호환성 체크 ======\r\n\r\n  const getBrowserSupport = useCallback((): BrowserSupportInfo => {\r\n    const userAgent = navigator.userAgent;\r\n    const isChrome = /Chrome/.test(userAgent) && !/Edg/.test(userAgent);\r\n    const isEdge = /Edg/.test(userAgent);\r\n    const isSafari = /Safari/.test(userAgent) && !/Chrome/.test(userAgent);\r\n    const isFirefox = /Firefox/.test(userAgent);\r\n    const isMobile = /Mobile|Android|iOS/.test(userAgent);\r\n    \r\n    const isSupported = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;\r\n    \r\n    const supportedFeatures: string[] = [];\r\n    const limitations: string[] = [];\r\n    \r\n    if (isSupported) {\r\n      supportedFeatures.push('음성 인식');\r\n      if (continuous) supportedFeatures.push('연속 인식');\r\n      if (interimResults) supportedFeatures.push('실시간 결과');\r\n    }\r\n    \r\n    if (!isSupported) {\r\n      limitations.push('음성 인식 미지원');\r\n    }\r\n    if (isSafari) {\r\n      limitations.push('Safari에서 제한적 지원');\r\n    }\r\n    if (isMobile && !isChrome) {\r\n      limitations.push('모바일에서 제한적 지원');\r\n    }\r\n    \r\n    let recommendation = '';\r\n    if (!isSupported) {\r\n      recommendation = 'Chrome 또는 Edge 브라우저를 사용하시기 바랍니다.';\r\n    } else if (isSafari || isFirefox) {\r\n      recommendation = '최적의 성능을 위해 Chrome 브라우저를 권장합니다.';\r\n    } else {\r\n      recommendation = '지원되는 브라우저입니다.';\r\n    }\r\n\r\n    return {\r\n      isSupported,\r\n      isChrome,\r\n      isEdge,\r\n      isSafari,\r\n      isFirefox,\r\n      isMobile,\r\n      recommendation,\r\n      supportedFeatures,\r\n      limitations\r\n    };\r\n  }, [continuous, interimResults]);\r\n\r\n  // ====== 권한 관리 ======\r\n\r\n  const checkMicrophonePermission = useCallback(async (): Promise<PermissionState> => {\r\n    try {\r\n      const result = await navigator.permissions.query({ name: 'microphone' as PermissionName });\r\n      return result.state;\r\n    } catch (error) {\r\n      logWarn(LogCategory.SPEECH, '마이크 권한 상태 확인 실패', error);\r\n      return 'prompt';\r\n    }\r\n  }, []);\r\n\r\n  const requestMicrophonePermission = useCallback(async (): Promise<boolean> => {\r\n    try {\r\n      const stream = await navigator.mediaDevices.getUserMedia({ \r\n        audio: {\r\n          echoCancellation: enableNoiseReduction,\r\n          noiseSuppression: enableNoiseReduction,\r\n          autoGainControl: enableNoiseReduction\r\n        }\r\n      });\r\n      \r\n      // 권한 확인 후 스트림 정리\r\n      stream.getTracks().forEach(track => track.stop());\r\n      \r\n      speechLogger.start({ \r\n        language, \r\n        continuous, \r\n        interimResults,\r\n        enableNoiseReduction\r\n      });\r\n\r\n      return true;\r\n    } catch (error: any) {\r\n      const structuredError = handleSpeechError(error, {\r\n        component: 'useSpeechRecognition',\r\n        action: 'requestMicrophonePermission'\r\n      });\r\n      \r\n      setError(structuredError);\r\n      return false;\r\n    }\r\n  }, [enableNoiseReduction, language, continuous, interimResults, setError]);\r\n\r\n  // ====== 음성 인식 초기화 ======\r\n\r\n  const initializeRecognition = useCallback(() => {\r\n    const browserSupport = getBrowserSupport();\r\n    \r\n    if (!browserSupport.isSupported) {\r\n      const error = handleError(\r\n        ErrorType.SPEECH_NOT_SUPPORTED,\r\n        '이 브라우저에서는 음성 인식을 지원하지 않습니다.',\r\n        { \r\n          component: 'useSpeechRecognition', \r\n          action: 'initialize',\r\n          additionalData: browserSupport\r\n        }\r\n      );\r\n      setError(error);\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;\r\n      \r\n      recognitionRef.current = new SpeechRecognition();\r\n      \r\n      // 기본 설정\r\n      recognitionRef.current.continuous = continuous;\r\n      recognitionRef.current.interimResults = interimResults;\r\n      recognitionRef.current.lang = language;\r\n      recognitionRef.current.maxAlternatives = maxAlternatives;\r\n\r\n      // 이벤트 핸들러 설정\r\n      setupEventHandlers();\r\n      \r\n      updateState({ \r\n        isSupported: true, \r\n        isInitialized: true,\r\n        error: null\r\n      });\r\n\r\n      if (debugMode) {\r\n        logInfo(LogCategory.SPEECH, '음성 인식 초기화 완료', {\r\n          continuous,\r\n          interimResults,\r\n          language,\r\n          maxAlternatives\r\n        });\r\n      }\r\n\r\n      return true;\r\n    } catch (error: any) {\r\n      const structuredError = handleError(\r\n        ErrorType.SPEECH_SERVICE_ERROR,\r\n        error,\r\n        { component: 'useSpeechRecognition', action: 'initialize' }\r\n      );\r\n      setError(structuredError);\r\n      return false;\r\n    }\r\n  }, [getBrowserSupport, continuous, interimResults, language, maxAlternatives, debugMode, updateState, setError]);\r\n\r\n  // ====== 이벤트 핸들러 설정 ======\r\n\r\n  const setupEventHandlers = useCallback(() => {\r\n    if (!recognitionRef.current) return;\r\n\r\n    recognitionRef.current.onstart = async () => {\r\n      recognitionStartTime.current = Date.now();\r\n      \r\n      // ✅ CLAUDE.local 준수: 플러그인을 통한 음성 인식 지연 측정 시작\r\n      measurementId.current = await measureAudioLatency();\r\n      \r\n      updateState({ \r\n        isListening: true, \r\n        error: null,\r\n        lastRecognitionTime: Date.now()\r\n      });\r\n      \r\n      if (debugMode) {\r\n        speechLogger.start({ language, continuous });\r\n      }\r\n      \r\n      onStart?.();\r\n    };\r\n\r\n    recognitionRef.current.onend = () => {\r\n      const recognitionTime = Date.now() - recognitionStartTime.current;\r\n      recognitionTimes.current.push(recognitionTime);\r\n      \r\n      updateState({ \r\n        isListening: false,\r\n        totalRecognitionTime: state.totalRecognitionTime + recognitionTime\r\n      });\r\n      \r\n      // 자동 재시작 처리\r\n      if (!isManualStop.current && autoRestart && restartCount.current < maxRestarts) {\r\n        setTimeout(() => {\r\n          if (!isManualStop.current && recognitionRef.current) {\r\n            restartListening();\r\n          }\r\n        }, restartDelay);\r\n      } else if (restartCount.current >= maxRestarts) {\r\n        logWarn(LogCategory.SPEECH, '최대 재시작 횟수 도달', {\r\n          restartCount: restartCount.current,\r\n          maxRestarts\r\n        });\r\n      }\r\n      \r\n      onEnd?.();\r\n    };\r\n\r\n    recognitionRef.current.onresult = (event: any) => {\r\n      let finalTranscript = '';\r\n      let interimTranscript = '';\r\n      let maxConfidence = 0;\r\n      const alternatives: Array<{ text: string; confidence: number }> = [];\r\n\r\n      // 결과 처리\r\n      for (let i = event.resultIndex; i < event.results.length; i++) {\r\n        const result = event.results[i];\r\n        \r\n        // 모든 대안 수집\r\n        for (let j = 0; j < result.length && j < maxAlternatives; j++) {\r\n          const alternative = result[j];\r\n          alternatives.push({\r\n            text: alternative.transcript,\r\n            confidence: alternative.confidence || 0\r\n          });\r\n        }\r\n        \r\n        const transcript = result[0].transcript;\r\n        const confidence = result[0].confidence || 0;\r\n\r\n        if (result.isFinal) {\r\n          // 최소 신뢰도 필터링\r\n          if (confidence >= minConfidence) {\r\n            finalTranscript += transcript;\r\n            maxConfidence = Math.max(maxConfidence, confidence);\r\n            confidenceScores.current.push(confidence);\r\n            \r\n            // ✅ CLAUDE.local 준수: 플러그인을 통한 음성 인식 지연 측정 종료\r\n            if (measurementId.current) {\r\n              await endAudioLatency(measurementId.current, transcript);\r\n              measurementId.current = null;\r\n            }\r\n            \r\n            speechLogger.result(transcript, confidence);\r\n          } else if (debugMode) {\r\n            logWarn(LogCategory.SPEECH, '낮은 신뢰도로 결과 무시', {\r\n              transcript,\r\n              confidence,\r\n              minConfidence\r\n            });\r\n          }\r\n        } else {\r\n          interimTranscript += transcript;\r\n        }\r\n      }\r\n\r\n      // 상태 업데이트\r\n      if (finalTranscript || interimTranscript) {\r\n        updateState(prev => ({\r\n          transcript: prev.transcript + finalTranscript,\r\n          interimTranscript,\r\n          finalTranscript: prev.finalTranscript + finalTranscript,\r\n          confidence: maxConfidence,\r\n          recognitionCount: finalTranscript ? prev.recognitionCount + 1 : prev.recognitionCount,\r\n          averageConfidence: confidenceScores.current.length > 0 \r\n            ? confidenceScores.current.reduce((sum, conf) => sum + conf, 0) / confidenceScores.current.length \r\n            : 0\r\n        }));\r\n\r\n        // 콜백 호출\r\n        if (finalTranscript) {\r\n          onResult?.(finalTranscript, true, maxConfidence);\r\n          resetSilenceTimer();\r\n        } else if (interimTranscript) {\r\n          onResult?.(interimTranscript, false, 0);\r\n          resetSilenceTimer();\r\n        }\r\n      }\r\n    };\r\n\r\n    recognitionRef.current.onerror = (event: any) => {\r\n      const structuredError = handleSpeechError(event, {\r\n        component: 'useSpeechRecognition',\r\n        action: 'recognition',\r\n        additionalData: {\r\n          restartCount: restartCount.current,\r\n          language,\r\n          continuous\r\n        }\r\n      });\r\n      \r\n      setError(structuredError);\r\n      \r\n      // 특정 에러에 대한 자동 복구 시도\r\n      if (event.error === 'no-speech' && autoRestart && restartCount.current < maxRestarts) {\r\n        setTimeout(() => {\r\n          if (!isManualStop.current) {\r\n            restartListening();\r\n          }\r\n        }, restartDelay);\r\n      }\r\n    };\r\n\r\n    recognitionRef.current.onnomatch = () => {\r\n      if (debugMode) {\r\n        logWarn(LogCategory.SPEECH, '음성 인식 매치 없음');\r\n      }\r\n    };\r\n\r\n    recognitionRef.current.onspeechstart = () => {\r\n      resetSilenceTimer();\r\n      onSpeechStart?.();\r\n    };\r\n\r\n    recognitionRef.current.onspeechend = () => {\r\n      startSilenceTimer();\r\n      onSpeechEnd?.();\r\n    };\r\n\r\n    recognitionRef.current.onsoundstart = () => {\r\n      onSoundStart?.();\r\n    };\r\n\r\n    recognitionRef.current.onsoundend = () => {\r\n      onSoundEnd?.();\r\n    };\r\n  }, [\r\n    language, continuous, autoRestart, maxRestarts, restartDelay, minConfidence, \r\n    debugMode, updateState, setError, onStart, onEnd, onResult, onSpeechStart, \r\n    onSpeechEnd, onSoundStart, onSoundEnd, state.totalRecognitionTime\r\n  ]);\r\n\r\n  // ====== 침묵 타이머 관리 ======\r\n\r\n  const resetSilenceTimer = useCallback(() => {\r\n    if (silenceTimer.current) {\r\n      clearTimeout(silenceTimer.current);\r\n      silenceTimer.current = null;\r\n    }\r\n  }, []);\r\n\r\n  const startSilenceTimer = useCallback(() => {\r\n    resetSilenceTimer();\r\n    \r\n    if (silenceTimeout > 0) {\r\n      silenceTimer.current = setTimeout(() => {\r\n        if (debugMode) {\r\n          logInfo(LogCategory.SPEECH, '침묵 타임아웃으로 인한 인식 중지');\r\n        }\r\n        stopListening();\r\n      }, silenceTimeout);\r\n    }\r\n  }, [resetSilenceTimer, silenceTimeout, debugMode]);\r\n\r\n  // ====== 주요 액션 함수들 ======\r\n\r\n  const startListening = useCallback(async (): Promise<boolean> => {\r\n    const endRenderMeasure = measureRender(1, 'startListening');\r\n    \r\n    try {\r\n      if (!state.isInitialized && !initializeRecognition()) {\r\n        return false;\r\n      }\r\n\r\n      if (!recognitionRef.current || !state.isSupported) {\r\n        const error = handleError(\r\n          ErrorType.SPEECH_NOT_SUPPORTED,\r\n          '음성 인식을 사용할 수 없습니다.',\r\n          { component: 'useSpeechRecognition', action: 'startListening' }\r\n        );\r\n        setError(error);\r\n        return false;\r\n      }\r\n\r\n      if (state.isListening) {\r\n        if (debugMode) {\r\n          logInfo(LogCategory.SPEECH, '이미 음성 인식이 실행 중입니다.');\r\n        }\r\n        return true;\r\n      }\r\n\r\n      // 마이크 권한 확인\r\n      const hasPermission = await requestMicrophonePermission();\r\n      if (!hasPermission) {\r\n        return false;\r\n      }\r\n\r\n      isManualStop.current = false;\r\n      restartCount.current = 0;\r\n      clearError();\r\n\r\n      recognitionRef.current.start();\r\n      \r\n      if (debugMode) {\r\n        logInfo(LogCategory.SPEECH, '음성 인식 시작', {\r\n          language,\r\n          continuous,\r\n          interimResults\r\n        });\r\n      }\r\n\r\n      return true;\r\n    } catch (error: any) {\r\n      const structuredError = handleSpeechError(error, {\r\n        component: 'useSpeechRecognition',\r\n        action: 'startListening'\r\n      });\r\n      \r\n      setError(structuredError);\r\n      return false;\r\n    } finally {\r\n      endRenderMeasure();\r\n    }\r\n  }, [\r\n    state.isInitialized, state.isSupported, state.isListening, initializeRecognition,\r\n    requestMicrophonePermission, clearError, setError, debugMode, language,\r\n    continuous, interimResults, measureRender\r\n  ]);\r\n\r\n  const stopListening = useCallback(() => {\r\n    if (!recognitionRef.current) return;\r\n\r\n    try {\r\n      isManualStop.current = true;\r\n      resetSilenceTimer();\r\n      \r\n      // ✅ CLAUDE.local 준수: 플러그인을 통한 측정 정리\r\n      if (measurementId.current) {\r\n        await endAudioLatency(measurementId.current);\r\n        measurementId.current = null;\r\n      }\r\n\r\n      recognitionRef.current.stop();\r\n      \r\n      if (debugMode) {\r\n        logInfo(LogCategory.SPEECH, '음성 인식 중지');\r\n      }\r\n    } catch (error: any) {\r\n      logWarn(LogCategory.SPEECH, '음성 인식 중지 실패', error);\r\n    }\r\n  }, [resetSilenceTimer, debugMode]);\r\n\r\n  const restartListening = useCallback(async (): Promise<boolean> => {\r\n    if (restartCount.current >= maxRestarts) {\r\n      const error = handleError(\r\n        ErrorType.SPEECH_SERVICE_ERROR,\r\n        '최대 재시작 횟수를 초과했습니다.',\r\n        { \r\n          component: 'useSpeechRecognition', \r\n          action: 'restartListening',\r\n          additionalData: { restartCount: restartCount.current, maxRestarts }\r\n        }\r\n      );\r\n      setError(error);\r\n      return false;\r\n    }\r\n\r\n    stopListening();\r\n    \r\n    // 짧은 지연 후 재시작\r\n    await new Promise(resolve => setTimeout(resolve, restartDelay));\r\n    \r\n    restartCount.current++;\r\n    \r\n    if (debugMode) {\r\n      logInfo(LogCategory.SPEECH, '음성 인식 재시작', {\r\n        restartCount: restartCount.current,\r\n        maxRestarts\r\n      });\r\n    }\r\n\r\n    return startListening();\r\n  }, [maxRestarts, stopListening, restartDelay, startListening, setError, debugMode]);\r\n\r\n  const resetTranscript = useCallback(() => {\r\n    updateState({\r\n      transcript: '',\r\n      interimTranscript: '',\r\n      finalTranscript: '',\r\n      confidence: 0\r\n    });\r\n    \r\n    if (debugMode) {\r\n      logInfo(LogCategory.SPEECH, '음성 인식 결과 초기화');\r\n    }\r\n  }, [updateState, debugMode]);\r\n\r\n  // ====== 통계 및 유틸리티 ======\r\n\r\n  const getRecognitionStatistics = useCallback((): RecognitionStatistics => {\r\n    const successRate = state.recognitionCount > 0 \r\n      ? (confidenceScores.current.filter(score => score >= minConfidence).length / state.recognitionCount) * 100 \r\n      : 0;\r\n    \r\n    const averageRecognitionTime = recognitionTimes.current.length > 0\r\n      ? recognitionTimes.current.reduce((sum, time) => sum + time, 0) / recognitionTimes.current.length\r\n      : 0;\r\n\r\n    return {\r\n      totalRecognitions: state.recognitionCount,\r\n      averageConfidence: state.averageConfidence,\r\n      averageRecognitionTime,\r\n      successRate,\r\n      errorCount: state.error ? 1 : 0,\r\n      lastRecognitionTime: state.lastRecognitionTime,\r\n      totalListeningTime: state.totalRecognitionTime\r\n    };\r\n  }, [state.recognitionCount, state.averageConfidence, state.error, state.lastRecognitionTime, state.totalRecognitionTime, minConfidence]);\r\n\r\n  const exportRecognitionData = useCallback(() => {\r\n    return {\r\n      state,\r\n      statistics: getRecognitionStatistics(),\r\n      browserSupport: getBrowserSupport(),\r\n      confidenceHistory: confidenceScores.current,\r\n      recognitionTimeHistory: recognitionTimes.current,\r\n      config: {\r\n        continuous,\r\n        interimResults,\r\n        language,\r\n        maxAlternatives,\r\n        autoRestart,\r\n        restartDelay,\r\n        maxRestarts,\r\n        minConfidence,\r\n        enableNoiseReduction,\r\n        silenceTimeout\r\n      },\r\n      exportTime: new Date().toISOString()\r\n    };\r\n  }, [\r\n    state, getRecognitionStatistics, getBrowserSupport,\r\n    continuous, interimResults, language, maxAlternatives,\r\n    autoRestart, restartDelay, maxRestarts, minConfidence,\r\n    enableNoiseReduction, silenceTimeout\r\n  ]);\r\n\r\n  // ====== 초기화 Effect ======\r\n\r\n  useEffect(() => {\r\n    initializeRecognition();\r\n    \r\n    return () => {\r\n      if (recognitionRef.current) {\r\n        try {\r\n          recognitionRef.current.stop();\r\n        } catch (error) {\r\n          // 정리 중 에러는 무시\r\n        }\r\n      }\r\n      resetSilenceTimer();\r\n    };\r\n  }, [initializeRecognition, resetSilenceTimer]);\r\n\r\n  // ====== 계산된 값들 ======\r\n\r\n  const fullTranscript = state.transcript + state.interimTranscript;\r\n  const hasTranscript = fullTranscript.trim().length > 0;\r\n  const isSpeaking = state.interimTranscript.length > 0;\r\n  const isProcessing = state.isListening && !isSpeaking;\r\n  const canStart = state.isSupported && !state.isListening && !state.error;\r\n\r\n  const config: Required<SpeechRecognitionOptions> = {\r\n    continuous,\r\n    interimResults,\r\n    language,\r\n    maxAlternatives,\r\n    autoRestart,\r\n    restartDelay,\r\n    maxRestarts,\r\n    minConfidence,\r\n    enableNoiseReduction,\r\n    silenceTimeout,\r\n    onStart: onStart || (() => {}),\r\n    onEnd: onEnd || (() => {}),\r\n    onResult: onResult || (() => {}),\r\n    onError: onError || (() => {}),\r\n    onSpeechStart: onSpeechStart || (() => {}),\r\n    onSpeechEnd: onSpeechEnd || (() => {}),\r\n    onSoundStart: onSoundStart || (() => {}),\r\n    onSoundEnd: onSoundEnd || (() => {}),\r\n    debugMode\r\n  };\r\n\r\n  // ====== 반환 값 ======\r\n\r\n  return {\r\n    // 상태\r\n    ...state,\r\n    \r\n    // 계산된 값들\r\n    fullTranscript,\r\n    hasTranscript,\r\n    isSpeaking,\r\n    isProcessing,\r\n    canStart,\r\n    \r\n    // 설정\r\n    config,\r\n    \r\n    // 액션들\r\n    startListening,\r\n    stopListening,\r\n    restartListening,\r\n    resetTranscript,\r\n    clearError,\r\n    requestMicrophonePermission,\r\n    checkMicrophonePermission,\r\n    getBrowserSupport,\r\n    getRecognitionStatistics,\r\n    exportRecognitionData\r\n  };\r\n};\r\n\r\nexport default useSpeechRecognition;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useSpeechRecognitionSimple.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useSpeedTraining.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SpeedTrainingEvent' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DifficultyMode' is defined but never used. Allowed unused vars must match /^_/u.","line":20,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":17},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The ref value 'eventHandlersRef.current' will likely have changed by the time this effect cleanup function runs. If this ref points to a node rendered by React, copy 'eventHandlersRef.current' to a variable inside the effect, and use that variable in the cleanup function.","line":94,"column":26,"nodeType":"Identifier","endLine":94,"endColumn":33},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'getSessionProgress'. Either include it or remove the dependency array.","line":240,"column":6,"nodeType":"ArrayExpression","endLine":240,"endColumn":56,"suggestions":[{"desc":"Update the dependencies array to be: [state.plugin, state.currentSession, safeSetState, getSessionProgress]","fix":{"range":[7150,7200],"text":"[state.plugin, state.currentSession, safeSetState, getSessionProgress]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Speed Training Hook\r\n * @description SpeedTrainingPlugin을 React 컴포넌트에서 쉽게 사용할 수 있는 Hook\r\n * CLAUDE.local 규칙 준수: 플러그인 우선 아키텍처 + React Hook 패턴\r\n */\r\n\r\nimport { useState, useEffect, useCallback, useRef } from 'react';\r\nimport { getSpeedTrainingPlugin } from '@/plugins/PluginManager';\r\nimport { useAppStore } from '@/store/useAppStore';\r\nimport {\r\n  ISpeedTrainingPlugin,\r\n  SpeedSessionOptions,\r\n  SpeedTrainingResults,\r\n  SpeedTrainingEvent,\r\n  SpeedTrainingEventHandler\r\n} from '@/plugins/speed/ISpeedTrainingPlugin';\r\nimport {\r\n  SpeedSession,\r\n  SpeedResult,\r\n  DifficultyMode\r\n} from '@/services/speedDifficultyModes';\r\n\r\n// Hook 상태 타입\r\nexport interface UseSpeedTrainingState {\r\n  plugin: ISpeedTrainingPlugin | null;\r\n  isPluginLoading: boolean;\r\n  isPluginReady: boolean;\r\n  pluginError: string | null;\r\n  currentSession: SpeedSession | null;\r\n  sessionProgress: {\r\n    currentQuestionIndex: number;\r\n    totalQuestions: number;\r\n    correctAnswers: number;\r\n    timeElapsed: number;\r\n    estimatedTimeRemaining: number;\r\n  } | null;\r\n  isSessionActive: boolean;\r\n  isProcessingAnswer: boolean;\r\n}\r\n\r\n// Hook 액션 타입\r\nexport interface UseSpeedTrainingActions {\r\n  initializePlugin: () => Promise<boolean>;\r\n  createSession: (options: SpeedSessionOptions) => Promise<SpeedSession | null>;\r\n  processAnswer: (questionId: string, userAnswer: string, responseTime: number) => Promise<SpeedResult | null>;\r\n  completeSession: () => Promise<SpeedTrainingResults | null>;\r\n  getSessionProgress: () => Promise<void>;\r\n  getPerformanceStats: () => Promise<any>;\r\n  getRecommendedSettings: () => Promise<any>;\r\n  resetSession: () => void;\r\n  addEventListener: (handler: SpeedTrainingEventHandler) => void;\r\n  removeEventListener: (handler: SpeedTrainingEventHandler) => void;\r\n}\r\n\r\n// Hook 반환 타입\r\nexport type UseSpeedTrainingReturn = UseSpeedTrainingState & UseSpeedTrainingActions;\r\n\r\n// Default state\r\nconst DEFAULT_STATE: UseSpeedTrainingState = {\r\n  plugin: null,\r\n  isPluginLoading: false,\r\n  isPluginReady: false,\r\n  pluginError: null,\r\n  currentSession: null,\r\n  sessionProgress: null,\r\n  isSessionActive: false,\r\n  isProcessingAnswer: false\r\n};\r\n\r\n/**\r\n * Speed Training Hook\r\n * @param autoInitialize 자동으로 플러그인 초기화 여부 (기본값: true)\r\n */\r\nexport const useSpeedTraining = (autoInitialize: boolean = true): UseSpeedTrainingReturn => {\r\n  // State\r\n  const [state, setState] = useState<UseSpeedTrainingState>(DEFAULT_STATE);\r\n  \r\n  // Auth state\r\n  const { user } = useAppStore();\r\n  \r\n  // Refs for cleanup\r\n  const eventHandlersRef = useRef<Set<SpeedTrainingEventHandler>>(new Set());\r\n  const isMountedRef = useRef(true);\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      isMountedRef.current = false;\r\n      // Remove all event listeners\r\n      if (state.plugin) {\r\n        eventHandlersRef.current.forEach(handler => {\r\n          state.plugin!.offSessionEvent(handler);\r\n        });\r\n        eventHandlersRef.current.clear();\r\n      }\r\n    };\r\n  }, [state.plugin]);\r\n\r\n  // Safe state update (prevent updates after unmount)\r\n  const safeSetState = useCallback((updater: Partial<UseSpeedTrainingState>) => {\r\n    if (isMountedRef.current) {\r\n      setState(prev => ({ ...prev, ...updater }));\r\n    }\r\n  }, []);\r\n\r\n  // Plugin 초기화\r\n  const initializePlugin = useCallback(async (): Promise<boolean> => {\r\n    if (state.plugin && state.isPluginReady) {\r\n      return true;\r\n    }\r\n\r\n    safeSetState({ \r\n      isPluginLoading: true, \r\n      pluginError: null \r\n    });\r\n\r\n    try {\r\n      console.log('🚀 Initializing Speed Training Plugin...');\r\n      \r\n      const pluginResult = await getSpeedTrainingPlugin();\r\n      if (!pluginResult.success) {\r\n        throw pluginResult.error;\r\n      }\r\n\r\n      const plugin = pluginResult.data;\r\n      \r\n      safeSetState({\r\n        plugin,\r\n        isPluginLoading: false,\r\n        isPluginReady: true,\r\n        pluginError: null\r\n      });\r\n\r\n      console.log('✅ Speed Training Plugin initialized successfully');\r\n      return true;\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Failed to initialize plugin';\r\n      console.error('❌ Speed Training Plugin initialization failed:', error);\r\n      \r\n      safeSetState({\r\n        plugin: null,\r\n        isPluginLoading: false,\r\n        isPluginReady: false,\r\n        pluginError: errorMessage\r\n      });\r\n      \r\n      return false;\r\n    }\r\n  }, [state.plugin, state.isPluginReady, safeSetState]);\r\n\r\n  // Auto-initialization\r\n  useEffect(() => {\r\n    if (autoInitialize && !state.plugin && !state.isPluginLoading) {\r\n      initializePlugin();\r\n    }\r\n  }, [autoInitialize, state.plugin, state.isPluginLoading, initializePlugin]);\r\n\r\n  // 세션 생성\r\n  const createSession = useCallback(async (options: SpeedSessionOptions): Promise<SpeedSession | null> => {\r\n    if (!state.plugin || !state.isPluginReady) {\r\n      console.warn('⚠️ Speed Training Plugin not ready');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      console.log('🎯 Creating speed training session...', options);\r\n      \r\n      const sessionResult = await state.plugin.createSession(options);\r\n      if (!sessionResult.success) {\r\n        throw sessionResult.error;\r\n      }\r\n\r\n      const session = sessionResult.data;\r\n      \r\n      safeSetState({\r\n        currentSession: session,\r\n        isSessionActive: true,\r\n        sessionProgress: {\r\n          currentQuestionIndex: 0,\r\n          totalQuestions: session.questions.length,\r\n          correctAnswers: 0,\r\n          timeElapsed: 0,\r\n          estimatedTimeRemaining: session.questions.length * 5000 // 기본 5초 추정\r\n        }\r\n      });\r\n\r\n      console.log('✅ Speed training session created:', session.sessionId);\r\n      return session;\r\n    } catch (error) {\r\n      console.error('❌ Failed to create speed training session:', error);\r\n      return null;\r\n    }\r\n  }, [state.plugin, state.isPluginReady, safeSetState]);\r\n\r\n  // 답변 처리\r\n  const processAnswer = useCallback(async (\r\n    questionId: string,\r\n    userAnswer: string,\r\n    responseTime: number\r\n  ): Promise<SpeedResult | null> => {\r\n    if (!state.plugin || !state.currentSession) {\r\n      console.warn('⚠️ No active session or plugin not ready');\r\n      return null;\r\n    }\r\n\r\n    safeSetState({ isProcessingAnswer: true });\r\n\r\n    try {\r\n      console.log('📝 Processing answer...', { questionId, userAnswer, responseTime });\r\n      \r\n      const resultData = await state.plugin.processAnswer(\r\n        state.currentSession.sessionId,\r\n        questionId,\r\n        userAnswer,\r\n        responseTime\r\n      );\r\n\r\n      if (!resultData.success) {\r\n        throw resultData.error;\r\n      }\r\n\r\n      const result = resultData.data;\r\n      \r\n      // Update session progress\r\n      await getSessionProgress();\r\n\r\n      safeSetState({ isProcessingAnswer: false });\r\n      \r\n      console.log('✅ Answer processed:', { \r\n        isCorrect: result.isCorrect,\r\n        bonusPoints: result.bonusPoints \r\n      });\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('❌ Failed to process answer:', error);\r\n      safeSetState({ isProcessingAnswer: false });\r\n      return null;\r\n    }\r\n  }, [state.plugin, state.currentSession, safeSetState]);\r\n\r\n  // 세션 완료\r\n  const completeSession = useCallback(async (): Promise<SpeedTrainingResults | null> => {\r\n    if (!state.plugin || !state.currentSession) {\r\n      console.warn('⚠️ No active session or plugin not ready');\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      console.log('🏁 Completing speed training session...');\r\n      \r\n      const resultsData = await state.plugin.completeSession(state.currentSession.sessionId);\r\n      if (!resultsData.success) {\r\n        throw resultsData.error;\r\n      }\r\n\r\n      const results = resultsData.data;\r\n      \r\n      safeSetState({\r\n        isSessionActive: false,\r\n        currentSession: null,\r\n        sessionProgress: null\r\n      });\r\n\r\n      console.log('✅ Speed training session completed:', {\r\n        totalScore: results.totalScore,\r\n        accuracy: results.accuracy,\r\n        bonusPoints: results.bonusPoints\r\n      });\r\n      \r\n      return results;\r\n    } catch (error) {\r\n      console.error('❌ Failed to complete session:', error);\r\n      return null;\r\n    }\r\n  }, [state.plugin, state.currentSession, safeSetState]);\r\n\r\n  // 진행 상황 조회\r\n  const getSessionProgress = useCallback(async (): Promise<void> => {\r\n    if (!state.plugin || !state.currentSession) {\r\n      return;\r\n    }\r\n\r\n    try {\r\n      const progressResult = await state.plugin.getSessionProgress(state.currentSession.sessionId);\r\n      if (progressResult.success) {\r\n        safeSetState({\r\n          sessionProgress: progressResult.data\r\n        });\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ Failed to get session progress:', error);\r\n    }\r\n  }, [state.plugin, state.currentSession, safeSetState]);\r\n\r\n  // 성능 통계 조회\r\n  const getPerformanceStats = useCallback(async () => {\r\n    if (!state.plugin) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const userId = user.id || 'anonymous';\r\n      const statsResult = await state.plugin.getPerformanceStats(userId);\r\n      return statsResult.success ? statsResult.data : null;\r\n    } catch (error) {\r\n      console.error('❌ Failed to get performance stats:', error);\r\n      return null;\r\n    }\r\n  }, [state.plugin, user.id]);\r\n\r\n  // 추천 설정 조회\r\n  const getRecommendedSettings = useCallback(async () => {\r\n    if (!state.plugin) {\r\n      return null;\r\n    }\r\n\r\n    try {\r\n      const userId = user.id || 'anonymous';\r\n      const settingsResult = await state.plugin.getRecommendedSettings(userId);\r\n      return settingsResult.success ? settingsResult.data : null;\r\n    } catch (error) {\r\n      console.error('❌ Failed to get recommended settings:', error);\r\n      return null;\r\n    }\r\n  }, [state.plugin, user.id]);\r\n\r\n  // 세션 리셋\r\n  const resetSession = useCallback(() => {\r\n    safeSetState({\r\n      currentSession: null,\r\n      sessionProgress: null,\r\n      isSessionActive: false,\r\n      isProcessingAnswer: false\r\n    });\r\n  }, [safeSetState]);\r\n\r\n  // 이벤트 리스너 추가\r\n  const addEventListener = useCallback((handler: SpeedTrainingEventHandler) => {\r\n    if (state.plugin) {\r\n      state.plugin.onSessionEvent(handler);\r\n      eventHandlersRef.current.add(handler);\r\n    }\r\n  }, [state.plugin]);\r\n\r\n  // 이벤트 리스너 제거\r\n  const removeEventListener = useCallback((handler: SpeedTrainingEventHandler) => {\r\n    if (state.plugin) {\r\n      state.plugin.offSessionEvent(handler);\r\n      eventHandlersRef.current.delete(handler);\r\n    }\r\n  }, [state.plugin]);\r\n\r\n  return {\r\n    // State\r\n    ...state,\r\n    \r\n    // Actions\r\n    initializePlugin,\r\n    createSession,\r\n    processAnswer,\r\n    completeSession,\r\n    getSessionProgress,\r\n    getPerformanceStats,\r\n    getRecommendedSettings,\r\n    resetSession,\r\n    addEventListener,\r\n    removeEventListener\r\n  };\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useStageData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useStatistics.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useTheme.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useThemedStyles.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'personalTheme'. Either exclude it or remove the dependency array.","line":115,"column":6,"nodeType":"ArrayExpression","endLine":115,"endColumn":32,"suggestions":[{"desc":"Update the dependencies array to be: [themeMode]","fix":{"range":[3516,3542],"text":"[themeMode]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'personalTheme'. Either exclude it or remove the dependency array.","line":144,"column":6,"nodeType":"ArrayExpression","endLine":144,"endColumn":32,"suggestions":[{"desc":"Update the dependencies array to be: [themeMode]","fix":{"range":[4469,4495],"text":"[themeMode]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 테마 기반 스타일을 제공하는 Hook\r\n * 김대수님의 개인 맞춤 색상과 기본 깔끔한 테마 사이를 전환\r\n */\r\n\r\nimport { useMemo } from 'react';\r\nimport { useTheme } from '@/store/useAppStore';\r\n\r\nexport interface ThemedStyles {\r\n  // Background Colors\r\n  bgPrimary: string;\r\n  bgSecondary: string;\r\n  bgAccent: string;\r\n  bgBase: string;\r\n  \r\n  // Text Colors  \r\n  textPrimary: string;\r\n  textSecondary: string;\r\n  textAccent: string;\r\n  \r\n  // Border Colors\r\n  borderPrimary: string;\r\n  borderSecondary: string;\r\n  borderAccent: string;\r\n  \r\n  // Button Styles\r\n  primaryButton: string;\r\n  secondaryButton: string;\r\n  accentButton: string;\r\n  \r\n  // Hover Effects\r\n  hoverPrimary: string;\r\n  hoverSecondary: string;\r\n  hoverAccent: string;\r\n  \r\n  // Progress & Status\r\n  progressBar: string;\r\n  successColor: string;\r\n  warningColor: string;\r\n}\r\n\r\nexport const useThemedStyles = (): ThemedStyles => {\r\n  const { themeMode, personalTheme } = useTheme();\r\n  \r\n  const styles = useMemo(() => {\r\n    if (themeMode === 'personal') {\r\n      // 미정 테마 (기본 테마와 동일한 깔끔한 회색)\r\n      return {\r\n        // Background Colors\r\n        bgPrimary: '#f9fafb',      // 깔끔한 회색 배경\r\n        bgSecondary: '#ffffff',    // 흰색\r\n        bgAccent: '#6b7280',       // 중간 회색\r\n        bgBase: '#f9fafb',         // 연한 회색 (스피킹 화면과 동일)\r\n        \r\n        // Text Colors\r\n        textPrimary: '#374151',    // 짙은 회색\r\n        textSecondary: '#6b7280',  // 중간 회색\r\n        textAccent: '#4b5563',     // 어두운 회색\r\n        \r\n        // Border Colors\r\n        borderPrimary: '#e5e7eb',  // 연한 회색 테두리\r\n        borderSecondary: '#d1d5db', // 중간 회색 테두리\r\n        borderAccent: '#9ca3af',   // 짙은 회색 테두리\r\n        \r\n        // Button Styles\r\n        primaryButton: 'bg-gray-600 hover:bg-gray-700 text-white',\r\n        secondaryButton: 'bg-white hover:bg-gray-50 border border-gray-300 text-gray-700',\r\n        accentButton: 'bg-blue-500 hover:bg-blue-600 text-white',\r\n        \r\n        // Hover Effects\r\n        hoverPrimary: 'hover:border-gray-400',\r\n        hoverSecondary: 'hover:border-blue-400',\r\n        hoverAccent: 'hover:border-gray-500',\r\n        \r\n        // Progress & Status\r\n        progressBar: '#6b7280',    // 회색\r\n        successColor: '#10b981',   // 초록\r\n        warningColor: '#f59e0b',   // 주황\r\n      };\r\n    } else {\r\n      // 기본 깔끔한 테마 (스피킹 화면 스타일)\r\n      return {\r\n        // Background Colors\r\n        bgPrimary: '#f9fafb',      // 깔끔한 회색 배경\r\n        bgSecondary: '#ffffff',    // 흰색\r\n        bgAccent: '#6b7280',       // 중간 회색\r\n        bgBase: '#f9fafb',         // 연한 회색 (스피킹 화면과 동일)\r\n        \r\n        // Text Colors\r\n        textPrimary: '#374151',    // 짙은 회색\r\n        textSecondary: '#6b7280',  // 중간 회색\r\n        textAccent: '#4b5563',     // 어두운 회색\r\n        \r\n        // Border Colors\r\n        borderPrimary: '#e5e7eb',  // 연한 회색 테두리\r\n        borderSecondary: '#d1d5db', // 중간 회색 테두리\r\n        borderAccent: '#9ca3af',   // 짙은 회색 테두리\r\n        \r\n        // Button Styles\r\n        primaryButton: 'bg-gray-600 hover:bg-gray-700 text-white',\r\n        secondaryButton: 'bg-white hover:bg-gray-50 border border-gray-300 text-gray-700',\r\n        accentButton: 'bg-blue-500 hover:bg-blue-600 text-white',\r\n        \r\n        // Hover Effects\r\n        hoverPrimary: 'hover:border-gray-400',\r\n        hoverSecondary: 'hover:border-blue-400',\r\n        hoverAccent: 'hover:border-gray-500',\r\n        \r\n        // Progress & Status\r\n        progressBar: '#6b7280',    // 회색\r\n        successColor: '#10b981',   // 초록\r\n        warningColor: '#f59e0b',   // 주황\r\n      };\r\n    }\r\n  }, [themeMode, personalTheme]);\r\n  \r\n  return styles;\r\n};\r\n\r\n// 인라인 스타일용 헬퍼\r\nexport const useThemedInlineStyles = () => {\r\n  const { themeMode, personalTheme } = useTheme();\r\n  \r\n  return useMemo(() => {\r\n    if (themeMode === 'personal') {\r\n      return {\r\n        primary: '#6b7280',        // 회색 (기본 테마와 동일)\r\n        secondary: '#ffffff',      // 흰색 (기본 테마와 동일)\r\n        accent: '#4b5563',         // 어두운 회색 (기본 테마와 동일)\r\n        base: '#f9fafb',          // 연한 회색 배경 (기본 테마와 동일)\r\n        text: '#374151',          // 짙은 회색 텍스트\r\n        border: '#e5e7eb',        // 연한 회색 테두리 (기본 테마와 동일)\r\n      };\r\n    } else {\r\n      return {\r\n        primary: '#6b7280',        // 회색 (깔끔한 스피킹 화면 스타일)\r\n        secondary: '#ffffff',      // 흰색\r\n        accent: '#4b5563',         // 어두운 회색\r\n        base: '#f9fafb',          // 연한 회색 배경 (스피킹 화면과 동일)\r\n        text: '#374151',          // 짙은 회색 텍스트\r\n        border: '#e5e7eb',        // 연한 회색 테두리\r\n      };\r\n    }\r\n  }, [themeMode, personalTheme]);\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useVocabulary.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\hooks\\useVoiceGuidance.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ISpeechProcessingService' is defined but never used. Allowed unused vars must match /^_/u.","line":2,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":57},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'serviceContainer'. Either include it or remove the dependency array.","line":153,"column":6,"nodeType":"ArrayExpression","endLine":153,"endColumn":44,"suggestions":[{"desc":"Update the dependencies array to be: [isSupported, serviceContainer, settings.enabled, settings.language, settings.pitch, settings.rate, settings.systemVoice, settings.volume, speechService]","fix":{"range":[5510,5548],"text":"[isSupported, serviceContainer, settings.enabled, settings.language, settings.pitch, settings.rate, settings.systemVoice, settings.volume, speechService]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'serviceContainer'. Either include it or remove the dependency array.","line":181,"column":6,"nodeType":"ArrayExpression","endLine":181,"endColumn":34,"suggestions":[{"desc":"Update the dependencies array to be: [isSupported, serviceContainer, speechService]","fix":{"range":[6521,6549],"text":"[isSupported, serviceContainer, speechService]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect, useMemo } from 'react';\r\nimport { ServiceContainer, type ISpeechProcessingService } from '@/container/ServiceContainer';\r\n\r\ninterface VoiceGuidanceSettings {\r\n  enabled: boolean;\r\n  systemVoice: boolean;\r\n  volume: number;\r\n  rate: number;\r\n  pitch: number;\r\n  language: string;\r\n}\r\n\r\ninterface VoiceGuidanceHook {\r\n  settings: VoiceGuidanceSettings;\r\n  isSupported: boolean;\r\n  isSpeaking: boolean;\r\n  speak: (text: string, type?: 'system' | 'content') => void;\r\n  stop: () => void;\r\n  pause: () => void;\r\n  resume: () => void;\r\n  updateSettings: (newSettings: Partial<VoiceGuidanceSettings>) => void;\r\n}\r\n\r\ninterface VoiceGuidanceOptions {\r\n  serviceContainer?: ServiceContainer;\r\n}\r\n\r\nexport const useVoiceGuidance = (options: VoiceGuidanceOptions = {}): VoiceGuidanceHook => {\r\n  const [settings, setSettings] = useState<VoiceGuidanceSettings>(() => {\r\n    const saved = localStorage.getItem('voiceGuidanceSettings');\r\n    return saved ? JSON.parse(saved) : {\r\n      enabled: false,\r\n      systemVoice: true,\r\n      volume: 0.8,\r\n      rate: 1.0,\r\n      pitch: 1.0,\r\n      language: 'en-US'\r\n    };\r\n  });\r\n\r\n  const [isSpeaking, setIsSpeaking] = useState(false);\r\n  \r\n  // 🔧 의존성 주입: ServiceContainer를 통해 SpeechPlugin 획득\r\n  const serviceContainer = useMemo(() => {\r\n    return options.serviceContainer || ServiceContainer.getInstance();\r\n  }, [options.serviceContainer]);\r\n\r\n  // 🔧 의존성 주입: ServiceContainer를 통해 SpeechProcessingService 획득\r\n  const speechService = useMemo(() => {\r\n    try {\r\n      return serviceContainer.getSpeechProcessingService();\r\n    } catch (error) {\r\n      console.error('[useVoiceGuidance] Failed to get speech service:', error);\r\n      return null;\r\n    }\r\n  }, [serviceContainer]);\r\n\r\n  const isSupported = typeof window !== 'undefined' && 'speechSynthesis' in window;\r\n\r\n  useEffect(() => {\r\n    localStorage.setItem('voiceGuidanceSettings', JSON.stringify(settings));\r\n  }, [settings]);\r\n\r\n  // 🔧 플러그인 이벤트 시스템 사용\r\n  useEffect(() => {\r\n    if (!isSupported || !speechService) return;\r\n\r\n    const handleSpeechStart = () => setIsSpeaking(true);\r\n    const handleSpeechEnd = () => setIsSpeaking(false);\r\n\r\n    // speechService 이벤트 리스너 등록 (플러그인 기반)\r\n    try {\r\n      // speechService가 이벤트 시스템을 지원하는 경우 사용\r\n      if (typeof speechService.on === 'function') {\r\n        speechService.on('speechStart', handleSpeechStart);\r\n        speechService.on('speechEnd', handleSpeechEnd);\r\n\r\n        return () => {\r\n          if (typeof speechService.off === 'function') {\r\n            speechService.off('speechStart', handleSpeechStart);\r\n            speechService.off('speechEnd', handleSpeechEnd);\r\n          }\r\n        };\r\n      } else {\r\n        // speechService가 이벤트 시스템을 지원하지 않는 경우 polling으로 상태 확인\r\n        const interval = setInterval(() => {\r\n          const wasSpeaking = isSpeaking;\r\n          const currentlySpeaking = speechService?.isProcessing?.() || false;\r\n          if (wasSpeaking !== currentlySpeaking) {\r\n            setIsSpeaking(currentlySpeaking);\r\n          }\r\n        }, 100);\r\n\r\n        return () => clearInterval(interval);\r\n      }\r\n    } catch (error) {\r\n      console.warn('[useVoiceGuidance] Event listener setup failed, using polling fallback:', error);\r\n\r\n      // 최종 fallback: polling으로 상태 확인\r\n      const interval = setInterval(() => {\r\n        const wasSpeaking = isSpeaking;\r\n        const currentlySpeaking = speechService?.isProcessing?.() || false;\r\n        if (wasSpeaking !== currentlySpeaking) {\r\n          setIsSpeaking(currentlySpeaking);\r\n        }\r\n      }, 100);\r\n\r\n      return () => clearInterval(interval);\r\n    }\r\n  }, [isSupported, speechService, isSpeaking]);\r\n\r\n  const speak = useCallback(async (text: string, type: 'system' | 'content' = 'system') => {\r\n    if (!isSupported || !settings.enabled || !speechService) return;\r\n    \r\n    // 시스템 음성과 콘텐츠 음성 구분\r\n    if (type === 'system' && !settings.systemVoice) return;\r\n\r\n    try {\r\n      // 🔧 Direct Web API 제거: speechService.speakAnswer 사용\r\n      const speechOptions = {\r\n        language: settings.language,\r\n        rate: type === 'system' ? settings.rate * 1.2 : settings.rate,\r\n        volume: type === 'system' ? Math.min(settings.volume, 0.6) : settings.volume,\r\n        pitch: type === 'system' ? settings.pitch * 0.9 : settings.pitch\r\n      };\r\n\r\n      // speechService의 speakAnswer 메서드 사용 (TTS 기능)\r\n      await speechService.speakAnswer(text, speechOptions);\r\n    } catch (error) {\r\n      console.error('[useVoiceGuidance] Speech service error:', error);\r\n      \r\n      // 🔧 플러그인 fallback: AdvancedSpeechPlugin 또는 기본 플러그인 사용\r\n      try {\r\n        // ServiceContainer의 AdvancedSpeechPlugin 시도\r\n        const advancedPlugin = serviceContainer.getAdvancedSpeechPlugin();\r\n        if (advancedPlugin) {\r\n          await advancedPlugin.speakText(text, {\r\n            language: settings.language,\r\n            rate: type === 'system' ? settings.rate * 1.2 : settings.rate,\r\n            volume: type === 'system' ? Math.min(settings.volume, 0.6) : settings.volume,\r\n            pitch: type === 'system' ? settings.pitch * 0.9 : settings.pitch\r\n          });\r\n          return;\r\n        }\r\n      } catch (pluginError) {\r\n        console.warn('[useVoiceGuidance] Advanced speech plugin fallback failed:', pluginError);\r\n      }\r\n\r\n      // 🚫 Direct Web API 호출 완전 제거 - 플러그인만 사용\r\n      console.error('[useVoiceGuidance] All speech plugins failed, unable to speak text');\r\n      throw new Error('Speech plugins not available');\r\n    }\r\n  }, [isSupported, settings, speechService]);\r\n\r\n  const stop = useCallback(() => {\r\n    if (!isSupported || !speechService) return;\r\n\r\n    try {\r\n      // 🔧 Direct Web API 제거: speechService.stopAllSpeech 사용\r\n      speechService.stopAllSpeech();\r\n      setIsSpeaking(false);\r\n    } catch (error) {\r\n      console.error('[useVoiceGuidance] Stop speech error:', error);\r\n      \r\n      // 🔧 플러그인 fallback: AdvancedSpeechPlugin 또는 기본 플러그인 사용\r\n      try {\r\n        const advancedPlugin = serviceContainer.getAdvancedSpeechPlugin();\r\n        if (advancedPlugin && typeof advancedPlugin.stopAll === 'function') {\r\n          advancedPlugin.stopAll();\r\n          setIsSpeaking(false);\r\n          return;\r\n        }\r\n      } catch (pluginError) {\r\n        console.warn('[useVoiceGuidance] Advanced speech plugin stop failed:', pluginError);\r\n      }\r\n\r\n      // 🚫 Direct Web API 호출 완전 제거\r\n      console.error('[useVoiceGuidance] All speech plugins failed, unable to stop speech');\r\n      setIsSpeaking(false);\r\n    }\r\n  }, [isSupported, speechService]);\r\n\r\n  const pause = useCallback(() => {\r\n    if (!isSupported || !speechService) return;\r\n\r\n    try {\r\n      // 🔧 Direct Web API 제거: speechService.pauseSpeech 사용\r\n      speechService.pauseSpeech();\r\n    } catch (error) {\r\n      console.error('[useVoiceGuidance] Pause speech error:', error);\r\n      \r\n      // 🚫 Direct Web API 호출 완전 제거\r\n      console.error('[useVoiceGuidance] Speech pause not supported by current plugin system');\r\n    }\r\n  }, [isSupported, speechService]);\r\n\r\n  const resume = useCallback(() => {\r\n    if (!isSupported || !speechService) return;\r\n\r\n    try {\r\n      // 🔧 Direct Web API 제거: speechService.resumeSpeech 사용\r\n      speechService.resumeSpeech();\r\n    } catch (error) {\r\n      console.error('[useVoiceGuidance] Resume speech error:', error);\r\n      \r\n      // 🚫 Direct Web API 호출 완전 제거\r\n      console.error('[useVoiceGuidance] Speech resume not supported by current plugin system');\r\n    }\r\n  }, [isSupported, speechService]);\r\n\r\n  const updateSettings = useCallback((newSettings: Partial<VoiceGuidanceSettings>) => {\r\n    setSettings(prev => ({ ...prev, ...newSettings }));\r\n  }, []);\r\n\r\n  return {\r\n    settings,\r\n    isSupported,\r\n    isSpeaking,\r\n    speak,\r\n    stop,\r\n    pause,\r\n    resume,\r\n    updateSettings\r\n  };\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\i18n\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\api.ts","messages":[{"ruleId":"no-undef","severity":1,"message":"'RequestInit' is not defined.","line":15,"column":14,"nodeType":"Identifier","messageId":"undef","endLine":15,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// API utilities for DASI English backend\r\nimport type { FeedbackResponse, DrillCard, StudySession, ApiResponse } from '@/types';\r\n\r\nconst API_BASE_URL = import.meta.env.VITE_API_BASE_URL || 'http://localhost:8081';\r\n\r\nclass ApiClient {\r\n  private baseUrl: string;\r\n\r\n  constructor(baseUrl: string) {\r\n    this.baseUrl = baseUrl;\r\n  }\r\n\r\n  private async request<T>(\r\n    endpoint: string, \r\n    options: RequestInit = {}\r\n  ): Promise<ApiResponse<T>> {\r\n    try {\r\n      const url = `${this.baseUrl}${endpoint}`;\r\n      const response = await fetch(url, {\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          ...options.headers,\r\n        },\r\n        ...options,\r\n      });\r\n\r\n      const data = await response.json();\r\n      \r\n      if (!response.ok) {\r\n        return {\r\n          success: false,\r\n          error: data.error || `HTTP ${response.status}`,\r\n        };\r\n      }\r\n\r\n      return {\r\n        success: true,\r\n        data,\r\n      };\r\n    } catch (error) {\r\n      return {\r\n        success: false,\r\n        error: error instanceof Error ? error.message : 'Network error',\r\n      };\r\n    }\r\n  }\r\n\r\n  // Health check\r\n  async health(): Promise<ApiResponse> {\r\n    return this.request('/health');\r\n  }\r\n\r\n  // Get drill cards for a specific level and stage\r\n  async getCards(level: number, stage: number | 'ALL'): Promise<ApiResponse<{\r\n    level: number;\r\n    stage: number | 'ALL';\r\n    cards: DrillCard[];\r\n    totalCards: number;\r\n    mode?: 'ALL';\r\n  }>> {\r\n    return this.request(`/cards?level=${level}&stage=${stage}`);\r\n  }\r\n\r\n  // Get all cards for a level (ALL mode)\r\n  async getAllLevelCards(level: number): Promise<ApiResponse<{\r\n    level: number;\r\n    mode: 'ALL';\r\n    cards: DrillCard[];\r\n    totalCards: number;\r\n    shuffled: boolean;\r\n  }>> {\r\n    return this.request(`/cards/all?level=${level}`);\r\n  }\r\n\r\n  // Get feedback from AI for user's answer\r\n  async getFeedback(params: {\r\n    front_ko: string;\r\n    sttText: string;\r\n    target_en: string;\r\n  }): Promise<ApiResponse<FeedbackResponse>> {\r\n    return this.request('/feedback', {\r\n      method: 'POST',\r\n      body: JSON.stringify(params),\r\n    });\r\n  }\r\n\r\n  // Session management\r\n  async startSession(params: {\r\n    userId: string;\r\n    level: number;\r\n    stage: number;\r\n    cardIds: string[];\r\n  }): Promise<ApiResponse<{ sessionId: string }>> {\r\n    return this.request('/session/start', {\r\n      method: 'POST',\r\n      body: JSON.stringify(params),\r\n    });\r\n  }\r\n\r\n  async submitAnswer(params: {\r\n    sessionId: string;\r\n    cardId: string;\r\n    userAnswer: string;\r\n    isCorrect: boolean;\r\n    score: number;\r\n    timeSpent: number;\r\n  }): Promise<ApiResponse<{ progress: any }>> {\r\n    return this.request('/session/submit', {\r\n      method: 'POST',\r\n      body: JSON.stringify(params),\r\n    });\r\n  }\r\n\r\n  async finishSession(sessionId: string): Promise<ApiResponse<{\r\n    summary: {\r\n      totalCards: number;\r\n      correctAnswers: number;\r\n      accuracy: number;\r\n      averageScore: number;\r\n      totalTime: number;\r\n      averageTimePerCard: number;\r\n    }\r\n  }>> {\r\n    return this.request('/session/finish', {\r\n      method: 'POST',\r\n      body: JSON.stringify({ sessionId }),\r\n    });\r\n  }\r\n\r\n  // STT service (if using cloud STT)\r\n  async transcribeAudio(params: {\r\n    audioBase64: string;\r\n    languageCode?: string;\r\n    phraseHints?: string[];\r\n  }): Promise<ApiResponse<{\r\n    transcript: string;\r\n    confidence: number | null;\r\n  }>> {\r\n    return this.request('/stt', {\r\n      method: 'POST',\r\n      body: JSON.stringify(params),\r\n    });\r\n  }\r\n\r\n  // Review API - Random review cards\r\n  async getRandomReview(params: {\r\n    userId?: string;\r\n    count?: number;\r\n    levels?: number[];\r\n  }): Promise<ApiResponse<{\r\n    cards: DrillCard[];\r\n    totalCards: number;\r\n    sourceLevels: number[];\r\n    type: string;\r\n  }>> {\r\n    const searchParams = new URLSearchParams();\r\n    if (params.userId) searchParams.append('userId', params.userId);\r\n    if (params.count) searchParams.append('count', params.count.toString());\r\n    if (params.levels && params.levels.length > 0) {\r\n      searchParams.append('levels', params.levels.join(','));\r\n    }\r\n\r\n    return this.request(`/review/random?${searchParams.toString()}`);\r\n  }\r\n\r\n  // Review API - Retry incorrect answers\r\n  async getRetryReview(params: {\r\n    userId: string;\r\n    sessionId?: string;\r\n  }): Promise<ApiResponse<{\r\n    cards: DrillCard[];\r\n    totalCards: number;\r\n    type: string;\r\n  }>> {\r\n    const searchParams = new URLSearchParams();\r\n    searchParams.append('userId', params.userId);\r\n    if (params.sessionId) searchParams.append('sessionId', params.sessionId);\r\n\r\n    return this.request(`/review/retry?${searchParams.toString()}`);\r\n  }\r\n}\r\n\r\n// Create and export API client instance\r\nexport const api = new ApiClient(API_BASE_URL);\r\n\r\n// Export types for convenience\r\nexport type { ApiResponse, FeedbackResponse, DrillCard, StudySession };","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\audioV2\\AudioSession.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\audioV2\\AudioSessionFactory.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":124,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":124,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AudioSession } from './AudioSession';\nimport type { AudioConfig, SessionCallbacks } from './types';\n\nexport class AudioSessionFactory {\n  private static levelConfigs: Record<number, Partial<AudioConfig>> = {\n    1: {\n      thinkTime: 3,\n      recordTime: 10,\n      promptDelay: 1000,\n      beepDuration: 300,\n      enableVAD: false,\n      vadThreshold: 0.1,\n      preRollTime: 500,\n      graceLateTime: 1000\n    },\n    2: {\n      thinkTime: 3,\n      recordTime: 12,\n      promptDelay: 800,\n      beepDuration: 250,\n      enableVAD: true,\n      vadThreshold: 0.15,\n      preRollTime: 400,\n      graceLateTime: 800\n    },\n    3: {\n      thinkTime: 2,\n      recordTime: 15,\n      promptDelay: 600,\n      beepDuration: 200,\n      enableVAD: true,\n      vadThreshold: 0.2,\n      preRollTime: 300,\n      graceLateTime: 600\n    },\n    4: {\n      thinkTime: 2,\n      recordTime: 20,\n      promptDelay: 500,\n      beepDuration: 150,\n      enableVAD: true,\n      vadThreshold: 0.25,\n      preRollTime: 200,\n      graceLateTime: 400\n    },\n    5: {\n      thinkTime: 1,\n      recordTime: 25,\n      promptDelay: 300,\n      beepDuration: 100,\n      enableVAD: true,\n      vadThreshold: 0.3,\n      preRollTime: 150,\n      graceLateTime: 300\n    },\n    6: {\n      thinkTime: 1,\n      recordTime: 30,\n      promptDelay: 200,\n      beepDuration: 100,\n      enableVAD: true,\n      vadThreshold: 0.35,\n      preRollTime: 100,\n      graceLateTime: 200\n    }\n  };\n\n  static async create(level: number, callbacks: SessionCallbacks = {}): Promise<AudioSession> {\n    // Validate browser compatibility\n    await this.checkBrowserCompatibility();\n\n    // Get level-specific configuration\n    const levelConfig = this.levelConfigs[level] || this.levelConfigs[1];\n    \n    const config: AudioConfig = {\n      level,\n      ...levelConfig\n    } as AudioConfig;\n\n    // Generate unique session ID\n    const sessionId = `session_${level}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n\n    return new AudioSession(sessionId, config, callbacks);\n  }\n\n  private static async checkBrowserCompatibility(): Promise<void> {\n    const issues: string[] = [];\n\n    // Check MediaRecorder\n    if (!window.MediaRecorder) {\n      issues.push('MediaRecorder API not supported');\n    }\n\n    // Check getUserMedia\n    if (!navigator.mediaDevices?.getUserMedia) {\n      issues.push('getUserMedia API not supported');\n    }\n\n    // Check Speech Recognition\n    const SpeechRecognition = (window as any).SpeechRecognition || (window as any).webkitSpeechRecognition;\n    if (!SpeechRecognition) {\n      issues.push('Speech Recognition API not supported');\n    }\n\n    // Check Speech Synthesis\n    if (!window.speechSynthesis) {\n      issues.push('Speech Synthesis API not supported');\n    }\n\n    // Check Web Audio API\n    const AudioContext = window.AudioContext || (window as any).webkitAudioContext;\n    if (!AudioContext) {\n      issues.push('Web Audio API not supported');\n    }\n\n    if (issues.length > 0) {\n      throw new Error(`Browser compatibility issues: ${issues.join(', ')}`);\n    }\n\n    // Test microphone access\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n      stream.getTracks().forEach(track => track.stop());\n    } catch (_error) {\n      throw new Error('Microphone access denied or not available');\n    }\n  }\n\n  static getSupportedLevels(): number[] {\n    return Object.keys(this.levelConfigs).map(Number).sort((a, b) => a - b);\n  }\n\n  static getLevelConfig(level: number): Partial<AudioConfig> {\n    return { ...this.levelConfigs[level] } || { ...this.levelConfigs[1] };\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\audioV2\\modules\\ASRClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\audioV2\\modules\\BeepPlayer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":12,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"export class BeepPlayer {\n  private audioContext: AudioContext | null = null;\n  private currentOscillator: OscillatorNode | null = null;\n  private isInitialized: boolean = false;\n\n  async initialize(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      this.audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\n      this.isInitialized = true;\n    } catch (_error) {\n      throw new Error('Failed to initialize audio context for beep player');\n    }\n  }\n\n  async playBeep(frequency: number = 800, duration: number = 200): Promise<void> {\n    if (!this.isInitialized) {\n      await this.initialize();\n    }\n\n    if (!this.audioContext) {\n      throw new Error('Audio context not available');\n    }\n\n    return new Promise((resolve) => {\n      const oscillator = this.audioContext!.createOscillator();\n      const gainNode = this.audioContext!.createGain();\n\n      this.currentOscillator = oscillator;\n\n      oscillator.connect(gainNode);\n      gainNode.connect(this.audioContext!.destination);\n\n      oscillator.frequency.setValueAtTime(frequency, this.audioContext!.currentTime);\n      gainNode.gain.setValueAtTime(0.3, this.audioContext!.currentTime);\n\n      oscillator.start();\n      oscillator.stop(this.audioContext!.currentTime + duration / 1000);\n\n      oscillator.onended = () => {\n        this.currentOscillator = null;\n        resolve();\n      };\n    });\n  }\n\n  stop(): void {\n    if (this.currentOscillator) {\n      this.currentOscillator.stop();\n      this.currentOscillator = null;\n    }\n  }\n\n  cleanup(): void {\n    this.stop();\n    if (this.audioContext) {\n      this.audioContext.close();\n      this.audioContext = null;\n    }\n    this.isInitialized = false;\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\audioV2\\modules\\Recorder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\audioV2\\modules\\StageClock.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\audioV2\\modules\\TTSPlayer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\audioV2\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\lib\\firebase.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\AchievementsPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AchievementData' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":79},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":117,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":117,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { useLocalStorage, STORAGE_KEYS, type Achievement, type AchievementData } from '@/hooks/useLocalStorage';\r\nimport { useUser } from '@/store/useAppStore';\r\n\r\n// 기본 업적 정의\r\nconst AVAILABLE_ACHIEVEMENTS: Achievement[] = [\r\n  // 학습 업적 (📚)\r\n  {\r\n    id: 'first_lesson',\r\n    title: '첫 걸음',\r\n    description: '첫 번째 레슨 완료',\r\n    type: 'learning',\r\n    icon: '🌱',\r\n    badge: '📚',\r\n    target: 1,\r\n    current: 0\r\n  },\r\n  {\r\n    id: 'complete_level_1',\r\n    title: '기초 마스터',\r\n    description: 'Level 1 완전 정복',\r\n    type: 'learning',\r\n    icon: '🎓',\r\n    badge: '📚',\r\n    target: 1,\r\n    current: 0\r\n  },\r\n  {\r\n    id: 'study_streak_7',\r\n    title: '일주일 연속',\r\n    description: '7일 연속 학습',\r\n    type: 'learning',\r\n    icon: '🔥',\r\n    badge: '📚',\r\n    target: 7,\r\n    current: 0\r\n  },\r\n  {\r\n    id: 'study_streak_30',\r\n    title: '한 달 연속',\r\n    description: '30일 연속 학습',\r\n    type: 'learning',\r\n    icon: '💯',\r\n    badge: '📚',\r\n    target: 30,\r\n    current: 0\r\n  },\r\n  {\r\n    id: 'complete_100_questions',\r\n    title: '백문백답',\r\n    description: '100문제 해결',\r\n    type: 'learning',\r\n    icon: '💯',\r\n    badge: '📚',\r\n    target: 100,\r\n    current: 0\r\n  },\r\n  \r\n  // 성과 업적 (🎯)\r\n  {\r\n    id: 'accuracy_90',\r\n    title: '정확한 발음',\r\n    description: '90% 이상 정확도 달성',\r\n    type: 'performance',\r\n    icon: '🎯',\r\n    badge: '🎯',\r\n    target: 90,\r\n    current: 0\r\n  },\r\n  {\r\n    id: 'speed_master',\r\n    title: '스피드 마스터',\r\n    description: '평균 응답시간 2초 이하',\r\n    type: 'performance',\r\n    icon: '⚡',\r\n    badge: '🎯',\r\n    target: 2,\r\n    current: 0\r\n  },\r\n  {\r\n    id: 'perfect_session',\r\n    title: '완벽한 세션',\r\n    description: '한 세션에서 100% 정답',\r\n    type: 'performance',\r\n    icon: '⭐',\r\n    badge: '🎯',\r\n    target: 1,\r\n    current: 0\r\n  },\r\n  \r\n  // 마일스톤 업적 (🏆)\r\n  {\r\n    id: 'reach_level_5',\r\n    title: '중급자',\r\n    description: 'Level 5 달성',\r\n    type: 'milestone',\r\n    icon: '🏅',\r\n    badge: '🏆',\r\n    target: 5,\r\n    current: 0\r\n  },\r\n  {\r\n    id: 'reach_level_10',\r\n    title: '고급자',\r\n    description: 'Level 10 달성',\r\n    type: 'milestone',\r\n    icon: '👑',\r\n    badge: '🏆',\r\n    target: 10,\r\n    current: 0\r\n  }\r\n];\r\n\r\nexport const AchievementsPage: React.FC = () => {\r\n  const navigate = useNavigate();\r\n  const user = useUser();\r\n  const { value: achievementData, updateValue } = useLocalStorage(STORAGE_KEYS.ACHIEVEMENTS);\r\n\r\n  // 업적 달성 상태 계산\r\n  const getAchievementStatus = (achievement: Achievement) => {\r\n    const isUnlocked = achievementData.unlockedAchievements.includes(achievement.id);\r\n    const progress = achievementData.achievementProgress[achievement.id];\r\n    const isNew = achievementData.newBadges.includes(achievement.id);\r\n    \r\n    return {\r\n      isUnlocked,\r\n      isNew,\r\n      progress: progress ? Math.min(100, (progress.current / progress.target) * 100) : 0,\r\n      current: progress?.current || 0,\r\n      target: progress?.target || achievement.target || 0\r\n    };\r\n  };\r\n\r\n  // 새 배지 확인 처리\r\n  const markBadgeAsSeen = (achievementId: string) => {\r\n    updateValue(prev => ({\r\n      ...prev,\r\n      newBadges: prev.newBadges.filter(id => id !== achievementId)\r\n    }));\r\n  };\r\n\r\n  // 카테고리별 업적 분류\r\n  const achievementsByType = {\r\n    learning: AVAILABLE_ACHIEVEMENTS.filter(a => a.type === 'learning'),\r\n    performance: AVAILABLE_ACHIEVEMENTS.filter(a => a.type === 'performance'),\r\n    milestone: AVAILABLE_ACHIEVEMENTS.filter(a => a.type === 'milestone')\r\n  };\r\n\r\n  // 전체 통계 계산\r\n  const totalAchievements = AVAILABLE_ACHIEVEMENTS.length;\r\n  const unlockedCount = achievementData.unlockedAchievements.length;\r\n  const completionRate = Math.round((unlockedCount / totalAchievements) * 100);\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gray-50\">\r\n      {/* Header */}\r\n      <div className=\"bg-white shadow-sm border-b\">\r\n        <div className=\"max-w-4xl mx-auto px-4 py-4\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <div className=\"flex items-center gap-4\">\r\n              <button\r\n                onClick={() => navigate('/')}\r\n                className=\"p-2 hover:bg-gray-100 rounded-lg transition-colors\"\r\n              >\r\n                <svg className=\"w-6 h-6 text-gray-600 dark:text-gray-300\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 19l-7-7 7-7\" />\r\n                </svg>\r\n              </button>\r\n              <div>\r\n                <h1 className=\"text-2xl font-bold text-gray-800 dark:text-white\">🏆 업적·배지</h1>\r\n                <p className=\"text-sm text-gray-600 dark:text-gray-300\">학습 성취도와 업적 확인</p>\r\n              </div>\r\n            </div>\r\n            <div className=\"text-right\">\r\n              <div className=\"text-2xl font-bold text-orange-600\">{unlockedCount}/{totalAchievements}</div>\r\n              <div className=\"text-xs text-gray-500\">달성률 {completionRate}%</div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Achievements Content */}\r\n      <div className=\"max-w-4xl mx-auto px-4 py-8\">\r\n        <div className=\"space-y-8\">\r\n\r\n          {/* 진행률 표시 */}\r\n          <div className=\"bg-white dark:bg-gray-800 rounded-lg transition-colors duration-300 shadow p-6\">\r\n            <h2 className=\"text-lg font-semibold text-gray-800 dark:text-white mb-4\">전체 진행률</h2>\r\n            <div className=\"w-full bg-gray-200 rounded-full h-3 mb-2\">\r\n              <div \r\n                className=\"bg-orange-500 h-3 rounded-full transition-all duration-500\"\r\n                style={{ width: `${completionRate}%` }}\r\n              ></div>\r\n            </div>\r\n            <div className=\"flex justify-between text-sm text-gray-600 dark:text-gray-300\">\r\n              <span>달성한 업적: {unlockedCount}개</span>\r\n              <span>{completionRate}% 완료</span>\r\n            </div>\r\n          </div>\r\n\r\n          {/* 학습 업적 */}\r\n          <div className=\"bg-white dark:bg-gray-800 rounded-lg transition-colors duration-300 shadow p-6\">\r\n            <h2 className=\"text-lg font-semibold text-gray-800 dark:text-white mb-6 flex items-center\">\r\n              <span className=\"text-2xl mr-3\">📚</span>\r\n              학습 업적\r\n            </h2>\r\n            <div className=\"grid md:grid-cols-2 gap-4\">\r\n              {achievementsByType.learning.map(achievement => {\r\n                const status = getAchievementStatus(achievement);\r\n                return (\r\n                  <div\r\n                    key={achievement.id}\r\n                    className={`relative p-4 border-2 rounded-lg transition-all ${\r\n                      status.isUnlocked\r\n                        ? 'border-green-200 bg-green-50'\r\n                        : 'border-gray-200 bg-gray-50'\r\n                    }`}\r\n                    onClick={() => status.isNew && markBadgeAsSeen(achievement.id)}\r\n                  >\r\n                    {status.isNew && (\r\n                      <div className=\"absolute -top-2 -right-2 bg-red-500 text-white text-xs px-2 py-1 rounded-full animate-pulse\">\r\n                        NEW!\r\n                      </div>\r\n                    )}\r\n                    <div className=\"flex items-center gap-3\">\r\n                      <div className={`text-2xl ${status.isUnlocked ? '' : 'grayscale opacity-50'}`}>\r\n                        {achievement.icon}\r\n                      </div>\r\n                      <div className=\"flex-1\">\r\n                        <div className={`font-medium ${status.isUnlocked ? 'text-green-800' : 'text-gray-600 dark:text-gray-300'}`}>\r\n                          {achievement.title}\r\n                        </div>\r\n                        <div className=\"text-sm text-gray-500\">{achievement.description}</div>\r\n                        {!status.isUnlocked && status.progress > 0 && (\r\n                          <div className=\"mt-2\">\r\n                            <div className=\"w-full bg-gray-200 rounded-full h-2\">\r\n                              <div \r\n                                className=\"bg-blue-500 h-2 rounded-full transition-all duration-300\"\r\n                                style={{ width: `${status.progress}%` }}\r\n                              ></div>\r\n                            </div>\r\n                            <div className=\"text-xs text-gray-500 mt-1\">\r\n                              {status.current}/{status.target}\r\n                            </div>\r\n                          </div>\r\n                        )}\r\n                      </div>\r\n                      {status.isUnlocked && (\r\n                        <div className=\"text-green-600\">\r\n                          <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\r\n                            <path fillRule=\"evenodd\" d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clipRule=\"evenodd\" />\r\n                          </svg>\r\n                        </div>\r\n                      )}\r\n                    </div>\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n          </div>\r\n\r\n          {/* 성과 업적 */}\r\n          <div className=\"bg-white dark:bg-gray-800 rounded-lg transition-colors duration-300 shadow p-6\">\r\n            <h2 className=\"text-lg font-semibold text-gray-800 dark:text-white mb-6 flex items-center\">\r\n              <span className=\"text-2xl mr-3\">🎯</span>\r\n              성과 업적\r\n            </h2>\r\n            <div className=\"grid md:grid-cols-2 gap-4\">\r\n              {achievementsByType.performance.map(achievement => {\r\n                const status = getAchievementStatus(achievement);\r\n                return (\r\n                  <div\r\n                    key={achievement.id}\r\n                    className={`relative p-4 border-2 rounded-lg transition-all ${\r\n                      status.isUnlocked\r\n                        ? 'border-blue-200 bg-blue-50'\r\n                        : 'border-gray-200 bg-gray-50'\r\n                    }`}\r\n                    onClick={() => status.isNew && markBadgeAsSeen(achievement.id)}\r\n                  >\r\n                    {status.isNew && (\r\n                      <div className=\"absolute -top-2 -right-2 bg-red-500 text-white text-xs px-2 py-1 rounded-full animate-pulse\">\r\n                        NEW!\r\n                      </div>\r\n                    )}\r\n                    <div className=\"flex items-center gap-3\">\r\n                      <div className={`text-2xl ${status.isUnlocked ? '' : 'grayscale opacity-50'}`}>\r\n                        {achievement.icon}\r\n                      </div>\r\n                      <div className=\"flex-1\">\r\n                        <div className={`font-medium ${status.isUnlocked ? 'text-blue-800' : 'text-gray-600 dark:text-gray-300'}`}>\r\n                          {achievement.title}\r\n                        </div>\r\n                        <div className=\"text-sm text-gray-500\">{achievement.description}</div>\r\n                        {!status.isUnlocked && status.progress > 0 && (\r\n                          <div className=\"mt-2\">\r\n                            <div className=\"w-full bg-gray-200 rounded-full h-2\">\r\n                              <div \r\n                                className=\"bg-blue-500 h-2 rounded-full transition-all duration-300\"\r\n                                style={{ width: `${status.progress}%` }}\r\n                              ></div>\r\n                            </div>\r\n                            <div className=\"text-xs text-gray-500 mt-1\">\r\n                              {status.current}/{status.target}\r\n                            </div>\r\n                          </div>\r\n                        )}\r\n                      </div>\r\n                      {status.isUnlocked && (\r\n                        <div className=\"text-blue-600\">\r\n                          <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\r\n                            <path fillRule=\"evenodd\" d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clipRule=\"evenodd\" />\r\n                          </svg>\r\n                        </div>\r\n                      )}\r\n                    </div>\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n          </div>\r\n\r\n          {/* 마일스톤 업적 */}\r\n          <div className=\"bg-white dark:bg-gray-800 rounded-lg transition-colors duration-300 shadow p-6\">\r\n            <h2 className=\"text-lg font-semibold text-gray-800 dark:text-white mb-6 flex items-center\">\r\n              <span className=\"text-2xl mr-3\">🏆</span>\r\n              마일스톤 업적\r\n            </h2>\r\n            <div className=\"grid md:grid-cols-2 gap-4\">\r\n              {achievementsByType.milestone.map(achievement => {\r\n                const status = getAchievementStatus(achievement);\r\n                return (\r\n                  <div\r\n                    key={achievement.id}\r\n                    className={`relative p-4 border-2 rounded-lg transition-all ${\r\n                      status.isUnlocked\r\n                        ? 'border-yellow-200 bg-yellow-50'\r\n                        : 'border-gray-200 bg-gray-50'\r\n                    }`}\r\n                    onClick={() => status.isNew && markBadgeAsSeen(achievement.id)}\r\n                  >\r\n                    {status.isNew && (\r\n                      <div className=\"absolute -top-2 -right-2 bg-red-500 text-white text-xs px-2 py-1 rounded-full animate-pulse\">\r\n                        NEW!\r\n                      </div>\r\n                    )}\r\n                    <div className=\"flex items-center gap-3\">\r\n                      <div className={`text-2xl ${status.isUnlocked ? '' : 'grayscale opacity-50'}`}>\r\n                        {achievement.icon}\r\n                      </div>\r\n                      <div className=\"flex-1\">\r\n                        <div className={`font-medium ${status.isUnlocked ? 'text-yellow-800' : 'text-gray-600 dark:text-gray-300'}`}>\r\n                          {achievement.title}\r\n                        </div>\r\n                        <div className=\"text-sm text-gray-500\">{achievement.description}</div>\r\n                        {!status.isUnlocked && status.progress > 0 && (\r\n                          <div className=\"mt-2\">\r\n                            <div className=\"w-full bg-gray-200 rounded-full h-2\">\r\n                              <div \r\n                                className=\"bg-yellow-500 h-2 rounded-full transition-all duration-300\"\r\n                                style={{ width: `${status.progress}%` }}\r\n                              ></div>\r\n                            </div>\r\n                            <div className=\"text-xs text-gray-500 mt-1\">\r\n                              Level {status.current}/{status.target}\r\n                            </div>\r\n                          </div>\r\n                        )}\r\n                      </div>\r\n                      {status.isUnlocked && (\r\n                        <div className=\"text-yellow-600\">\r\n                          <svg className=\"w-6 h-6\" fill=\"currentColor\" viewBox=\"0 0 20 20\">\r\n                            <path fillRule=\"evenodd\" d=\"M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z\" clipRule=\"evenodd\" />\r\n                          </svg>\r\n                        </div>\r\n                      )}\r\n                    </div>\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n          </div>\r\n\r\n          {/* 안내 메시지 */}\r\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\r\n            <h3 className=\"font-semibold text-blue-800 mb-2\">💡 업적 달성 방법</h3>\r\n            <ul className=\"text-sm text-blue-700 space-y-1\">\r\n              <li>• 꾸준히 학습하면 자동으로 업적이 달성됩니다</li>\r\n              <li>• 새로운 배지는 빨간색 NEW! 표시로 알려드립니다</li>\r\n              <li>• 진행 중인 업적은 진행률이 표시됩니다</li>\r\n              <li>• 달성한 업적은 녹색/파란색/노란색으로 표시됩니다</li>\r\n            </ul>\r\n          </div>\r\n\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AchievementsPage;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\AdaptivePackPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useSRSEngine' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SpeechRecorder' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'clearError' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":20,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":43},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadData'. Either include it or remove the dependency array.","line":53,"column":6,"nodeType":"ArrayExpression","endLine":53,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [loadData, user.id]","fix":{"range":[2322,2331],"text":"[loadData, user.id]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'finishPack'. Either include it or remove the dependency array.","line":67,"column":6,"nodeType":"ArrayExpression","endLine":67,"endColumn":45,"suggestions":[{"desc":"Update the dependencies array to be: [currentPack, currentIndex, isStudying, finishPack]","fix":{"range":[2723,2762],"text":"[currentPack, currentIndex, isStudying, finishPack]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":82,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":82,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":110,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'responseTime' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":144,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":144,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'quality' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":179,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":179,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":198,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":198,"endColumn":19},{"ruleId":"no-undef","severity":1,"message":"'nextCard' is not defined.","line":320,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":320,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { useUser, useAppStore, useLearningMode } from '@/store/useAppStore';\r\nimport { adaptivePackService, type AdaptivePack, type LearningAnalytics, type AdaptivePackCard } from '@/services/adaptivePackService';\r\nimport { useSRSEngine } from '@/hooks/useSRSEngine';\r\nimport { WritingModeInput } from '@/components/WritingModeInput';\r\nimport { WritingModeFeedback } from '@/components/WritingModeFeedback';\r\nimport { SpeechRecorder } from '@/components/SpeechRecorder';\r\nimport { AutoSpeakingFlowV2 } from '@/components/AutoSpeakingFlowV2';\r\nimport { FeedbackPanel } from '@/components/FeedbackPanel';\r\nimport { useSpeech } from '@/hooks/useSpeech';\r\nimport { api } from '@/lib/api';\r\nimport type { FeedbackResponse } from '@/types';\r\nimport type { WritingFeedback } from '@/services/writingMode';\r\n\r\nexport const AdaptivePackPage: React.FC = () => {\r\n  const navigate = useNavigate();\r\n  const user = useUser();\r\n  const learningMode = useLearningMode();\r\n  const { setLoading, setError, clearError } = useAppStore();\r\n\r\n  // Analytics & Packs\r\n  const [analytics, setAnalytics] = useState<LearningAnalytics | null>(null);\r\n  const [savedPacks, setSavedPacks] = useState<AdaptivePack[]>([]);\r\n  const [currentPack, setCurrentPack] = useState<AdaptivePack | null>(null);\r\n  \r\n  // Study Session\r\n  const [currentIndex, setCurrentIndex] = useState(0);\r\n  const [currentCard, setCurrentCard] = useState<AdaptivePackCard | null>(null);\r\n  const [isStudying, setIsStudying] = useState(false);\r\n  \r\n  // Feedback\r\n  const [speechFeedback, setSpeechFeedback] = useState<FeedbackResponse | null>(null);\r\n  const [writingFeedback, setWritingFeedback] = useState<WritingFeedback | null>(null);\r\n  const [cardStartTime, setCardStartTime] = useState<number>(0);\r\n\r\n  // UI States\r\n  const [showPackGenerator, setShowPackGenerator] = useState(false);\r\n  const [generationOptions, setGenerationOptions] = useState({\r\n    algorithm: 'standard' as 'standard' | 'intensive' | 'review_focused',\r\n    targetSize: 15\r\n  });\r\n\r\n  const speech = useSpeech({\r\n    apiBaseUrl: import.meta.env.VITE_API_BASE_URL,\r\n    preferCloudSTT: false,\r\n    language: 'en-US',\r\n  });\r\n\r\n  // Load data on mount\r\n  useEffect(() => {\r\n    loadData();\r\n  }, [user.id]);\r\n\r\n  // Set current card when pack/index changes\r\n  useEffect(() => {\r\n    if (currentPack && isStudying) {\r\n      if (currentIndex < currentPack.cards.length) {\r\n        setCurrentCard(currentPack.cards[currentIndex]);\r\n        setCardStartTime(Date.now());\r\n        setSpeechFeedback(null);\r\n        setWritingFeedback(null);\r\n      } else {\r\n        finishPack();\r\n      }\r\n    }\r\n  }, [currentPack, currentIndex, isStudying]);\r\n\r\n  const loadData = async () => {\r\n    if (!user.id) return;\r\n\r\n    setLoading(true);\r\n    try {\r\n      // Load analytics and saved packs\r\n      const [analyticsData, packsData] = await Promise.all([\r\n        adaptivePackService.analyzeLearningData(user.id),\r\n        adaptivePackService.getSavedAdaptivePacks(user.id)\r\n      ]);\r\n      \r\n      setAnalytics(analyticsData);\r\n      setSavedPacks(packsData);\r\n    } catch (error) {\r\n      setError('데이터 로드에 실패했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const generateNewPack = async () => {\r\n    if (!user.id) return;\r\n\r\n    setLoading(true);\r\n    try {\r\n      const newPack = await adaptivePackService.generateAdaptivePack(\r\n        user.id,\r\n        generationOptions.targetSize,\r\n        generationOptions.algorithm\r\n      );\r\n      \r\n      setSavedPacks([newPack, ...savedPacks]);\r\n      setShowPackGenerator(false);\r\n      setError(''); // Clear any previous errors\r\n      \r\n      // Optionally start the new pack immediately\r\n      if (newPack.cards.length > 0) {\r\n        setCurrentPack(newPack);\r\n        setCurrentIndex(0);\r\n        setIsStudying(true);\r\n      }\r\n    } catch (error) {\r\n      setError('학습팩 생성에 실패했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const startPack = (pack: AdaptivePack) => {\r\n    setCurrentPack(pack);\r\n    setCurrentIndex(0);\r\n    setIsStudying(true);\r\n  };\r\n\r\n  const handleSpeechResult = async (transcript: string, confidence: number) => {\r\n    if (!currentCard) return;\r\n\r\n    await processAnswer(transcript, confidence, true);\r\n  };\r\n\r\n  const handleWritingSubmit = async (userInput: string, feedback: WritingFeedback) => {\r\n    if (!currentCard) return;\r\n\r\n    setWritingFeedback(feedback);\r\n    await processAnswer(userInput, feedback.score / 100, false, feedback);\r\n  };\r\n\r\n  const processAnswer = async (\r\n    userAnswer: string,\r\n    confidence: number,\r\n    isSpeaking: boolean,\r\n    writingFeedback?: WritingFeedback\r\n  ) => {\r\n    if (!currentCard) return;\r\n\r\n    const responseTime = (Date.now() - cardStartTime) / 1000;\r\n    setLoading(true);\r\n\r\n    try {\r\n      let isCorrect = false;\r\n      let score = 0;\r\n\r\n      if (isSpeaking) {\r\n        // Speaking mode - use feedback API\r\n        const feedbackResponse = await api.getFeedback({\r\n          front_ko: currentCard.cardData.front_ko,\r\n          sttText: userAnswer,\r\n          target_en: currentCard.cardData.target_en,\r\n        });\r\n\r\n        if (feedbackResponse.success && feedbackResponse.data) {\r\n          setSpeechFeedback(feedbackResponse.data);\r\n          isCorrect = feedbackResponse.data.correct;\r\n          score = feedbackResponse.data.score;\r\n        }\r\n      } else {\r\n        // Writing mode - already processed\r\n        isCorrect = writingFeedback?.isCorrect || false;\r\n        score = writingFeedback?.score || 0;\r\n      }\r\n\r\n      // Update SRS system\r\n      if (currentCard.srsInfo) {\r\n        let quality: 0 | 1 | 2 | 3 | 4 | 5 = 3;\r\n        \r\n        if (!isCorrect) {\r\n          quality = confidence > 0.7 ? 2 : confidence > 0.4 ? 1 : 0;\r\n        } else {\r\n          if (score >= 90) quality = 5;\r\n          else if (score >= 80) quality = 4;\r\n          else quality = 3;\r\n        }\r\n\r\n        // TODO: Migrate to new SRS Engine system\r\n        // const srsEngine = useSRSEngine();\r\n        // await srsEngine.updateCard(currentCard.cardId, {\r\n        //   quality,\r\n        //   responseTime,\r\n        //   isCorrect\r\n        // });\r\n      }\r\n\r\n      // Play TTS if available and answer was incorrect\r\n      if (speech.isTTSAvailable && !isCorrect) {\r\n        setTimeout(() => {\r\n          speech.speak(currentCard!.cardData.target_en);\r\n        }, 1500);\r\n      }\r\n\r\n    } catch (error) {\r\n      setError('답변 처리 중 오류가 발생했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleNextCard = () => {\r\n    setCurrentIndex(currentIndex + 1);\r\n  };\r\n\r\n  const finishPack = () => {\r\n    setIsStudying(false);\r\n    setCurrentPack(null);\r\n    setCurrentCard(null);\r\n    loadData(); // Refresh analytics\r\n    \r\n    navigate('/', {\r\n      state: {\r\n        message: `Adaptive Pack 완료! ${currentPack?.cards.length}개 카드를 학습했습니다.`\r\n      }\r\n    });\r\n  };\r\n\r\n  const hasAnswer = speechFeedback || writingFeedback;\r\n\r\n  if (isStudying && currentCard) {\r\n    // Study Session UI\r\n    return (\r\n      <div className=\"min-h-screen bg-gray-50\">\r\n        {/* Header */}\r\n        <div className=\"bg-white shadow-sm border-b\">\r\n          <div className=\"max-w-2xl mx-auto px-4 py-3\">\r\n            <div className=\"flex items-center justify-between\">\r\n              <button\r\n                onClick={() => setIsStudying(false)}\r\n                className=\"text-gray-600 hover:text-gray-800\"\r\n              >\r\n                ← 뒤로\r\n              </button>\r\n              <div className=\"text-center\">\r\n                <h1 className=\"text-lg font-semibold\">\r\n                  {currentPack?.title}\r\n                </h1>\r\n                <div className=\"text-sm text-gray-500\">\r\n                  {currentCard.reason === 'wrong_answer' ? '🔴 오답 복습' :\r\n                   currentCard.reason === 'forgetting_curve' ? '📅 망각곡선' :\r\n                   currentCard.reason === 'weakness_pattern' ? '🎯 약점 보강' :\r\n                   '🔥 난이도 조절'}\r\n                </div>\r\n              </div>\r\n              <div className=\"text-sm text-gray-500\">\r\n                {currentIndex + 1}/{currentPack?.totalCards}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Progress Bar */}\r\n        <div className=\"bg-white border-b\">\r\n          <div className=\"max-w-2xl mx-auto px-4 py-2\">\r\n            <div className=\"bg-gray-200 rounded-full h-2\">\r\n              <div \r\n                className=\"bg-gradient-to-r from-purple-500 to-pink-500 h-2 rounded-full transition-all duration-300\"\r\n                style={{ \r\n                  width: `${((currentIndex + 1) / (currentPack?.totalCards || 1)) * 100}%`\r\n                }}\r\n              />\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Main Content */}\r\n        <div className=\"max-w-2xl mx-auto px-4 py-8\">\r\n          {/* Korean Prompt Card */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-8 mb-8\">\r\n            <div className=\"text-center\">\r\n              <div className=\"flex items-center justify-center mb-2\">\r\n                <span className=\"text-sm font-medium text-gray-500\">한국어를 영어로</span>\r\n                <span className=\"ml-3 text-xs px-2 py-1 rounded-full bg-purple-100 text-purple-700\">\r\n                  {currentCard.reasonDetail}\r\n                </span>\r\n              </div>\r\n              <p className=\"text-2xl font-bold text-gray-800 mb-6\">\r\n                {currentCard.cardData.front_ko}\r\n              </p>\r\n              \r\n              {/* Expected Answer (shown after feedback) */}\r\n              {hasAnswer && (\r\n                <div className=\"text-sm text-gray-600 bg-gray-50 rounded p-3\">\r\n                  <span className=\"font-medium\">정답: </span>\r\n                  {currentCard.cardData.target_en}\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n\r\n          {/* Input Section */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-8 mb-8\">\r\n            <div className=\"text-center\">\r\n              {learningMode.mode === 'writing' ? (\r\n                <WritingModeInput\r\n                  question={{\r\n                    id: currentCard.cardData.id,\r\n                    front_ko: currentCard.cardData.front_ko,\r\n                    target_en: currentCard.cardData.target_en,\r\n                    level: user.level,\r\n                    stage: user.stage,\r\n                    difficulty: currentCard.expectedDifficulty\r\n                  }}\r\n                  onSubmit={handleWritingSubmit}\r\n                  disabled={!!writingFeedback}\r\n                />\r\n              ) : (\r\n                <AutoSpeakingFlowV2\r\n                  currentCard={currentCard.cardData}\r\n                  onSpeechResult={handleSpeechResult}\r\n                  onTimeout={() => {\r\n                    // AutoSpeakingFlowV2에서 이미 정답을 재생하므로 바로 다음 카드로\r\n                    console.log('[AdaptivePackPage] Timeout - proceeding to next card');\r\n                    setTimeout(() => {\r\n                      if (currentCard) {\r\n                        nextCard();\r\n                      }\r\n                    }, 100);\r\n                  }}\r\n                  isActive={!speechFeedback}\r\n                  recordingDuration={10}\r\n                />\r\n              )}\r\n            </div>\r\n          </div>\r\n\r\n          {/* Feedback Section */}\r\n          {writingFeedback && (\r\n            <WritingModeFeedback\r\n              feedback={writingFeedback}\r\n              targetAnswer={currentCard.cardData.target_en}\r\n              onPlayAnswer={() => speech.speak(currentCard.cardData.target_en)}\r\n              canPlayAnswer={speech.isTTSAvailable}\r\n            />\r\n          )}\r\n\r\n          {speechFeedback && (\r\n            <FeedbackPanel\r\n              feedback={speechFeedback}\r\n              onPlayAnswer={() => speech.speak(currentCard.cardData.target_en)}\r\n              canPlayAnswer={speech.isTTSAvailable}\r\n            />\r\n          )}\r\n\r\n          {/* Navigation */}\r\n          <div className=\"flex justify-between items-center mt-6\">\r\n            <div className=\"flex space-x-2\">\r\n              {hasAnswer && (\r\n                <button\r\n                  onClick={() => speech.speak(currentCard.cardData.target_en)}\r\n                  disabled={!speech.isTTSAvailable}\r\n                  className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 text-sm\"\r\n                >\r\n                  🔊 정답 듣기\r\n                </button>\r\n              )}\r\n            </div>\r\n\r\n            {currentIndex < (currentPack?.totalCards || 0) - 1 ? (\r\n              <button\r\n                onClick={handleNextCard}\r\n                disabled={!hasAnswer}\r\n                className=\"px-6 py-3 bg-green-500 text-white rounded-lg disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-green-600 transition-colors\"\r\n              >\r\n                다음 카드 →\r\n              </button>\r\n            ) : (\r\n              <button\r\n                onClick={finishPack}\r\n                disabled={!hasAnswer}\r\n                className=\"px-6 py-3 bg-purple-500 text-white rounded-lg disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-purple-600 transition-colors\"\r\n              >\r\n                팩 완료\r\n              </button>\r\n            )}\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Main Page UI\r\n  return (\r\n    <div className=\"min-h-screen bg-gradient-to-br from-purple-50 to-pink-100 p-4\">\r\n      <div className=\"max-w-6xl mx-auto\">\r\n        {/* Header */}\r\n        <div className=\"text-center mb-8\">\r\n          <button\r\n            onClick={() => navigate('/')}\r\n            className=\"text-gray-600 hover:text-gray-800 mb-4\"\r\n          >\r\n            ← 뒤로\r\n          </button>\r\n          <h1 className=\"text-4xl font-bold text-gray-800 mb-2\">\r\n            🎯 개인 맞춤팩 (Adaptive)\r\n          </h1>\r\n          <p className=\"text-gray-600 text-lg\">\r\n            AI가 분석한 오답 + 망각곡선 + 약점 패턴 완전 자동화\r\n          </p>\r\n        </div>\r\n\r\n        <div className=\"grid lg:grid-cols-3 gap-6\">\r\n          {/* Analytics Panel */}\r\n          <div className=\"lg:col-span-1\">\r\n            <div className=\"bg-white rounded-2xl shadow-xl p-6 mb-6\">\r\n              <h2 className=\"text-2xl font-bold text-gray-800 mb-4\">\r\n                📊 학습 분석\r\n              </h2>\r\n              \r\n              {analytics ? (\r\n                <div className=\"space-y-4\">\r\n                  <div className=\"bg-blue-50 rounded-lg p-4\">\r\n                    <div className=\"text-2xl font-bold text-blue-600\">{analytics.correctRate}%</div>\r\n                    <div className=\"text-sm text-gray-600\">전체 정답률</div>\r\n                  </div>\r\n                  \r\n                  <div className=\"bg-green-50 rounded-lg p-4\">\r\n                    <div className=\"text-2xl font-bold text-green-600\">{analytics.totalAnswered}</div>\r\n                    <div className=\"text-sm text-gray-600\">총 학습 카드</div>\r\n                  </div>\r\n                  \r\n                  <div className=\"bg-purple-50 rounded-lg p-4\">\r\n                    <div className=\"text-2xl font-bold text-purple-600\">{analytics.averageResponseTime}s</div>\r\n                    <div className=\"text-sm text-gray-600\">평균 응답 시간</div>\r\n                  </div>\r\n\r\n                  <div className=\"bg-orange-50 rounded-lg p-4\">\r\n                    <div className=\"text-2xl font-bold text-orange-600\">{analytics.identifiedWeaknesses.length}</div>\r\n                    <div className=\"text-sm text-gray-600\">식별된 약점</div>\r\n                  </div>\r\n                </div>\r\n              ) : (\r\n                <div className=\"text-center py-8 text-gray-500\">\r\n                  <p>분석 데이터 로딩 중...</p>\r\n                </div>\r\n              )}\r\n\r\n              <button\r\n                onClick={() => setShowPackGenerator(true)}\r\n                className=\"w-full mt-6 bg-gradient-to-r from-purple-600 to-pink-600 text-white py-3 rounded-xl hover:from-purple-700 hover:to-pink-700 transition-all duration-200 font-medium\"\r\n              >\r\n                🚀 새 Adaptive Pack 생성\r\n              </button>\r\n            </div>\r\n\r\n            {/* Learning Insights */}\r\n            {analytics && analytics.identifiedWeaknesses.length > 0 && (\r\n              <div className=\"bg-white rounded-2xl shadow-xl p-6\">\r\n                <h3 className=\"text-lg font-bold text-gray-800 mb-4\">🔍 약점 분석</h3>\r\n                <div className=\"space-y-3\">\r\n                  {analytics.identifiedWeaknesses.map((weakness, index) => (\r\n                    <div key={index} className=\"border-l-4 border-orange-500 bg-orange-50 p-3 rounded-r-lg\">\r\n                      <div className=\"flex items-center justify-between mb-1\">\r\n                        <span className=\"font-medium text-sm\">{weakness.pattern}</span>\r\n                        <span className=\"text-xs bg-orange-200 text-orange-800 px-2 py-1 rounded-full\">\r\n                          Level {weakness.level}\r\n                        </span>\r\n                      </div>\r\n                      <p className=\"text-xs text-gray-600\">{weakness.description}</p>\r\n                    </div>\r\n                  ))}\r\n                </div>\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          {/* Saved Packs */}\r\n          <div className=\"lg:col-span-2\">\r\n            <div className=\"bg-white rounded-2xl shadow-xl p-6\">\r\n              <div className=\"flex items-center justify-between mb-6\">\r\n                <h2 className=\"text-2xl font-bold text-gray-800\">📦 생성된 Adaptive Pack</h2>\r\n                <span className=\"text-sm text-gray-500\">{savedPacks.length}개</span>\r\n              </div>\r\n\r\n              {savedPacks.length === 0 ? (\r\n                <div className=\"text-center py-16\">\r\n                  <div className=\"text-6xl mb-4\">🤖</div>\r\n                  <p className=\"text-xl font-medium text-gray-700 mb-2\">아직 Adaptive Pack이 없습니다</p>\r\n                  <p className=\"text-gray-500 mb-6\">AI가 오답, 망각곡선, 약점 패턴을 분석해서 맞춤형 학습팩을 만들어드립니다</p>\r\n                  <button\r\n                    onClick={() => setShowPackGenerator(true)}\r\n                    className=\"bg-gradient-to-r from-purple-600 to-pink-600 text-white px-6 py-3 rounded-xl hover:from-purple-700 hover:to-pink-700 transition-all duration-200 font-medium\"\r\n                  >\r\n                    첫 번째 Adaptive Pack 생성\r\n                  </button>\r\n                </div>\r\n              ) : (\r\n                <div className=\"grid md:grid-cols-2 gap-4\">\r\n                  {savedPacks.map((pack) => (\r\n                    <div\r\n                      key={pack.id}\r\n                      className=\"border rounded-xl p-4 hover:shadow-lg transition-shadow cursor-pointer bg-gradient-to-br from-white to-purple-50\"\r\n                      onClick={() => startPack(pack)}\r\n                    >\r\n                      <div className=\"flex items-start justify-between mb-3\">\r\n                        <h3 className=\"font-bold text-gray-800 text-lg leading-tight\">\r\n                          {pack.title}\r\n                        </h3>\r\n                        <span className=\"px-2 py-1 rounded-full text-xs font-medium bg-purple-100 text-purple-700\">\r\n                          {pack.algorithm}\r\n                        </span>\r\n                      </div>\r\n                      \r\n                      <p className=\"text-sm text-gray-600 mb-3\">{pack.description}</p>\r\n                      \r\n                      <div className=\"flex items-center justify-between text-sm text-gray-500 mb-3\">\r\n                        <span>📝 {pack.totalCards}카드</span>\r\n                        <span>⏱️ ~{pack.estimatedTime}분</span>\r\n                      </div>\r\n\r\n                      {/* Pack Composition */}\r\n                      <div className=\"flex flex-wrap gap-1 mb-3\">\r\n                        {pack.cards.filter(c => c.reason === 'wrong_answer').length > 0 && (\r\n                          <span className=\"text-xs bg-red-100 text-red-700 px-2 py-1 rounded-full\">\r\n                            🔴 오답 {pack.cards.filter(c => c.reason === 'wrong_answer').length}\r\n                          </span>\r\n                        )}\r\n                        {pack.cards.filter(c => c.reason === 'forgetting_curve').length > 0 && (\r\n                          <span className=\"text-xs bg-orange-100 text-orange-700 px-2 py-1 rounded-full\">\r\n                            📅 망각 {pack.cards.filter(c => c.reason === 'forgetting_curve').length}\r\n                          </span>\r\n                        )}\r\n                        {pack.cards.filter(c => c.reason === 'weakness_pattern').length > 0 && (\r\n                          <span className=\"text-xs bg-blue-100 text-blue-700 px-2 py-1 rounded-full\">\r\n                            🎯 약점 {pack.cards.filter(c => c.reason === 'weakness_pattern').length}\r\n                          </span>\r\n                        )}\r\n                      </div>\r\n\r\n                      {/* Learning Objectives */}\r\n                      <div className=\"text-xs text-gray-600\">\r\n                        <strong>목표:</strong> {pack.learningObjectives.slice(0, 2).join(', ')}\r\n                        {pack.learningObjectives.length > 2 && '...'}\r\n                      </div>\r\n                    </div>\r\n                  ))}\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Pack Generator Modal */}\r\n        {showPackGenerator && (\r\n          <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50\">\r\n            <div className=\"bg-white rounded-2xl shadow-2xl max-w-lg w-full\">\r\n              <div className=\"p-6\">\r\n                <div className=\"flex items-center justify-between mb-6\">\r\n                  <h3 className=\"text-2xl font-bold text-gray-800\">🚀 Adaptive Pack 생성</h3>\r\n                  <button\r\n                    onClick={() => setShowPackGenerator(false)}\r\n                    className=\"text-gray-400 hover:text-gray-600 text-2xl\"\r\n                  >\r\n                    ×\r\n                  </button>\r\n                </div>\r\n\r\n                <div className=\"space-y-4 mb-6\">\r\n                  <div>\r\n                    <label className=\"block text-sm font-medium text-gray-700 mb-2\">알고리즘</label>\r\n                    <select\r\n                      value={generationOptions.algorithm}\r\n                      onChange={(e) => setGenerationOptions({\r\n                        ...generationOptions, \r\n                        algorithm: e.target.value as any\r\n                      })}\r\n                      className=\"w-full p-3 border border-gray-300 rounded-lg\"\r\n                    >\r\n                      <option value=\"standard\">표준 (균형잡힌 학습)</option>\r\n                      <option value=\"intensive\">집중 (오답 위주)</option>\r\n                      <option value=\"review_focused\">복습 중심 (망각곡선 우선)</option>\r\n                    </select>\r\n                  </div>\r\n                  \r\n                  <div>\r\n                    <label className=\"block text-sm font-medium text-gray-700 mb-2\">카드 수</label>\r\n                    <select\r\n                      value={generationOptions.targetSize}\r\n                      onChange={(e) => setGenerationOptions({\r\n                        ...generationOptions, \r\n                        targetSize: parseInt(e.target.value)\r\n                      })}\r\n                      className=\"w-full p-3 border border-gray-300 rounded-lg\"\r\n                    >\r\n                      <option value={10}>10개 (빠른 학습)</option>\r\n                      <option value={15}>15개 (표준)</option>\r\n                      <option value={20}>20개 (심화)</option>\r\n                      <option value={30}>30개 (집중)</option>\r\n                    </select>\r\n                  </div>\r\n                </div>\r\n\r\n                <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6\">\r\n                  <h4 className=\"font-semibold text-blue-900 mb-2\">🤖 AI 분석 기반</h4>\r\n                  <ul className=\"text-sm text-blue-800 space-y-1\">\r\n                    <li>• 오답률과 망각곡선 데이터 종합 분석</li>\r\n                    <li>• 개인별 약점 패턴 자동 식별</li>\r\n                    <li>• 최적 학습 순서와 난이도 조정</li>\r\n                    <li>• SuperMemo SM-2 알고리즘 적용</li>\r\n                  </ul>\r\n                </div>\r\n\r\n                <div className=\"flex gap-3\">\r\n                  <button\r\n                    onClick={() => setShowPackGenerator(false)}\r\n                    className=\"flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-xl hover:bg-gray-50 font-medium\"\r\n                  >\r\n                    취소\r\n                  </button>\r\n                  <button\r\n                    onClick={generateNewPack}\r\n                    disabled={!analytics || analytics.totalAnswered < 5}\r\n                    className=\"flex-1 py-3 px-4 bg-gradient-to-r from-purple-600 to-pink-600 text-white rounded-xl hover:from-purple-700 hover:to-pink-700 disabled:opacity-50 disabled:cursor-not-allowed font-medium\"\r\n                  >\r\n                    생성하기\r\n                  </button>\r\n                </div>\r\n                \r\n                {(!analytics || analytics.totalAnswered < 5) && (\r\n                  <p className=\"text-xs text-gray-500 mt-2 text-center\">\r\n                    최소 5개 이상의 카드를 학습한 후 생성 가능합니다\r\n                  </p>\r\n                )}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\AllModePage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useMemo' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useCallback' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":47,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":58},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useSRSEngine' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SpeechRecorder' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":24},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadSRSStats'. Either include it or remove the dependency array.","line":63,"column":6,"nodeType":"ArrayExpression","endLine":63,"endColumn":15,"suggestions":[{"desc":"Update the dependencies array to be: [loadSRSStats, user.id]","fix":{"range":[2788,2797],"text":"[loadSRSStats, user.id]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadCurrentCard'. Either include it or remove the dependency array.","line":70,"column":6,"nodeType":"ArrayExpression","endLine":70,"endColumn":52,"suggestions":[{"desc":"Update the dependencies array to be: [reviewSession, currentIndex, isSessionActive, loadCurrentCard]","fix":{"range":[2962,3008],"text":"[reviewSession, currentIndex, isSessionActive, loadCurrentCard]"}}]},{"ruleId":"no-undef","severity":1,"message":"'stats' is not defined.","line":78,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":78,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":106,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":106,"endColumn":19},{"ruleId":"no-undef","severity":1,"message":"'srsService' is not defined.","line":122,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":122,"endColumn":35},{"ruleId":"no-undef","severity":1,"message":"'srsService' is not defined.","line":125,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":125,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":145,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":145,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":183,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":183,"endColumn":19},{"ruleId":"no-undef","severity":1,"message":"'srsService' is not defined.","line":276,"column":11,"nodeType":"Identifier","messageId":"undef","endLine":276,"endColumn":21},{"ruleId":"no-undef","severity":1,"message":"'nextCard' is not defined.","line":498,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":498,"endColumn":33}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":14,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useMemo, useCallback } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { useUser, useAppStore, useLearningMode } from '@/store/useAppStore';\r\n// import { srsService, type SRSCard, type SRSReviewSession } from '@/services/srsService';\r\n// TODO: Migrate to new SRS Engine system - useSRSEngine hook from @/hooks/useSRSEngine\r\nimport { useSRSEngine } from '@/hooks/useSRSEngine';\r\nimport type { ReviewCard } from '@/services/srs/SRSEngine';\r\nimport { WritingModeInput } from '@/components/WritingModeInput';\r\nimport { WritingModeFeedback } from '@/components/WritingModeFeedback';\r\nimport { SpeechRecorder } from '@/components/SpeechRecorder';\r\nimport { AutoSpeakingFlowV2 } from '@/components/AutoSpeakingFlowV2';\r\nimport { FeedbackPanel } from '@/components/FeedbackPanel';\r\nimport { useSpeech } from '@/hooks/useSpeech';\r\nimport { api } from '@/lib/api';\r\nimport { getServiceContainer } from '@/container/ServiceContainer';\r\nimport type { IScoreCalculationService } from '@/container/ServiceContainer';\r\nimport type { DrillCard, FeedbackResponse } from '@/types';\r\nimport type { WritingFeedback } from '@/services/writingMode';\r\n\r\nexport const AllModePage: React.FC = React.memo(() => {\r\n  const navigate = useNavigate();\r\n  const user = useUser();\r\n  const learningMode = useLearningMode();\r\n  const { setLoading, setError, clearError } = useAppStore();\r\n\r\n  // SRS 관련 상태\r\n  // const [reviewSession, setReviewSession] = useState<SRSReviewSession | null>(null);\r\n  // const [currentSRSCard, setCurrentSRSCard] = useState<SRSCard | null>(null);\r\n  const [reviewSession, setReviewSession] = useState<any | null>(null);\r\n  const [currentSRSCard, setCurrentSRSCard] = useState<ReviewCard | null>(null);\r\n  const [currentCardData, setCurrentCardData] = useState<DrillCard | null>(null);\r\n  const [currentIndex, setCurrentIndex] = useState(0);\r\n\r\n  // 피드백 상태\r\n  const [speechFeedback, setSpeechFeedback] = useState<FeedbackResponse | null>(null);\r\n  const [writingFeedback, setWritingFeedback] = useState<WritingFeedback | null>(null);\r\n\r\n  // SRS 통계\r\n  const [srsStats, setSrsStats] = useState({\r\n    totalCards: 0,\r\n    dueToday: 0,\r\n    averageEaseFactor: 2.5,\r\n    accuracyRate: 0,\r\n    streakDays: 0\r\n  });\r\n\r\n  const [cardStartTime, setCardStartTime] = useState<number>(0);\r\n  const [isSessionActive, setIsSessionActive] = useState(false);\r\n\r\n  // 서비스 컨테이너에서 의존성 주입\r\n  const serviceContainer = getServiceContainer();\r\n  const scoreCalculator: IScoreCalculationService = serviceContainer.getScoreCalculationService();\r\n  \r\n  const speech = useSpeech({\r\n    apiBaseUrl: import.meta.env.VITE_API_BASE_URL,\r\n    preferCloudSTT: false,\r\n    language: 'en-US',\r\n  });\r\n\r\n  // SRS 통계 로드\r\n  useEffect(() => {\r\n    loadSRSStats();\r\n  }, [user.id]);\r\n\r\n  // 복습 세션 시작\r\n  useEffect(() => {\r\n    if (isSessionActive && reviewSession && reviewSession.reviewCards.length > 0) {\r\n      loadCurrentCard();\r\n    }\r\n  }, [reviewSession, currentIndex, isSessionActive]);\r\n\r\n  const loadSRSStats = async () => {\r\n    if (!user.id) return;\r\n    \r\n    try {\r\n      // const stats = await srsService.getSRSStats(user.id);\r\n      // TODO: Migrate to new SRS Engine system\r\n      setSrsStats(stats);\r\n    } catch (error) {\r\n      console.error('SRS 통계 로드 실패:', error);\r\n    }\r\n  };\r\n\r\n  const loadCurrentCard = async () => {\r\n    if (!reviewSession || currentIndex >= reviewSession.reviewCards.length) return;\r\n\r\n    const srsCard = reviewSession.reviewCards[currentIndex];\r\n    setCurrentSRSCard(srsCard);\r\n\r\n    try {\r\n      // 실제 카드 데이터 로드 (레벨/스테이지에서)\r\n      const response = await api.getCards(srsCard.level, srsCard.stage);\r\n      \r\n      if (response.success && response.data) {\r\n        // cardId로 특정 카드 찾기\r\n        const foundCard = response.data.cards.find(card => card.id === srsCard.cardId);\r\n        if (foundCard) {\r\n          setCurrentCardData(foundCard);\r\n          setCardStartTime(Date.now());\r\n        } else {\r\n          setError('카드를 찾을 수 없습니다');\r\n        }\r\n      } else {\r\n        setError(response.error || '카드를 불러오는데 실패했습니다');\r\n      }\r\n    } catch (error) {\r\n      setError('네트워크 오류가 발생했습니다');\r\n    }\r\n  };\r\n\r\n  const startReviewSession = async (mode: 'due' | 'random') => {\r\n    if (!user.id) return;\r\n\r\n    setLoading(true);\r\n    clearError();\r\n\r\n    try {\r\n      let session: any; // TODO: Use new SRS Engine types\r\n      \r\n      if (mode === 'due') {\r\n        // 복습이 필요한 카드들\r\n        session = await srsService.startReviewSession(user.id, 20);\r\n      } else {\r\n        // 가중치 랜덤 선택\r\n        const randomCards = await srsService.getWeightedRandomCards(user.id, 20);\r\n        session = {\r\n          sessionId: `random_${Date.now()}`,\r\n          userId: user.id,\r\n          reviewCards: randomCards,\r\n          startTime: new Date(),\r\n          totalCards: randomCards.length,\r\n          completedCards: 0,\r\n          accuracyRate: 0\r\n        };\r\n      }\r\n\r\n      if (session.reviewCards.length === 0) {\r\n        setError('복습할 카드가 없습니다');\r\n        return;\r\n      }\r\n\r\n      setReviewSession(session);\r\n      setCurrentIndex(0);\r\n      setIsSessionActive(true);\r\n    } catch (error) {\r\n      setError('세션 시작에 실패했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleSpeechResult = async (transcript: string, confidence: number) => {\r\n    if (!currentCardData || !currentSRSCard) return;\r\n\r\n    await processAnswer(transcript, confidence, true);\r\n  };\r\n\r\n  const handleWritingSubmit = async (userInput: string, feedback: WritingFeedback) => {\r\n    if (!currentCardData || !currentSRSCard) return;\r\n\r\n    setWritingFeedback(feedback);\r\n    await processAnswer(userInput, feedback.score / 100, false, feedback);\r\n  };\r\n\r\n  const processAnswer = async (\r\n    userAnswer: string, \r\n    confidence: number, \r\n    isSpeaking: boolean,\r\n    writingFeedback?: WritingFeedback\r\n  ) => {\r\n    if (!validateAnswerProcessing()) return;\r\n\r\n    const responseTime = calculateResponseTime();\r\n    setLoading(true);\r\n\r\n    try {\r\n      const evaluationResult = await evaluateUserAnswer(userAnswer, isSpeaking, writingFeedback);\r\n      \r\n      if (evaluationResult) {\r\n        await updateSRSRecord(evaluationResult, responseTime);\r\n      }\r\n\r\n    } catch (error) {\r\n      handleAnswerProcessingError();\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * 답변 처리 전 검증\r\n   */\r\n  const validateAnswerProcessing = (): boolean => {\r\n    return !!(currentCardData && currentSRSCard);\r\n  };\r\n\r\n  /**\r\n   * 응답 시간 계산\r\n   */\r\n  const calculateResponseTime = (): number => {\r\n    return (Date.now() - cardStartTime) / 1000;\r\n  };\r\n\r\n  /**\r\n   * 사용자 답변 평가\r\n   */\r\n  const evaluateUserAnswer = async (\r\n    userAnswer: string,\r\n    isSpeaking: boolean,\r\n    writingFeedback?: WritingFeedback\r\n  ): Promise<{ isCorrect: boolean; score: number; confidence: number; responseTime: number } | null> => {\r\n    let isCorrect = false;\r\n    let score = 0;\r\n    const responseTime = calculateResponseTime();\r\n\r\n    if (isSpeaking) {\r\n      const speakingResult = await evaluateSpeakingAnswer(userAnswer);\r\n      if (!speakingResult) return null;\r\n      \r\n      isCorrect = speakingResult.isCorrect;\r\n      score = speakingResult.score;\r\n    } else {\r\n      const writingResult = evaluateWritingAnswer(writingFeedback);\r\n      isCorrect = writingResult.isCorrect;\r\n      score = writingResult.score;\r\n    }\r\n\r\n    return { isCorrect, score, confidence: Math.max(0.6, score / 100), responseTime };\r\n  };\r\n\r\n  /**\r\n   * 말하기 답변 평가\r\n   */\r\n  const evaluateSpeakingAnswer = async (userAnswer: string): Promise<{ isCorrect: boolean; score: number } | null> => {\r\n    if (!currentCardData) return null;\r\n\r\n    const feedbackResponse = await api.getFeedback({\r\n      front_ko: currentCardData.front_ko,\r\n      sttText: userAnswer,\r\n      target_en: currentCardData.target_en,\r\n    });\r\n\r\n    if (feedbackResponse.success && feedbackResponse.data) {\r\n      setSpeechFeedback(feedbackResponse.data);\r\n      return {\r\n        isCorrect: feedbackResponse.data.correct,\r\n        score: feedbackResponse.data.score\r\n      };\r\n    }\r\n\r\n    return null;\r\n  };\r\n\r\n  /**\r\n   * 쓰기 답변 평가\r\n   */\r\n  const evaluateWritingAnswer = (writingFeedback?: WritingFeedback): { isCorrect: boolean; score: number } => {\r\n    return {\r\n      isCorrect: writingFeedback?.isCorrect || false,\r\n      score: writingFeedback?.score || 0\r\n    };\r\n  };\r\n\r\n  /**\r\n   * SRS 레코드 업데이트\r\n   */\r\n  const updateSRSRecord = async (\r\n    evaluationResult: { isCorrect: boolean; score: number; confidence: number; responseTime: number }\r\n  ): Promise<void> => {\r\n    if (!currentSRSCard) return;\r\n\r\n    const qualityResult = calculateLearningQuality(evaluationResult);\r\n    \r\n    console.log('[AllModePage] Quality calculation result:', qualityResult);\r\n\r\n    await srsService.updateCardAfterReview(user.id, currentSRSCard.cardId, {\r\n      quality: qualityResult.quality,\r\n      responseTime: evaluationResult.responseTime,\r\n      isCorrect: evaluationResult.isCorrect\r\n    });\r\n  };\r\n\r\n  /**\r\n   * 학습 품질 점수 계산\r\n   */\r\n  const calculateLearningQuality = (evaluationResult: { isCorrect: boolean; score: number; confidence: number; responseTime: number }) => {\r\n    return scoreCalculator.calculateQuality({\r\n      isCorrect: evaluationResult.isCorrect,\r\n      confidence: evaluationResult.confidence,\r\n      score: evaluationResult.score,\r\n      responseTime: evaluationResult.responseTime\r\n    });\r\n  };\r\n\r\n  /**\r\n   * 답변 처리 에러 처리\r\n   */\r\n  const handleAnswerProcessingError = (): void => {\r\n    setError('답변 처리 중 오류가 발생했습니다');\r\n  };\r\n\r\n  const handleNextCard = () => {\r\n    const nextIndex = currentIndex + 1;\r\n    \r\n    if (nextIndex < reviewSession!.reviewCards.length) {\r\n      setCurrentIndex(nextIndex);\r\n      setSpeechFeedback(null);\r\n      setWritingFeedback(null);\r\n    } else {\r\n      finishSession();\r\n    }\r\n  };\r\n\r\n  const finishSession = async () => {\r\n    // 세션 완료 처리\r\n    await loadSRSStats(); // 통계 업데이트\r\n    navigate('/', { \r\n      state: { \r\n        message: `ALL 모드 완료! ${reviewSession?.totalCards}개 카드를 복습했습니다.`\r\n      }\r\n    });\r\n  };\r\n\r\n  const hasAnswer = speechFeedback || writingFeedback;\r\n\r\n  if (!isSessionActive) {\r\n    return (\r\n      <div className=\"min-h-screen bg-gradient-to-br from-purple-50 to-indigo-100 p-4\">\r\n        <div className=\"max-w-2xl mx-auto\">\r\n          {/* Header */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-6 mb-6\">\r\n            <div className=\"flex items-center justify-between mb-4\">\r\n              <button\r\n                onClick={() => navigate('/')}\r\n                className=\"text-gray-600 hover:text-gray-800\"\r\n              >\r\n                ← 뒤로\r\n              </button>\r\n              <h1 className=\"text-2xl font-bold text-center\">\r\n                🔄 ALL 모드 (망각곡선 복습)\r\n              </h1>\r\n              <div className=\"w-8\"></div>\r\n            </div>\r\n            \r\n            <p className=\"text-gray-600 text-center\">\r\n              SRS 알고리즘으로 최적화된 복습 시스템\r\n            </p>\r\n          </div>\r\n\r\n          {/* SRS 통계 */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-6 mb-6\">\r\n            <h2 className=\"text-xl font-bold mb-4\">📊 복습 현황</h2>\r\n            \r\n            <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\r\n              <div className=\"bg-blue-50 rounded-lg p-4 text-center\">\r\n                <div className=\"text-2xl font-bold text-blue-600\">{srsStats.totalCards}</div>\r\n                <div className=\"text-sm text-gray-600\">전체 카드</div>\r\n              </div>\r\n              \r\n              <div className=\"bg-red-50 rounded-lg p-4 text-center\">\r\n                <div className=\"text-2xl font-bold text-red-600\">{srsStats.dueToday}</div>\r\n                <div className=\"text-sm text-gray-600\">오늘 복습</div>\r\n              </div>\r\n              \r\n              <div className=\"bg-green-50 rounded-lg p-4 text-center\">\r\n                <div className=\"text-2xl font-bold text-green-600\">{srsStats.accuracyRate}%</div>\r\n                <div className=\"text-sm text-gray-600\">정답률</div>\r\n              </div>\r\n              \r\n              <div className=\"bg-purple-50 rounded-lg p-4 text-center\">\r\n                <div className=\"text-2xl font-bold text-purple-600\">{srsStats.averageEaseFactor}</div>\r\n                <div className=\"text-sm text-gray-600\">평균 난이도</div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* 학습 모드 선택 */}\r\n          <div className=\"space-y-4\">\r\n            <button\r\n              onClick={() => startReviewSession('due')}\r\n              disabled={srsStats.dueToday === 0}\r\n              className=\"w-full bg-gradient-to-r from-red-500 to-orange-500 hover:from-red-600 hover:to-orange-600 disabled:from-gray-300 disabled:to-gray-400 text-white font-bold py-4 px-6 rounded-lg transition-all duration-200\"\r\n            >\r\n              📅 오늘 복습할 카드 ({srsStats.dueToday}개)\r\n            </button>\r\n\r\n            <button\r\n              onClick={() => startReviewSession('random')}\r\n              disabled={srsStats.totalCards === 0}\r\n              className=\"w-full bg-gradient-to-r from-purple-500 to-indigo-500 hover:from-purple-600 hover:to-indigo-600 disabled:from-gray-300 disabled:to-gray-400 text-white font-bold py-4 px-6 rounded-lg transition-all duration-200\"\r\n            >\r\n              🎲 가중치 랜덤 복습 (20개)\r\n            </button>\r\n\r\n            <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4\">\r\n              <h3 className=\"font-semibold text-blue-900 mb-2\">💡 ALL 모드 특징</h3>\r\n              <ul className=\"text-sm text-blue-800 space-y-1\">\r\n                <li>• <strong>망각곡선 기반:</strong> SuperMemo SM-2 알고리즘 사용</li>\r\n                <li>• <strong>개인 맞춤:</strong> 틀린 문제는 더 자주, 맞힌 문제는 간격 증가</li>\r\n                <li>• <strong>가중치 시스템:</strong> 오답률과 마지막 학습일을 고려한 선택</li>\r\n                <li>• <strong>모드 연동:</strong> {learningMode.mode === 'writing' ? '✍️ Writing' : '🎤 Speaking'} 모드로 학습</li>\r\n              </ul>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // 학습 세션 중인 경우\r\n  return (\r\n    <div className=\"min-h-screen bg-gray-50\">\r\n      {/* Header */}\r\n      <div className=\"bg-white shadow-sm border-b\">\r\n        <div className=\"max-w-2xl mx-auto px-4 py-3\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <button\r\n              onClick={() => navigate('/')}\r\n              className=\"text-gray-600 hover:text-gray-800\"\r\n            >\r\n              ← 뒤로\r\n            </button>\r\n            <div className=\"text-center\">\r\n              <h1 className=\"text-lg font-semibold\">\r\n                ALL 모드 복습\r\n              </h1>\r\n              <div className=\"text-sm text-gray-500\">\r\n                Level {currentSRSCard?.level}.{currentSRSCard?.stage}\r\n              </div>\r\n            </div>\r\n            <div className=\"text-sm text-gray-500\">\r\n              {currentIndex + 1}/{reviewSession?.totalCards}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Progress Bar */}\r\n      <div className=\"bg-white border-b\">\r\n        <div className=\"max-w-2xl mx-auto px-4 py-2\">\r\n          <div className=\"bg-gray-200 rounded-full h-2\">\r\n            <div \r\n              className=\"bg-purple-500 h-2 rounded-full transition-all duration-300\"\r\n              style={{ \r\n                width: `${((currentIndex + 1) / (reviewSession?.totalCards || 1)) * 100}%`\r\n              }}\r\n            />\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Main Content */}\r\n      {currentCardData && (\r\n        <div className=\"max-w-2xl mx-auto px-4 py-8\">\r\n          {/* Korean Prompt Card */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-8 mb-8\">\r\n            <div className=\"text-center\">\r\n              <h2 className=\"text-sm font-medium text-gray-500 mb-2\">한국어를 영어로</h2>\r\n              <p className=\"text-2xl font-bold text-gray-800 mb-6\">\r\n                {currentCardData.front_ko}\r\n              </p>\r\n              \r\n              {/* Expected Answer (shown after feedback) */}\r\n              {hasAnswer && (\r\n                <div className=\"text-sm text-gray-600 bg-gray-50 rounded p-3\">\r\n                  <span className=\"font-medium\">정답: </span>\r\n                  {currentCardData.target_en}\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n\r\n          {/* Input Section */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-8 mb-8\">\r\n            <div className=\"text-center\">\r\n              {learningMode.mode === 'writing' ? (\r\n                <WritingModeInput\r\n                  question={{\r\n                    id: currentCardData.id,\r\n                    front_ko: currentCardData.front_ko,\r\n                    target_en: currentCardData.target_en,\r\n                    level: currentSRSCard?.level || 1,\r\n                    stage: currentSRSCard?.stage || 1,\r\n                    difficulty: currentSRSCard?.difficulty || 'medium'\r\n                  }}\r\n                  onSubmit={handleWritingSubmit}\r\n                  disabled={!!writingFeedback}\r\n                />\r\n              ) : (\r\n                <AutoSpeakingFlowV2\r\n                  currentCard={currentCardData}\r\n                  onSpeechResult={handleSpeechResult}\r\n                  onTimeout={() => {\r\n                    // AutoSpeakingFlowV2에서 이미 정답을 재생하므로 바로 다음 카드로\r\n                    console.log('[AllModePage] Timeout - proceeding to next card');\r\n                    setTimeout(() => {\r\n                      if (currentSRSCard) {\r\n                        nextCard();\r\n                      }\r\n                    }, 100);\r\n                  }}\r\n                  isActive={!speechFeedback}\r\n                  recordingDuration={10}\r\n                />\r\n              )}\r\n            </div>\r\n          </div>\r\n\r\n          {/* Feedback Section */}\r\n          {writingFeedback && (\r\n            <WritingModeFeedback\r\n              feedback={writingFeedback}\r\n              targetAnswer={currentCardData.target_en}\r\n              onPlayAnswer={() => speech.speak(currentCardData.target_en)}\r\n              canPlayAnswer={speech.isTTSAvailable}\r\n            />\r\n          )}\r\n\r\n          {speechFeedback && (\r\n            <FeedbackPanel\r\n              feedback={speechFeedback}\r\n              onPlayAnswer={() => speech.speak(currentCardData.target_en)}\r\n              canPlayAnswer={speech.isTTSAvailable}\r\n            />\r\n          )}\r\n\r\n          {/* Navigation */}\r\n          <div className=\"flex justify-between items-center mt-6\">\r\n            <div className=\"flex space-x-2\">\r\n              {hasAnswer && (\r\n                <button\r\n                  onClick={() => speech.speak(currentCardData.target_en)}\r\n                  disabled={!speech.isTTSAvailable}\r\n                  className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 text-sm\"\r\n                >\r\n                  🔊 정답 듣기\r\n                </button>\r\n              )}\r\n            </div>\r\n\r\n            {currentIndex < (reviewSession?.totalCards || 0) - 1 ? (\r\n              <button\r\n                onClick={handleNextCard}\r\n                disabled={!hasAnswer}\r\n                className=\"px-6 py-3 bg-green-500 text-white rounded-lg disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-green-600 transition-colors\"\r\n              >\r\n                다음 카드 →\r\n              </button>\r\n            ) : (\r\n              <button\r\n                onClick={finishSession}\r\n                disabled={!hasAnswer}\r\n                className=\"px-6 py-3 bg-purple-500 text-white rounded-lg disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-purple-600 transition-colors\"\r\n              >\r\n                복습 완료\r\n              </button>\r\n            )}\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\AudioV2TestPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\CurriculumLintPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\CurriculumTestPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\DashboardHome.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useAppStore' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'themeMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":17,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setThemeMode' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":17,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":34},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'metrics' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":29,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":29,"endColumn":12},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'levelProgress' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":30,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":30,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'refreshStats' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":34,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":34,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'level' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":696,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":696,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'stageData' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":698,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":698,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState, useCallback, useMemo, memo } from 'react';\nimport { useNavigate, useSearchParams } from 'react-router-dom';\nimport { useAppStore, useUser, useTheme, useSpeakingStage, useStageProgress } from '@/store/useAppStore';\nimport { useStatistics } from '@/hooks/useStatistics';\nimport { useThemedInlineStyles } from '@/hooks/useThemedStyles';\n\nexport const DashboardHome: React.FC = memo(() => {\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const [isDeveloperMode, setIsDeveloperMode] = useState(false);\n  const [currentViewLevel, setCurrentViewLevel] = useState<number | null>(null);\n  const [selectedStage, setSelectedStage] = useState<number | string | null>(null);\n  const [currentView, setCurrentView] = useState<'levels' | 'stage' | 'review' | 'stats' | 'curve' | 'situational'>('levels');\n  const [currentTab, setCurrentTab] = useState<'pattern' | 'situational'>('pattern');\n  \n  // Theme System\n  const { themeMode, setThemeMode } = useTheme();\n  const inlineStyles = useThemedInlineStyles();\n  \n  // Speaking Stage System (3단계 선택)\n  const { stage: speakingStage, setSpeakingStage } = useSpeakingStage();\n  \n  // Stage Progress System (3단계 진행률 관리)\n  const { getStageProgress } = useStageProgress();\n\n  // 사용자 상태 및 통계 Hook\n  const user = useUser();\n  const { \n    metrics, \n    levelProgress, \n    formattedMetrics, \n    isLoading: statsLoading, \n    error: statsError,\n    refresh: refreshStats \n  } = useStatistics({ \n    userId: user.id,\n    enabled: !!user.id,\n    refreshInterval: 5 * 60 * 1000 // 5분마다 자동 새로고침\n  });\n\n  // URL 파라미터 확인하여 바로 스테이지 뷰 열기\n  useEffect(() => {\n    const levelParam = searchParams.get('level');\n    const viewParam = searchParams.get('view');\n    \n    if (levelParam && viewParam === 'stage') {\n      const level = parseInt(levelParam);\n      if (level >= 1 && level <= 10) {\n        showStageView(level);\n      }\n    }\n  }, [searchParams]);\n\n  // Memoize level data to prevent recalculation\n  const levelData = useMemo(() => [\n    {\n      level: 1,\n      title: \"구조 패턴 중심 (19 스테이지)\",\n      description: \"영어 문장의 기본 뼈대를 단계별로 습득\",\n      verbs: [\"Be동사\", \"일반동사\", \"부정문\", \"의문문\", \"기초확장\"],\n      targetAccuracy: 80,\n      targetSpeed: 3.0,\n      stages: 19,\n      stageVerbs: {\n        1: [\"Be동사 현재\"], 2: [\"Be동사 과거\"], 3: [\"Be동사 미래\"],\n        4: [\"일반동사 현재\"], 5: [\"일반동사 과거\"], 6: [\"일반동사 미래\"],\n        7: [\"Be동사 부정\"], 8: [\"일반동사 부정\"],\n        9: [\"Be동사 의문문\"], 10: [\"일반동사 의문문\"], 11: [\"Wh- 질문\"],\n        12: [\"There is/are\"], 13: [\"I like\"], 14: [\"I have\"], 15: [\"I want to\"],\n        16: [\"at/in/on 전치사\"], 17: [\"a/an/the 관사\"], 18: [\"This/That\"], 19: [\"Please/Can you\"]\n      }\n    },\n    {\n      level: 2,\n      title: \"기본 문법 패턴\",\n      description: \"be동사, 일반동사, 조동사의 기본 패턴 습득\",\n      verbs: [\"be동사\", \"일반동사\", \"조동사\", \"현재진행형\", \"과거형\", \"미래형\"],\n      targetAccuracy: 80,\n      targetSpeed: 2.5,\n      stages: 20,\n      stageVerbs: {\n        1: [\"be동사 현재형 (긍정문)\"], 2: [\"be동사 현재형 (부정문)\"], 3: [\"be동사 현재형 (의문문)\"],\n        4: [\"일반동사 현재형 (긍정문)\"], 5: [\"일반동사 현재형 (부정문)\"], 6: [\"일반동사 현재형 (의문문)\"],\n        7: [\"현재진행형 (긍정문)\"], 8: [\"현재진행형 (부정문)\"], 9: [\"현재진행형 (의문문)\"],\n        10: [\"can 조동사 (긍정문)\"], 11: [\"can 조동사 (부정문)\"], 12: [\"can 조동사 (의문문)\"],\n        13: [\"과거형 (긍정문)\"], 14: [\"과거형 (부정문)\"], 15: [\"과거형 (의문문)\"],\n        16: [\"will 미래형 (긍정문)\"], 17: [\"will 미래형 (부정문)\"], 18: [\"will 미래형 (의문문)\"],\n        19: [\"have to 의무형\"], 20: [\"종합 복습 및 비교급\"]\n      }\n    },\n    {\n      level: 3,\n      title: \"시제·태·논리 확장 패턴\",\n      description: \"복합 시제, 조동사, 관계절, 논리 연결의 고급 문법 패턴\",\n      verbs: [\"미래형심화\", \"현재완료\", \"과거완료\", \"수동태\", \"조동사확장\", \"조건문\", \"가정법\"],\n      targetAccuracy: 85,\n      targetSpeed: 2.0,\n      stages: 30,\n      stageVerbs: {\n        1: [\"미래형 심화 (will vs be going to)\"], 2: [\"현재완료 경험·완료 용법\"],\n        3: [\"현재완료 결과·계속 + 시간표현\"], 4: [\"과거완료·과거완료진행형\"],\n        5: [\"수동태 기본 (be + p.p.)\"], 6: [\"수동태 심화 (조동사 + 수동태)\"],\n        7: [\"조동사 확장 1 (would, could, might)\"], 8: [\"조동사 확장 2 (should have, could have)\"],\n        9: [\"조건문 기본 (1형식, 2형식)\"], 10: [\"가정법 과거 (If I were you)\"],\n        11: [\"가정법 과거완료 (If I had known)\"]\n      }\n    },\n    {\n      level: 4,\n      title: \"거래 동사\",\n      description: \"진행형/부정/의문 혼합 + 1초 도전 일부\",\n      verbs: [\"buy\", \"sell\", \"use\", \"try\", \"find\"],\n      targetAccuracy: 85,\n      targetSpeed: 2.0,\n      stages: 32,\n      stageVerbs: {\n        1: [\"buy\"], 2: [\"sell\"], 3: [\"use\"], 4: [\"try\"], 5: [\"find\"],\n        6: [\"buy\", \"sell\"], 7: [\"use\", \"try\"], 8: [\"find\", \"buy\"], 9: [\"sell\", \"use\"], 10: [\"buy\", \"sell\", \"use\", \"try\", \"find\"]\n      }\n    },\n    {\n      level: 5,\n      title: \"소통 동사\",\n      description: \"3인칭 단수/과거 혼합 패턴\",\n      verbs: [\"give\", \"tell\", \"show\", \"meet\", \"help\"],\n      targetAccuracy: 88,\n      targetSpeed: 1.5,\n      stages: 30,\n      stageVerbs: {\n        1: [\"give\"], 2: [\"tell\"], 3: [\"show\"], 4: [\"meet\"], 5: [\"help\"],\n        6: [\"give\", \"tell\"], 7: [\"show\", \"meet\"], 8: [\"help\", \"give\"], 9: [\"tell\", \"show\"], 10: [\"give\", \"tell\", \"show\", \"meet\", \"help\"]\n      }\n    },\n    {\n      level: 6,\n      title: \"행동 동사\",\n      description: \"시제 전환 속도 증가\",\n      verbs: [\"come\", \"leave\", \"start\", \"finish\", \"plan\"],\n      targetAccuracy: 88,\n      targetSpeed: 1.5,\n      stages: 44,\n      stageVerbs: {\n        1: [\"come\"], 2: [\"leave\"], 3: [\"start\"], 4: [\"finish\"], 5: [\"plan\"],\n        6: [\"come\", \"leave\"], 7: [\"start\", \"finish\"], 8: [\"plan\", \"come\"], 9: [\"leave\", \"start\"], 10: [\"come\", \"leave\", \"start\", \"finish\", \"plan\"]\n      }\n    },\n    {\n      level: 7,\n      title: \"선택 동사\",\n      description: \"이유/의견 연결 패턴\",\n      verbs: [\"choose\", \"decide\", \"prefer\", \"expect\", \"suppose\"],\n      targetAccuracy: 90,\n      targetSpeed: 1.2,\n      stages: 42,\n      stageVerbs: {\n        1: [\"choose\"], 2: [\"decide\"], 3: [\"prefer\"], 4: [\"expect\"], 5: [\"suppose\"],\n        6: [\"choose\", \"decide\"], 7: [\"prefer\", \"expect\"], 8: [\"suppose\", \"choose\"], 9: [\"decide\", \"prefer\"], 10: [\"choose\", \"decide\", \"prefer\", \"expect\", \"suppose\"]\n      }\n    },\n    {\n      level: 8,\n      title: \"허용 동사\",\n      description: \"let/make, to부정사 패턴 확장\",\n      verbs: [\"keep\", \"let\", \"allow\", \"suggest\", \"recommend\"],\n      targetAccuracy: 90,\n      targetSpeed: 1.2,\n      stages: 50,\n      stageVerbs: {\n        1: [\"keep\"], 2: [\"let\"], 3: [\"allow\"], 4: [\"suggest\"], 5: [\"recommend\"],\n        6: [\"keep\", \"let\"], 7: [\"allow\", \"suggest\"], 8: [\"recommend\", \"keep\"], 9: [\"let\", \"allow\"], 10: [\"keep\", \"let\", \"allow\", \"suggest\", \"recommend\"]\n      }\n    },\n    {\n      level: 9,\n      title: \"전문 동사\",\n      description: \"추상/업무형 단어 혼입\",\n      verbs: [\"improve\", \"reduce\", \"compare\", \"analyze\", \"design\"],\n      targetAccuracy: 92,\n      targetSpeed: 1.0,\n      stages: 48,\n      stageVerbs: {\n        1: [\"improve\"], 2: [\"reduce\"], 3: [\"compare\"], 4: [\"analyze\"], 5: [\"design\"],\n        6: [\"improve\", \"reduce\"], 7: [\"compare\", \"analyze\"], 8: [\"design\", \"improve\"], 9: [\"reduce\", \"compare\"], 10: [\"improve\", \"reduce\", \"compare\", \"analyze\", \"design\"]\n      }\n    },\n    {\n      level: 10,\n      title: \"고급 동사\",\n      description: \"고난도 조합 패턴\",\n      verbs: [\"coordinate\", \"negotiate\", \"prioritize\", \"implement\", \"evaluate\"],\n      targetAccuracy: 95,\n      targetSpeed: 1.0,\n      stages: 50,\n      stageVerbs: {\n        1: [\"coordinate\"], 2: [\"negotiate\"], 3: [\"prioritize\"], 4: [\"implement\"], 5: [\"evaluate\"],\n        6: [\"coordinate\", \"negotiate\"], 7: [\"prioritize\", \"implement\"], 8: [\"evaluate\", \"coordinate\"], 9: [\"negotiate\", \"prioritize\"], 10: [\"coordinate\", \"negotiate\", \"prioritize\", \"implement\", \"evaluate\"]\n      }\n    }\n  ], []);\n\n  // 상황학습 6그룹 데이터\n  const situationalData = [\n    {\n      group: 1,\n      title: \"Customer Excellence\",\n      subtitle: \"고객 서비스 완성\",\n      stages: \"A5-S17~S20\",\n      difficulty: 2,\n      description: \"고객과의 서비스 완료 및 관계 유지\",\n      scenarios: [\"서비스 문의 응답\", \"문제 해결 제안\", \"서비스 품질 확인\", \"서비스 종료 및 관계 유지\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 2,\n      title: \"Professional Communication\",\n      subtitle: \"전문 소통 능력\",\n      stages: \"A4-S13~S16\",\n      difficulty: 3,\n      description: \"이메일, 보고서, 업무 커뮤니케이션\",\n      scenarios: [\"이메일 감사 및 확인\", \"보고서 작성 및 검토\", \"보고서 권고사항 및 실행계획\", \"문서 승인 및 피드백\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 3,\n      title: \"Meeting Leadership\",\n      subtitle: \"회의 진행 리더십\",\n      stages: \"A1-S01~S04\",\n      difficulty: 3,\n      description: \"회의 주도 및 효과적 진행\",\n      scenarios: [\"회의 시작 및 목적 설명\", \"안건 제시 및 논의 유도\", \"의견 조율 및 합의 도출\", \"회의 정리 및 후속 조치\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 4,\n      title: \"Presentation Mastery\",\n      subtitle: \"발표 완성도\",\n      stages: \"A2-S05~S08\",\n      difficulty: 3,\n      description: \"효과적인 프레젠테이션 및 설득\",\n      scenarios: [\"발표 시작 및 개요 소개\", \"핵심 내용 전달\", \"질의응답 및 토론\", \"발표 마무리 및 감사\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 5,\n      title: \"Strategic Negotiation\",\n      subtitle: \"전략적 협상\",\n      stages: \"A3-S09~S12\",\n      difficulty: 4,\n      description: \"비즈니스 협상 및 거래 성사\",\n      scenarios: [\"협상 시작 및 조건 제시\", \"상호 이익 탐색\", \"양보 및 대안 모색\", \"확정 및 거래 마무리\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 6,\n      title: \"Team Leadership\",\n      subtitle: \"팀 리더십\",\n      stages: \"A6-S21~S24\",\n      difficulty: 4,\n      description: \"팀 관리 및 프로젝트 리더십\",\n      scenarios: [\"팀 동기부여 및 목표 설정\", \"성과 피드백 및 코칭\", \"갈등 해결 및 팀 조율\", \"프로젝트 완료 및 성과 공유\"],\n      completed: false,\n      progress: 0\n    }\n  ];\n\n  // Level 5 학술연구 6그룹 데이터\n  const level5SituationalData = [\n    {\n      group: 1,\n      title: \"Research Foundation\",\n      subtitle: \"연구 기초 설정\",\n      stages: \"A1-S01~S04\",\n      difficulty: 3,\n      description: \"연구 목적, 가설, 이론적 근거 설정\",\n      scenarios: [\"연구 목적 및 가설 제시\", \"이론적 근거 수립\", \"연구 디자인 설정\", \"선행연구 검토\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 2,\n      title: \"Academic Presentation\",\n      subtitle: \"학술 발표 마스터리\",\n      stages: \"A2-S05~S08\",\n      difficulty: 3,\n      description: \"학술 발표 및 논문 발표 기법\",\n      scenarios: [\"학술 발표 도입 및 구조화\", \"연구 결과 제시\", \"논의 및 토론 진행\", \"발표 마무리 및 Q&A\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 3,\n      title: \"Research Methodology\",\n      subtitle: \"연구방법론 전문성\",\n      stages: \"A3-S09~S12\",\n      difficulty: 4,\n      description: \"연구방법, 데이터 분석 및 해석\",\n      scenarios: [\"연구방법 선택 및 설명\", \"데이터 수집 및 분석\", \"결과 해석 및 논의\", \"연구의 한계 인정\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 4,\n      title: \"Interdisciplinary Research\",\n      subtitle: \"학제간 연구 협력\",\n      stages: \"A4-S13~S16\",\n      difficulty: 4,\n      description: \"다학제 연구 및 협력 프로젝트\",\n      scenarios: [\"학제간 연구 협력\", \"통합 방법론 개발\", \"공동연구 프로젝트\", \"연구성과 공유\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 5,\n      title: \"Publication & Peer Review\",\n      subtitle: \"논문 출판 및 심사\",\n      stages: \"A5-S17~S20\",\n      difficulty: 4,\n      description: \"학술지 발표 및 동료심사 과정\",\n      scenarios: [\"논문 작성 및 제출\", \"동료심사 대응\", \"수정 및 재제출\", \"학술적 기여도 평가\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 6,\n      title: \"Academic Leadership\",\n      subtitle: \"학술 리더십\",\n      stages: \"A6-S21~S24\",\n      difficulty: 5,\n      description: \"연구팀 리더십 및 학술계 기여\",\n      scenarios: [\"연구팀 리더십\", \"학술 네트워킹\", \"연구비 획득 및 관리\", \"학계 기여 및 영향력\"],\n      completed: false,\n      progress: 0\n    }\n  ];\n\n  // Level 6 전문분야 4그룹 데이터\n  const level6SituationalData = [\n    {\n      group: 1,\n      title: \"Legal Excellence\",\n      subtitle: \"법률 전문성\",\n      stages: \"D1-S01~S03\",\n      difficulty: 5,\n      description: \"법률 계약서 작성 및 법률 자문\",\n      scenarios: [\"법률 계약서 작성 및 검토\", \"법률 자문 및 상담\", \"법적 분쟁 해결\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 2,\n      title: \"Medical Professional\",\n      subtitle: \"의료 전문성\",\n      stages: \"D2-S04~S06\",\n      difficulty: 5,\n      description: \"의료 진료 및 환자 커뮤니케이션\",\n      scenarios: [\"환자 진료 및 상담\", \"의료진 소통\", \"진단 및 치료 계획\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 3,\n      title: \"Technical Engineering\",\n      subtitle: \"기술 엔지니어링\",\n      stages: \"D3-S07~S09\",\n      difficulty: 5,\n      description: \"기술 설계 및 엔지니어링 커뮤니케이션\",\n      scenarios: [\"기술 설계 및 개발\", \"엔지니어링 커뮤니케이션\", \"품질 보증 및 최적화\"],\n      completed: false,\n      progress: 0\n    },\n    {\n      group: 4,\n      title: \"Financial Expertise\",\n      subtitle: \"금융 전문성\",\n      stages: \"D4-S10~S12\",\n      difficulty: 5,\n      description: \"금융 분석 및 투자 자문\",\n      scenarios: [\"금융 상품 설계\", \"투자 자문 및 위험관리\", \"금융시장 분석\"],\n      completed: false,\n      progress: 0\n    }\n  ];\n\n  // 사용자 진행 상황 (임시 데이터)\n  const [userProgress] = useState({\n    currentLevel: 1,\n    levels: [\n      { \n        level: 1, \n        completed: false, \n        progress: 0, \n        bestAccuracy: 0, \n        attempts: 0,\n        stages: Array.from({length: 19}, (_, i) => ({ \n          stage: i + 1, \n          completed: false, \n          accuracy: 0, \n          attempts: 0 \n        }))\n      },\n      { \n        level: 2, \n        completed: false, \n        progress: 0,  // Level 1 완료 전까지 0%\n        bestAccuracy: 0, \n        attempts: 0,\n        stages: [\n          { stage: 1, completed: false, accuracy: 0, attempts: 0 },\n          { stage: 2, completed: false, accuracy: 0, attempts: 0 },\n          { stage: 3, completed: false, accuracy: 0, attempts: 0 },\n          { stage: 4, completed: false, accuracy: 0, attempts: 0 },\n          ...Array.from({length: 16}, (_, i) => ({ \n            stage: i + 5, \n            completed: false, \n            accuracy: 0, \n            attempts: 0 \n          }))\n        ]\n      },\n      ...Array.from({length: 8}, (_, i) => ({\n        level: i + 3,\n        completed: false,\n        progress: 0,\n        bestAccuracy: 0,\n        attempts: 0,\n        stages: Array.from({length: levelData[i + 2]?.stages || 10}, (_, j) => ({\n          stage: j + 1,\n          completed: false,\n          accuracy: 0,\n          attempts: 0\n        }))\n      }))\n    ]\n  });\n\n  // 모드 토글 기능\n  const toggleDeveloperMode = useCallback(() => {\n    setIsDeveloperMode(!isDeveloperMode);\n    console.log(isDeveloperMode ? '👤 일반 모드 활성화' : '🔧 개발자 모드 활성화');\n  }, [isDeveloperMode]);\n\n  // 레벨 카드 생성 함수\n  const createLevelCards = useCallback(() => {\n    return levelData.map(level => {\n      const userLevelData = userProgress.levels.find(l => l.level === level.level) || \n                          { level: level.level, completed: false, progress: 0, bestAccuracy: 0, attempts: 0 };\n      \n      const isUnlocked = isDeveloperMode || level.level === 1 || \n                       (userProgress.levels.find(l => l.level === level.level - 1)?.completed);\n      const isCompleted = userLevelData.completed;\n      \n      let icon = '🔒';\n      if (isCompleted) icon = '🏆';\n      else if (isUnlocked) icon = '⭐';\n      \n      return (\n        <div\n          key={level.level}\n          className={`level-card ${isCompleted ? 'completed' : (isUnlocked ? 'unlocked' : 'locked')}`}\n          onClick={isUnlocked ? () => showStageView(level.level) : undefined}\n          style={{\n            background: '#ffffff',\n            borderRadius: '15px',\n            padding: '25px',\n            cursor: isUnlocked ? 'pointer' : 'not-allowed',\n            transition: 'all 0.3s ease',\n            border: isCompleted ? '3px solid #f59e0b' : (isUnlocked ? '3px solid #10b981' : '3px solid transparent'),\n            position: 'relative',\n            opacity: isUnlocked ? 1 : 0.6\n          }}\n          onMouseEnter={(e) => {\n            if (isUnlocked) {\n              e.currentTarget.style.transform = 'translateY(-5px)';\n              e.currentTarget.style.boxShadow = '0 10px 30px rgba(0,0,0,0.15)';\n            }\n          }}\n          onMouseLeave={(e) => {\n            if (isUnlocked) {\n              e.currentTarget.style.transform = 'translateY(0)';\n              e.currentTarget.style.boxShadow = 'none';\n            }\n          }}\n        >\n          <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>\n            <div style={{ fontSize: '1.5em', fontWeight: 'bold', color: '#1f2937' }}>Level {level.level}</div>\n            <div style={{ fontSize: '2em' }}>{icon}</div>\n          </div>\n          <div style={{ background: '#e5e7eb', borderRadius: '10px', height: '8px', marginBottom: '15px', overflow: 'hidden' }}>\n            <div style={{ \n              background: 'linear-gradient(90deg, #10b981, #059669)', \n              height: '100%', \n              borderRadius: '10px', \n              transition: 'width 0.5s ease',\n              width: `${userLevelData.progress}%`\n            }}></div>\n          </div>\n          <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.9em', color: '#64748b' }}>\n            <span>진행률: {userLevelData.progress}%</span>\n            <span>최고: {userLevelData.bestAccuracy}%</span>\n          </div>\n          <h3 style={{ margin: '10px 0 5px 0', color: '#1f2937' }}>{level.title}</h3>\n          <div style={{ fontSize: '0.9em', color: '#64748b', marginTop: '10px' }}>{level.description}</div>\n          <div style={{ fontSize: '0.9em', color: '#64748b', marginTop: '10px' }}>\n            <strong>동사:</strong> {level.verbs.join(', ')}\n          </div>\n          <div style={{ fontSize: '0.9em', color: '#64748b' }}>\n            <strong>목표:</strong> 정확도 {level.targetAccuracy}%\n          </div>\n        </div>\n      );\n    });\n  }, [userProgress.levels, isDeveloperMode, levelData]);\n\n  // 스테이지 뷰 표시\n  const showStageView = (levelNum: number) => {\n    setCurrentViewLevel(levelNum);\n    setCurrentView('stage');\n  };\n\n  // 스테이지 스텝 생성 (실제 진행률 데이터 사용)\n\n  const createStageSteps = (level: any) => {\n    const userLevelData = userProgress.levels.find(l => l.level === level.level);\n    const userStages = userLevelData?.stages || [];\n    \n    const steps = [];\n    \n    for (let i = 1; i <= level.stages; i++) {\n      const stageData = userStages.find(s => s.stage === i);\n      const stageProgress = getStageProgress(level.level, i); // [1단계, 2단계, 3단계] 완료 여부 - 실제 데이터 사용\n      const completedSteps = stageProgress.filter(Boolean).length; // 완료된 단계 수\n      const progressPercentage = (completedSteps / 3) * 100; // 진행률\n      \n      let stepClass = 'step';\n      let title = '';\n      \n      if (stageData?.completed) {\n        stepClass += ' completed';\n        title = `완료됨 - 정확도: ${stageData.accuracy}%, 시도: ${stageData.attempts}번`;\n      } else if (isDeveloperMode || i === 1 || (userStages.find(s => s.stage === i - 1)?.completed)) {\n        if (stageData && stageData.attempts > 0) {\n          stepClass += ' current';\n          title = `진행중 - 최고: ${stageData.accuracy}%, 시도: ${stageData.attempts}번`;\n        } else {\n          stepClass += ' current';\n          title = '시작 가능';\n        }\n      } else {\n        stepClass += ' locked';\n        title = '잠금됨 - 이전 스테이지를 완료하세요';\n      }\n      \n      steps.push(\n        <div\n          key={i}\n          style={{\n            display: 'flex',\n            flexDirection: 'column',\n            alignItems: 'center',\n            gap: '8px'\n          }}\n        >\n          {/* 스테이지 원 */}\n          <div\n            className={stepClass}\n            title={title}\n            onClick={() => !stepClass.includes('locked') && selectStage(level.level, i)}\n            style={{\n              width: '50px',\n              height: '50px',\n              borderRadius: '50%',\n              display: 'flex',\n              alignItems: 'center',\n              justifyContent: 'center',\n              fontWeight: 'bold',\n              cursor: stepClass.includes('locked') ? 'not-allowed' : 'pointer',\n              transition: 'all 0.3s',\n              fontSize: '14px',\n              background: stepClass.includes('completed') ? '#10b981' : \n                         stepClass.includes('current') ? '#3b82f6' : '#e5e7eb',\n              color: stepClass.includes('locked') ? '#9ca3af' : 'white',\n              animation: stepClass.includes('current') ? 'pulse 2s infinite' : 'none',\n              border: selectedStage === i ? '3px solid #f59e0b' : '2px solid transparent',\n              boxShadow: selectedStage === i ? '0 0 0 2px rgba(245, 158, 11, 0.3)' : 'none'\n            }}\n          >\n            {i}\n          </div>\n          \n          {/* 3단계 진행률 표시 */}\n          <div style={{\n            display: 'flex',\n            flexDirection: 'column',\n            alignItems: 'center',\n            gap: '4px',\n            width: '60px'\n          }}>\n            {/* 진행률 바 */}\n            <div style={{\n              width: '100%',\n              height: '4px',\n              backgroundColor: '#e5e7eb',\n              borderRadius: '2px',\n              overflow: 'hidden'\n            }}>\n              <div style={{\n                width: `${progressPercentage}%`,\n                height: '100%',\n                backgroundColor: progressPercentage === 100 ? '#10b981' : progressPercentage > 0 ? '#3b82f6' : '#e5e7eb',\n                borderRadius: '2px',\n                transition: 'width 0.3s ease'\n              }}></div>\n            </div>\n            \n            {/* 3단계 점 표시 */}\n            <div style={{\n              display: 'flex',\n              gap: '3px',\n              alignItems: 'center'\n            }}>\n              {stageProgress.map((completed, stepIndex) => (\n                <div\n                  key={stepIndex}\n                  style={{\n                    width: '6px',\n                    height: '6px',\n                    borderRadius: '50%',\n                    backgroundColor: completed ? '#10b981' : '#d1d5db',\n                    transition: 'background-color 0.3s ease'\n                  }}\n                  title={`${stepIndex + 1}단계 ${completed ? '완료' : '미완료'}`}\n                />\n              ))}\n            </div>\n            \n            {/* 진행률 텍스트 */}\n            <div style={{\n              fontSize: '10px',\n              color: '#6b7280',\n              textAlign: 'center'\n            }}>\n              {completedSteps}/3\n            </div>\n          </div>\n        </div>\n      );\n    }\n    \n    // ALL 버튼 추가\n    const allStagesCompleted = userStages.length === level.stages && userStages.every(stage => stage.completed);\n    const isAllUnlocked = isDeveloperMode || allStagesCompleted;\n    \n    steps.push(\n      <div\n        key=\"ALL\"\n        className={`step all-step ${!isAllUnlocked ? 'locked' : ''}`}\n        title={isAllUnlocked ? '레벨 전체 동사 통합 훈련' : '잠금됨 - 모든 스테이지를 완료하세요'}\n        onClick={isAllUnlocked ? () => selectAllStage(level.level) : undefined}\n        style={{\n          width: '60px',\n          height: '60px',\n          borderRadius: '50%',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'center',\n          fontWeight: 'bold',\n          fontSize: '12px',\n          cursor: isAllUnlocked ? 'pointer' : 'not-allowed',\n          background: isAllUnlocked ? 'linear-gradient(135deg, #f59e0b, #d97706)' : '#e5e7eb',\n          color: isAllUnlocked ? 'white' : '#9ca3af',\n          border: selectedStage === 'ALL' ? '3px solid #ef4444' : '2px solid transparent',\n          boxShadow: selectedStage === 'ALL' ? '0 0 0 2px rgba(239, 68, 68, 0.3)' : 'none'\n        }}\n      >\n        ALL\n      </div>\n    );\n    \n    return steps;\n  };\n\n  // 스테이지 선택\n  const selectStage = (levelNum: number, stageNum: number) => {\n    console.log(`Selected Level ${levelNum}, Stage ${stageNum}`);\n    if (selectedStage === stageNum) {\n      setSelectedStage(null); // 같은 스테이지 클릭시 선택 해제\n    } else {\n      setSelectedStage(stageNum);\n    }\n    \n    const level = levelData.find(l => l.level === levelNum);\n    const userLevelData = userProgress.levels.find(l => l.level === levelNum);\n    const stageData = userLevelData?.stages?.find(s => s.stage === stageNum);\n  };\n\n  // ALL 스테이지 선택\n  const selectAllStage = (levelNum: number) => {\n    const level = levelData.find(l => l.level === levelNum);\n    const userLevelData = userProgress.levels.find(l => l.level === levelNum);\n    const userStages = userLevelData?.stages || [];\n    \n    const allStagesCompleted = userStages.length === level!.stages && userStages.every(stage => stage.completed);\n    \n    if (!isDeveloperMode && !allStagesCompleted) {\n      alert('모든 스테이지를 완료해야 ALL 모드를 사용할 수 있습니다!');\n      return;\n    }\n    \n    console.log(`Selected Level ${levelNum}, ALL Stages`);\n    if (selectedStage === 'ALL') {\n      setSelectedStage(null); // 같은 ALL 클릭시 선택 해제\n    } else {\n      setSelectedStage('ALL');\n    }\n  };\n\n  // 스테이지 시작\n  const startStage = () => {\n    if (currentViewLevel && selectedStage) {\n      const level = levelData.find(l => l.level === currentViewLevel);\n      \n      let stageVerbs;\n      if (selectedStage === 'ALL') {\n        stageVerbs = level!.verbs;\n      } else {\n        stageVerbs = level?.stageVerbs?.[selectedStage as number] || level?.verbs || [];\n      }\n      \n      // pattern-training으로 이동\n      const params = new URLSearchParams({\n        level: currentViewLevel.toString(),\n        stage: selectedStage.toString(),\n        verbs: stageVerbs.join(','),\n        targetAccuracy: level!.targetAccuracy.toString(),\n        developerMode: isDeveloperMode ? 'true' : 'false'\n      });\n      \n      navigate(`/pattern-training?${params.toString()}`);\n    } else {\n      alert('먼저 스테이지를 선택해주세요!');\n    }\n  };\n\n  const currentLevel = currentViewLevel ? levelData.find(l => l.level === currentViewLevel) : null;\n\n  return (\n    <div className=\"font-sans bg-gray-50 dark:bg-gray-900 min-h-screen p-5 transition-colors duration-300\">\n      <div className=\"max-w-6xl mx-auto bg-white dark:bg-gray-800 rounded-3xl shadow-xl overflow-hidden border border-gray-200 dark:border-gray-700 transition-colors duration-300\">\n        {/* 헤더 */}\n        <div style={{\n          background: inlineStyles.secondary,\n          color: inlineStyles.text,\n          padding: '30px',\n          textAlign: 'center',\n          position: 'relative',\n          borderBottom: `1px solid ${inlineStyles.border}`\n        }}>\n          {/* 홈 버튼 */}\n          <button\n            onClick={() => navigate('/')}\n            style={{\n              position: 'absolute',\n              top: '20px',\n              left: '20px',\n              background: 'rgba(255,255,255,0.2)',\n              border: '1px solid rgba(255,255,255,0.3)',\n              color: 'white',\n              padding: '8px 15px',\n              borderRadius: '25px',\n              cursor: 'pointer',\n              fontSize: '14px',\n              fontWeight: 'bold',\n              backdropFilter: 'blur(10px)',\n              transition: 'all 0.3s'\n            }}\n            onMouseEnter={(e) => {\n              e.currentTarget.style.background = 'rgba(255,255,255,0.3)';\n            }}\n            onMouseLeave={(e) => {\n              e.currentTarget.style.background = 'rgba(255,255,255,0.2)';\n            }}\n          >\n            🏠 홈\n          </button>\n          {/* 모드 토글 */}\n          <div style={{\n            position: 'absolute',\n            top: '20px',\n            right: '20px',\n            display: 'flex',\n            alignItems: 'center',\n            gap: '12px',\n            background: 'rgba(255,255,255,0.2)',\n            border: '1px solid rgba(255,255,255,0.3)',\n            borderRadius: '25px',\n            padding: '8px 15px',\n            backdropFilter: 'blur(10px)'\n          }}>\n            <span style={{\n              color: 'white',\n              fontSize: '14px',\n              fontWeight: isDeveloperMode ? '500' : 'bold',\n              opacity: isDeveloperMode ? 0.8 : 1\n            }}>일반</span>\n            <div\n              onClick={toggleDeveloperMode}\n              style={{\n                position: 'relative',\n                width: '50px',\n                height: '24px',\n                background: isDeveloperMode ? '#10b981' : 'rgba(255,255,255,0.3)',\n                borderRadius: '12px',\n                cursor: 'pointer',\n                transition: 'background 0.3s'\n              }}\n            >\n              <div style={{\n                position: 'absolute',\n                top: '2px',\n                left: isDeveloperMode ? '28px' : '2px',\n                width: '20px',\n                height: '20px',\n                background: 'white',\n                borderRadius: '50%',\n                transition: 'left 0.3s',\n                boxShadow: '0 2px 4px rgba(0,0,0,0.2)'\n              }}></div>\n            </div>\n            <span style={{\n              color: 'white',\n              fontSize: '14px',\n              fontWeight: isDeveloperMode ? 'bold' : '500',\n              opacity: isDeveloperMode ? 1 : 0.8\n            }}>개발자</span>\n            {isDeveloperMode && (\n              <div style={{\n                position: 'absolute',\n                top: '-5px',\n                right: '-5px',\n                background: '#ef4444',\n                color: 'white',\n                fontSize: '10px',\n                padding: '2px 6px',\n                borderRadius: '10px',\n                fontWeight: 'bold'\n              }}>DEV</div>\n            )}\n          </div>\n\n          <h1 style={{ fontSize: '2.5em', marginBottom: '10px' }}>🎯 DASI English</h1>\n          <p style={{ fontSize: '1.2em', opacity: 0.9 }}>Do you vs Are you 완전 정복 - 10레벨 시스템</p>\n          \n          {/* 탭 버튼 */}\n          <div style={{\n            display: 'flex',\n            justifyContent: 'center',\n            gap: '10px',\n            marginTop: '25px'\n          }}>\n            <button\n              onClick={() => {\n                setCurrentTab('pattern');\n                setCurrentView('levels');\n              }}\n              style={{\n                background: currentTab === 'pattern' ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)',\n                border: '1px solid rgba(255,255,255,0.3)',\n                color: 'white',\n                padding: '12px 24px',\n                borderRadius: '25px',\n                cursor: 'pointer',\n                fontSize: '16px',\n                fontWeight: 'bold',\n                backdropFilter: 'blur(10px)',\n                transition: 'all 0.3s'\n              }}\n            >\n              📖 패턴학습\n            </button>\n            <button\n              onClick={() => {\n                setCurrentTab('situational');\n                setCurrentView('situational');\n              }}\n              style={{\n                background: currentTab === 'situational' ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.1)',\n                border: '1px solid rgba(255,255,255,0.3)',\n                color: 'white',\n                padding: '12px 24px',\n                borderRadius: '25px',\n                cursor: 'pointer',\n                fontSize: '16px',\n                fontWeight: 'bold',\n                backdropFilter: 'blur(10px)',\n                transition: 'all 0.3s'\n              }}\n            >\n              💼 상황학습\n            </button>\n          </div>\n          \n          <div style={{\n            display: 'flex',\n            justifyContent: 'center',\n            gap: '30px',\n            marginTop: '20px'\n          }}>\n            <div style={{ textAlign: 'center' }}>\n              <div style={{ fontSize: '2em', fontWeight: 'bold' }}>\n                {statsLoading ? '...' : (formattedMetrics?.currentLevelText || user.level || '1')}\n              </div>\n              <div style={{ fontSize: '0.9em', opacity: 0.8 }}>현재 레벨</div>\n            </div>\n            <div style={{ textAlign: 'center' }}>\n              <div style={{ fontSize: '2em', fontWeight: 'bold', color: statsError ? '#ef4444' : 'inherit' }}>\n                {statsLoading ? '...' : (formattedMetrics?.overallProgressText || '0%')}\n              </div>\n              <div style={{ fontSize: '0.9em', opacity: 0.8 }}>전체 진행률</div>\n            </div>\n            <div style={{ textAlign: 'center' }}>\n              <div style={{ fontSize: '2em', fontWeight: 'bold', color: statsError ? '#ef4444' : 'inherit' }}>\n                {statsLoading ? '...' : (formattedMetrics?.averageAccuracyText || '0%')}\n              </div>\n              <div style={{ fontSize: '0.9em', opacity: 0.8 }}>평균 정확도</div>\n            </div>\n            <div style={{ textAlign: 'center' }}>\n              <div style={{ fontSize: '2em', fontWeight: 'bold', color: statsError ? '#ef4444' : 'inherit' }}>\n                {statsLoading ? '...' : (formattedMetrics?.incorrectCountText || '0')}\n              </div>\n              <div style={{ fontSize: '0.9em', opacity: 0.8 }}>틀린 문제</div>\n            </div>\n            <div style={{ textAlign: 'center' }}>\n              <div style={{ fontSize: '2em', fontWeight: 'bold' }}>0</div>\n              <div style={{ fontSize: '0.9em', opacity: 0.8 }}>복습 대기</div>\n            </div>\n          </div>\n        </div>\n\n        {/* 패턴학습 - 레벨 선택 화면 */}\n        {currentView === 'levels' && currentTab === 'pattern' && (\n          <div style={{ padding: '30px' }}>\n            <div style={{\n              display: 'grid',\n              gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',\n              gap: '20px'\n            }}>\n              {createLevelCards()}\n            </div>\n          </div>\n        )}\n\n        {/* 상황학습 화면 */}\n        {currentView === 'situational' && (\n          <div style={{ padding: '30px' }}>\n            {/* Level 4 비즈니스 */}\n            <div style={{ marginBottom: '50px' }}>\n              <h2 style={{ color: '#1f2937', fontSize: '1.8em', marginBottom: '20px', textAlign: 'center' }}>\n                💼 Level 4: Business Mastery\n              </h2>\n              <div style={{\n                display: 'grid',\n                gridTemplateColumns: 'repeat(auto-fit, minmax(350px, 1fr))',\n                gap: '20px'\n              }}>\n                {situationalData.map(group => {\n                  const isCompleted = group.completed;\n                  const difficultyStars = '⭐'.repeat(group.difficulty);\n                  \n                  return (\n                    <div\n                      key={group.group}\n                      className={`situational-card ${isCompleted ? 'completed' : 'available'}`}\n                      onClick={() => navigate(`/situational-training?level=4&group=${group.group}&title=${encodeURIComponent(group.title)}`)}\n                      style={{\n                        background: '#ffffff',\n                        borderRadius: '15px',\n                        padding: '25px',\n                        cursor: 'pointer',\n                        transition: 'all 0.3s ease',\n                        border: isCompleted ? '3px solid #f59e0b' : '3px solid #10b981',\n                        position: 'relative',\n                        opacity: 1\n                      }}\n                      onMouseEnter={(e) => {\n                        e.currentTarget.style.transform = 'translateY(-5px)';\n                        e.currentTarget.style.boxShadow = '0 10px 30px rgba(0,0,0,0.15)';\n                      }}\n                      onMouseLeave={(e) => {\n                        e.currentTarget.style.transform = 'translateY(0)';\n                        e.currentTarget.style.boxShadow = 'none';\n                      }}\n                    >\n                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>\n                        <div style={{ fontSize: '1.3em', fontWeight: 'bold', color: '#1f2937' }}>Group {group.group}</div>\n                        <div style={{ fontSize: '1.5em' }}>{difficultyStars}</div>\n                      </div>\n                      <div style={{ background: '#e5e7eb', borderRadius: '10px', height: '8px', marginBottom: '15px', overflow: 'hidden' }}>\n                        <div style={{ \n                          background: 'linear-gradient(90deg, #10b981, #059669)', \n                          height: '100%', \n                          borderRadius: '10px', \n                          transition: 'width 0.5s ease',\n                          width: `${group.progress}%`\n                        }}></div>\n                      </div>\n                      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.9em', color: '#64748b' }}>\n                        <span>진행률: {group.progress}%</span>\n                        <span>{group.stages}</span>\n                      </div>\n                      <h3 style={{ margin: '10px 0 5px 0', color: '#1f2937' }}>{group.title}</h3>\n                      <div style={{ fontSize: '1em', color: '#4338ca', fontWeight: '600', marginBottom: '8px' }}>{group.subtitle}</div>\n                      <div style={{ fontSize: '0.9em', color: '#64748b', marginBottom: '15px' }}>{group.description}</div>\n                      <div style={{ \n                        background: '#f1f5f9', \n                        borderRadius: '8px', \n                        padding: '12px', \n                        fontSize: '0.8em', \n                        color: '#475569' \n                      }}>\n                        <strong>주요 상황:</strong>\n                        <ul style={{ margin: '5px 0 0 15px', lineHeight: '1.4' }}>\n                          {group.scenarios.map((scenario, idx) => (\n                            <li key={idx}>{scenario}</li>\n                          ))}\n                        </ul>\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n            \n            {/* Level 5 학술연구 */}\n            <div style={{ marginBottom: '50px' }}>\n              <h2 style={{ color: '#1f2937', fontSize: '1.8em', marginBottom: '20px', textAlign: 'center' }}>\n                🎓 Level 5: Academic Research Excellence\n              </h2>\n              <div style={{\n                display: 'grid',\n                gridTemplateColumns: 'repeat(auto-fit, minmax(350px, 1fr))',\n                gap: '20px'\n              }}>\n                {level5SituationalData.map(group => {\n                  const isCompleted = group.completed;\n                  const difficultyStars = '⭐'.repeat(group.difficulty);\n                  \n                  return (\n                    <div\n                      key={group.group}\n                      className={`situational-card ${isCompleted ? 'completed' : 'available'}`}\n                      onClick={() => navigate(`/situational-training?level=5&group=${group.group}&title=${encodeURIComponent(group.title)}`)}\n                      style={{\n                        background: '#ffffff',\n                        borderRadius: '15px',\n                        padding: '25px',\n                        cursor: 'pointer',\n                        transition: 'all 0.3s ease',\n                        border: isCompleted ? '3px solid #f59e0b' : '3px solid #0ea5e9',\n                        position: 'relative',\n                        opacity: 1\n                      }}\n                      onMouseEnter={(e) => {\n                        e.currentTarget.style.transform = 'translateY(-5px)';\n                        e.currentTarget.style.boxShadow = '0 10px 30px rgba(0,0,0,0.15)';\n                      }}\n                      onMouseLeave={(e) => {\n                        e.currentTarget.style.transform = 'translateY(0)';\n                        e.currentTarget.style.boxShadow = 'none';\n                      }}\n                    >\n                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>\n                        <div style={{ fontSize: '1.3em', fontWeight: 'bold', color: '#1f2937' }}>Group {group.group}</div>\n                        <div style={{ fontSize: '1.5em' }}>{difficultyStars}</div>\n                      </div>\n                      <div style={{ background: '#e5e7eb', borderRadius: '10px', height: '8px', marginBottom: '15px', overflow: 'hidden' }}>\n                        <div style={{ \n                          background: 'linear-gradient(90deg, #0ea5e9, #0284c7)', \n                          height: '100%', \n                          borderRadius: '10px', \n                          transition: 'width 0.5s ease',\n                          width: `${group.progress}%`\n                        }}></div>\n                      </div>\n                      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.9em', color: '#64748b' }}>\n                        <span>진행률: {group.progress}%</span>\n                        <span>{group.stages}</span>\n                      </div>\n                      <h3 style={{ margin: '10px 0 5px 0', color: '#1f2937' }}>{group.title}</h3>\n                      <div style={{ fontSize: '1em', color: '#0c4a6e', fontWeight: '600', marginBottom: '8px' }}>{group.subtitle}</div>\n                      <div style={{ fontSize: '0.9em', color: '#64748b', marginBottom: '15px' }}>{group.description}</div>\n                      <div style={{ \n                        background: '#f0f9ff', \n                        borderRadius: '8px', \n                        padding: '12px', \n                        fontSize: '0.8em', \n                        color: '#0c4a6e' \n                      }}>\n                        <strong>주요 상황:</strong>\n                        <ul style={{ margin: '5px 0 0 15px', lineHeight: '1.4' }}>\n                          {group.scenarios.map((scenario, idx) => (\n                            <li key={idx}>{scenario}</li>\n                          ))}\n                        </ul>\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n            \n            {/* Level 6 전문분야 */}\n            <div>\n              <h2 style={{ color: '#1f2937', fontSize: '1.8em', marginBottom: '20px', textAlign: 'center' }}>\n                🎯 Level 6: Professional Domain Expertise\n              </h2>\n              <div style={{\n                display: 'grid',\n                gridTemplateColumns: 'repeat(auto-fit, minmax(350px, 1fr))',\n                gap: '20px'\n              }}>\n                {level6SituationalData.map(group => {\n                  const isCompleted = group.completed;\n                  const difficultyStars = '⭐'.repeat(group.difficulty);\n                  \n                  return (\n                    <div\n                      key={group.group}\n                      className={`situational-card ${isCompleted ? 'completed' : 'available'}`}\n                      onClick={() => navigate(`/situational-training?level=6&group=${group.group}&title=${encodeURIComponent(group.title)}`)}\n                      style={{\n                        background: '#ffffff',\n                        borderRadius: '15px',\n                        padding: '25px',\n                        cursor: 'pointer',\n                        transition: 'all 0.3s ease',\n                        border: isCompleted ? '3px solid #f59e0b' : '3px solid #c084fc',\n                        position: 'relative',\n                        opacity: 1\n                      }}\n                      onMouseEnter={(e) => {\n                        e.currentTarget.style.transform = 'translateY(-5px)';\n                        e.currentTarget.style.boxShadow = '0 10px 30px rgba(0,0,0,0.15)';\n                      }}\n                      onMouseLeave={(e) => {\n                        e.currentTarget.style.transform = 'translateY(0)';\n                        e.currentTarget.style.boxShadow = 'none';\n                      }}\n                    >\n                      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>\n                        <div style={{ fontSize: '1.3em', fontWeight: 'bold', color: '#1f2937' }}>Group {group.group}</div>\n                        <div style={{ fontSize: '1.5em' }}>{difficultyStars}</div>\n                      </div>\n                      <div style={{ background: '#e5e7eb', borderRadius: '10px', height: '8px', marginBottom: '15px', overflow: 'hidden' }}>\n                        <div style={{ \n                          background: 'linear-gradient(90deg, #c084fc, #a855f7)', \n                          height: '100%', \n                          borderRadius: '10px', \n                          transition: 'width 0.5s ease',\n                          width: `${group.progress}%`\n                        }}></div>\n                      </div>\n                      <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '0.9em', color: '#64748b' }}>\n                        <span>진행률: {group.progress}%</span>\n                        <span>{group.stages}</span>\n                      </div>\n                      <h3 style={{ margin: '10px 0 5px 0', color: '#1f2937' }}>{group.title}</h3>\n                      <div style={{ fontSize: '1em', color: '#7c2d92', fontWeight: '600', marginBottom: '8px' }}>{group.subtitle}</div>\n                      <div style={{ fontSize: '0.9em', color: '#64748b', marginBottom: '15px' }}>{group.description}</div>\n                      <div style={{ \n                        background: '#fdf4ff', \n                        borderRadius: '8px', \n                        padding: '12px', \n                        fontSize: '0.8em', \n                        color: '#7c2d92' \n                      }}>\n                        <strong>주요 상황:</strong>\n                        <ul style={{ margin: '5px 0 0 15px', lineHeight: '1.4' }}>\n                          {group.scenarios.map((scenario, idx) => (\n                            <li key={idx}>{scenario}</li>\n                          ))}\n                        </ul>\n                      </div>\n                    </div>\n                  );\n                })}\n              </div>\n            </div>\n          </div>\n        )}\n\n        {/* 패턴학습 - 스테이지 상세 화면 */}\n        {currentView === 'stage' && currentLevel && (\n          <div style={{ padding: '30px' }}>\n            <div style={{\n              display: 'flex',\n              justifyContent: 'space-between',\n              alignItems: 'center',\n              marginBottom: '30px',\n              paddingBottom: '20px',\n              borderBottom: '2px solid #e5e7eb'\n            }}>\n              <button\n                onClick={() => setCurrentView('levels')}\n                style={{\n                  background: '#6b7280',\n                  color: 'white',\n                  border: 'none',\n                  padding: '10px 20px',\n                  borderRadius: '8px',\n                  cursor: 'pointer',\n                  fontSize: '16px',\n                  display: 'flex',\n                  alignItems: 'center',\n                  gap: '8px'\n                }}\n              >\n                ← 레벨 선택으로\n              </button>\n              <div style={{ fontSize: '2em', color: '#1f2937' }}>\n                Level {currentLevel.level} - {currentLevel.title}\n              </div>\n              <div></div>\n            </div>\n\n            <div style={{\n              display: 'grid',\n              gridTemplateColumns: currentLevel.level === 2 ? 'repeat(10, 1fr)' : \n                                 currentLevel.level === 3 ? 'repeat(10, 1fr)' : 'repeat(auto-fit, minmax(60px, 1fr))',\n              justifyItems: 'center',\n              alignItems: 'center',\n              gap: '15px',\n              margin: '30px 0',\n              padding: '30px 20px',\n              background: '#f8fafc',\n              borderRadius: '15px',\n              maxWidth: currentLevel.level === 2 ? '800px' : currentLevel.level === 3 ? '900px' : '100%',\n              marginLeft: 'auto',\n              marginRight: 'auto'\n            }}>\n              {createStageSteps(currentLevel)}\n            </div>\n\n            <div style={{\n              display: 'grid',\n              gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',\n              gap: '20px',\n              margin: '30px 0'\n            }}>\n              <div style={{\n                background: '#f8fafc',\n                padding: '20px',\n                borderRadius: '10px',\n                borderLeft: '4px solid #3b82f6'\n              }}>\n                <h3 style={{ color: '#1f2937', marginBottom: '10px' }}>🎯 학습 동사</h3>\n                <p style={{ color: '#64748b' }}>{currentLevel.verbs.join(', ')}</p>\n              </div>\n              <div style={{\n                background: '#f8fafc',\n                padding: '20px',\n                borderRadius: '10px',\n                borderLeft: '4px solid #3b82f6'\n              }}>\n                <h3 style={{ color: '#1f2937', marginBottom: '10px' }}>📝 학습 패턴</h3>\n                <p style={{ color: '#64748b' }}>I go, I don't go, Do you go?<br/>I'm going, I'm not going, Are you going?</p>\n              </div>\n              <div style={{\n                background: '#f8fafc',\n                padding: '20px',\n                borderRadius: '10px',\n                borderLeft: '4px solid #3b82f6'\n              }}>\n                <h3 style={{ color: '#1f2937', marginBottom: '10px' }}>🎯 목표</h3>\n                <p style={{ color: '#64748b' }}>정확도 {currentLevel.targetAccuracy}% 이상</p>\n              </div>\n              <div style={{\n                background: '#f8fafc',\n                padding: '20px',\n                borderRadius: '10px',\n                borderLeft: '4px solid #3b82f6'\n              }}>\n                <h3 style={{ color: '#1f2937', marginBottom: '10px' }}>📊 현재 성과</h3>\n                <p style={{ color: '#64748b' }}>정확도: 0%<br/>최고 기록: 0%<br/>시도 횟수: 0</p>\n              </div>\n            </div>\n\n            {/* 3단계 선택 버튼 */}\n            <div style={{\n              marginTop: '30px',\n              marginBottom: '20px'\n            }}>\n              <div style={{\n                textAlign: 'center',\n                marginBottom: '15px'\n              }}>\n                <h3 style={{ color: '#1f2937', marginBottom: '5px', fontSize: '18px' }}>학습 단계 선택</h3>\n                <p style={{ color: '#64748b', fontSize: '14px' }}>속도에 따라 단계를 선택하세요</p>\n              </div>\n              \n              <div style={{\n                display: 'grid',\n                gridTemplateColumns: 'repeat(3, 1fr)',\n                gap: '15px',\n                maxWidth: '400px',\n                margin: '0 auto'\n              }}>\n                <button\n                  onClick={() => setSpeakingStage(1)}\n                  style={{\n                    padding: '15px',\n                    border: speakingStage === 1 ? '2px solid #10b981' : '2px solid #d1d5db',\n                    borderRadius: '10px',\n                    background: speakingStage === 1 ? '#f0fdf4' : '#ffffff',\n                    color: speakingStage === 1 ? '#065f46' : '#374151',\n                    cursor: 'pointer',\n                    transition: 'all 0.2s ease',\n                    textAlign: 'center'\n                  }}\n                  onMouseEnter={(e) => {\n                    if (speakingStage !== 1) {\n                      e.currentTarget.style.borderColor = '#10b981';\n                      e.currentTarget.style.background = '#f0fdf4';\n                    }\n                  }}\n                  onMouseLeave={(e) => {\n                    if (speakingStage !== 1) {\n                      e.currentTarget.style.borderColor = '#d1d5db';\n                      e.currentTarget.style.background = '#ffffff';\n                    }\n                  }}\n                >\n                  <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '4px' }}>1단계</div>\n                  <div style={{ fontSize: '12px', color: '#6b7280' }}>3초 응답</div>\n                </button>\n                \n                <button\n                  onClick={() => setSpeakingStage(2)}\n                  style={{\n                    padding: '15px',\n                    border: speakingStage === 2 ? '2px solid #3b82f6' : '2px solid #d1d5db',\n                    borderRadius: '10px',\n                    background: speakingStage === 2 ? '#eff6ff' : '#ffffff',\n                    color: speakingStage === 2 ? '#1e40af' : '#374151',\n                    cursor: 'pointer',\n                    transition: 'all 0.2s ease',\n                    textAlign: 'center'\n                  }}\n                  onMouseEnter={(e) => {\n                    if (speakingStage !== 2) {\n                      e.currentTarget.style.borderColor = '#3b82f6';\n                      e.currentTarget.style.background = '#eff6ff';\n                    }\n                  }}\n                  onMouseLeave={(e) => {\n                    if (speakingStage !== 2) {\n                      e.currentTarget.style.borderColor = '#d1d5db';\n                      e.currentTarget.style.background = '#ffffff';\n                    }\n                  }}\n                >\n                  <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '4px' }}>2단계</div>\n                  <div style={{ fontSize: '12px', color: '#6b7280' }}>2초 응답</div>\n                </button>\n                \n                <button\n                  onClick={() => setSpeakingStage(3)}\n                  style={{\n                    padding: '15px',\n                    border: speakingStage === 3 ? '2px solid #8b5cf6' : '2px solid #d1d5db',\n                    borderRadius: '10px',\n                    background: speakingStage === 3 ? '#f3f4f6' : '#ffffff',\n                    color: speakingStage === 3 ? '#5b21b6' : '#374151',\n                    cursor: 'pointer',\n                    transition: 'all 0.2s ease',\n                    textAlign: 'center'\n                  }}\n                  onMouseEnter={(e) => {\n                    if (speakingStage !== 3) {\n                      e.currentTarget.style.borderColor = '#8b5cf6';\n                      e.currentTarget.style.background = '#f3f4f6';\n                    }\n                  }}\n                  onMouseLeave={(e) => {\n                    if (speakingStage !== 3) {\n                      e.currentTarget.style.borderColor = '#d1d5db';\n                      e.currentTarget.style.background = '#ffffff';\n                    }\n                  }}\n                >\n                  <div style={{ fontSize: '18px', fontWeight: 'bold', marginBottom: '4px' }}>3단계</div>\n                  <div style={{ fontSize: '12px', color: '#6b7280' }}>1초 응답</div>\n                </button>\n              </div>\n              \n              <div style={{\n                textAlign: 'center',\n                marginTop: '10px'\n              }}>\n                <p style={{ fontSize: '12px', color: '#6b7280' }}>\n                  현재 선택: <span style={{ fontWeight: '600', color: '#374151' }}>\n                    {speakingStage}단계 ({speakingStage === 1 ? '3초' : speakingStage === 2 ? '2초' : '1초'} 응답)\n                  </span>\n                </p>\n              </div>\n            </div>\n\n            <div style={{\n              display: 'flex',\n              justifyContent: 'center',\n              gap: '20px',\n              marginTop: '20px'\n            }}>\n              <button\n                onClick={startStage}\n                style={{\n                  padding: '15px 30px',\n                  border: 'none',\n                  borderRadius: '10px',\n                  fontSize: '18px',\n                  fontWeight: 'bold',\n                  cursor: 'pointer',\n                  transition: 'all 0.3s',\n                  color: 'white',\n                  background: 'linear-gradient(135deg, #10b981, #059669)'\n                }}\n                onMouseEnter={(e) => {\n                  e.currentTarget.style.transform = 'translateY(-2px)';\n                  e.currentTarget.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';\n                }}\n                onMouseLeave={(e) => {\n                  e.currentTarget.style.transform = 'translateY(0)';\n                  e.currentTarget.style.boxShadow = 'none';\n                }}\n              >\n                🚀 스테이지 시작\n              </button>\n              <button\n                onClick={() => alert('상세 통계 화면을 표시합니다.')}\n                style={{\n                  padding: '15px 30px',\n                  border: 'none',\n                  borderRadius: '10px',\n                  fontSize: '18px',\n                  fontWeight: 'bold',\n                  cursor: 'pointer',\n                  transition: 'all 0.3s',\n                  color: 'white',\n                  background: 'linear-gradient(135deg, #3b82f6, #1d4ed8)'\n                }}\n                onMouseEnter={(e) => {\n                  e.currentTarget.style.transform = 'translateY(-2px)';\n                  e.currentTarget.style.boxShadow = '0 5px 15px rgba(0,0,0,0.3)';\n                }}\n                onMouseLeave={(e) => {\n                  e.currentTarget.style.transform = 'translateY(0)';\n                  e.currentTarget.style.boxShadow = 'none';\n                }}\n              >\n                📊 상세 통계\n              </button>\n            </div>\n          </div>\n        )}\n      </div>\n\n      {/* CSS 애니메이션 */}\n      <style dangerouslySetInnerHTML={{\n        __html: `\n          @keyframes pulse {\n            0%, 100% { transform: scale(1); }\n            50% { transform: scale(1.1); }\n          }\n        `\n      }} />\n    </div>\n  );\n});\n\nexport default DashboardHome;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\Home.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\HomePage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useState' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'LearningMode' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":91,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":103},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleLevelSelect' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":46,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":26}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { useUser, useAppStore, useLearningMode, useSpeakingStage, useStageSelection, type LearningMode } from '@/store/useAppStore';\r\nimport { StageSelectionModal } from '@/components/StageSelectionModal';\r\nimport { SpeakingStageSelector } from '@/components/SpeakingStageSelector';\r\n\r\nexport const HomePage: React.FC = () => {\r\n  const navigate = useNavigate();\r\n  const user = useUser();\r\n  const learningMode = useLearningMode();\r\n  const speakingStage = useSpeakingStage();\r\n  const { setUserLevel, setUserStage, setLearningMode } = useAppStore();\r\n  const { setSelectedLevel, setStageModalOpen } = useStageSelection();\r\n\r\n  const handleStartStudy = () => {\r\n    // ver2 동사군 레이블 매핑 (level-system.html과 100% 일치)\r\n    const verbsByLevel: Record<number, string> = {\r\n      1: 'Be동사, 일반동사, 부정문, 의문문, 기초확장',\r\n      2: 'be동사, 일반동사, 조동사, 현재진행형, 과거형, 미래형',\r\n      3: '미래형심화, 현재완료, 과거완료, 수동태, 조동사확장, 조건문, 가정법',\r\n      4: 'buy, sell, use, try, find',\r\n      5: 'give, tell, show, meet, help',\r\n      6: 'come, leave, start, finish, plan',\r\n      7: 'choose, decide, prefer, expect, suppose',\r\n      8: 'keep, let, allow, suggest, recommend',\r\n      9: 'improve, reduce, compare, analyze, design',\r\n      10: 'coordinate, negotiate, prioritize, implement, evaluate'\r\n    };\r\n\r\n    // Navigate to pattern training with current level and stage\r\n    const params = new URLSearchParams();\r\n    params.set('level', user.level.toString());\r\n    params.set('stage', user.stage.toString());\r\n    params.set(\r\n      'verbs',\r\n      verbsByLevel[user.level] \r\n        || availableLevels.find(l => l.level === user.level)?.title \r\n        || 'General'\r\n    );\r\n    params.set('targetAccuracy', '80');\r\n    params.set('developerMode', 'false');\r\n    \r\n    window.location.href = `/pattern-training?${params.toString()}`;\r\n  };\r\n\r\n  const handleLevelSelect = (level: number, stage: number = 1) => {\r\n    setUserLevel(level);\r\n    setUserStage(stage);\r\n  };\r\n\r\n  const handleLevelClick = (level: number) => {\r\n    setSelectedLevel(level);\r\n    setStageModalOpen(true);\r\n  };\r\n\r\n  // 완성된 레벨들과 사용 가능한 스테이지 정보\r\n  const availableLevels = [\r\n    { \r\n      level: 1, \r\n      title: '기초 표현', \r\n      description: 'A1 영어 기초 패턴', \r\n      stages: 19, \r\n      completed: true,\r\n      color: 'bg-emerald-500'\r\n    },\r\n    { \r\n      level: 2, \r\n      title: '기본 패턴', \r\n      description: 'A2-B1 기초 문법', \r\n      stages: 20, \r\n      completed: true,\r\n      color: 'bg-green-500'\r\n    },\r\n    { \r\n      level: 3, \r\n      title: '고급 문법', \r\n      description: 'B1-B2 복문 구조', \r\n      stages: 28, \r\n      completed: true,\r\n      color: 'bg-blue-500'\r\n    },\r\n    { \r\n      level: 4, \r\n      title: '고급 표현', \r\n      description: 'B2-C1 실무 영어', \r\n      stages: 29, \r\n      completed: true,\r\n      color: 'bg-purple-500'\r\n    },\r\n    { \r\n      level: 5, \r\n      title: '고급 비즈니스', \r\n      description: 'C1-C2 비즈니스 영어', \r\n      stages: 29, \r\n      completed: true,\r\n      color: 'bg-indigo-500'\r\n    },\r\n    { \r\n      level: 6, \r\n      title: '도메인 전문성', \r\n      description: 'C2 전문 분야 영어', \r\n      stages: 34, \r\n      completed: true,\r\n      color: 'bg-orange-500'\r\n    },\r\n    { \r\n      level: 7, \r\n      title: '비즈니스 영어', \r\n      description: 'C2 고급 비즈니스', \r\n      stages: 42, \r\n      completed: true,\r\n      color: 'bg-red-500'\r\n    },\r\n    { \r\n      level: 8, \r\n      title: '고급 담화', \r\n      description: 'C2+ 고급 표현', \r\n      stages: 46, \r\n      completed: true,\r\n      color: 'bg-pink-500'\r\n    },\r\n    { \r\n      level: 9, \r\n      title: '전문가 담화', \r\n      description: 'Expert 전문가 수준', \r\n      stages: 52, \r\n      completed: true,\r\n      color: 'bg-violet-500'\r\n    },\r\n    { \r\n      level: 10, \r\n      title: '원어민 수준', \r\n      description: 'Native 원어민 수준', \r\n      stages: 52, \r\n      completed: true,\r\n      color: 'bg-slate-600'\r\n    }\r\n  ];\r\n\r\n  const getLevelTitle = (level: number) => {\r\n    const found = availableLevels.find(l => l.level === level);\r\n    return found ? found.title : `Level ${level}`;\r\n  };\r\n\r\n  const getProgressPercentage = () => {\r\n    // Calculate progress based on available levels\r\n    const totalStages = availableLevels.slice(0, user.level - 1).reduce((acc, level) => acc + level.stages, 0) + user.stage;\r\n    const maxStages = availableLevels.reduce((acc, level) => acc + level.stages, 0);\r\n    return Math.round((totalStages / maxStages) * 100);\r\n  };\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4\">\r\n      <div className=\"max-w-4xl w-full bg-white rounded-lg shadow-lg p-8\">\r\n        {/* Header */}\r\n        <div className=\"text-center mb-8\">\r\n          <h1 className=\"text-4xl font-bold text-gray-800 mb-2\">\r\n            🎯 DASI English\r\n          </h1>\r\n          <p className=\"text-gray-600\">다시 영어 - 한국인 특화 AI 영어 학습</p>\r\n        </div>\r\n\r\n        {/* Learning Mode Selection */}\r\n        <div className=\"bg-gradient-to-r from-purple-500 to-pink-500 rounded-lg p-6 text-white mb-6\">\r\n          <div className=\"text-center mb-6\">\r\n            <h2 className=\"text-xl font-bold mb-3\">🎯 학습 모드 선택</h2>\r\n            <p className=\"text-sm opacity-90\">모든 학습에 적용되는 입력 방식을 선택하세요</p>\r\n            \r\n            {/* 현재 선택된 모드 표시 */}\r\n            <div className=\"mt-4 px-4 py-2 bg-white bg-opacity-20 rounded-lg inline-block\">\r\n              <div className=\"text-sm font-medium\">\r\n                현재 선택: {learningMode === 'writing' ? '✍️ Writing 모드' : '🎤 Speaking 모드'}\r\n              </div>\r\n            </div>\r\n          </div>\r\n          \r\n          <div className=\"grid grid-cols-2 gap-4\">\r\n            <button\r\n              onClick={() => setLearningMode('writing')}\r\n              className={`p-6 rounded-lg transition-all duration-300 border-2 ${\r\n                learningMode === 'writing'\r\n                  ? 'bg-white text-purple-600 shadow-xl transform scale-105 border-white'\r\n                  : 'bg-white bg-opacity-10 hover:bg-opacity-20 border-white border-opacity-30 hover:border-opacity-50'\r\n              }`}\r\n            >\r\n              <div className=\"text-3xl mb-3\">✍️</div>\r\n              <div className={`font-bold text-base mb-2 ${\r\n                learningMode === 'writing' ? 'text-purple-600' : 'text-white'\r\n              }`}>\r\n                Writing 모드\r\n              </div>\r\n              <div className={`text-sm ${\r\n                learningMode === 'writing' ? 'text-purple-500' : 'text-white opacity-80'\r\n              }`}>\r\n                키보드 입력, 문법 체크\r\n              </div>\r\n              {learningMode === 'writing' && (\r\n                <div className=\"mt-3 text-purple-600 font-bold text-sm\">\r\n                  ✓ 선택됨\r\n                </div>\r\n              )}\r\n            </button>\r\n            \r\n            <button\r\n              onClick={() => setLearningMode('speaking')}\r\n              className={`p-6 rounded-lg transition-all duration-300 border-2 ${\r\n                learningMode === 'speaking'\r\n                  ? 'bg-white text-purple-600 shadow-xl transform scale-105 border-white'\r\n                  : 'bg-white bg-opacity-10 hover:bg-opacity-20 border-white border-opacity-30 hover:border-opacity-50'\r\n              }`}\r\n            >\r\n              <div className=\"text-3xl mb-3\">🎤</div>\r\n              <div className={`font-bold text-base mb-2 ${\r\n                learningMode === 'speaking' ? 'text-purple-600' : 'text-white'\r\n              }`}>\r\n                Speaking 모드\r\n              </div>\r\n              <div className={`text-sm ${\r\n                learningMode === 'speaking' ? 'text-purple-500' : 'text-white opacity-80'\r\n              }`}>\r\n                음성 입력, 발음 체크\r\n              </div>\r\n              {learningMode === 'speaking' && (\r\n                <div className=\"mt-3 text-purple-600 font-bold text-sm\">\r\n                  ✓ 선택됨\r\n                </div>\r\n              )}\r\n            </button>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Current Level Display */}\r\n        <div className=\"bg-gradient-to-r from-blue-500 to-indigo-600 rounded-lg p-6 text-white mb-6\">\r\n          <div className=\"flex items-center justify-between mb-4\">\r\n            <div>\r\n              <h2 className=\"text-sm font-medium opacity-90\">현재 레벨</h2>\r\n              <h3 className=\"text-2xl font-bold\">\r\n                Level {user.level} - {getLevelTitle(user.level)}\r\n              </h3>\r\n            </div>\r\n            <div className=\"text-right\">\r\n              <div className=\"text-sm opacity-90\">스테이지</div>\r\n              <div className=\"text-xl font-bold\">\r\n                {user.stage === 'ALL' ? 'ALL' : `${user.stage}/${availableLevels.find(l => l.level === user.level)?.stages || 10}`}\r\n              </div>\r\n            </div>\r\n          </div>\r\n          \r\n          {/* Progress Bar */}\r\n          <div className=\"bg-white bg-opacity-20 rounded-full h-2 mb-2\">\r\n            <div \r\n              className=\"bg-white rounded-full h-2 transition-all duration-500\"\r\n              style={{ \r\n                width: user.stage === 'ALL' \r\n                  ? '100%' \r\n                  : `${(user.stage / (availableLevels.find(l => l.level === user.level)?.stages || 10)) * 100}%` \r\n              }}\r\n            />\r\n          </div>\r\n          <div className=\"text-xs opacity-90 flex items-center justify-center space-x-2\">\r\n            <span>전체 진행도: {getProgressPercentage()}%</span>\r\n            <span>•</span>\r\n            <div className={`px-2 py-1 rounded text-xs font-medium ${\r\n              learningMode === 'writing' \r\n                ? 'bg-blue-500 text-white' \r\n                : 'bg-green-500 text-white'\r\n            }`}>\r\n              {learningMode === 'writing' ? '✍️ Writing' : '🎤 Speaking'} 모드\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Speaking Stage Selector - Only show in Speaking mode */}\r\n        {learningMode === 'speaking' && (\r\n          <SpeakingStageSelector\r\n            currentStage={speakingStage.stage}\r\n            onStageChange={speakingStage.setSpeakingStage}\r\n          />\r\n        )}\r\n\r\n        {/* 메인 학습 섹션 3개로 분리 */}\r\n        <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6 mb-8\">\r\n          {/* 메인 학습 섹션 */}\r\n          <div className=\"bg-white rounded-lg shadow-lg border border-gray-200\">\r\n            <div className=\"bg-gradient-to-r from-blue-500 to-indigo-600 text-white p-4 rounded-t-lg\">\r\n              <h2 className=\"text-lg font-bold\">메인 학습</h2>\r\n              <p className=\"text-sm opacity-90\">주요 학습 기능</p>\r\n            </div>\r\n            <div className=\"p-4 space-y-3\">\r\n              <button\r\n                onClick={handleStartStudy}\r\n                className=\"w-full bg-gradient-to-r from-green-500 to-emerald-500 hover:from-green-600 hover:to-emerald-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200\"\r\n              >\r\n                🎯 Level {user.level}{user.stage === 'ALL' ? ' ALL 모드' : ` Stage ${user.stage}`} 학습 시작\r\n              </button>\r\n              \r\n              <button\r\n                onClick={() => navigate('/all-mode')}\r\n                className=\"w-full bg-gradient-to-r from-orange-500 to-red-500 hover:from-orange-600 hover:to-red-600 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200\"\r\n              >\r\n                🔄 ALL 모드\r\n                <div className=\"text-xs opacity-90 mt-1\">망각곡선 복습</div>\r\n              </button>\r\n              \r\n              <button\r\n                onClick={() => navigate('/personalized')}\r\n                className=\"w-full bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-700 hover:to-pink-700 text-white font-bold py-3 px-4 rounded-lg transition-all duration-200\"\r\n              >\r\n                🤖 맞춤팩\r\n                <div className=\"text-xs opacity-90 mt-1\">AI 자동생성</div>\r\n              </button>\r\n            </div>\r\n          </div>\r\n\r\n          {/* 학습 관리 섹션 */}\r\n          <div className=\"bg-white rounded-lg shadow-lg border border-gray-200\">\r\n            <div className=\"bg-gradient-to-r from-green-500 to-teal-600 text-white p-4 rounded-t-lg\">\r\n              <h2 className=\"text-lg font-bold\">학습 관리</h2>\r\n              <p className=\"text-sm opacity-90\">진도 및 성과 관리</p>\r\n            </div>\r\n            <div className=\"p-4 space-y-3\">\r\n              <button\r\n                onClick={() => navigate('/progress')}\r\n                className=\"w-full bg-indigo-500 hover:bg-indigo-600 text-white font-medium py-3 px-4 rounded-lg transition-colors duration-200\"\r\n              >\r\n                📊 진도 관리\r\n              </button>\r\n              \r\n              {/* 레벨 선택자 */}\r\n              <div className=\"bg-gray-50 rounded-lg p-3\">\r\n                <h3 className=\"font-medium text-gray-800 mb-2 text-sm\">📚 레벨 선택</h3>\r\n                <div className=\"grid grid-cols-5 gap-1\">\r\n                  {availableLevels.slice(0, 10).map((levelInfo) => (\r\n                    <button\r\n                      key={levelInfo.level}\r\n                      onClick={() => handleLevelClick(levelInfo.level)}\r\n                      className={`p-2 rounded text-xs font-bold transition-all duration-200 ${\r\n                        user.level === levelInfo.level\r\n                          ? `${levelInfo.color} text-white shadow-md`\r\n                          : 'bg-white border border-gray-200 hover:border-gray-300 text-gray-700'\r\n                      }`}\r\n                      title={`Level ${levelInfo.level}: ${levelInfo.title}`}\r\n                    >\r\n                      {levelInfo.level}\r\n                    </button>\r\n                  ))}\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n\r\n          {/* 보조 학습 섹션 */}\r\n          <div className=\"bg-white rounded-lg shadow-lg border border-gray-200\">\r\n            <div className=\"bg-gradient-to-r from-purple-500 to-pink-600 text-white p-4 rounded-t-lg\">\r\n              <h2 className=\"text-lg font-bold\">보조 학습</h2>\r\n              <p className=\"text-sm opacity-90\">추가 기능 및 도구</p>\r\n            </div>\r\n            <div className=\"p-4 space-y-3\">\r\n              <button\r\n                onClick={() => navigate('/scenario')}\r\n                className=\"w-full bg-teal-500 hover:bg-teal-600 text-white font-medium py-3 px-4 rounded-lg transition-colors duration-200\"\r\n              >\r\n                🎭 시나리오 대화\r\n              </button>\r\n              \r\n              <button\r\n                onClick={() => alert('준비중입니다.')}\r\n                className=\"w-full relative bg-gray-400 text-white font-medium py-3 px-4 rounded-lg cursor-not-allowed\"\r\n                disabled\r\n              >\r\n                📋 학습 계획\r\n                <span className=\"absolute top-1 right-2 bg-yellow-500 text-black text-xs px-2 py-0.5 rounded-full font-bold\">준비중</span>\r\n              </button>\r\n              \r\n              <button\r\n                onClick={() => alert('준비중입니다.')}\r\n                className=\"w-full relative bg-gray-400 text-white font-medium py-3 px-4 rounded-lg cursor-not-allowed\"\r\n                disabled\r\n              >\r\n                📄 성과 분석\r\n                <span className=\"absolute top-1 right-2 bg-yellow-500 text-black text-xs px-2 py-0.5 rounded-full font-bold\">준비중</span>\r\n              </button>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* 4-tile 통계 미리보기 */}\r\n        <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 mb-8\">\r\n          <div className=\"bg-gradient-to-r from-blue-500 to-blue-600 text-white rounded-lg p-4 text-center\">\r\n            <div className=\"text-2xl font-bold\">{user.level}</div>\r\n            <div className=\"text-sm opacity-90\">현재 레벨</div>\r\n          </div>\r\n          <div className=\"bg-gradient-to-r from-green-500 to-green-600 text-white rounded-lg p-4 text-center\">\r\n            <div className=\"text-2xl font-bold\">{user.stage}</div>\r\n            <div className=\"text-sm opacity-90\">현재 스테이지</div>\r\n          </div>\r\n          <div className=\"bg-gradient-to-r from-purple-500 to-purple-600 text-white rounded-lg p-4 text-center\">\r\n            <div className=\"text-2xl font-bold\">{getProgressPercentage()}%</div>\r\n            <div className=\"text-sm opacity-90\">전체 진도</div>\r\n          </div>\r\n          <div className=\"bg-gradient-to-r from-orange-500 to-orange-600 text-white rounded-lg p-4 text-center\">\r\n            <div className=\"text-2xl font-bold\">{learningMode === 'writing' ? '✍️' : '🎤'}</div>\r\n            <div className=\"text-sm opacity-90\">{learningMode === 'writing' ? 'Writing' : 'Speaking'} 모드</div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Development Tools */}\r\n        <div className=\"mt-6 pt-4 border-t border-gray-200\">\r\n          <details className=\"group\">\r\n            <summary className=\"cursor-pointer text-sm text-gray-500 hover:text-gray-700 transition-colors\">\r\n              🔧 개발 도구\r\n            </summary>\r\n            <div className=\"mt-3 grid grid-cols-2 gap-2 text-xs\">\r\n              <button \r\n                onClick={() => navigate('/curriculum-test')}\r\n                className=\"text-purple-600 hover:text-purple-800 transition-colors p-2 bg-purple-50 rounded\"\r\n              >\r\n                🧪 커리큘럼 테스트\r\n              </button>\r\n              <button \r\n                onClick={() => navigate('/curriculum-lint')}\r\n                className=\"text-indigo-600 hover:text-indigo-800 transition-colors p-2 bg-indigo-50 rounded\"\r\n              >\r\n                📋 콘텐츠 린트\r\n              </button>\r\n              <button \r\n                onClick={() => navigate('/audio-test')}\r\n                className=\"text-red-600 hover:text-red-800 transition-colors p-2 bg-red-50 rounded\"\r\n              >\r\n                🎵 AudioV2 테스트\r\n              </button>\r\n              <button \r\n                onClick={() => navigate('/settings')}\r\n                className=\"text-gray-600 hover:text-gray-800 transition-colors p-2 bg-gray-50 rounded\"\r\n              >\r\n                ⚙️ 설정\r\n              </button>\r\n            </div>\r\n          </details>\r\n        </div>\r\n\r\n        {/* Stage Selection Modal */}\r\n        <StageSelectionModal availableLevels={availableLevels} />\r\n      </div>\r\n    </div>\r\n  );\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\ImitationPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setAudioUrl' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":13,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCurrentSentence' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":14,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setFeedback' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":15,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Imitation Page - 모방 학습 페이지\r\n */\r\n\r\nimport React, { useState, useRef } from 'react';\r\n\r\ninterface ImitationPageProps {\r\n  // TODO: Props 타입 정의 추가\r\n}\r\n\r\nconst ImitationPage: React.FC<ImitationPageProps> = () => {\r\n  const [isRecording, setIsRecording] = useState(false);\r\n  const [audioUrl, setAudioUrl] = useState<string>('');\r\n  const [currentSentence, setCurrentSentence] = useState('Hello, how are you?');\r\n  const [feedback, setFeedback] = useState<string>('');\r\n  const audioRef = useRef<HTMLAudioElement>(null);\r\n\r\n  const startRecording = async () => {\r\n    setIsRecording(true);\r\n    // TODO: 실제 녹음 로직 구현 (기존 AudioRecorder 컴포넌트 활용)\r\n  };\r\n\r\n  const stopRecording = async () => {\r\n    setIsRecording(false);\r\n    // TODO: 녹음 중단 및 분석 로직 구현\r\n  };\r\n\r\n  const playTargetAudio = () => {\r\n    // TODO: TTS를 통한 목표 문장 재생\r\n    console.log('Playing target sentence:', currentSentence);\r\n  };\r\n\r\n  return (\r\n    <div className=\"imitation-page\">\r\n      <div className=\"container mx-auto px-4 py-6\">\r\n        <h1 className=\"text-2xl font-bold mb-6\">모방 학습</h1>\r\n        \r\n        {/* 목표 문장 섹션 */}\r\n        <div className=\"target-sentence-section bg-white rounded-lg shadow-md p-6 mb-6\">\r\n          <h2 className=\"text-xl font-semibold mb-4\">목표 문장</h2>\r\n          <div className=\"sentence-display bg-blue-50 rounded-lg p-4 mb-4\">\r\n            <p className=\"text-lg text-blue-800 font-medium\">{currentSentence}</p>\r\n          </div>\r\n          \r\n          <div className=\"audio-controls mb-4\">\r\n            <button \r\n              onClick={playTargetAudio}\r\n              className=\"bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600 transition-colors mr-3\"\r\n            >\r\n              🔊 목표 발음 듣기\r\n            </button>\r\n            <button className=\"bg-gray-500 text-white px-4 py-2 rounded-md hover:bg-gray-600 transition-colors\">\r\n              느리게 재생\r\n            </button>\r\n          </div>\r\n        </div>\r\n\r\n        {/* 녹음 섹션 */}\r\n        <div className=\"recording-section bg-white rounded-lg shadow-md p-6 mb-6\">\r\n          <h2 className=\"text-xl font-semibold mb-4\">발음 연습</h2>\r\n          \r\n          <div className=\"recording-controls mb-4\">\r\n            {!isRecording ? (\r\n              <button \r\n                onClick={startRecording}\r\n                className=\"bg-red-500 text-white px-6 py-3 rounded-full hover:bg-red-600 transition-colors\"\r\n              >\r\n                🎤 녹음 시작\r\n              </button>\r\n            ) : (\r\n              <button \r\n                onClick={stopRecording}\r\n                className=\"bg-gray-500 text-white px-6 py-3 rounded-full hover:bg-gray-600 transition-colors\"\r\n              >\r\n                ⏹️ 녹음 중단\r\n              </button>\r\n            )}\r\n          </div>\r\n\r\n          {isRecording && (\r\n            <div className=\"recording-indicator\">\r\n              <div className=\"flex items-center justify-center\">\r\n                <div className=\"animate-pulse bg-red-500 rounded-full h-4 w-4 mr-2\"></div>\r\n                <span className=\"text-red-500 font-medium\">녹음 중...</span>\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {audioUrl && (\r\n            <div className=\"recorded-audio mt-4\">\r\n              <h3 className=\"font-medium mb-2\">녹음된 음성</h3>\r\n              <audio ref={audioRef} controls className=\"w-full\">\r\n                <source src={audioUrl} type=\"audio/webm\" />\r\n              </audio>\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n        {/* 피드백 섹션 */}\r\n        {feedback && (\r\n          <div className=\"feedback-section bg-white rounded-lg shadow-md p-6\">\r\n            <h2 className=\"text-xl font-semibold mb-4\">발음 피드백</h2>\r\n            <div className=\"feedback-content bg-yellow-50 rounded-lg p-4\">\r\n              <p className=\"text-yellow-800\">{feedback}</p>\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* 진행 상황 */}\r\n        <div className=\"progress-section bg-white rounded-lg shadow-md p-6 mt-6\">\r\n          <h2 className=\"text-xl font-semibold mb-4\">학습 진행 상황</h2>\r\n          <div className=\"progress-bar bg-gray-200 rounded-full h-2 mb-2\">\r\n            <div className=\"progress-fill bg-blue-500 h-2 rounded-full\" style={{ width: '35%' }}></div>\r\n          </div>\r\n          <p className=\"text-sm text-gray-600\">전체 진행률: 35% (7/20 문장 완료)</p>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ImitationPage;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\LandingHome.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isDark' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":11,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentLevelProgress' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":124,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":124,"endColumn":31},{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":169,"column":71,"nodeType":"Identifier","messageId":"undef","endLine":169,"endColumn":84},{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":172,"column":76,"nodeType":"Identifier","messageId":"undef","endLine":172,"endColumn":89}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { useUser, useStageSelection } from '@/store/useAppStore';\nimport { StageSelectionModal } from '@/components/StageSelectionModal';\nimport { useTheme } from '@/hooks/useTheme';\n\nexport const LandingHome: React.FC = () => {\n  const navigate = useNavigate();\n  const user = useUser();\n  const { setSelectedLevel, setStageModalOpen } = useStageSelection();\n  const { toggleTheme, isDark, getThemeIcon, getThemeLabel } = useTheme();\n\n  // 완성된 레벨들과 사용 가능한 스테이지 정보\n  const availableLevels = [\n    { \n      level: 1, \n      title: '기초 표현', \n      description: 'A1 영어 기초 패턴', \n      stages: 19, \n      completed: true,\n      color: 'bg-emerald-500'\n    },\n    { \n      level: 2, \n      title: '기본 패턴', \n      description: 'A2-B1 기초 문법', \n      stages: 20, \n      completed: true,\n      color: 'bg-green-500'\n    },\n    { \n      level: 3, \n      title: '고급 문법', \n      description: 'B1-B2 복문 구조', \n      stages: 28, \n      completed: true,\n      color: 'bg-blue-500'\n    },\n    { \n      level: 4, \n      title: '고급 표현', \n      description: 'B2-C1 실무 영어', \n      stages: 29, \n      completed: true,\n      color: 'bg-purple-500'\n    },\n    { \n      level: 5, \n      title: '고급 비즈니스', \n      description: 'C1-C2 비즈니스 영어', \n      stages: 29, \n      completed: true,\n      color: 'bg-indigo-500'\n    },\n    { \n      level: 6, \n      title: '도메인 전문성', \n      description: 'C2 전문 분야 영어', \n      stages: 34, \n      completed: true,\n      color: 'bg-orange-500'\n    },\n    { \n      level: 7, \n      title: '비즈니스 영어', \n      description: 'C2 고급 비즈니스', \n      stages: 42, \n      completed: true,\n      color: 'bg-red-500'\n    },\n    { \n      level: 8, \n      title: '고급 담화', \n      description: 'C2+ 고급 표현', \n      stages: 46, \n      completed: true,\n      color: 'bg-pink-500'\n    },\n    { \n      level: 9, \n      title: '전문가 담화', \n      description: 'Expert 전문가 수준', \n      stages: 52, \n      completed: true,\n      color: 'bg-violet-500'\n    },\n    { \n      level: 10, \n      title: '원어민 수준', \n      description: 'Native 원어민 수준', \n      stages: 52, \n      completed: true,\n      color: 'bg-slate-600'\n    }\n  ];\n\n  const showComingSoon = (feature: string) => {\n    alert(`🚧 ${feature} 기능은 현재 개발 중입니다.\\n\\n곧 만나보실 수 있습니다! 😊`);\n  };\n\n  const handleSettings = () => {\n    navigate('/settings');\n  };\n\n  const handlePatternLearning = () => {\n    navigate('/dashboard');\n  };\n\n  const handleProgressManagement = () => {\n    navigate('/progress'); // 진도관리 페이지로 이동\n  };\n\n  const handleAchievements = () => {\n    navigate('/achievements'); // 업적 페이지로 이동\n  };\n\n  const handleVocabulary = () => {\n    navigate('/vocabulary'); // 단어장 페이지로 이동\n  };\n\n  // 동적 통계 계산\n  const calculateStats = () => {\n    // 현재 레벨 진행률 계산\n    const currentLevelProgress = user.stage === 'ALL' \n      ? 100 \n      : Math.round((user.stage / 19) * 100);\n    \n    // 전체 완성된 스테이지 수 (Level 1-2 완성 기준)\n    const completedStages = user.level === 1 \n      ? Math.max(0, user.stage - 1)\n      : (user.level - 1) * 19 + (user.stage === 'ALL' ? 19 : user.stage - 1);\n    \n    // 연속 학습일 (로컬스토리지에서 가져오거나 기본값)\n    const getConsecutiveDays = () => {\n      try {\n        const lastStudyDate = localStorage.getItem('lastStudyDate');\n        const consecutiveDays = localStorage.getItem('consecutiveDays');\n        const today = new Date().toDateString();\n        \n        if (lastStudyDate === today) {\n          return parseInt(consecutiveDays || '1');\n        }\n        return 1; // 기본값\n      } catch {\n        return 1;\n      }\n    };\n    \n    return {\n      currentLevel: user.level,\n      stageProgress: user.stage === 'ALL' ? 'ALL' : `${user.stage}/19`,\n      completionRate: `${Math.min(100, Math.round((completedStages / 380) * 100))}%`, // Level 1-10 총 380개 스테이지 기준\n      consecutiveDays: getConsecutiveDays()\n    };\n  };\n\n  const stats = calculateStats();\n\n  // 스테이지 모달 이벤트 리스너\n  useEffect(() => {\n    // 패턴 트레이닝에서 뒤로가기 시 스테이지 모달 열기\n    const handleOpenStageModal = (event: CustomEvent) => {\n      const { level } = event.detail;\n      setSelectedLevel(level);\n      setStageModalOpen(true);\n    };\n\n    // 커스텀 이벤트 리스너 등록\n    window.addEventListener('openStageModal', handleOpenStageModal as EventListener);\n    \n    return () => {\n      window.removeEventListener('openStageModal', handleOpenStageModal as EventListener);\n    };\n  }, [setSelectedLevel, setStageModalOpen]);\n\n  return (\n    <div className=\"min-h-screen p-5 bg-gray-50 dark:bg-gray-900 transition-colors duration-300\">\n      <div className=\"max-w-4xl mx-auto rounded-2xl shadow-lg overflow-hidden bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 transition-colors duration-300\">\n        {/* Header */}\n        <div className=\"p-10 text-center relative bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 text-gray-900 dark:text-white transition-colors duration-300\">\n          {/* Dark Mode Toggle Button */}\n          <button\n            onClick={toggleTheme}\n            className=\"absolute top-4 right-4 px-4 py-2 rounded-lg text-sm font-medium transition-all duration-300 hover:scale-105 bg-gray-200 dark:bg-gray-600 text-gray-700 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-500\"\n            title={getThemeLabel()}\n            aria-label={getThemeLabel()}\n          >\n            {getThemeIcon()} {getThemeLabel()}\n          </button>\n          \n          <h1 className=\"text-5xl font-bold mb-3\">🎯 DASI English</h1>\n          <p className=\"text-xl opacity-90\">다시 영어 - 한국인 특화 AI 영어 학습</p>\n        </div>\n        \n        <div className=\"p-10 bg-white dark:bg-gray-800 transition-colors duration-300\">\n          {/* 메인 학습 */}\n          <div className=\"mb-10\">\n            <h2 className=\"text-xl font-bold mb-5 pl-4 text-gray-900 dark:text-white border-l-4 border-blue-500 dark:border-blue-400\">\n              메인 학습\n            </h2>\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-5\">\n              <button\n                onClick={handlePatternLearning}\n                className=\"group relative rounded-2xl p-6 cursor-pointer transition-all duration-300 hover:transform hover:-translate-y-2 hover:shadow-xl text-left overflow-hidden bg-white dark:bg-gray-700 border-2 border-gray-200 dark:border-gray-600 hover:border-blue-500 dark:hover:border-blue-400\"\n              >\n                <div className=\"absolute top-0 left-0 right-0 h-1 bg-blue-500 dark:bg-blue-400 transform scale-x-0 group-hover:scale-x-100 transition-transform duration-300\"></div>\n                <div className=\"text-4xl mb-4\">📚</div>\n                <div className=\"text-xl font-bold mb-3 text-gray-900 dark:text-white\">패턴 학습 (Lv1~10)</div>\n                <div className=\"leading-relaxed text-gray-600 dark:text-gray-300\">\n                  한국인 특화 27개 문법 패턴을 3초→1초 속도로 완전 자동화하는 체계적 훈련\n                </div>\n              </button>\n              \n              <button\n                onClick={() => showComingSoon('모방 학습')}\n                className=\"group relative bg-white dark:bg-gray-700 border-2 border-gray-200 dark:border-gray-600 rounded-2xl p-6 cursor-pointer transition-all duration-300 hover:transform hover:-translate-y-2 hover:shadow-xl hover:border-blue-400 dark:hover:border-blue-400 text-left overflow-hidden opacity-70\"\n              >\n                <div className=\"absolute top-4 right-4 bg-gray-500 dark:bg-gray-600 text-white text-xs px-2 py-1 rounded-lg font-bold\">\n                  준비중\n                </div>\n                <div className=\"absolute top-0 left-0 right-0 h-1 bg-blue-400 transform scale-x-0 group-hover:scale-x-100 transition-transform duration-300\"></div>\n                <div className=\"text-4xl mb-4\">🎭</div>\n                <div className=\"text-xl font-bold mb-3 text-gray-800 dark:text-white\">모방 학습 (Lv1~10)</div>\n                <div className=\"text-gray-600 dark:text-gray-300 leading-relaxed\">\n                  원어민 대화를 듣고 자신의 말로 재구성하는 자연스러운 회화 훈련\n                </div>\n              </button>\n            </div>\n          </div>\n          \n          {/* 학습 관리 */}\n          <div className=\"mb-10\">\n            <h2 className=\"text-xl font-bold text-gray-800 dark:text-white mb-5 border-l-4 border-gray-500 dark:border-gray-400 pl-4\">\n              학습 관리\n            </h2>\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-5\">\n              <button\n                onClick={handleProgressManagement}\n                className=\"group relative bg-white dark:bg-gray-700 border-2 border-gray-200 dark:border-gray-600 rounded-2xl p-6 cursor-pointer transition-all duration-300 hover:transform hover:-translate-y-2 hover:shadow-xl hover:border-gray-400 dark:hover:border-gray-400 text-left overflow-hidden\"\n              >\n                <div className=\"absolute top-4 right-4 bg-green-500 text-white text-xs px-2 py-1 rounded-lg font-bold\">\n                  SRS 활성\n                </div>\n                <div className=\"absolute top-0 left-0 right-0 h-1 bg-gray-400 transform scale-x-0 group-hover:scale-x-100 transition-transform duration-300\"></div>\n                <div className=\"text-4xl mb-4\">📊</div>\n                <div className=\"text-xl font-bold mb-3 text-gray-800 dark:text-white\">진도관리</div>\n                <div className=\"text-gray-600 dark:text-gray-300 leading-relaxed\">\n                  망각곡선 기반 복습 알림, 학습 현황 및 다음 단계 추천\n                </div>\n              </button>\n              \n              <button\n                onClick={handleAchievements}\n                className=\"group relative bg-white dark:bg-gray-700 border-2 border-gray-200 dark:border-gray-600 rounded-2xl p-6 cursor-pointer transition-all duration-300 hover:transform hover:-translate-y-2 hover:shadow-xl hover:border-gray-400 dark:hover:border-gray-400 text-left overflow-hidden\"\n              >\n                <div className=\"absolute top-4 right-4 bg-orange-500 text-white text-xs px-2 py-1 rounded-lg font-bold\">\n                  활성\n                </div>\n                <div className=\"absolute top-0 left-0 right-0 h-1 bg-gray-400 transform scale-x-0 group-hover:scale-x-100 transition-transform duration-300\"></div>\n                <div className=\"text-4xl mb-4\">🏆</div>\n                <div className=\"text-xl font-bold mb-3 text-gray-800 dark:text-white\">업적·배지</div>\n                <div className=\"text-gray-600 dark:text-gray-300 leading-relaxed\">\n                  학습 성취도 배지, 연속 학습 업적, 레벨별 달성 기록 및 진행률 확인\n                </div>\n              </button>\n            </div>\n          </div>\n          \n          {/* 보조 학습 */}\n          <div className=\"mb-10\">\n            <h2 className=\"text-xl font-bold text-gray-800 dark:text-white mb-5 border-l-4 border-gray-600 dark:border-gray-500 pl-4\">\n              보조 학습\n            </h2>\n            <div className=\"grid grid-cols-1 md:grid-cols-2 gap-5\">\n              <button\n                onClick={handleVocabulary}\n                className=\"group relative bg-white dark:bg-gray-700 border-2 border-gray-200 dark:border-gray-600 rounded-2xl p-6 cursor-pointer transition-all duration-300 hover:transform hover:-translate-y-2 hover:shadow-xl hover:border-gray-500 dark:hover:border-gray-400 text-left overflow-hidden\"\n              >\n                <div className=\"absolute top-4 right-4 bg-green-500 text-white text-xs px-2 py-1 rounded-lg font-bold\">\n                  활성\n                </div>\n                <div className=\"absolute top-0 left-0 right-0 h-1 bg-gray-500 transform scale-x-0 group-hover:scale-x-100 transition-transform duration-300\"></div>\n                <div className=\"text-4xl mb-4\">📖</div>\n                <div className=\"text-xl font-bold mb-3 text-gray-800 dark:text-white\">단어장</div>\n                <div className=\"text-gray-600 dark:text-gray-300 leading-relaxed\">\n                  패턴 학습 기반 단어 추출, 레벨별 단어 목록, SRS 복습 시스템\n                </div>\n              </button>\n              \n              <button\n                onClick={handleSettings}\n                className=\"group relative bg-white dark:bg-gray-700 border-2 border-gray-200 dark:border-gray-600 rounded-2xl p-6 cursor-pointer transition-all duration-300 hover:transform hover:-translate-y-2 hover:shadow-xl hover:border-gray-500 dark:hover:border-gray-400 text-left overflow-hidden\"\n              >\n                <div className=\"absolute top-4 right-4 bg-blue-500 text-white text-xs px-2 py-1 rounded-lg font-bold\">\n                  활성\n                </div>\n                <div className=\"absolute top-0 left-0 right-0 h-1 bg-gray-500 transform scale-x-0 group-hover:scale-x-100 transition-transform duration-300\"></div>\n                <div className=\"text-4xl mb-4\">⚙️</div>\n                <div className=\"text-xl font-bold mb-3 text-gray-800 dark:text-white\">설정</div>\n                <div className=\"text-gray-600 dark:text-gray-300 leading-relaxed\">\n                  음성 설정, 알림 설정, 학습 환경 개인화 및 계정 관리\n                </div>\n              </button>\n            </div>\n          </div>\n          \n          {/* 학습 현황 및 진행률 통계 */}\n          <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4 p-5 bg-gray-50 dark:bg-gray-700 rounded-lg border border-gray-200 dark:border-gray-600 transition-colors duration-300\">\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-blue-600 dark:text-blue-400\">Level {stats.currentLevel}</div>\n              <div className=\"text-xs text-gray-600 dark:text-gray-300 mt-1\">현재 레벨</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-green-600 dark:text-green-400\">{stats.stageProgress}</div>\n              <div className=\"text-xs text-gray-600 dark:text-gray-300 mt-1\">스테이지 진행률</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-purple-600 dark:text-purple-400\">{stats.completionRate}</div>\n              <div className=\"text-xs text-gray-600 dark:text-gray-300 mt-1\">전체 완성도</div>\n            </div>\n            <div className=\"text-center\">\n              <div className=\"text-2xl font-bold text-orange-600 dark:text-orange-400\">{stats.consecutiveDays}일</div>\n              <div className=\"text-xs text-gray-600 dark:text-gray-300 mt-1\">연속 학습</div>\n            </div>\n          </div>\n        </div>\n\n        {/* Stage Selection Modal */}\n        <StageSelectionModal availableLevels={availableLevels} />\n      </div>\n    </div>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\MigrationPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\PatternPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentPattern' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":24,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setCurrentPattern' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":24,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Pattern Page - 패턴 학습 페이지\r\n */\r\n\r\nimport React, { useState, useEffect } from 'react';\r\n\r\ninterface PatternPageProps {\r\n  // TODO: Props 타입 정의 추가\r\n}\r\n\r\ninterface PatternData {\r\n  id: string;\r\n  title: string;\r\n  level: string;\r\n  patterns: Array<{\r\n    id: string;\r\n    pattern: string;\r\n    meaning: string;\r\n    examples: string[];\r\n  }>;\r\n}\r\n\r\nconst PatternPage: React.FC<PatternPageProps> = () => {\r\n  const [currentPattern, setCurrentPattern] = useState<PatternData | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [selectedLevel, setSelectedLevel] = useState('1');\r\n\r\n  useEffect(() => {\r\n    // TODO: 패턴 데이터 로드\r\n    setIsLoading(false);\r\n  }, [selectedLevel]);\r\n\r\n  return (\r\n    <div className=\"pattern-page\">\r\n      <div className=\"container mx-auto px-4 py-6\">\r\n        <h1 className=\"text-2xl font-bold mb-6\">패턴 학습</h1>\r\n        \r\n        {/* 레벨 선택 */}\r\n        <div className=\"level-selector mb-6\">\r\n          <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n            학습 레벨 선택\r\n          </label>\r\n          <select \r\n            value={selectedLevel}\r\n            onChange={(e) => setSelectedLevel(e.target.value)}\r\n            className=\"border border-gray-300 rounded-md px-3 py-2 bg-white\"\r\n          >\r\n            <option value=\"1\">Level 1 - 기본 패턴</option>\r\n            <option value=\"2\">Level 2 - 기본 문법</option>\r\n            <option value=\"3\">Level 3 - 고급 문법</option>\r\n            <option value=\"4\">Level 4 - 비즈니스</option>\r\n            <option value=\"5\">Level 5 - 학술</option>\r\n            <option value=\"6\">Level 6 - 전문</option>\r\n          </select>\r\n        </div>\r\n\r\n        {/* 패턴 학습 영역 */}\r\n        <div className=\"pattern-learning-area bg-white rounded-lg shadow-md p-6\">\r\n          {isLoading ? (\r\n            <div className=\"text-center py-8\">\r\n              <p className=\"text-gray-600\">패턴 데이터를 불러오는 중...</p>\r\n            </div>\r\n          ) : (\r\n            <div className=\"pattern-content\">\r\n              <h2 className=\"text-xl font-semibold mb-4\">\r\n                Level {selectedLevel} 패턴 학습\r\n              </h2>\r\n              \r\n              {/* TODO: PatternTrainingFlow 컴포넌트 통합 */}\r\n              <div className=\"pattern-display mb-6\">\r\n                <div className=\"pattern-card bg-blue-50 rounded-lg p-4 mb-4\">\r\n                  <h3 className=\"font-medium text-blue-800 mb-2\">현재 패턴</h3>\r\n                  <p className=\"text-blue-600 text-lg mb-2\">I want to + 동사원형</p>\r\n                  <p className=\"text-sm text-gray-600\">의미: ~하고 싶다</p>\r\n                </div>\r\n                \r\n                <div className=\"examples mb-4\">\r\n                  <h4 className=\"font-medium mb-2\">예문</h4>\r\n                  <ul className=\"space-y-2\">\r\n                    <li className=\"bg-gray-50 rounded px-3 py-2\">\r\n                      I want to learn English.\r\n                    </li>\r\n                    <li className=\"bg-gray-50 rounded px-3 py-2\">\r\n                      I want to go home.\r\n                    </li>\r\n                  </ul>\r\n                </div>\r\n                \r\n                <div className=\"practice-section\">\r\n                  <button className=\"bg-blue-500 text-white px-6 py-2 rounded-md hover:bg-blue-600 transition-colors\">\r\n                    패턴 연습 시작\r\n                  </button>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PatternPage;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\PatternTestPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\PatternTrainingPage.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'handleAnswerEvaluation'. Either exclude it or remove the dependency array.","line":211,"column":8,"nodeType":"ArrayExpression","endLine":211,"endColumn":65,"suggestions":[{"desc":"Update the dependencies array to be: [levelNumber, moveToNextQuestion]","fix":{"range":[8215,8272],"text":"[levelNumber, moveToNextQuestion]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'stageId' is defined but never used. Allowed unused args must match /^_/u.","line":240,"column":25,"nodeType":null,"messageId":"unusedVar","endLine":240,"endColumn":32},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'moveToNextQuestion'. Either include it or remove the dependency array.","line":246,"column":7,"nodeType":"ArrayExpression","endLine":246,"endColumn":102,"suggestions":[{"desc":"Update the dependencies array to be: [playBeepSound, startRecognition, moveToNextQuestion, updateStageProgress, levelNumber, stageNumber, speakingStage]","fix":{"range":[9519,9614],"text":"[playBeepSound, startRecognition, moveToNextQuestion, updateStageProgress, levelNumber, stageNumber, speakingStage]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * PatternTrainingPageV3 - 리팩토링된 패턴 훈련 페이지\r\n * \r\n * 주요 개선사항:\r\n * - 모듈화된 커스텀 훅으로 로직 분리\r\n * - 재사용 가능한 UI 컴포넌트로 분리\r\n * - 코드 길이 90% 단축 (1,042줄 → ~150줄)\r\n * - 유지보수성 및 테스트 용이성 향상\r\n */\r\n\r\nimport React, { useState, useCallback, useRef, useEffect } from 'react';\r\nimport { useSearchParams } from 'react-router-dom';\r\nimport { usePatternTrainingManager, type PatternTrainingManagerConfig } from '@/hooks/usePatternTrainingManager';\r\nimport { useStageData, type Question } from '@/hooks/useStageData';\r\nimport { useAudioManager } from '@/hooks/useAudioManager';\r\nimport { useSimpleSpeechRecognition } from '@/hooks/useSimpleSpeechRecognition';\r\nimport { useSpeakingStage, useStageProgress } from '@/store/useAppStore';\r\nimport { evaluateAnswer } from '@/utils/answerNormalization';\r\nimport { getCountdownDuration, getStageName } from '@/utils/speakingStageUtils';\r\n\r\n// UI Components\r\nimport { LoadingOverlay } from '@/components/LoadingOverlay';\r\nimport { TrainingHeader } from '@/components/TrainingHeader';\r\nimport { QuestionCard } from '@/components/QuestionCard';\r\nimport { ControlPanel } from '@/components/ControlPanel';\r\n\r\ntype Phase = 'idle' | 'tts' | 'countdown' | 'recognition' | 'waiting';\r\ntype EvaluationType = 'correct' | 'incorrect';\r\n\r\nconst PatternTrainingPageV3: React.FC = () => {\r\n  // URL 파라미터 추출\r\n  const [searchParams] = useSearchParams();\r\n  const levelNumber = Math.max(1, parseInt(searchParams.get('level') || '1', 10));\r\n  const phaseNumber = Math.max(1, parseInt(searchParams.get('phase') || '1', 10));\r\n  const stageNumber = Math.max(1, parseInt(searchParams.get('stage') || '1', 10));\r\n  \r\n  // 스피킹 단계 상태 가져오기\r\n  const { stage: speakingStage } = useSpeakingStage();\r\n  const { updateStageProgress } = useStageProgress();\r\n  \r\n  // 스피킹 단계별 설정은 유틸리티 함수 사용\r\n\r\n  // URL 파라미터 검증 로깅\r\n  useEffect(() => {\r\n    if (isNaN(levelNumber) || isNaN(phaseNumber) || isNaN(stageNumber)) {\r\n      console.warn('⚠️ 잘못된 URL 파라미터가 감지되어 기본값으로 설정됨');\r\n    }\r\n    console.log(`🔗 URL 파라미터 로드: Level=${levelNumber}, Phase=${phaseNumber}, Stage=${stageNumber}`);\r\n    console.log(`⏱️ 스피킹 단계: ${getStageName(speakingStage)}`);\r\n  }, [levelNumber, phaseNumber, stageNumber, speakingStage]);\r\n\r\n  // 상태 관리\r\n  const [currentIndex, setCurrentIndex] = useState<number>(0);\r\n  const [isTraining, setIsTraining] = useState<boolean>(false);\r\n  const [isPaused, setIsPaused] = useState<boolean>(false);\r\n  const [currentPhase, setCurrentPhase] = useState<Phase>('idle');\r\n  const [countdownText, setCountdownText] = useState<string>('');\r\n  const [recognitionTimeText, setRecognitionTimeText] = useState<string>('');\r\n  const [showAnswer, setShowAnswer] = useState<boolean>(false);\r\n  const [answerEvaluation, setAnswerEvaluation] = useState<string>('');\r\n  const [evaluationType, setEvaluationType] = useState<EvaluationType>('correct');\r\n  const [recognitionResult, setRecognitionResult] = useState<string>('');\r\n  const [interimResult, setInterimResult] = useState<string>('');\r\n\r\n  // Refs for state consistency\r\n  const currentQuestionsRef = useRef<Question[]>([]);\r\n  const currentIndexRef = useRef<number>(0);\r\n  const pausedStateRef = useRef<{phase: Phase, remainingTime?: number} | null>(null);\r\n\r\n  // 커스텀 훅들\r\n  const { currentQuestions, isLoading, loadingMessage, loadStageData } = useStageData({\r\n    levelNumber,\r\n    phaseNumber,\r\n    stageNumber\r\n  });\r\n\r\n  const { playKoreanTTS, playBeepSound, stopAllAudio } = useAudioManager();\r\n\r\n  // 다음 문제로 이동\r\n  const moveToNextQuestion = useCallback(() => {\r\n    setCurrentIndex(prevIndex => {\r\n      const nextIndex = prevIndex + 1;\r\n      const questions = currentQuestionsRef.current;\r\n      \r\n      console.log(`🔍 [DEBUG] moveToNextQuestion: currentIndex=${prevIndex}, nextIndex=${nextIndex}, questions.length=${questions.length}`);\r\n      \r\n      if (nextIndex >= questions.length) {\r\n        // 모든 문제 완료\r\n        setIsTraining(false);\r\n        setCurrentPhase('idle');\r\n        manager.current.stopAllTimers();\r\n        \r\n        const stageId = `level-${levelNumber}-phase-${phaseNumber}-stage-${stageNumber}`;\r\n        manager.current.handleStageCompletion(stageId);\r\n        \r\n        return 0;\r\n      } else {\r\n        // 다음 문제로 이동\r\n        setCurrentPhase('tts');\r\n        setAnswerEvaluation('');\r\n        setRecognitionResult('');\r\n        setInterimResult('');\r\n        setShowAnswer(false);\r\n        \r\n        // 다음 문제 TTS 재생\r\n        const nextQuestion = questions[nextIndex];\r\n        stopAllAudio(); // 기존 음성 중단\r\n        setTimeout(async () => {\r\n          await playBeepSound('start');\r\n          playKoreanTTS(nextQuestion.ko).then(async () => {\r\n          setCurrentPhase('countdown');\r\n          await playBeepSound('countdown');\r\n          const countdownTime = getCountdownDuration(speakingStage);\r\n          manager.current.startCountdown(countdownTime);\r\n          });\r\n        }, 50);\r\n        \r\n        return nextIndex;\r\n      }\r\n    });\r\n  }, [levelNumber, phaseNumber, stageNumber, speakingStage, playKoreanTTS, playBeepSound, stopAllAudio]);\r\n\r\n  // stopRecognition 참조를 저장할 ref\r\n  const stopRecognitionRef = useRef<(() => void) | null>(null);\r\n\r\n  // 실시간 정답 판정 처리 함수\r\n  const handleAnswerEvaluation = useCallback((userAnswer: string, isRealtime = false) => {\r\n    const currentQuestions = currentQuestionsRef.current;\r\n    const currentIndex = currentIndexRef.current;\r\n    const currentQuestion = currentQuestions[currentIndex];\r\n    \r\n    if (!currentQuestion) {\r\n      console.warn('❌ currentQuestion이 없음 - currentIndex:', currentIndex, 'questions.length:', currentQuestions.length);\r\n      return false;\r\n    }\r\n\r\n    const correctAnswer = currentQuestion.en;\r\n    const evaluation = evaluateAnswer(userAnswer, correctAnswer, levelNumber, 'pattern');\r\n    \r\n    if (evaluation.isCorrect) {\r\n      console.log(`🎤 ${isRealtime ? '실시간' : '최종'} 정답 인식:`, userAnswer, '/ 정답:', correctAnswer);\r\n      \r\n      // 음성인식 타이머 즉시 중지\r\n      manager.current.stopAllTimers();\r\n      if (stopRecognitionRef.current) {\r\n        stopRecognitionRef.current();\r\n      }\r\n      setRecognitionTimeText('');\r\n\r\n      setAnswerEvaluation('✅ 정답입니다!');\r\n      setEvaluationType('correct');\r\n      setRecognitionResult(userAnswer);\r\n      // 실시간 정답 시 즉시, 최종 정답 시 1초 후\r\n      setTimeout(moveToNextQuestion, isRealtime ? 500 : 1000);\r\n      return true;\r\n    }\r\n    \r\n    return false;\r\n  }, [levelNumber, moveToNextQuestion]);\r\n\r\n  const { startRecognition, stopRecognition } = useSimpleSpeechRecognition({\r\n    onInterimResult: useCallback((userAnswer: string, confidence: number) => {\r\n      // 실시간 중간 결과 UI 업데이트\r\n      setInterimResult(userAnswer);\r\n      \r\n      // 실시간 중간 결과로 정답 판정 (높은 신뢰도일 때만)\r\n      if (confidence > 0.7) {\r\n        const wasCorrect = handleAnswerEvaluation(userAnswer, true);\r\n        if (wasCorrect) {\r\n          console.log('⚡ 실시간 정답 처리로 즉시 진행!');\r\n          setInterimResult(''); // 정답 처리 후 중간 결과 클리어\r\n        }\r\n      }\r\n    }, [handleAnswerEvaluation]),\r\n    \r\n    onResult: useCallback((userAnswer: string) => {\r\n      // 최종 결과 처리 (실시간으로 이미 처리되지 않은 경우)\r\n      const currentQuestions = currentQuestionsRef.current;\r\n      const currentIndex = currentIndexRef.current;\r\n      const currentQuestion = currentQuestions[currentIndex];\r\n      \r\n      if (!currentQuestion) return;\r\n\r\n      const correctAnswer = currentQuestion.en;\r\n      console.log('🎤 사용자 최종 답변:', userAnswer, '/ 정답:', correctAnswer);\r\n      \r\n      const evaluation = evaluateAnswer(userAnswer, correctAnswer, levelNumber, 'pattern');\r\n      \r\n      // 음성인식 타이머 즉시 중지\r\n      manager.current.stopAllTimers();\r\n      if (stopRecognitionRef.current) {\r\n        stopRecognitionRef.current();\r\n      }\r\n      setRecognitionTimeText('');\r\n\r\n      if (evaluation.isCorrect) {\r\n        setAnswerEvaluation('✅ 정답입니다!');\r\n        setEvaluationType('correct');\r\n        setRecognitionResult(userAnswer);\r\n        setTimeout(moveToNextQuestion, 1000);\r\n      } else {\r\n        setAnswerEvaluation(`❌ 틀렸습니다. 정답: ${correctAnswer}`);\r\n        setEvaluationType('incorrect');\r\n        setRecognitionResult(userAnswer);\r\n        setShowAnswer(true);\r\n        setTimeout(() => {\r\n          setShowAnswer(false);\r\n          moveToNextQuestion();\r\n        }, 2000);\r\n      }\r\n    }, [levelNumber, handleAnswerEvaluation, moveToNextQuestion])\r\n  });\r\n\r\n  // stopRecognition 함수 참조를 ref에 저장\r\n  useEffect(() => {\r\n    stopRecognitionRef.current = stopRecognition;\r\n  }, [stopRecognition]);\r\n\r\n  // 패턴 훈련 매니저 설정\r\n  const managerConfig: PatternTrainingManagerConfig = useCallback(() => ({\r\n    onCountdownTick: (remainingTime: number) => {\r\n      setCountdownText(remainingTime.toString());\r\n    },\r\n    onCountdownComplete: () => {\r\n      setCurrentPhase('recognition');\r\n      playBeepSound('recognition');\r\n      startRecognition();\r\n      // 음성인식 타이머 시작 (10초 제한)\r\n      manager.current.startRecognition(10);\r\n    },\r\n    onRecognitionTick: (remainingTime: number) => {\r\n      setRecognitionTimeText(remainingTime.toString());\r\n    },\r\n    onRecognitionComplete: () => {\r\n      setCurrentPhase('waiting');\r\n      setRecognitionTimeText('');\r\n      // 음성인식 시간 초과 시 자동으로 다음 문제로\r\n      moveToNextQuestion();\r\n    },\r\n    onCompletionEvent: (stageId: string) => {\r\n      // 해당 스피킹 단계를 완료로 표시\r\n      updateStageProgress(levelNumber, stageNumber, speakingStage, true);\r\n      console.log(`✅ 진행률 업데이트: Level ${levelNumber}, Stage ${stageNumber}, ${speakingStage}단계 완료`);\r\n      alert(`🎉 Stage ${stageNumber} (${speakingStage}단계) 훈련 완료!\\n\\n${getStageName(speakingStage)}를 성공했습니다!`);\r\n    }\r\n  }), [levelNumber, stageNumber, speakingStage, updateStageProgress, playBeepSound, startRecognition])();\r\n\r\n  const manager = useRef(usePatternTrainingManager(managerConfig));\r\n\r\n  // 현재 문제 계산\r\n  const currentQuestion = currentQuestions[currentIndex] || { ko: '', en: '' };\r\n\r\n  // Refs 동기화\r\n  useEffect(() => {\r\n    currentQuestionsRef.current = currentQuestions;\r\n  }, [currentQuestions]);\r\n\r\n  useEffect(() => {\r\n    currentIndexRef.current = currentIndex;\r\n  }, [currentIndex]);\r\n\r\n  // 훈련 시작\r\n  const startTraining = useCallback(() => {\r\n    if (currentQuestions.length === 0) {\r\n      alert('문제 데이터를 먼저 로드해주세요!');\r\n      return;\r\n    }\r\n\r\n    setIsTraining(true);\r\n    setCurrentIndex(0);\r\n    setCurrentPhase('tts');\r\n    \r\n    // 첫 번째 문제 시작\r\n    const firstQuestion = currentQuestions[0];\r\n    stopAllAudio(); // 기존 음성 중단\r\n    setTimeout(async () => {\r\n      await playBeepSound('start');\r\n      playKoreanTTS(firstQuestion.ko).then(async () => {\r\n        setCurrentPhase('countdown');\r\n        await playBeepSound('countdown');\r\n        const countdownTime = getCountdownDuration(speakingStage);\r\n        manager.current.startCountdown(countdownTime);\r\n      });\r\n    }, 50);\r\n  }, [currentQuestions, speakingStage, playKoreanTTS, playBeepSound, stopAllAudio]);\r\n\r\n  // 훈련 일시정지\r\n  const pauseTraining = useCallback(() => {\r\n    if (!isTraining) return;\r\n    \r\n    setIsPaused(true);\r\n    pausedStateRef.current = { phase: currentPhase };\r\n    manager.current.pauseAllTimers();\r\n    if (stopRecognitionRef.current) {\r\n      stopRecognitionRef.current();\r\n    }\r\n  }, [isTraining, currentPhase]);\r\n\r\n  // 훈련 재개\r\n  const resumeTraining = useCallback(() => {\r\n    if (!isPaused || !pausedStateRef.current) return;\r\n    \r\n    setIsPaused(false);\r\n    const { phase } = pausedStateRef.current;\r\n    setCurrentPhase(phase);\r\n    manager.current.resumeAllTimers();\r\n    pausedStateRef.current = null;\r\n  }, [isPaused]);\r\n\r\n  // 훈련 중지\r\n  const stopTraining = useCallback(() => {\r\n    setIsTraining(false);\r\n    setIsPaused(false);\r\n    setCurrentPhase('idle');\r\n    setCurrentIndex(0);\r\n    manager.current.stopAllTimers();\r\n    if (stopRecognitionRef.current) {\r\n      stopRecognitionRef.current();\r\n    }\r\n    pausedStateRef.current = null;\r\n  }, []);\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gradient-to-br from-blue-50 via-white to-purple-50 dark:from-gray-900 dark:via-gray-800 dark:to-gray-900 transition-colors duration-300\">\r\n      {/* 로딩 오버레이 */}\r\n      <LoadingOverlay isVisible={isLoading} message={loadingMessage} />\r\n\r\n      {/* 헤더 */}\r\n      <TrainingHeader\r\n        levelNumber={levelNumber}\r\n        phaseNumber={phaseNumber}\r\n        stageNumber={stageNumber}\r\n        currentIndex={currentIndex}\r\n        totalQuestions={currentQuestions.length}\r\n      />\r\n\r\n      {/* 메인 콘텐츠 */}\r\n      <div className=\"max-w-4xl mx-auto px-4 py-8\">\r\n        {/* 문제 카드 */}\r\n        <QuestionCard\r\n          currentQuestion={currentQuestion}\r\n          currentPhase={currentPhase}\r\n          countdownText={countdownText}\r\n          recognitionTimeText={recognitionTimeText}\r\n          showAnswer={showAnswer}\r\n          answerEvaluation={answerEvaluation}\r\n          evaluationType={evaluationType}\r\n          recognitionResult={recognitionResult}\r\n          interimResult={interimResult}\r\n        />\r\n\r\n        {/* 컨트롤 패널 */}\r\n        <ControlPanel\r\n          isTraining={isTraining}\r\n          isPaused={isPaused}\r\n          currentPhase={currentPhase}\r\n          hasQuestions={currentQuestions.length > 0}\r\n          currentIndex={currentIndex}\r\n          totalQuestions={currentQuestions.length}\r\n          onStartTraining={startTraining}\r\n          onPauseTraining={pauseTraining}\r\n          onResumeTraining={resumeTraining}\r\n          onStopTraining={stopTraining}\r\n          onLoadData={loadStageData}\r\n        />\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default PatternTrainingPageV3;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\PersonalizedPacksPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\ProgressManagementPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'index' is defined but never used. Allowed unused args must match /^_/u.","line":101,"column":67,"nodeType":null,"messageId":"unusedVar","endLine":101,"endColumn":72}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport ProgressDashboard from '../components/ProgressDashboard';\r\n\r\nconst ProgressManagementPage: React.FC = () => {\r\n  const [activeTab, setActiveTab] = useState<'overview' | 'detailed' | 'analytics'>('detailed'); // 기본값을 detailed로\r\n  const navigate = useNavigate();\r\n  const userId = 'dev-user'; // 실제로는 auth context에서 가져옴\r\n\r\n  const renderTabContent = () => {\r\n    switch (activeTab) {\r\n      case 'overview':\r\n        return <ProgressDashboard userId={userId} />;\r\n      \r\n      case 'detailed':\r\n        return (\r\n          <div className=\"max-w-6xl mx-auto p-6\">\r\n            <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white dark:text-white mb-6\">📋 상세 진도 분석</h2>\r\n            \r\n            {/* 스테이지별 상세 분석 */}\r\n            <div className=\"grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8\">\r\n              {/* 완료율 분포 */}\r\n              <div className=\"bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6 transition-colors duration-300\">\r\n                <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white dark:text-white mb-4\">📊 완료율 분포</h3>\r\n                <div className=\"space-y-4\">\r\n                  <div className=\"flex items-center justify-between\">\r\n                    <span className=\"text-sm text-gray-600 dark:text-gray-300\">90% 이상 (마스터)</span>\r\n                    <div className=\"flex items-center gap-2\">\r\n                      <div className=\"w-24 bg-gray-200 rounded-full h-2\">\r\n                        <div className=\"bg-green-500 h-2 rounded-full\" style={{ width: '35%' }}></div>\r\n                      </div>\r\n                      <span className=\"text-sm font-medium text-green-600\">12개</span>\r\n                    </div>\r\n                  </div>\r\n                  <div className=\"flex items-center justify-between\">\r\n                    <span className=\"text-sm text-gray-600 dark:text-gray-300\">70-89% (완료)</span>\r\n                    <div className=\"flex items-center gap-2\">\r\n                      <div className=\"w-24 bg-gray-200 rounded-full h-2\">\r\n                        <div className=\"bg-blue-500 h-2 rounded-full\" style={{ width: '45%' }}></div>\r\n                      </div>\r\n                      <span className=\"text-sm font-medium text-blue-600\">18개</span>\r\n                    </div>\r\n                  </div>\r\n                  <div className=\"flex items-center justify-between\">\r\n                    <span className=\"text-sm text-gray-600 dark:text-gray-300\">50-69% (진행중)</span>\r\n                    <div className=\"flex items-center gap-2\">\r\n                      <div className=\"w-24 bg-gray-200 rounded-full h-2\">\r\n                        <div className=\"bg-yellow-500 h-2 rounded-full\" style={{ width: '20%' }}></div>\r\n                      </div>\r\n                      <span className=\"text-sm font-medium text-yellow-600\">8개</span>\r\n                    </div>\r\n                  </div>\r\n                  <div className=\"flex items-center justify-between\">\r\n                    <span className=\"text-sm text-gray-600 dark:text-gray-300\">50% 미만 (시작)</span>\r\n                    <div className=\"flex items-center gap-2\">\r\n                      <div className=\"w-24 bg-gray-200 rounded-full h-2\">\r\n                        <div className=\"bg-red-500 h-2 rounded-full\" style={{ width: '15%' }}></div>\r\n                      </div>\r\n                      <span className=\"text-sm font-medium text-red-600\">6개</span>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              {/* 학습 패턴 */}\r\n              <div className=\"bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg transition-colors duration-300 p-6\">\r\n                <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white mb-4\">⏰ 학습 패턴</h3>\r\n                <div className=\"space-y-4\">\r\n                  <div>\r\n                    <div className=\"flex justify-between text-sm text-gray-600 dark:text-gray-300 mb-1\">\r\n                      <span>가장 활발한 시간</span>\r\n                      <span className=\"font-medium text-blue-600\">오후 7-9시</span>\r\n                    </div>\r\n                  </div>\r\n                  <div>\r\n                    <div className=\"flex justify-between text-sm text-gray-600 dark:text-gray-300 mb-1\">\r\n                      <span>평균 세션 시간</span>\r\n                      <span className=\"font-medium text-green-600\">25분</span>\r\n                    </div>\r\n                  </div>\r\n                  <div>\r\n                    <div className=\"flex justify-between text-sm text-gray-600 dark:text-gray-300 mb-1\">\r\n                      <span>주간 학습 일수</span>\r\n                      <span className=\"font-medium text-purple-600\">5.2일</span>\r\n                    </div>\r\n                  </div>\r\n                  <div>\r\n                    <div className=\"flex justify-between text-sm text-gray-600 dark:text-gray-300 mb-1\">\r\n                      <span>연속 학습 기록</span>\r\n                      <span className=\"font-medium text-orange-600\">12일</span>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n\r\n            {/* 월별 진도 그래프 */}\r\n            <div className=\"bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg transition-colors duration-300 p-6\">\r\n              <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white mb-4\">📈 월별 진도 변화</h3>\r\n              <div className=\"h-64 flex items-end justify-between gap-2\">\r\n                {['1월', '2월', '3월', '4월', '5월', '6월'].map((month, index) => {\r\n                  const height = Math.random() * 200 + 20;\r\n                  const completedStages = Math.floor(Math.random() * 15) + 5;\r\n                  return (\r\n                    <div key={month} className=\"flex-1 flex flex-col items-center\">\r\n                      <div className=\"w-full bg-gray-200 rounded-t\" style={{ height: '200px' }}>\r\n                        <div \r\n                          className=\"w-full bg-blue-500 rounded-t transition-all duration-500\"\r\n                          style={{ height: `${(height / 200) * 100}%`, marginTop: 'auto' }}\r\n                        ></div>\r\n                      </div>\r\n                      <div className=\"text-xs text-gray-600 dark:text-gray-300 mt-2\">{month}</div>\r\n                      <div className=\"text-xs font-medium text-blue-600\">{completedStages}개</div>\r\n                    </div>\r\n                  );\r\n                })}\r\n              </div>\r\n            </div>\r\n          </div>\r\n        );\r\n      \r\n      case 'analytics':\r\n        return (\r\n          <div className=\"max-w-6xl mx-auto p-6\">\r\n            <h2 className=\"text-2xl font-bold text-gray-900 dark:text-white mb-6\">🔍 고급 분석</h2>\r\n            \r\n            {/* 실력 변화 추이 */}\r\n            <div className=\"bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg transition-colors duration-300 p-6 mb-8\">\r\n              <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white mb-4\">📊 실력 변화 추이</h3>\r\n              <div className=\"grid grid-cols-1 md:grid-cols-2 gap-6\">\r\n                <div>\r\n                  <h4 className=\"font-medium text-gray-700 dark:text-gray-300 mb-3\">정확도 변화</h4>\r\n                  <div className=\"space-y-3\">\r\n                    <div className=\"flex items-center justify-between\">\r\n                      <span className=\"text-sm text-gray-600 dark:text-gray-300\">이번 주</span>\r\n                      <div className=\"flex items-center gap-2\">\r\n                        <span className=\"text-sm font-medium\">85%</span>\r\n                        <span className=\"text-xs text-green-600\">↗ +3%</span>\r\n                      </div>\r\n                    </div>\r\n                    <div className=\"flex items-center justify-between\">\r\n                      <span className=\"text-sm text-gray-600 dark:text-gray-300\">지난 주</span>\r\n                      <div className=\"flex items-center gap-2\">\r\n                        <span className=\"text-sm font-medium\">82%</span>\r\n                        <span className=\"text-xs text-green-600\">↗ +1%</span>\r\n                      </div>\r\n                    </div>\r\n                    <div className=\"flex items-center justify-between\">\r\n                      <span className=\"text-sm text-gray-600 dark:text-gray-300\">이번 달 평균</span>\r\n                      <div className=\"flex items-center gap-2\">\r\n                        <span className=\"text-sm font-medium\">83%</span>\r\n                        <span className=\"text-xs text-green-600\">↗ +5%</span>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n                \r\n                <div>\r\n                  <h4 className=\"font-medium text-gray-700 dark:text-gray-300 mb-3\">응답 속도 변화</h4>\r\n                  <div className=\"space-y-3\">\r\n                    <div className=\"flex items-center justify-between\">\r\n                      <span className=\"text-sm text-gray-600 dark:text-gray-300\">이번 주</span>\r\n                      <div className=\"flex items-center gap-2\">\r\n                        <span className=\"text-sm font-medium\">4.2초</span>\r\n                        <span className=\"text-xs text-blue-600\">↘ -0.3초</span>\r\n                      </div>\r\n                    </div>\r\n                    <div className=\"flex items-center justify-between\">\r\n                      <span className=\"text-sm text-gray-600 dark:text-gray-300\">지난 주</span>\r\n                      <div className=\"flex items-center gap-2\">\r\n                        <span className=\"text-sm font-medium\">4.5초</span>\r\n                        <span className=\"text-xs text-blue-600\">↘ -0.2초</span>\r\n                      </div>\r\n                    </div>\r\n                    <div className=\"flex items-center justify-between\">\r\n                      <span className=\"text-sm text-gray-600 dark:text-gray-300\">이번 달 평균</span>\r\n                      <div className=\"flex items-center gap-2\">\r\n                        <span className=\"text-sm font-medium\">4.7초</span>\r\n                        <span className=\"text-xs text-blue-600\">↘ -0.8초</span>\r\n                      </div>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n\r\n            {/* 학습 권장사항 */}\r\n            <div className=\"bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-200 rounded-lg p-6\">\r\n              <h3 className=\"text-lg font-semibold text-gray-900 dark:text-white mb-4\">💡 개인 맞춤 학습 권장사항</h3>\r\n              <div className=\"space-y-4\">\r\n                <div className=\"flex items-start gap-3\">\r\n                  <span className=\"text-green-500 text-xl\">🎯</span>\r\n                  <div>\r\n                    <h4 className=\"font-medium text-gray-900 dark:text-white\">집중 학습 영역</h4>\r\n                    <p className=\"text-sm text-gray-600 dark:text-gray-300\">\r\n                      Level 3의 관계대명사와 Level 4의 비즈니스 표현에서 정확도가 낮습니다. \r\n                      이 영역을 집중적으로 복습하는 것을 권장합니다.\r\n                    </p>\r\n                  </div>\r\n                </div>\r\n                \r\n                <div className=\"flex items-start gap-3\">\r\n                  <span className=\"text-blue-500 text-xl\">⏰</span>\r\n                  <div>\r\n                    <h4 className=\"font-medium text-gray-900 dark:text-white\">최적 학습 시간</h4>\r\n                    <p className=\"text-sm text-gray-600 dark:text-gray-300\">\r\n                      오후 7-9시에 가장 좋은 성과를 보이고 있습니다. \r\n                      이 시간대에 어려운 내용을 학습하시면 더 효과적입니다.\r\n                    </p>\r\n                  </div>\r\n                </div>\r\n                \r\n                <div className=\"flex items-start gap-3\">\r\n                  <span className=\"text-purple-500 text-xl\">📚</span>\r\n                  <div>\r\n                    <h4 className=\"font-medium text-gray-900 dark:text-white\">학습량 조절</h4>\r\n                    <p className=\"text-sm text-gray-600 dark:text-gray-300\">\r\n                      현재 일일 25분씩 학습하고 있습니다. \r\n                      조금 더 늘려서 30-35분으로 하면 더 빠른 진전을 볼 수 있습니다.\r\n                    </p>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        );\r\n      \r\n      default:\r\n        return null;\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900 transition-colors duration-300\">\r\n      {/* 헤더 */}\r\n      <div className=\"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 transition-colors duration-300\">\r\n        <div className=\"max-w-6xl mx-auto px-6 py-4\">\r\n          <div className=\"flex items-center gap-4 mb-4\">\r\n            <button\r\n              onClick={() => navigate('/')}\r\n              className=\"flex items-center gap-2 px-3 py-2 text-gray-600 dark:text-gray-300 dark:text-gray-300 hover:text-indigo-600 dark:hover:text-indigo-400 hover:bg-gray-50 dark:hover:bg-gray-700 rounded-lg transition-colors\"\r\n            >\r\n              <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M10 19l-7-7m0 0l7-7m-7 7h18\" />\r\n              </svg>\r\n              뒤로가기\r\n            </button>\r\n            <h1 className=\"text-2xl font-bold text-gray-900 dark:text-white dark:text-white\">📊 진도 관리</h1>\r\n          </div>\r\n          \r\n          {/* 탭 네비게이션 */}\r\n          <div className=\"flex gap-1\">\r\n            {[\r\n              { key: 'overview', label: '전체 현황', icon: '📋' },\r\n              { key: 'detailed', label: '상세 분석', icon: '📊' },\r\n              { key: 'analytics', label: '고급 분석', icon: '🔍' }\r\n            ].map(tab => (\r\n              <button\r\n                key={tab.key}\r\n                onClick={() => setActiveTab(tab.key as any)}\r\n                className={`px-4 py-2 rounded-lg text-sm font-medium transition-colors ${\r\n                  activeTab === tab.key\r\n                    ? 'bg-blue-600 text-white'\r\n                    : 'text-gray-600 dark:text-gray-300 hover:text-gray-900 dark:text-white hover:bg-gray-100'\r\n                }`}\r\n              >\r\n                {tab.icon} {tab.label}\r\n              </button>\r\n            ))}\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* 콘텐츠 */}\r\n      {renderTabContent()}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ProgressManagementPage;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\ResultPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'user' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":23,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":23,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\r\nimport { useNavigate, useLocation } from 'react-router-dom';\r\nimport { useAppStore, useUser } from '@/store/useAppStore';\r\n\r\ninterface SessionSummary {\r\n  totalCards: number;\r\n  correctAnswers: number;\r\n  accuracy: number;\r\n  averageScore: number;\r\n  totalTime: number;\r\n  averageTimePerCard: number;\r\n}\r\n\r\ninterface LocationState {\r\n  summary: SessionSummary;\r\n  level: number;\r\n  stage: number;\r\n}\r\n\r\nexport const ResultPage: React.FC = () => {\r\n  const navigate = useNavigate();\r\n  const location = useLocation();\r\n  const user = useUser();\r\n  const { setUser } = useAppStore();\r\n  \r\n  const state = location.state as LocationState;\r\n  \r\n  if (!state || !state.summary) {\r\n    return (\r\n      <div className=\"min-h-screen flex items-center justify-center\">\r\n        <div className=\"text-center\">\r\n          <p className=\"text-gray-600 mb-4\">결과를 찾을 수 없습니다</p>\r\n          <button\r\n            onClick={() => navigate('/')}\r\n            className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\r\n          >\r\n            홈으로 돌아가기\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const { summary, level, stage } = state;\r\n  \r\n  // Determine if user passed the stage (80% accuracy threshold)\r\n  const passed = summary.accuracy >= 80;\r\n  \r\n  // Calculate next level/stage\r\n  const getNextStage = () => {\r\n    if (passed) {\r\n      if (stage < 10) {\r\n        return { level, stage: stage + 1 };\r\n      } else if (level < 10) {\r\n        return { level: level + 1, stage: 1 };\r\n      } else {\r\n        return { level: 10, stage: 10 }; // Max level reached\r\n      }\r\n    }\r\n    return { level, stage }; // Stay at current stage if failed\r\n  };\r\n\r\n  const handleContinue = () => {\r\n    if (passed) {\r\n      const nextStage = getNextStage();\r\n      setUser({\r\n        level: nextStage.level,\r\n        stage: nextStage.stage,\r\n      });\r\n    }\r\n    navigate('/');\r\n  };\r\n\r\n  const handleRetry = () => {\r\n    navigate('/study');\r\n  };\r\n\r\n  const formatTime = (seconds: number) => {\r\n    const mins = Math.floor(seconds / 60);\r\n    const secs = seconds % 60;\r\n    if (mins > 0) {\r\n      return `${mins}분 ${secs}초`;\r\n    }\r\n    return `${secs}초`;\r\n  };\r\n\r\n  const getPerformanceLevel = (accuracy: number) => {\r\n    if (accuracy >= 95) return { level: '완벽!', color: 'text-green-600', emoji: '🌟' };\r\n    if (accuracy >= 80) return { level: '우수', color: 'text-blue-600', emoji: '🎉' };\r\n    if (accuracy >= 60) return { level: '보통', color: 'text-yellow-600', emoji: '👍' };\r\n    return { level: '재도전', color: 'text-red-600', emoji: '💪' };\r\n  };\r\n\r\n  const performance = getPerformanceLevel(summary.accuracy);\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4\">\r\n      <div className=\"max-w-lg w-full bg-white rounded-lg shadow-lg p-8\">\r\n        {/* Header */}\r\n        <div className=\"text-center mb-8\">\r\n          <div className=\"text-6xl mb-4\">{performance.emoji}</div>\r\n          <h1 className=\"text-3xl font-bold text-gray-800 mb-2\">\r\n            세션 완료\r\n          </h1>\r\n          <p className=\"text-gray-600\">\r\n            Level {level}.{stage} 결과\r\n          </p>\r\n        </div>\r\n\r\n        {/* Overall Performance */}\r\n        <div className={`text-center mb-8 p-6 rounded-lg ${\r\n          passed ? 'bg-green-50 border border-green-200' : 'bg-red-50 border border-red-200'\r\n        }`}>\r\n          <h2 className={`text-2xl font-bold mb-2 ${\r\n            passed ? 'text-green-800' : 'text-red-800'\r\n          }`}>\r\n            {passed ? '🎉 통과!' : '💪 재도전!'}\r\n          </h2>\r\n          <p className={`text-lg ${performance.color}`}>\r\n            {performance.level}\r\n          </p>\r\n        </div>\r\n\r\n        {/* Detailed Stats */}\r\n        <div className=\"space-y-4 mb-8\">\r\n          <div className=\"flex items-center justify-between p-4 bg-gray-50 rounded-lg\">\r\n            <div className=\"flex items-center space-x-3\">\r\n              <span className=\"text-2xl\">🎯</span>\r\n              <span className=\"font-medium\">정확도</span>\r\n            </div>\r\n            <span className={`text-xl font-bold ${performance.color}`}>\r\n              {summary.accuracy}%\r\n            </span>\r\n          </div>\r\n\r\n          <div className=\"flex items-center justify-between p-4 bg-gray-50 rounded-lg\">\r\n            <div className=\"flex items-center space-x-3\">\r\n              <span className=\"text-2xl\">📊</span>\r\n              <span className=\"font-medium\">평균 점수</span>\r\n            </div>\r\n            <span className=\"text-xl font-bold text-blue-600\">\r\n              {summary.averageScore}/100\r\n            </span>\r\n          </div>\r\n\r\n          <div className=\"flex items-center justify-between p-4 bg-gray-50 rounded-lg\">\r\n            <div className=\"flex items-center space-x-3\">\r\n              <span className=\"text-2xl\">✅</span>\r\n              <span className=\"font-medium\">정답/전체</span>\r\n            </div>\r\n            <span className=\"text-xl font-bold text-green-600\">\r\n              {summary.correctAnswers}/{summary.totalCards}\r\n            </span>\r\n          </div>\r\n\r\n          <div className=\"flex items-center justify-between p-4 bg-gray-50 rounded-lg\">\r\n            <div className=\"flex items-center space-x-3\">\r\n              <span className=\"text-2xl\">⏱️</span>\r\n              <span className=\"font-medium\">총 시간</span>\r\n            </div>\r\n            <span className=\"text-xl font-bold text-purple-600\">\r\n              {formatTime(summary.totalTime)}\r\n            </span>\r\n          </div>\r\n\r\n          <div className=\"flex items-center justify-between p-4 bg-gray-50 rounded-lg\">\r\n            <div className=\"flex items-center space-x-3\">\r\n              <span className=\"text-2xl\">🚀</span>\r\n              <span className=\"font-medium\">문제당 평균시간</span>\r\n            </div>\r\n            <span className=\"text-xl font-bold text-indigo-600\">\r\n              {summary.averageTimePerCard}초\r\n            </span>\r\n          </div>\r\n        </div>\r\n\r\n        {/* Progress Message */}\r\n        {passed && (\r\n          <div className=\"bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6\">\r\n            <div className=\"text-center text-blue-800\">\r\n              {level === 10 && stage === 10 ? (\r\n                <p className=\"font-medium\">🏆 모든 레벨을 완료했습니다!</p>\r\n              ) : stage === 10 ? (\r\n                <p className=\"font-medium\">\r\n                  🎉 Level {level} 완료! Level {level + 1}으로 진급합니다\r\n                </p>\r\n              ) : (\r\n                <p className=\"font-medium\">\r\n                  🎯 Stage {stage + 1}로 진행합니다\r\n                </p>\r\n              )}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {!passed && (\r\n          <div className=\"bg-orange-50 border border-orange-200 rounded-lg p-4 mb-6\">\r\n            <div className=\"text-center text-orange-800\">\r\n              <p className=\"font-medium\">\r\n                💪 80% 이상의 정확도가 필요합니다\r\n              </p>\r\n              <p className=\"text-sm mt-1\">\r\n                다시 도전해서 실력을 향상시켜보세요!\r\n              </p>\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* Action Buttons */}\r\n        <div className=\"space-y-3\">\r\n          {passed ? (\r\n            <button\r\n              onClick={handleContinue}\r\n              className=\"w-full bg-green-500 hover:bg-green-600 text-white font-bold py-4 px-6 rounded-lg transition-colors duration-200 text-lg\"\r\n            >\r\n              {level === 10 && stage === 10 ? '🏆 완료' : '🚀 다음 단계로'}\r\n            </button>\r\n          ) : (\r\n            <button\r\n              onClick={handleRetry}\r\n              className=\"w-full bg-blue-500 hover:bg-blue-600 text-white font-bold py-4 px-6 rounded-lg transition-colors duration-200 text-lg\"\r\n            >\r\n              💪 다시 도전하기\r\n            </button>\r\n          )}\r\n          \r\n          <button\r\n            onClick={() => navigate('/')}\r\n            className=\"w-full bg-gray-500 hover:bg-gray-600 text-white font-medium py-3 px-6 rounded-lg transition-colors duration-200\"\r\n          >\r\n            🏠 홈으로 돌아가기\r\n          </button>\r\n        </div>\r\n\r\n        {/* Tips */}\r\n        <div className=\"mt-8 pt-6 border-t border-gray-200\">\r\n          <h3 className=\"text-sm font-medium text-gray-700 mb-3\">💡 학습 팁</h3>\r\n          <ul className=\"text-xs text-gray-600 space-y-2\">\r\n            <li>• 정확한 발음보다는 자연스러운 억양에 집중하세요</li>\r\n            <li>• 틀린 문제는 정답을 듣고 따라 말해보세요</li>\r\n            <li>• 매일 조금씩이라도 꾸준히 연습하는 것이 중요합니다</li>\r\n          </ul>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\ReviewPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DrillCard' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":24},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'resetStudyState'. Either include it or remove the dependency array.","line":44,"column":6,"nodeType":"ArrayExpression","endLine":44,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [resetStudyState]","fix":{"range":[1380,1382],"text":"[resetStudyState]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":77,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":112,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'confidence' is defined but never used. Allowed unused args must match /^_/u.","line":119,"column":57,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":67},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'responseTime' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":122,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":122,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":150,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":150,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { useAppStore, useUser, useStudy, useUI } from '@/store/useAppStore';\r\nimport { SpeechRecorder } from '@/components/SpeechRecorder';\r\nimport { FeedbackPanel } from '@/components/FeedbackPanel';\r\nimport { useSpeech } from '@/hooks/useSpeech';\r\nimport { api } from '@/lib/api';\r\nimport type { DrillCard } from '@/types';\r\n\r\nexport const ReviewPage: React.FC = () => {\r\n  const navigate = useNavigate();\r\n  const user = useUser();\r\n  const study = useStudy();\r\n  const ui = useUI();\r\n  \r\n  const {\r\n    setCurrentCard,\r\n    setCards,\r\n    setFeedback,\r\n    setCurrentSession,\r\n    resetStudyState,\r\n    setLoading,\r\n    setError,\r\n    clearError,\r\n  } = useAppStore();\r\n\r\n  const [reviewType, setReviewType] = useState<'random' | 'retry' | null>(null);\r\n  const [reviewCount, setReviewCount] = useState(15);\r\n  const [selectedLevels, setSelectedLevels] = useState<number[]>([2, 3, 4]);\r\n  const [cardStartTime, setCardStartTime] = useState<number>(0);\r\n  const [incorrectCards, setIncorrectCards] = useState<string[]>([]);\r\n\r\n  const speech = useSpeech({\r\n    apiBaseUrl: import.meta.env.VITE_API_BASE_URL,\r\n    preferCloudSTT: false,\r\n    language: 'en-US',\r\n  });\r\n\r\n  // Cleanup on unmount\r\n  useEffect(() => {\r\n    return () => {\r\n      resetStudyState();\r\n    };\r\n  }, []);\r\n\r\n  const startRandomReview = async () => {\r\n    setLoading(true);\r\n    clearError();\r\n    \r\n    try {\r\n      const response = await api.getRandomReview({\r\n        userId: user.id,\r\n        count: reviewCount,\r\n        levels: selectedLevels,\r\n      });\r\n      \r\n      if (response.success && response.data) {\r\n        setCards(response.data.cards);\r\n        if (response.data.cards.length > 0) {\r\n          setCurrentCard(response.data.cards[0], 0);\r\n          setCardStartTime(Date.now());\r\n          setReviewType('random');\r\n          \r\n          // Create session for review\r\n          setCurrentSession({\r\n            id: `review_${Date.now()}`,\r\n            userId: user.id,\r\n            level: 0, // Mixed levels\r\n            stage: 0, // Review mode\r\n            startedAt: new Date(),\r\n            items: [],\r\n          });\r\n        }\r\n      } else {\r\n        setError(response.error || '복습 카드를 불러오는데 실패했습니다');\r\n      }\r\n    } catch (error) {\r\n      setError('네트워크 오류가 발생했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const startRetryReview = async () => {\r\n    setLoading(true);\r\n    clearError();\r\n    \r\n    try {\r\n      const response = await api.getRetryReview({\r\n        userId: user.id,\r\n      });\r\n      \r\n      if (response.success && response.data) {\r\n        setCards(response.data.cards);\r\n        if (response.data.cards.length > 0) {\r\n          setCurrentCard(response.data.cards[0], 0);\r\n          setCardStartTime(Date.now());\r\n          setReviewType('retry');\r\n          \r\n          setCurrentSession({\r\n            id: `retry_${Date.now()}`,\r\n            userId: user.id,\r\n            level: 0,\r\n            stage: 0,\r\n            startedAt: new Date(),\r\n            items: [],\r\n          });\r\n        }\r\n      } else {\r\n        setError(response.error || '오답 복습 카드를 불러오는데 실패했습니다');\r\n      }\r\n    } catch (error) {\r\n      setError('네트워크 오류가 발생했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleSpeechResult = async (transcript: string, confidence: number) => {\r\n    if (!study.currentCard || !study.currentSession) return;\r\n\r\n    const responseTime = Date.now() - cardStartTime;\r\n    setLoading(true);\r\n\r\n    try {\r\n      const feedbackResponse = await api.getFeedback({\r\n        front_ko: study.currentCard.front_ko,\r\n        sttText: transcript,\r\n        target_en: study.currentCard.target_en,\r\n      });\r\n\r\n      if (feedbackResponse.success && feedbackResponse.data) {\r\n        const feedback = feedbackResponse.data;\r\n        setFeedback(feedback);\r\n\r\n        // Track incorrect answers for retry mode\r\n        if (!feedback.correct) {\r\n          setIncorrectCards(prev => [...prev, study.currentCard!.id]);\r\n        }\r\n\r\n        // Play correct answer if TTS is available and answer was incorrect\r\n        if (speech.isTTSAvailable && !feedback.correct) {\r\n          setTimeout(() => {\r\n            speech.speak(study.currentCard!.target_en);\r\n          }, 1500);\r\n        }\r\n      } else {\r\n        setError(feedbackResponse.error || '피드백을 받는데 실패했습니다');\r\n      }\r\n    } catch (error) {\r\n      setError('피드백 처리 중 오류가 발생했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleNextCard = () => {\r\n    const nextIndex = study.currentIndex + 1;\r\n    \r\n    if (nextIndex < study.cards.length) {\r\n      setCurrentCard(study.cards[nextIndex], nextIndex);\r\n      setCardStartTime(Date.now());\r\n      setFeedback(null);\r\n    } else {\r\n      finishReview();\r\n    }\r\n  };\r\n\r\n  const handlePreviousCard = () => {\r\n    const prevIndex = study.currentIndex - 1;\r\n    \r\n    if (prevIndex >= 0) {\r\n      setCurrentCard(study.cards[prevIndex], prevIndex);\r\n      setCardStartTime(Date.now());\r\n      setFeedback(null);\r\n    }\r\n  };\r\n\r\n  const finishReview = () => {\r\n    const correctCount = study.cards.length - incorrectCards.length;\r\n    const accuracy = Math.round((correctCount / study.cards.length) * 100);\r\n    \r\n    navigate('/result', { \r\n      state: { \r\n        summary: {\r\n          totalCards: study.cards.length,\r\n          correctAnswers: correctCount,\r\n          accuracy: accuracy,\r\n          reviewType: reviewType\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  const toggleLevel = (level: number) => {\r\n    setSelectedLevels(prev => \r\n      prev.includes(level) \r\n        ? prev.filter(l => l !== level)\r\n        : [...prev, level]\r\n    );\r\n  };\r\n\r\n  // Render setup screen\r\n  if (!reviewType || !study.currentCard) {\r\n    return (\r\n      <div className=\"min-h-screen bg-gray-50 p-4\">\r\n        <div className=\"max-w-lg mx-auto\">\r\n          {/* Header */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-6 mb-6\">\r\n            <button\r\n              onClick={() => navigate('/')}\r\n              className=\"text-gray-600 hover:text-gray-800 mb-4\"\r\n            >\r\n              ← 홈으로 돌아가기\r\n            </button>\r\n            <h1 className=\"text-2xl font-bold text-gray-800 mb-2\">복습 모드</h1>\r\n            <p className=\"text-gray-600\">완성된 레벨에서 랜덤 복습하기</p>\r\n          </div>\r\n\r\n          {/* Random Review Setup */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-6 mb-4\">\r\n            <h2 className=\"text-lg font-semibold text-gray-800 mb-4\">🔄 랜덤 복습</h2>\r\n            \r\n            <div className=\"mb-4\">\r\n              <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n                복습할 문장 수: {reviewCount}개\r\n              </label>\r\n              <input\r\n                type=\"range\"\r\n                min=\"5\"\r\n                max=\"30\"\r\n                value={reviewCount}\r\n                onChange={(e) => setReviewCount(parseInt(e.target.value))}\r\n                className=\"w-full\"\r\n              />\r\n              <div className=\"flex justify-between text-xs text-gray-500 mt-1\">\r\n                <span>5개</span>\r\n                <span>30개</span>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"mb-4\">\r\n              <label className=\"block text-sm font-medium text-gray-700 mb-2\">\r\n                복습할 레벨 선택\r\n              </label>\r\n              <div className=\"grid grid-cols-2 gap-2\">\r\n                {[2, 3, 4, 5].map((level) => (\r\n                  <button\r\n                    key={level}\r\n                    onClick={() => toggleLevel(level)}\r\n                    className={`p-3 rounded-lg border text-sm font-medium transition-colors ${\r\n                      selectedLevels.includes(level)\r\n                        ? 'bg-blue-500 text-white border-blue-500'\r\n                        : 'bg-gray-50 text-gray-700 border-gray-200 hover:bg-gray-100'\r\n                    }`}\r\n                  >\r\n                    Level {level}\r\n                  </button>\r\n                ))}\r\n              </div>\r\n            </div>\r\n\r\n            <button\r\n              onClick={startRandomReview}\r\n              disabled={selectedLevels.length === 0 || ui.isLoading}\r\n              className=\"w-full bg-orange-500 hover:bg-orange-600 disabled:bg-gray-300 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-200\"\r\n            >\r\n              {ui.isLoading ? '로딩 중...' : '랜덤 복습 시작'}\r\n            </button>\r\n          </div>\r\n\r\n          {/* Retry Review */}\r\n          <div className=\"bg-white rounded-lg shadow-lg p-6\">\r\n            <h2 className=\"text-lg font-semibold text-gray-800 mb-4\">🔁 오답 복습</h2>\r\n            <p className=\"text-gray-600 mb-4 text-sm\">\r\n              최근 틀린 문제들을 다시 연습해보세요.\r\n            </p>\r\n            <button\r\n              onClick={startRetryReview}\r\n              disabled={ui.isLoading}\r\n              className=\"w-full bg-red-500 hover:bg-red-600 disabled:bg-gray-300 text-white font-bold py-3 px-6 rounded-lg transition-colors duration-200\"\r\n            >\r\n              {ui.isLoading ? '로딩 중...' : '오답 복습 시작'}\r\n            </button>\r\n          </div>\r\n\r\n          {ui.error && (\r\n            <div className=\"bg-red-50 border border-red-200 rounded-lg p-4 mt-4\">\r\n              <p className=\"text-red-600\">{ui.error}</p>\r\n              <button\r\n                onClick={clearError}\r\n                className=\"mt-2 text-red-500 hover:text-red-700 font-medium\"\r\n              >\r\n                다시 시도\r\n              </button>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Render study interface (same as StudyPage)\r\n  return (\r\n    <div className=\"min-h-screen bg-gray-50\">\r\n      {/* Header */}\r\n      <div className=\"bg-white shadow-sm border-b\">\r\n        <div className=\"max-w-2xl mx-auto px-4 py-3\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <button\r\n              onClick={() => navigate('/')}\r\n              className=\"text-gray-600 hover:text-gray-800\"\r\n            >\r\n              ← 뒤로\r\n            </button>\r\n            <div className=\"text-center\">\r\n              <h1 className=\"text-lg font-semibold\">\r\n                {reviewType === 'random' ? '🔄 랜덤 복습' : '🔁 오답 복습'}\r\n              </h1>\r\n            </div>\r\n            <div className=\"text-sm text-gray-500\">\r\n              {study.currentIndex + 1}/{study.cards.length}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Progress Bar */}\r\n      <div className=\"bg-white border-b\">\r\n        <div className=\"max-w-2xl mx-auto px-4 py-2\">\r\n          <div className=\"bg-gray-200 rounded-full h-2\">\r\n            <div \r\n              className=\"bg-orange-500 h-2 rounded-full transition-all duration-300\"\r\n              style={{ \r\n                width: `${((study.currentIndex + 1) / study.cards.length) * 100}%`\r\n              }}\r\n            />\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Main Content */}\r\n      <div className=\"max-w-2xl mx-auto px-4 py-8\">\r\n        {/* Korean Prompt Card */}\r\n        <div className=\"bg-white rounded-lg shadow-lg p-8 mb-8\">\r\n          <div className=\"text-center\">\r\n            <h2 className=\"text-sm font-medium text-gray-500 mb-2\">한국어를 영어로</h2>\r\n            <p className=\"text-2xl font-bold text-gray-800 mb-6\">\r\n              {study.currentCard.front_ko}\r\n            </p>\r\n            \r\n            {/* Card Source Info */}\r\n            {(study.currentCard as any).level && (\r\n              <div className=\"text-xs text-gray-500 mb-4\">\r\n                Level {(study.currentCard as any).level} - {(study.currentCard as any).stageTitle}\r\n              </div>\r\n            )}\r\n            \r\n            {/* Expected Answer (shown after feedback) */}\r\n            {study.feedback && (\r\n              <div className=\"text-sm text-gray-600 bg-gray-50 rounded p-3\">\r\n                <span className=\"font-medium\">정답: </span>\r\n                {study.currentCard.target_en}\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n\r\n        {/* Speech Recorder */}\r\n        <div className=\"bg-white rounded-lg shadow-lg p-8 mb-8\">\r\n          <div className=\"text-center\">\r\n            <SpeechRecorder\r\n              onResult={handleSpeechResult}\r\n              onError={(error) => setError(error)}\r\n              phraseHints={[study.currentCard.target_en]}\r\n              disabled={ui.isLoading || !!study.feedback}\r\n            />\r\n          </div>\r\n        </div>\r\n\r\n        {/* Feedback Panel */}\r\n        {study.feedback && (\r\n          <FeedbackPanel\r\n            feedback={study.feedback}\r\n            onPlayAnswer={() => speech.speak(study.currentCard!.target_en)}\r\n            canPlayAnswer={speech.isTTSAvailable}\r\n          />\r\n        )}\r\n\r\n        {/* Navigation Controls */}\r\n        <div className=\"flex justify-between items-center\">\r\n          <button\r\n            onClick={handlePreviousCard}\r\n            disabled={study.currentIndex === 0}\r\n            className=\"px-6 py-3 bg-gray-500 text-white rounded-lg disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-gray-600 transition-colors\"\r\n          >\r\n            ← 이전 카드\r\n          </button>\r\n\r\n          <div className=\"flex space-x-2\">\r\n            {study.feedback && (\r\n              <button\r\n                onClick={() => speech.speak(study.currentCard!.target_en)}\r\n                disabled={!speech.isTTSAvailable}\r\n                className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 text-sm\"\r\n              >\r\n                🔊 정답 듣기\r\n              </button>\r\n            )}\r\n          </div>\r\n\r\n          {study.currentIndex < study.cards.length - 1 ? (\r\n            <button\r\n              onClick={handleNextCard}\r\n              disabled={!study.feedback}\r\n              className=\"px-6 py-3 bg-green-500 text-white rounded-lg disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-green-600 transition-colors\"\r\n            >\r\n              다음 카드 →\r\n            </button>\r\n          ) : (\r\n            <button\r\n              onClick={finishReview}\r\n              disabled={!study.feedback}\r\n              className=\"px-6 py-3 bg-purple-500 text-white rounded-lg disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-purple-600 transition-colors\"\r\n            >\r\n              복습 완료\r\n            </button>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\ScenarioDialoguePage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentTurn' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":19,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":19,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { \r\n  scenarioDialogueService, \r\n  ScenarioCategory, \r\n  DialogueScenario, \r\n  DialogueSession, \r\n  DialogueTurn \r\n} from '../services/scenarioDialogue';\r\n\r\nconst ScenarioDialoguePage: React.FC = () => {\r\n  const navigate = useNavigate();\r\n  const chatEndRef = useRef<HTMLDivElement>(null);\r\n  \r\n  const [categories, setCategories] = useState<ScenarioCategory[]>([]);\r\n  const [selectedCategory, setSelectedCategory] = useState<ScenarioCategory | null>(null);\r\n  const [selectedScenario, setSelectedScenario] = useState<DialogueScenario | null>(null);\r\n  const [currentSession, setCurrentSession] = useState<DialogueSession | null>(null);\r\n  const [currentTurn, setCurrentTurn] = useState<DialogueTurn | null>(null);\r\n  const [userInput, setUserInput] = useState('');\r\n  const [chatHistory, setChatHistory] = useState<Array<{\r\n    speaker: 'user' | 'ai';\r\n    message: string;\r\n    feedback?: string;\r\n    score?: number;\r\n    timestamp: Date;\r\n  }>>([]);\r\n  const [isLoading, setIsLoading] = useState(false);\r\n  const [isCompleted, setIsCompleted] = useState(false);\r\n  const [sessionSummary, setSessionSummary] = useState<any>(null);\r\n\r\n  useEffect(() => {\r\n    loadCategories();\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    scrollToBottom();\r\n  }, [chatHistory]);\r\n\r\n  const scrollToBottom = () => {\r\n    chatEndRef.current?.scrollIntoView({ behavior: 'smooth' });\r\n  };\r\n\r\n  const loadCategories = async () => {\r\n    setIsLoading(true);\r\n    try {\r\n      const categoriesData = await scenarioDialogueService.getScenarioCategories();\r\n      setCategories(categoriesData);\r\n    } catch (error) {\r\n      console.error('Failed to load categories:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleCategorySelect = (category: ScenarioCategory) => {\r\n    setSelectedCategory(category);\r\n    setSelectedScenario(null);\r\n  };\r\n\r\n  const handleScenarioSelect = async (scenario: DialogueScenario) => {\r\n    setSelectedScenario(scenario);\r\n    try {\r\n      const session = await scenarioDialogueService.startDialogueSession('current-user', scenario.id);\r\n      setCurrentSession(session);\r\n      \r\n      // 첫 번째 AI 턴이 있으면 표시\r\n      if (scenario.turns && scenario.turns.length > 0) {\r\n        const firstTurn = scenario.turns[0];\r\n        if (firstTurn.speaker === 'ai') {\r\n          setChatHistory([{\r\n            speaker: 'ai',\r\n            message: firstTurn.text_en,\r\n            timestamp: new Date()\r\n          }]);\r\n          setCurrentTurn(firstTurn);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to start dialogue session:', error);\r\n    }\r\n  };\r\n\r\n  const handleUserSubmit = async (e: React.FormEvent) => {\r\n    e.preventDefault();\r\n    if (!userInput.trim() || !currentSession || isLoading) return;\r\n\r\n    setIsLoading(true);\r\n    \r\n    // 사용자 입력을 채팅 히스토리에 추가\r\n    const userMessage = {\r\n      speaker: 'user' as const,\r\n      message: userInput,\r\n      timestamp: new Date()\r\n    };\r\n    setChatHistory(prev => [...prev, userMessage]);\r\n    setUserInput('');\r\n\r\n    try {\r\n      const response = await scenarioDialogueService.processUserTurn(currentSession.sessionId, userInput);\r\n      \r\n      // AI 응답을 채팅 히스토리에 추가\r\n      const aiMessage = {\r\n        speaker: 'ai' as const,\r\n        message: response.aiResponse,\r\n        feedback: response.feedback,\r\n        score: response.score,\r\n        timestamp: new Date()\r\n      };\r\n      setChatHistory(prev => [...prev, aiMessage]);\r\n\r\n      if (response.isCompleted) {\r\n        setIsCompleted(true);\r\n        const summary = await scenarioDialogueService.completeDialogueSession(currentSession.sessionId);\r\n        setSessionSummary(summary);\r\n      } else if (response.nextTurn) {\r\n        setCurrentTurn(response.nextTurn);\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to process user turn:', error);\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleRestart = () => {\r\n    setSelectedCategory(null);\r\n    setSelectedScenario(null);\r\n    setCurrentSession(null);\r\n    setCurrentTurn(null);\r\n    setChatHistory([]);\r\n    setIsCompleted(false);\r\n    setSessionSummary(null);\r\n    setUserInput('');\r\n  };\r\n\r\n  const getDifficultyColor = (difficulty: string) => {\r\n    switch (difficulty) {\r\n      case 'beginner': return 'bg-green-100 text-green-800';\r\n      case 'intermediate': return 'bg-yellow-100 text-yellow-800';\r\n      case 'advanced': return 'bg-red-100 text-red-800';\r\n      default: return 'bg-gray-100 text-gray-800';\r\n    }\r\n  };\r\n\r\n  const getDifficultyText = (difficulty: string) => {\r\n    switch (difficulty) {\r\n      case 'beginner': return '초급';\r\n      case 'intermediate': return '중급';\r\n      case 'advanced': return '고급';\r\n      default: return difficulty;\r\n    }\r\n  };\r\n\r\n  if (isLoading && categories.length === 0) {\r\n    return (\r\n      <div className=\"min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center\">\r\n        <div className=\"text-center\">\r\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-indigo-600 mx-auto mb-4\"></div>\r\n          <p className=\"text-gray-600\">시나리오 로딩 중...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100\">\r\n      {/* Header */}\r\n      <div className=\"bg-white shadow-sm border-b border-gray-200 p-4\">\r\n        <div className=\"max-w-4xl mx-auto flex items-center justify-between\">\r\n          <div className=\"flex items-center space-x-3\">\r\n            <button\r\n              onClick={() => navigate('/')}\r\n              className=\"text-gray-600 hover:text-gray-800 transition-colors\"\r\n            >\r\n              ←\r\n            </button>\r\n            <h1 className=\"text-2xl font-bold text-gray-800 flex items-center\">\r\n              🎭 시나리오 대화 모드\r\n            </h1>\r\n          </div>\r\n          \r\n          {currentSession && (\r\n            <div className=\"flex items-center space-x-3\">\r\n              <span className=\"text-sm text-gray-600\">\r\n                Turn {chatHistory.filter(h => h.speaker === 'user').length}\r\n              </span>\r\n              <button\r\n                onClick={handleRestart}\r\n                className=\"px-3 py-1 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors text-sm\"\r\n              >\r\n                다시 시작\r\n              </button>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"max-w-4xl mx-auto p-4\">\r\n        {!selectedCategory ? (\r\n          /* Category Selection */\r\n          <div>\r\n            <div className=\"text-center mb-8\">\r\n              <h2 className=\"text-3xl font-bold text-gray-800 mb-2\">대화 시나리오 선택</h2>\r\n              <p className=\"text-gray-600\">상황에 맞는 대화를 연습해보세요</p>\r\n            </div>\r\n\r\n            <div className=\"grid md:grid-cols-2 lg:grid-cols-3 gap-4\">\r\n              {categories.map((category) => (\r\n                <div\r\n                  key={category.id}\r\n                  onClick={() => handleCategorySelect(category)}\r\n                  className=\"bg-white rounded-2xl shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow duration-200 border border-gray-100\"\r\n                >\r\n                  <div className=\"text-center\">\r\n                    <div className=\"text-4xl mb-3\">{category.icon}</div>\r\n                    <h3 className=\"text-xl font-bold text-gray-800 mb-2\">{category.name}</h3>\r\n                    <p className=\"text-gray-600 text-sm mb-4\">{category.description}</p>\r\n                    <div className=\"text-xs text-gray-500\">\r\n                      {category.scenarios.length}개 시나리오\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              ))}\r\n            </div>\r\n          </div>\r\n        ) : !selectedScenario ? (\r\n          /* Scenario Selection */\r\n          <div>\r\n            <div className=\"flex items-center mb-6\">\r\n              <button\r\n                onClick={() => setSelectedCategory(null)}\r\n                className=\"text-gray-600 hover:text-gray-800 mr-3\"\r\n              >\r\n                ← 뒤로\r\n              </button>\r\n              <div>\r\n                <h2 className=\"text-2xl font-bold text-gray-800 flex items-center\">\r\n                  {selectedCategory.icon} {selectedCategory.name}\r\n                </h2>\r\n                <p className=\"text-gray-600\">{selectedCategory.description}</p>\r\n              </div>\r\n            </div>\r\n\r\n            <div className=\"space-y-4\">\r\n              {selectedCategory.scenarios.map((scenario) => (\r\n                <div\r\n                  key={scenario.id}\r\n                  onClick={() => handleScenarioSelect(scenario)}\r\n                  className=\"bg-white rounded-xl shadow-lg p-6 cursor-pointer hover:shadow-xl transition-shadow duration-200 border border-gray-100\"\r\n                >\r\n                  <div className=\"flex items-start justify-between mb-3\">\r\n                    <h3 className=\"text-xl font-bold text-gray-800\">{scenario.title}</h3>\r\n                    <span className={`px-3 py-1 rounded-full text-sm font-medium ${getDifficultyColor(scenario.difficulty)}`}>\r\n                      {getDifficultyText(scenario.difficulty)}\r\n                    </span>\r\n                  </div>\r\n                  \r\n                  <p className=\"text-gray-600 mb-4\">{scenario.description}</p>\r\n                  \r\n                  <div className=\"flex items-center justify-between text-sm text-gray-500\">\r\n                    <div className=\"flex items-center space-x-4\">\r\n                      <span>⏱️ {scenario.estimatedTime}분</span>\r\n                      <span>💬 {scenario.totalTurns}턴</span>\r\n                    </div>\r\n                    <span className=\"text-blue-600 font-medium\">시작하기 →</span>\r\n                  </div>\r\n                </div>\r\n              ))}\r\n            </div>\r\n          </div>\r\n        ) : (\r\n          /* Chat Interface */\r\n          <div className=\"bg-white rounded-2xl shadow-xl h-[70vh] flex flex-col\">\r\n            {/* Scenario Info Header */}\r\n            <div className=\"border-b border-gray-200 p-4\">\r\n              <div className=\"flex items-start justify-between mb-2\">\r\n                <h3 className=\"font-bold text-gray-800\">{selectedScenario.title}</h3>\r\n                <span className={`px-2 py-1 rounded-full text-xs font-medium ${getDifficultyColor(selectedScenario.difficulty)}`}>\r\n                  {getDifficultyText(selectedScenario.difficulty)}\r\n                </span>\r\n              </div>\r\n              <p className=\"text-sm text-gray-600\">{selectedScenario.context}</p>\r\n              <p className=\"text-xs text-blue-600 mt-1\">목표: {selectedScenario.objective}</p>\r\n            </div>\r\n\r\n            {/* Chat Messages */}\r\n            <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\r\n              {chatHistory.map((chat, index) => (\r\n                <div\r\n                  key={index}\r\n                  className={`flex ${chat.speaker === 'user' ? 'justify-end' : 'justify-start'}`}\r\n                >\r\n                  <div className={`max-w-[70%] rounded-2xl p-3 ${\r\n                    chat.speaker === 'user' \r\n                      ? 'bg-blue-600 text-white' \r\n                      : 'bg-gray-100 text-gray-800'\r\n                  }`}>\r\n                    <p>{chat.message}</p>\r\n                    {chat.feedback && (\r\n                      <div className=\"mt-2 p-2 bg-green-50 rounded-lg border border-green-200\">\r\n                        <p className=\"text-xs text-green-800\">💡 {chat.feedback}</p>\r\n                        {chat.score && (\r\n                          <p className=\"text-xs text-green-600 mt-1\">점수: {chat.score}/100</p>\r\n                        )}\r\n                      </div>\r\n                    )}\r\n                  </div>\r\n                </div>\r\n              ))}\r\n              \r\n              {isLoading && (\r\n                <div className=\"flex justify-start\">\r\n                  <div className=\"bg-gray-100 rounded-2xl p-3\">\r\n                    <div className=\"flex space-x-1\">\r\n                      <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\"></div>\r\n                      <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '0.1s' }}></div>\r\n                      <div className=\"w-2 h-2 bg-gray-400 rounded-full animate-bounce\" style={{ animationDelay: '0.2s' }}></div>\r\n                    </div>\r\n                  </div>\r\n                </div>\r\n              )}\r\n              <div ref={chatEndRef} />\r\n            </div>\r\n\r\n            {/* Input Area */}\r\n            {!isCompleted && (\r\n              <div className=\"border-t border-gray-200 p-4\">\r\n                <form onSubmit={handleUserSubmit} className=\"flex space-x-3\">\r\n                  <input\r\n                    type=\"text\"\r\n                    value={userInput}\r\n                    onChange={(e) => setUserInput(e.target.value)}\r\n                    placeholder=\"영어로 답변해보세요...\"\r\n                    className=\"flex-1 border border-gray-300 rounded-xl px-4 py-3 focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                    disabled={isLoading}\r\n                  />\r\n                  <button\r\n                    type=\"submit\"\r\n                    disabled={!userInput.trim() || isLoading}\r\n                    className=\"px-6 py-3 bg-blue-600 text-white rounded-xl hover:bg-blue-700 disabled:opacity-50 disabled:cursor-not-allowed transition-colors\"\r\n                  >\r\n                    전송\r\n                  </button>\r\n                </form>\r\n              </div>\r\n            )}\r\n          </div>\r\n        )}\r\n\r\n        {/* Session Summary Modal */}\r\n        {isCompleted && sessionSummary && (\r\n          <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50\">\r\n            <div className=\"bg-white rounded-2xl shadow-2xl max-w-lg w-full p-6\">\r\n              <div className=\"text-center mb-6\">\r\n                <div className=\"text-6xl mb-3\">🎉</div>\r\n                <h3 className=\"text-2xl font-bold text-gray-800\">대화 완료!</h3>\r\n                <p className=\"text-lg text-blue-600 font-semibold mt-2\">\r\n                  최종 점수: {sessionSummary.finalScore}/100\r\n                </p>\r\n              </div>\r\n\r\n              <div className=\"space-y-4 mb-6\">\r\n                <div>\r\n                  <h4 className=\"font-medium text-gray-800 mb-2\">📋 요약</h4>\r\n                  <p className=\"text-sm text-gray-600\">{sessionSummary.summary}</p>\r\n                </div>\r\n\r\n                <div>\r\n                  <h4 className=\"font-medium text-gray-800 mb-2\">🏆 성취</h4>\r\n                  <div className=\"space-y-1\">\r\n                    {sessionSummary.achievements.map((achievement: string, index: number) => (\r\n                      <div key={index} className=\"flex items-center text-sm text-green-700\">\r\n                        <span className=\"mr-2\">✓</span>\r\n                        {achievement}\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                </div>\r\n\r\n                <div>\r\n                  <h4 className=\"font-medium text-gray-800 mb-2\">💡 개선 사항</h4>\r\n                  <div className=\"space-y-1\">\r\n                    {sessionSummary.recommendations.map((recommendation: string, index: number) => (\r\n                      <div key={index} className=\"flex items-center text-sm text-blue-700\">\r\n                        <span className=\"mr-2\">→</span>\r\n                        {recommendation}\r\n                      </div>\r\n                    ))}\r\n                  </div>\r\n                </div>\r\n              </div>\r\n\r\n              <div className=\"flex space-x-3\">\r\n                <button\r\n                  onClick={handleRestart}\r\n                  className=\"flex-1 py-3 px-4 bg-blue-600 text-white rounded-xl hover:bg-blue-700 transition-colors font-medium\"\r\n                >\r\n                  다른 시나리오 시도\r\n                </button>\r\n                <button\r\n                  onClick={() => navigate('/')}\r\n                  className=\"flex-1 py-3 px-4 border border-gray-300 text-gray-700 rounded-xl hover:bg-gray-50 transition-colors font-medium\"\r\n                >\r\n                  홈으로 가기\r\n                </button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default ScenarioDialoguePage;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\SettingsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\SituationPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Situation' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentScenario' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":28,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":28,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Situation Page - 상황 학습 페이지\r\n */\r\n\r\nimport React, { useState } from 'react';\r\n\r\ninterface SituationPageProps {\r\n  // TODO: Props 타입 정의 추가\r\n}\r\n\r\ninterface Situation {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  level: string;\r\n  scenarios: Array<{\r\n    id: string;\r\n    situation: string;\r\n    dialogue: Array<{\r\n      speaker: string;\r\n      text: string;\r\n    }>;\r\n  }>;\r\n}\r\n\r\nconst SituationPage: React.FC<SituationPageProps> = () => {\r\n  const [selectedSituation, setSelectedSituation] = useState<string>('restaurant');\r\n  const [currentScenario, setCurrentScenario] = useState(0);\r\n  const [userResponse, setUserResponse] = useState<string>('');\r\n\r\n  const situations = [\r\n    { id: 'restaurant', title: '레스토랑에서', description: '음식 주문하기' },\r\n    { id: 'airport', title: '공항에서', description: '체크인 및 탑승' },\r\n    { id: 'hotel', title: '호텔에서', description: '체크인 및 문의' },\r\n    { id: 'shopping', title: '쇼핑할 때', description: '제품 문의 및 구매' },\r\n    { id: 'business', title: '비즈니스 미팅', description: '회의 및 프레젠테이션' },\r\n  ];\r\n\r\n  const mockDialogue = [\r\n    { speaker: 'Waiter', text: 'Good evening! Welcome to our restaurant. How many people are in your party?' },\r\n    { speaker: 'You', text: '[Your response here]' },\r\n    { speaker: 'Waiter', text: 'Right this way, please. Here are your menus.' },\r\n    { speaker: 'You', text: '[Your response here]' }\r\n  ];\r\n\r\n  const handleSituationChange = (situationId: string) => {\r\n    setSelectedSituation(situationId);\r\n    setCurrentScenario(0);\r\n    setUserResponse('');\r\n  };\r\n\r\n  const handleResponseSubmit = () => {\r\n    // TODO: 사용자 응답 분석 및 피드백 제공\r\n    console.log('User response:', userResponse);\r\n  };\r\n\r\n  return (\r\n    <div className=\"situation-page\">\r\n      <div className=\"container mx-auto px-4 py-6\">\r\n        <h1 className=\"text-2xl font-bold mb-6\">상황 학습</h1>\r\n        \r\n        {/* 상황 선택 섹션 */}\r\n        <div className=\"situation-selector bg-white rounded-lg shadow-md p-6 mb-6\">\r\n          <h2 className=\"text-xl font-semibold mb-4\">학습할 상황 선택</h2>\r\n          <div className=\"grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4\">\r\n            {situations.map((situation) => (\r\n              <div\r\n                key={situation.id}\r\n                onClick={() => handleSituationChange(situation.id)}\r\n                className={`situation-card p-4 rounded-lg cursor-pointer transition-colors ${\r\n                  selectedSituation === situation.id\r\n                    ? 'bg-blue-100 border-2 border-blue-500'\r\n                    : 'bg-gray-50 border-2 border-gray-200 hover:bg-gray-100'\r\n                }`}\r\n              >\r\n                <h3 className=\"font-medium text-gray-800 mb-1\">{situation.title}</h3>\r\n                <p className=\"text-sm text-gray-600\">{situation.description}</p>\r\n              </div>\r\n            ))}\r\n          </div>\r\n        </div>\r\n\r\n        {/* 대화 시나리오 섹션 */}\r\n        <div className=\"scenario-section bg-white rounded-lg shadow-md p-6 mb-6\">\r\n          <h2 className=\"text-xl font-semibold mb-4\">\r\n            대화 시나리오: {situations.find(s => s.id === selectedSituation)?.title}\r\n          </h2>\r\n          \r\n          <div className=\"dialogue-container mb-6\">\r\n            {mockDialogue.map((line, index) => (\r\n              <div key={index} className={`dialogue-line mb-3 ${line.speaker === 'You' ? 'user-line' : 'other-line'}`}>\r\n                <div className={`p-3 rounded-lg ${\r\n                  line.speaker === 'You' \r\n                    ? 'bg-blue-50 ml-8' \r\n                    : 'bg-gray-50 mr-8'\r\n                }`}>\r\n                  <div className=\"speaker-name font-medium text-sm mb-1\">\r\n                    {line.speaker}\r\n                  </div>\r\n                  {line.speaker === 'You' && line.text.includes('[Your response here]') ? (\r\n                    <textarea\r\n                      value={userResponse}\r\n                      onChange={(e) => setUserResponse(e.target.value)}\r\n                      placeholder=\"여기에 응답을 입력하세요...\"\r\n                      className=\"w-full p-2 border border-gray-300 rounded resize-none\"\r\n                      rows={2}\r\n                    />\r\n                  ) : (\r\n                    <div className=\"dialogue-text\">{line.text}</div>\r\n                  )}\r\n                </div>\r\n              </div>\r\n            ))}\r\n          </div>\r\n\r\n          {/* 응답 제출 버튼 */}\r\n          <div className=\"response-actions\">\r\n            <button \r\n              onClick={handleResponseSubmit}\r\n              disabled={!userResponse.trim()}\r\n              className=\"bg-blue-500 text-white px-6 py-2 rounded-md hover:bg-blue-600 transition-colors disabled:bg-gray-300 mr-3\"\r\n            >\r\n              응답 제출\r\n            </button>\r\n            <button className=\"bg-gray-500 text-white px-6 py-2 rounded-md hover:bg-gray-600 transition-colors\">\r\n              🔊 음성으로 응답\r\n            </button>\r\n          </div>\r\n        </div>\r\n\r\n        {/* 상황별 핵심 표현 섹션 */}\r\n        <div className=\"key-expressions bg-white rounded-lg shadow-md p-6\">\r\n          <h2 className=\"text-xl font-semibold mb-4\">핵심 표현</h2>\r\n          <div className=\"expressions-grid grid grid-cols-1 md:grid-cols-2 gap-4\">\r\n            <div className=\"expression-card bg-green-50 rounded-lg p-3\">\r\n              <div className=\"expression font-medium text-green-800 mb-1\">\r\n                Table for two, please.\r\n              </div>\r\n              <div className=\"translation text-sm text-green-600\">\r\n                두 명 자리 부탁합니다.\r\n              </div>\r\n            </div>\r\n            <div className=\"expression-card bg-green-50 rounded-lg p-3\">\r\n              <div className=\"expression font-medium text-green-800 mb-1\">\r\n                Could I see the menu?\r\n              </div>\r\n              <div className=\"translation text-sm text-green-600\">\r\n                메뉴 좀 볼 수 있을까요?\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SituationPage;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\SituationalTrainingPage.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'levelGroupMapping'. Either include it or remove the dependency array.","line":104,"column":6,"nodeType":"ArrayExpression","endLine":104,"endColumn":20,"suggestions":[{"desc":"Update the dependencies array to be: [level, group, levelGroupMapping]","fix":{"range":[4048,4062],"text":"[level, group, levelGroupMapping]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useEffect, useState } from 'react';\nimport { useNavigate, useSearchParams } from 'react-router-dom';\nimport { useAnswerEvaluation } from '@/hooks/useAnswerEvaluation';\n\ninterface Sentence {\n  id: string;\n  kr: string;\n  en: string;\n  form: 'aff' | 'neg' | 'wh_q';\n}\n\ninterface StageData {\n  stage_id: string;\n  title: string;\n  count: number;\n  sentences: Sentence[];\n  forms_distribution?: {\n    aff: number;\n    neg: number;\n    wh_q: number;\n  };\n}\n\nexport const SituationalTrainingPage: React.FC = () => {\n  const navigate = useNavigate();\n  const [searchParams] = useSearchParams();\n  const [stageData, setStageData] = useState<StageData[]>([]);\n  const [currentSentence, setCurrentSentence] = useState<Sentence | null>(null);\n  const [userInput, setUserInput] = useState('');\n  const [feedback, setFeedback] = useState<{type: 'correct' | 'incorrect' | null, message: string}>({type: null, message: ''});\n  const [currentIndex, setCurrentIndex] = useState(0);\n  const [score, setScore] = useState({ correct: 0, total: 0 });\n  const [isLoading, setIsLoading] = useState(true);\n\n  const level = searchParams.get('level');\n  const group = searchParams.get('group');\n  const groupTitle = searchParams.get('title');\n\n  // Answer evaluation hook with level-appropriate settings\n  const { evaluate } = useAnswerEvaluation({\n    level: parseInt(level || '4'),\n    mode: 'situational',\n    enableLogging: true\n  });\n\n  // Level별 그룹 스테이지 ID 매핑\n  const levelGroupMapping: { [key: string]: { [key: string]: string[] } } = {\n    '4': {\n      '1': ['Lv4-A5-S17', 'Lv4-A5-S18', 'Lv4-A5-S19', 'Lv4-A5-S20'], // Customer Excellence\n      '2': ['Lv4-A4-S13', 'Lv4-A4-S14', 'Lv4-A4-S15', 'Lv4-A4-S16'], // Professional Communication\n      '3': ['Lv4-A1-S01', 'Lv4-A1-S02', 'Lv4-A1-S03', 'Lv4-A1-S04'], // Meeting Leadership\n      '4': ['Lv4-A2-S05', 'Lv4-A2-S06', 'Lv4-A2-S07', 'Lv4-A2-S08'], // Presentation Mastery\n      '5': ['Lv4-A3-S09', 'Lv4-A3-S10', 'Lv4-A3-S11', 'Lv4-A3-S12'], // Strategic Negotiation\n      '6': ['Lv4-A6-S21', 'Lv4-A6-S22', 'Lv4-A6-S23', 'Lv4-A6-S24']  // Team Leadership\n    },\n    '5': {\n      '1': ['Lv5-A1-S01', 'Lv5-A1-S02', 'Lv5-A1-S03', 'Lv5-A1-S04'], // Research Foundation\n      '2': ['Lv5-A2-S05', 'Lv5-A2-S06', 'Lv5-A2-S07', 'Lv5-A2-S08'], // Academic Presentation\n      '3': ['Lv5-A3-S09', 'Lv5-A3-S10', 'Lv5-A3-S11', 'Lv5-A3-S12'], // Research Methodology\n      '4': ['Lv5-A4-S13', 'Lv5-A4-S14', 'Lv5-A4-S15', 'Lv5-A4-S16'], // Interdisciplinary Research\n      '5': ['Lv5-A5-S17', 'Lv5-A5-S18', 'Lv5-A5-S19', 'Lv5-A5-S20'], // Publication & Peer Review\n      '6': ['Lv5-A6-S21', 'Lv5-A6-S22', 'Lv5-A6-S23', 'Lv5-A6-S24']  // Academic Leadership\n    },\n    '6': {\n      '1': ['Lv6-D1-S01', 'Lv6-D1-S02', 'Lv6-D1-S03'], // Legal Excellence\n      '2': ['Lv6-D2-S04', 'Lv6-D2-S05', 'Lv6-D2-S06'], // Medical Professional\n      '3': ['Lv6-D3-S07', 'Lv6-D3-S08', 'Lv6-D3-S09'], // Technical Engineering\n      '4': ['Lv6-D4-S10', 'Lv6-D4-S11', 'Lv6-D4-S12']  // Financial Expertise\n    }\n  };\n\n  const allSentences = stageData.flatMap(stage => stage.sentences);\n\n  useEffect(() => {\n    const loadStageData = async () => {\n      if (!level || !group || !levelGroupMapping[level] || !levelGroupMapping[level][group]) {\n        console.error('Invalid level or group:', level, group);\n        return;\n      }\n\n      setIsLoading(true);\n      const stageIds = levelGroupMapping[level][group];\n      const loadedStages: StageData[] = [];\n\n      for (const stageId of stageIds) {\n        try {\n          const response = await fetch(`/patterns/level_${level}_situational/${stageId}_bank.json`);\n          if (response.ok) {\n            const stageData = await response.json();\n            loadedStages.push(stageData);\n          } else {\n            console.error(`Failed to load stage ${stageId}`);\n          }\n        } catch (error) {\n          console.error(`Error loading stage ${stageId}:`, error);\n        }\n      }\n\n      setStageData(loadedStages);\n      setIsLoading(false);\n    };\n\n    loadStageData();\n  }, [level, group]);\n\n  useEffect(() => {\n    if (allSentences.length > 0 && currentIndex < allSentences.length) {\n      setCurrentSentence(allSentences[currentIndex]);\n      setUserInput('');\n      setFeedback({type: null, message: ''});\n    }\n  }, [allSentences, currentIndex]);\n\n  const checkAnswer = () => {\n    if (!currentSentence) return;\n\n    // Use modular answer evaluation with contraction support\n    const evaluation = evaluate(userInput, currentSentence.en);\n    \n    setScore(prev => ({\n      correct: prev.correct + (evaluation.isCorrect ? 1 : 0),\n      total: prev.total + 1\n    }));\n\n    setFeedback({\n      type: evaluation.isCorrect ? 'correct' : 'incorrect',\n      message: evaluation.isCorrect ? '정답입니다! 🎉' : evaluation.feedback\n    });\n\n    // 2초 후 다음 문제로\n    setTimeout(() => {\n      setCurrentIndex(prev => prev + 1);\n    }, 2000);\n  };\n\n  const handleKeyPress = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && !feedback.type) {\n      checkAnswer();\n    }\n  };\n\n  if (isLoading) {\n    return (\n      <div style={{\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center',\n        height: '100vh',\n        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'\n      }}>\n        <div style={{ color: 'white', fontSize: '1.5em' }}>\n          상황학습 데이터 로딩 중... 🔄\n        </div>\n      </div>\n    );\n  }\n\n  if (currentIndex >= allSentences.length) {\n    const accuracy = Math.round((score.correct / score.total) * 100);\n    \n    return (\n      <div style={{\n        fontFamily: \"'Segoe UI', Arial, sans-serif\",\n        background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',\n        minHeight: '100vh',\n        display: 'flex',\n        justifyContent: 'center',\n        alignItems: 'center'\n      }}>\n        <div style={{\n          background: 'white',\n          borderRadius: '20px',\n          padding: '40px',\n          textAlign: 'center',\n          boxShadow: '0 20px 40px rgba(0,0,0,0.3)',\n          maxWidth: '500px'\n        }}>\n          <h1 style={{ color: '#1f2937', marginBottom: '20px' }}>🎉 훈련 완료!</h1>\n          <div style={{ fontSize: '3em', marginBottom: '20px' }}>\n            {accuracy >= 90 ? '🏆' : accuracy >= 80 ? '🥈' : accuracy >= 70 ? '🥉' : '📚'}\n          </div>\n          <div style={{ fontSize: '2em', color: '#1f2937', marginBottom: '10px' }}>\n            정확도: {accuracy}%\n          </div>\n          <div style={{ color: '#64748b', marginBottom: '30px' }}>\n            {score.correct} / {score.total} 정답\n          </div>\n          <div style={{ display: 'flex', gap: '15px', justifyContent: 'center' }}>\n            <button\n              onClick={() => navigate('/dashboard')}\n              style={{\n                background: 'linear-gradient(135deg, #3b82f6, #1d4ed8)',\n                color: 'white',\n                border: 'none',\n                padding: '12px 24px',\n                borderRadius: '10px',\n                fontSize: '16px',\n                cursor: 'pointer'\n              }}\n            >\n              홈으로\n            </button>\n            <button\n              onClick={() => window.location.reload()}\n              style={{\n                background: 'linear-gradient(135deg, #10b981, #059669)',\n                color: 'white',\n                border: 'none',\n                padding: '12px 24px',\n                borderRadius: '10px',\n                fontSize: '16px',\n                cursor: 'pointer'\n              }}\n            >\n              다시 도전\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div style={{\n      fontFamily: \"'Segoe UI', Arial, sans-serif\",\n      background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',\n      minHeight: '100vh',\n      padding: '20px'\n    }}>\n      <div style={{\n        maxWidth: '800px',\n        margin: '0 auto',\n        background: 'white',\n        borderRadius: '20px',\n        boxShadow: '0 20px 40px rgba(0,0,0,0.3)',\n        overflow: 'hidden'\n      }}>\n        {/* 헤더 */}\n        <div style={{\n          background: 'linear-gradient(135deg, #4338ca, #7c3aed)',\n          color: 'white',\n          padding: '30px',\n          textAlign: 'center',\n          position: 'relative'\n        }}>\n          <button\n            onClick={() => navigate('/dashboard')}\n            style={{\n              position: 'absolute',\n              top: '20px',\n              left: '20px',\n              background: 'rgba(255,255,255,0.2)',\n              border: '1px solid rgba(255,255,255,0.3)',\n              color: 'white',\n              padding: '8px 15px',\n              borderRadius: '25px',\n              cursor: 'pointer',\n              fontSize: '14px',\n              fontWeight: 'bold',\n              backdropFilter: 'blur(10px)'\n            }}\n          >\n            ← 홈\n          </button>\n\n          <h1 style={{ fontSize: '2em', marginBottom: '10px' }}>\n            {level === '4' ? '💼' : level === '5' ? '🎓' : '🎯'} Level {level} 상황학습 - {groupTitle}\n          </h1>\n          <div style={{ display: 'flex', justifyContent: 'center', gap: '30px' }}>\n            <div>\n              <div style={{ fontSize: '1.5em', fontWeight: 'bold' }}>{currentIndex + 1}</div>\n              <div style={{ fontSize: '0.9em', opacity: 0.8 }}>/ {allSentences.length}</div>\n            </div>\n            <div>\n              <div style={{ fontSize: '1.5em', fontWeight: 'bold' }}>{Math.round((score.correct / Math.max(score.total, 1)) * 100)}%</div>\n              <div style={{ fontSize: '0.9em', opacity: 0.8 }}>정확도</div>\n            </div>\n            <div>\n              <div style={{ fontSize: '1.5em', fontWeight: 'bold' }}>{score.correct}</div>\n              <div style={{ fontSize: '0.9em', opacity: 0.8 }}>정답</div>\n            </div>\n          </div>\n        </div>\n\n        {/* 훈련 영역 */}\n        <div style={{ padding: '40px' }}>\n          {currentSentence && (\n            <>\n              <div style={{\n                background: '#f8fafc',\n                borderRadius: '15px',\n                padding: '30px',\n                textAlign: 'center',\n                marginBottom: '30px',\n                border: '2px solid #e2e8f0'\n              }}>\n                <div style={{ fontSize: '1.2em', color: '#64748b', marginBottom: '15px' }}>\n                  다음을 영어로 번역하세요:\n                </div>\n                <div style={{ fontSize: '1.8em', color: '#1f2937', fontWeight: 'bold' }}>\n                  {currentSentence.kr}\n                </div>\n              </div>\n\n              <div style={{ marginBottom: '20px' }}>\n                <input\n                  type=\"text\"\n                  value={userInput}\n                  onChange={(e) => setUserInput(e.target.value)}\n                  onKeyPress={handleKeyPress}\n                  placeholder=\"영어 번역을 입력하세요...\"\n                  style={{\n                    width: '100%',\n                    padding: '15px 20px',\n                    fontSize: '18px',\n                    border: '2px solid #e2e8f0',\n                    borderRadius: '10px',\n                    outline: 'none',\n                    background: feedback.type ? \n                      (feedback.type === 'correct' ? '#f0fdf4' : '#fef2f2') : 'white',\n                    borderColor: feedback.type ?\n                      (feedback.type === 'correct' ? '#10b981' : '#ef4444') : '#e2e8f0'\n                  }}\n                  disabled={!!feedback.type}\n                />\n              </div>\n\n              {feedback.message && (\n                <div style={{\n                  padding: '15px',\n                  borderRadius: '10px',\n                  textAlign: 'center',\n                  fontSize: '1.1em',\n                  fontWeight: 'bold',\n                  background: feedback.type === 'correct' ? '#dcfce7' : '#fee2e2',\n                  color: feedback.type === 'correct' ? '#166534' : '#dc2626',\n                  marginBottom: '20px'\n                }}>\n                  {feedback.message}\n                </div>\n              )}\n\n              {!feedback.type && (\n                <div style={{ textAlign: 'center' }}>\n                  <button\n                    onClick={checkAnswer}\n                    disabled={!userInput.trim()}\n                    style={{\n                      background: userInput.trim() ? \n                        'linear-gradient(135deg, #10b981, #059669)' : '#e5e7eb',\n                      color: userInput.trim() ? 'white' : '#9ca3af',\n                      border: 'none',\n                      padding: '15px 30px',\n                      borderRadius: '10px',\n                      fontSize: '18px',\n                      fontWeight: 'bold',\n                      cursor: userInput.trim() ? 'pointer' : 'not-allowed',\n                      transition: 'all 0.3s'\n                    }}\n                  >\n                    확인 ✓\n                  </button>\n                </div>\n              )}\n            </>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\SmartReviewPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useEffect' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":36}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\r\nimport SmartReviewSession from '../components/SmartReviewSession';\r\nimport ReviewAnalyticsDashboard from '../components/ReviewAnalyticsDashboard';\r\n\r\ninterface ReviewResults {\r\n  totalSentences: number;\r\n  correctAnswers: number;\r\n  averageTime: number;\r\n  improvementAreas: string[];\r\n}\r\n\r\nconst SmartReviewPage: React.FC = () => {\r\n  const [currentView, setCurrentView] = useState<'dashboard' | 'session' | 'results'>('dashboard');\r\n  const [sessionResults, setSessionResults] = useState<ReviewResults | null>(null);\r\n  const userId = 'dev-user'; // 실제로는 auth context에서 가져옴\r\n\r\n  const handleStartReview = () => {\r\n    setCurrentView('session');\r\n    setSessionResults(null);\r\n  };\r\n\r\n  const handleSessionComplete = (results: ReviewResults) => {\r\n    setSessionResults(results);\r\n    setCurrentView('results');\r\n  };\r\n\r\n  const handleBackToDashboard = () => {\r\n    setCurrentView('dashboard');\r\n    setSessionResults(null);\r\n  };\r\n\r\n  const renderSessionResults = () => {\r\n    if (!sessionResults) return null;\r\n\r\n    const accuracyPercentage = Math.round((sessionResults.correctAnswers / sessionResults.totalSentences) * 100);\r\n    const averageTimeSeconds = Math.round(sessionResults.averageTime / 1000);\r\n\r\n    return (\r\n      <div className=\"max-w-4xl mx-auto p-6\">\r\n        <div className=\"text-center mb-8\">\r\n          <h2 className=\"text-3xl font-bold text-gray-900 mb-2\">🎉 복습 완료!</h2>\r\n          <p className=\"text-gray-600\">오늘의 복습 세션이 완료되었습니다.</p>\r\n        </div>\r\n\r\n        {/* 주요 결과 */}\r\n        <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6 mb-8\">\r\n          <div className=\"bg-white border border-gray-200 rounded-lg p-6 text-center\">\r\n            <div className=\"text-3xl font-bold text-blue-600 mb-2\">{sessionResults.totalSentences}</div>\r\n            <div className=\"text-gray-600\">복습한 문장</div>\r\n          </div>\r\n          \r\n          <div className=\"bg-white border border-gray-200 rounded-lg p-6 text-center\">\r\n            <div className=\"text-3xl font-bold text-green-600 mb-2\">{accuracyPercentage}%</div>\r\n            <div className=\"text-gray-600\">정확도</div>\r\n          </div>\r\n          \r\n          <div className=\"bg-white border border-gray-200 rounded-lg p-6 text-center\">\r\n            <div className=\"text-3xl font-bold text-purple-600 mb-2\">{averageTimeSeconds}초</div>\r\n            <div className=\"text-gray-600\">평균 응답 시간</div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* 성과 분석 */}\r\n        <div className=\"bg-white border border-gray-200 rounded-lg p-6 mb-8\">\r\n          <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">📈 성과 분석</h3>\r\n          \r\n          {accuracyPercentage >= 80 ? (\r\n            <div className=\"flex items-start gap-3 p-4 bg-green-50 border border-green-200 rounded-lg mb-4\">\r\n              <span className=\"text-green-500 text-2xl\">🌟</span>\r\n              <div>\r\n                <h4 className=\"font-medium text-green-900\">훌륭한 성과!</h4>\r\n                <p className=\"text-green-700 text-sm\">높은 정확도를 보여주고 있습니다. 더 어려운 단계로 도전해보세요!</p>\r\n              </div>\r\n            </div>\r\n          ) : accuracyPercentage >= 60 ? (\r\n            <div className=\"flex items-start gap-3 p-4 bg-yellow-50 border border-yellow-200 rounded-lg mb-4\">\r\n              <span className=\"text-yellow-500 text-2xl\">📚</span>\r\n              <div>\r\n                <h4 className=\"font-medium text-yellow-900\">좋은 진전!</h4>\r\n                <p className=\"text-yellow-700 text-sm\">꾸준히 향상되고 있습니다. 조금 더 집중해서 학습해보세요.</p>\r\n              </div>\r\n            </div>\r\n          ) : (\r\n            <div className=\"flex items-start gap-3 p-4 bg-blue-50 border border-blue-200 rounded-lg mb-4\">\r\n              <span className=\"text-blue-500 text-2xl\">💪</span>\r\n              <div>\r\n                <h4 className=\"font-medium text-blue-900\">추가 학습이 필요해요</h4>\r\n                <p className=\"text-blue-700 text-sm\">기초를 다시 한번 점검하고 꾸준히 복습하면 향상될 거예요!</p>\r\n              </div>\r\n            </div>\r\n          )}\r\n\r\n          {/* 개선 영역 */}\r\n          {sessionResults.improvementAreas.length > 0 && (\r\n            <div>\r\n              <h4 className=\"font-medium text-gray-900 mb-3\">🎯 집중 개선 영역</h4>\r\n              <div className=\"space-y-2\">\r\n                {sessionResults.improvementAreas.map((area, index) => (\r\n                  <div key={index} className=\"flex items-center gap-2 text-sm text-gray-700\">\r\n                    <span className=\"w-1.5 h-1.5 bg-blue-500 rounded-full\"></span>\r\n                    {area}\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n        {/* 다음 단계 추천 */}\r\n        <div className=\"bg-gradient-to-r from-blue-50 to-purple-50 border border-blue-200 rounded-lg p-6 mb-8\">\r\n          <h3 className=\"text-lg font-semibold text-gray-900 mb-4\">🚀 다음 단계</h3>\r\n          <div className=\"grid grid-cols-1 md:grid-cols-2 gap-4\">\r\n            <button\r\n              onClick={handleStartReview}\r\n              className=\"p-4 bg-white border border-blue-200 rounded-lg hover:bg-blue-50 transition-colors text-left\"\r\n            >\r\n              <h4 className=\"font-medium text-blue-900 mb-1\">추가 복습하기</h4>\r\n              <p className=\"text-sm text-blue-700\">더 많은 문장으로 복습을 이어가세요</p>\r\n            </button>\r\n            \r\n            <button\r\n              onClick={handleBackToDashboard}\r\n              className=\"p-4 bg-white border border-purple-200 rounded-lg hover:bg-purple-50 transition-colors text-left\"\r\n            >\r\n              <h4 className=\"font-medium text-purple-900 mb-1\">분석 보기</h4>\r\n              <p className=\"text-sm text-purple-700\">상세한 학습 분석을 확인하세요</p>\r\n            </button>\r\n          </div>\r\n        </div>\r\n\r\n        {/* 돌아가기 버튼 */}\r\n        <div className=\"text-center\">\r\n          <button\r\n            onClick={handleBackToDashboard}\r\n            className=\"px-6 py-3 bg-gray-600 text-white rounded-lg hover:bg-gray-700 transition-colors\"\r\n          >\r\n            대시보드로 돌아가기\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  const renderContent = () => {\r\n    switch (currentView) {\r\n      case 'session':\r\n        return (\r\n          <SmartReviewSession\r\n            userId={userId}\r\n            onComplete={handleSessionComplete}\r\n          />\r\n        );\r\n      \r\n      case 'results':\r\n        return renderSessionResults();\r\n      \r\n      case 'dashboard':\r\n      default:\r\n        return (\r\n          <div>\r\n            {/* 대시보드 헤더 */}\r\n            <div className=\"max-w-6xl mx-auto p-6\">\r\n              <div className=\"flex justify-between items-center mb-6\">\r\n                <div>\r\n                  <h1 className=\"text-3xl font-bold text-gray-900 mb-2\">🧠 스마트 복습</h1>\r\n                  <p className=\"text-gray-600\">AI 기반 개인 맞춤 복습 시스템</p>\r\n                </div>\r\n                \r\n                <button\r\n                  onClick={handleStartReview}\r\n                  className=\"px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium\"\r\n                >\r\n                  복습 시작하기\r\n                </button>\r\n              </div>\r\n\r\n              {/* 빠른 시작 카드들 */}\r\n              <div className=\"grid grid-cols-1 md:grid-cols-3 gap-6 mb-8\">\r\n                <div \r\n                  onClick={handleStartReview}\r\n                  className=\"bg-gradient-to-br from-blue-500 to-blue-600 text-white p-6 rounded-lg cursor-pointer hover:from-blue-600 hover:to-blue-700 transition-all\"\r\n                >\r\n                  <h3 className=\"text-lg font-semibold mb-2\">📚 오늘의 복습</h3>\r\n                  <p className=\"text-blue-100 text-sm mb-3\">개인 맞춤 복습 문장으로 학습</p>\r\n                  <div className=\"text-2xl font-bold\">30개 문장</div>\r\n                </div>\r\n\r\n                <div className=\"bg-gradient-to-br from-green-500 to-green-600 text-white p-6 rounded-lg\">\r\n                  <h3 className=\"text-lg font-semibold mb-2\">🎯 취약점 집중</h3>\r\n                  <p className=\"text-green-100 text-sm mb-3\">어려웠던 문장 위주로 복습</p>\r\n                  <div className=\"text-2xl font-bold\">15개 문장</div>\r\n                </div>\r\n\r\n                <div className=\"bg-gradient-to-br from-purple-500 to-purple-600 text-white p-6 rounded-lg\">\r\n                  <h3 className=\"text-lg font-semibold mb-2\">⚡ 빠른 복습</h3>\r\n                  <p className=\"text-purple-100 text-sm mb-3\">5분 안에 빠르게 복습</p>\r\n                  <div className=\"text-2xl font-bold\">10개 문장</div>\r\n                </div>\r\n              </div>\r\n            </div>\r\n\r\n            {/* 분석 대시보드 */}\r\n            <ReviewAnalyticsDashboard userId={userId} />\r\n          </div>\r\n        );\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gray-50\">\r\n      {renderContent()}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default SmartReviewPage;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\SpeedModePage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\StageFocusPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\StudyPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SpeechRecorder' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SpeakingStageSelector' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SpeakingFlowController' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useSRSEngine' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'DrillCard' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'FeedbackResponse' is defined but never used. Allowed unused vars must match /^_/u.","line":17,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sessionStartTime' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":39,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":39,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'speakingFlowState' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":46,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":46,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sessionConfig' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":53,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":53,"endColumn":22},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'autoNextTimeoutId', 'setError', and 'user'. Either include them or remove the dependency array.","line":140,"column":6,"nodeType":"ArrayExpression","endLine":140,"endColumn":43,"suggestions":[{"desc":"Update the dependencies array to be: [autoNextTimeoutId, loadCards, resetStudyState, setError, user, user.id]","fix":{"range":[5652,5689],"text":"[autoNextTimeoutId, loadCards, resetStudyState, setError, user, user.id]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'startSession'. Either include it or remove the dependency array.","line":147,"column":6,"nodeType":"ArrayExpression","endLine":147,"endColumn":55,"suggestions":[{"desc":"Update the dependencies array to be: [study.cards, isSessionActive, isTrainingRunning, startSession]","fix":{"range":[5916,5965],"text":"[study.cards, isSessionActive, isTrainingRunning, startSession]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":173,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":173,"endColumn":19},{"ruleId":"no-undef","severity":1,"message":"'srsService' is not defined.","line":285,"column":17,"nodeType":"Identifier","messageId":"undef","endLine":285,"endColumn":27},{"ruleId":"no-undef","severity":1,"message":"'srsService' is not defined.","line":423,"column":15,"nodeType":"Identifier","messageId":"undef","endLine":423,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":431,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":431,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":563,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":563,"endColumn":19},{"ruleId":"no-undef","severity":1,"message":"'PatternTrainingFlowFinal' is not defined.","line":709,"column":16,"nodeType":"JSXIdentifier","messageId":"undef","endLine":709,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useCallback, useMemo, memo } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { useAppStore, useUser, useStudy, useUI, useLearningMode, useSpeakingStage } from '@/store/useAppStore';\r\nimport { SpeechRecorder } from '@/components/SpeechRecorder';\r\nimport { SpeakingStageSelector } from '@/components/SpeakingStageSelector';\r\nimport { SpeakingFlowController } from '@/components/SpeakingFlowController';\r\n// import { PatternTrainingFlow } from '@/components/PatternTrainingFlow';\\n// TODO: Migrate to new modularized PatternTrainingPageV3 system\\nimport { PatternTrainingFlowFinal } from '@/components/PatternTrainingFlowFinal';\r\nimport { FeedbackPanel } from '@/components/FeedbackPanel';\r\nimport { WritingModeInput } from '@/components/WritingModeInput';\r\nimport { WritingModeFeedback } from '@/components/WritingModeFeedback';\r\nimport { useSpeech } from '@/hooks/useSpeech';\r\nimport { api } from '@/lib/api';\r\n// import { srsService } from '@/services/srsService';\r\n// TODO: Migrate to new SRS Engine system\r\nimport { useSRSEngine } from '@/hooks/useSRSEngine';\r\nimport { useAuthService } from '@/services/authService';\r\nimport type { DrillCard, FeedbackResponse } from '@/types';\r\nimport type { WritingFeedback } from '@/services/writingMode';\r\n\r\nexport const StudyPage: React.FC = memo(() => {\r\n  const navigate = useNavigate();\r\n  const user = useUser();\r\n  const study = useStudy();\r\n  const ui = useUI();\r\n  const learningMode = useLearningMode();\r\n  const speakingStage = useSpeakingStage();\r\n  \r\n  const {\r\n    setCurrentCard,\r\n    setCards,\r\n    setFeedback,\r\n    setCurrentSession,\r\n    resetStudyState,\r\n    setLoading,\r\n    setError,\r\n    clearError,\r\n  } = useAppStore();\r\n\r\n  const [sessionStartTime, setSessionStartTime] = useState<number>(0);\r\n  const [cardStartTime, setCardStartTime] = useState<number>(0);\r\n  const [isSessionActive, setIsSessionActive] = useState(false);\r\n  const [writingFeedback, setWritingFeedback] = useState<WritingFeedback | null>(null);\r\n  const [writingInputValue, setWritingInputValue] = useState<string>('');\r\n  const [autoNextTimeoutId, setAutoNextTimeoutId] = useState<NodeJS.Timeout | null>(null);\r\n  const [autoNextCountdown, setAutoNextCountdown] = useState<number>(0);\r\n  const [speakingFlowState, setSpeakingFlowState] = useState<'idle' | 'tts' | 'beep' | 'waiting' | 'recording'>('idle');\r\n  const [isTrainingRunning, setIsTrainingRunning] = useState(false);\r\n  const [isTrainingPaused, setIsTrainingPaused] = useState(false);\r\n\r\n  const { handleStudyComplete, isAuthenticated } = useAuthService();\r\n  \r\n  // Memoize expensive calculations\r\n  const sessionConfig = useMemo(() => ({\r\n    level: user.level,\r\n    stage: user.stage,\r\n    mode: learningMode.mode\r\n  }), [user.level, user.stage, learningMode.mode]);\r\n  \r\n  const speech = useSpeech({\r\n    apiBaseUrl: import.meta.env.VITE_API_BASE_URL,\r\n    preferCloudSTT: false,\r\n    language: 'en-US',\r\n  });\r\n\r\n  const loadCards = useCallback(async () => {\r\n    setLoading(true);\r\n    clearError();\r\n    \r\n    try {\r\n      console.log(`🔄 카드 로딩 시작: Level ${user.level}, Stage ${user.stage}`);\r\n      \r\n      let response;\r\n      if (user.stage === 'ALL') {\r\n        console.log(`🔄 ALL 모드로 카드 로딩: Level ${user.level}`);\r\n        response = await api.getAllLevelCards(user.level);\r\n      } else {\r\n        response = await api.getCards(user.level, user.stage);\r\n      }\r\n      \r\n      // 📋 상세한 API 응답 구조 로깅\r\n      console.log('📥 API 응답 전체:', JSON.stringify(response, null, 2));\r\n      console.log('📥 response.success:', response.success);\r\n      console.log('📥 response.data:', response.data);\r\n      console.log('📥 response.data?.cards:', response.data?.cards);\r\n      console.log('📥 response.data?.cards 타입:', typeof response.data?.cards);\r\n      console.log('📥 response.data?.cards Array.isArray:', Array.isArray(response.data?.cards));\r\n      \r\n      if (response.success && response.data) {\r\n        // ✅ 이중 래핑된 구조에서 카드 데이터 접근\r\n        const cards = response.data.data?.cards;\r\n        \r\n        if (Array.isArray(cards)) {\r\n          console.log(`✅ 카드 로딩 성공: ${cards.length}개`);\r\n          setCards(cards);\r\n          \r\n          if (cards.length > 0) {\r\n            setCurrentCard(cards[0], 0);\r\n            setCardStartTime(Date.now());\r\n            // 새 세션 시작 시 입력값 클리어\r\n            setWritingInputValue('');\r\n          } else {\r\n            console.warn('⚠️ 카드 배열이 비어있음');\r\n            setError('이 레벨/스테이지에 카드가 없습니다');\r\n          }\r\n        } else {\r\n          console.error('❌ response.data.cards가 배열이 아님:', cards);\r\n          setError('카드 데이터 형식이 올바르지 않습니다');\r\n        }\r\n      } else {\r\n        console.error('❌ API 응답 실패:');\r\n        console.error('  - response.success:', response.success);\r\n        console.error('  - response.error:', response.error);\r\n        console.error('  - response.data:', response.data);\r\n        setError(response.error || '카드를 불러오는데 실패했습니다');\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ 네트워크 오류:', error);\r\n      setError('네트워크 오류가 발생했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, [user.level, user.stage, setLoading, clearError, setCards, setCurrentCard, setError]);\r\n\r\n  // Load cards when component mounts\r\n  useEffect(() => {\r\n    console.log('🏁 StudyPage 마운트, 사용자 상태:', user);\r\n    if (user.id) {\r\n      loadCards();\r\n    } else {\r\n      console.warn('⚠️ 사용자 ID가 없어 카드 로딩을 건너뜀');\r\n      setError('사용자 정보가 없습니다. 다시 로그인해주세요.');\r\n    }\r\n    return () => {\r\n      // Cleanup on unmount\r\n      if (autoNextTimeoutId) {\r\n        clearTimeout(autoNextTimeoutId);\r\n      }\r\n      resetStudyState();\r\n    };\r\n  }, [loadCards, resetStudyState, user.id]);\r\n\r\n  // Start session when cards are loaded and training is running\r\n  useEffect(() => {\r\n    if (study.cards?.length && study.cards.length > 0 && !isSessionActive && isTrainingRunning) {\r\n      startSession();\r\n    }\r\n  }, [study.cards, isSessionActive, isTrainingRunning]);\r\n\r\n  const startSession = async () => {\r\n    if (!user.id || !study.cards?.length || study.cards.length === 0) return;\r\n\r\n    try {\r\n      const cardIds = study.cards.map(card => card.id);\r\n      const response = await api.startSession({\r\n        userId: user.id,\r\n        level: user.level,\r\n        stage: user.stage,\r\n        cardIds,\r\n      });\r\n\r\n      if (response.success && response.data) {\r\n        setCurrentSession({\r\n          id: response.data.sessionId,\r\n          userId: user.id,\r\n          level: user.level,\r\n          stage: user.stage,\r\n          startedAt: new Date(),\r\n          items: [],\r\n        });\r\n        setIsSessionActive(true);\r\n        setSessionStartTime(Date.now());\r\n      }\r\n    } catch (error) {\r\n      setError('세션 시작에 실패했습니다');\r\n    }\r\n  };\r\n\r\n  // Pattern Training Flow Result Handler with Firebase integration\r\n  const handlePatternTrainingResult = async (userAnswer: string, isCorrect: boolean, confidence: number, responseTime?: number) => {\r\n    console.log('🎯 StudyPage: handlePatternTrainingResult 호출됨', { userAnswer, isCorrect, confidence, responseTime });\r\n    \r\n    // Calculate score based on correctness and confidence\r\n    const score = isCorrect ? Math.max(70, Math.round(confidence * 100)) : 0;\r\n    \r\n    // Firebase 진행도 업데이트 (인증된 사용자만)\r\n    if (isAuthenticated && responseTime) {\r\n      console.log('[DEBUG] 🔥 Firebase 진행도 업데이트 시작');\r\n      \r\n      const completionData = {\r\n        level: user.level,\r\n        stage: user.stage,\r\n        score: score,\r\n        timeSpent: responseTime,\r\n        mistakes: isCorrect ? 0 : 1\r\n      };\r\n      \r\n      // 백그라운드에서 Firebase 업데이트 (기존 로직에 영향 주지 않음)\r\n      handleStudyComplete(completionData).then(success => {\r\n        if (success) {\r\n          console.log('[DEBUG] ✅ Firebase 진행도 업데이트 성공');\r\n        } else {\r\n          console.log('[DEBUG] ❌ Firebase 진행도 업데이트 실패');\r\n        }\r\n      }).catch(error => {\r\n        console.error('[DEBUG] ❌ Firebase 진행도 업데이트 에러:', error);\r\n      });\r\n    } else {\r\n      console.log('[DEBUG] ⚠️ Firebase 업데이트 스킵:', { \r\n        isAuthenticated, \r\n        hasResponseTime: !!responseTime \r\n      });\r\n    }\r\n    \r\n    // 기존 로직 유지\r\n    await handleSpeechResult(userAnswer, confidence);\r\n  };\r\n\r\n  const handleSpeechResult = async (transcript: string, confidence: number) => {\r\n    console.log('🎯 StudyPage: handleSpeechResult 호출됨', { transcript, confidence });\r\n    console.log('🎯 StudyPage: currentCard:', study.currentCard);\r\n    console.log('🎯 StudyPage: currentSession:', study.currentSession);\r\n    \r\n    if (!study.currentCard) {\r\n      console.error('❌ StudyPage: currentCard가 없음');\r\n      return;\r\n    }\r\n    \r\n    // 세션이 없으면 자동으로 생성 시도\r\n    if (!study.currentSession && user.id) {\r\n      console.log('🔄 StudyPage: 세션이 없어서 자동으로 세션 시작 시도');\r\n      try {\r\n        await startSession();\r\n      } catch (error) {\r\n        console.error('❌ 세션 시작 실패:', error);\r\n      }\r\n    }\r\n\r\n    const responseTime = Date.now() - cardStartTime;\r\n    console.log('🕐 StudyPage: responseTime:', responseTime);\r\n    setLoading(true);\r\n\r\n    // 빈 transcript인 경우 기본값으로 처리\r\n    const processedTranscript = transcript.trim() || '[음성 인식 실패]';\r\n    \r\n    try {\r\n      \r\n      // Get rule-based feedback\r\n      const feedbackResponse = await api.getFeedback({\r\n        front_ko: study.currentCard.front_ko,\r\n        sttText: processedTranscript,\r\n        target_en: study.currentCard.target_en,\r\n      });\r\n\r\n      console.log('📝 StudyPage: feedbackResponse:', feedbackResponse);\r\n      \r\n      if (feedbackResponse.success && feedbackResponse.data) {\r\n        const feedback = feedbackResponse.data;\r\n        console.log('✅ StudyPage: 피드백 설정:', feedback);\r\n        setFeedback(feedback);\r\n\r\n        // Submit answer to session (세션이 있는 경우에만)\r\n        if (study.currentSession?.id) {\r\n          await api.submitAnswer({\r\n            sessionId: study.currentSession.id,\r\n            cardId: study.currentCard.id,\r\n            userAnswer: transcript,\r\n            isCorrect: feedback.correct,\r\n            score: feedback.score,\r\n            timeSpent: Math.round(responseTime / 1000),\r\n          });\r\n        } else {\r\n          console.log('⚠️ StudyPage: 세션이 없어서 답변 제출 건너뜀');\r\n        }\r\n\r\n        // Play correct answer if TTS is available and answer was incorrect\r\n        // Speaking 모드에서는 자동 플로우가 TTS를 담당하므로 여기서는 재생하지 않음\r\n        if (speech.isTTSAvailable && !feedback.correct && learningMode.mode !== 'speaking') {\r\n          setTimeout(() => {\r\n            speech.speak(study.currentCard!.target_en);\r\n          }, 1500);\r\n        }\r\n\r\n        // SRS 시스템에 카드 추가 (첫 학습 시)\r\n        try {\r\n          await srsService.addCardToSRS(user.id, study.currentCard.id, {\r\n            level: user.level,\r\n            stage: user.stage,\r\n            difficulty: 'medium'\r\n          });\r\n        } catch (error) {\r\n          console.error('SRS 카드 추가 실패:', error);\r\n        }\r\n        \r\n        // Speaking 모드에서 자동으로 4초 후 다음 카드로 진행 (HTML 버전과 동일)\r\n        console.log('🎯 StudyPage: learningMode:', learningMode);\r\n        if (learningMode.mode === 'speaking') {\r\n          console.log('🎤 StudyPage: Speaking 모드 - 4초 후 자동 진행 설정');\r\n          const timeout = setTimeout(() => {\r\n            console.log('⏰ StudyPage: 4초 후 다음 카드 이동');\r\n            handleNextCard();\r\n          }, 4000); // HTML 버전과 동일하게 4초로 변경\r\n          setAutoNextTimeoutId(timeout);\r\n          setAutoNextCountdown(4); // 4초로 변경\r\n          \r\n          // 카운트다운 타이머\r\n          const countdownInterval = setInterval(() => {\r\n            setAutoNextCountdown(prev => {\r\n              if (prev <= 1) {\r\n                clearInterval(countdownInterval);\r\n                return 0;\r\n              }\r\n              return prev - 1;\r\n            });\r\n          }, 1000);\r\n        }\r\n      } else {\r\n        console.error('❌ StudyPage: 피드백 실패:', feedbackResponse.error);\r\n        \r\n        // 피드백 실패 시에도 기본 피드백 생성하여 진행\r\n        const fallbackFeedback = {\r\n          correct: false,\r\n          score: 0,\r\n          message: '음성 인식에 실패했습니다. 다음 문제로 넘어갑니다.',\r\n          userAnswer: processedTranscript,\r\n          correctAnswer: study.currentCard.target_en,\r\n          feedback: '음성을 다시 한 번 명확하게 말해주세요.'\r\n        };\r\n        \r\n        console.log('🔄 StudyPage: 기본 피드백으로 진행:', fallbackFeedback);\r\n        setFeedback(fallbackFeedback);\r\n        \r\n        // Speaking 모드에서 자동으로 4초 후 다음 카드로 진행 (HTML 버전과 동일)\r\n        console.log('🎯 StudyPage: learningMode:', learningMode);\r\n        if (learningMode.mode === 'speaking') {\r\n          console.log('🎤 StudyPage: Speaking 모드 - 4초 후 자동 진행 설정');\r\n          const timeout = setTimeout(() => {\r\n            console.log('⏰ StudyPage: 4초 후 다음 카드 이동');\r\n            handleNextCard();\r\n          }, 4000);\r\n          setAutoNextTimeoutId(timeout);\r\n          setAutoNextCountdown(4);\r\n          \r\n          // 카운트다운 타이머\r\n          const countdownInterval = setInterval(() => {\r\n            setAutoNextCountdown(prev => {\r\n              if (prev <= 1) {\r\n                clearInterval(countdownInterval);\r\n                return 0;\r\n              }\r\n              return prev - 1;\r\n            });\r\n          }, 1000);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      console.error('❌ StudyPage: 피드백 처리 오류:', error);\r\n      \r\n      // 오류 발생 시에도 기본 피드백 생성하여 진행\r\n      const errorFeedback = {\r\n        correct: false,\r\n        score: 0,\r\n        message: '처리 중 오류가 발생했습니다. 다음 문제로 넘어갑니다.',\r\n        userAnswer: processedTranscript || '[처리 오류]',\r\n        correctAnswer: study.currentCard.target_en,\r\n        feedback: '다시 시도해주세요.'\r\n      };\r\n      \r\n      console.log('🔄 StudyPage: 오류 시 기본 피드백으로 진행:', errorFeedback);\r\n      setFeedback(errorFeedback);\r\n      \r\n      // Speaking 모드에서 자동으로 4초 후 다음 카드로 진행\r\n      if (learningMode.mode === 'speaking') {\r\n        console.log('🎤 StudyPage: 오류 시에도 Speaking 모드 - 4초 후 자동 진행');\r\n        const timeout = setTimeout(() => {\r\n          console.log('⏰ StudyPage: 오류 처리 후 4초 후 다음 카드 이동');\r\n          handleNextCard();\r\n        }, 4000);\r\n        setAutoNextTimeoutId(timeout);\r\n        setAutoNextCountdown(4);\r\n        \r\n        // 카운트다운 타이머\r\n        const countdownInterval = setInterval(() => {\r\n          setAutoNextCountdown(prev => {\r\n            if (prev <= 1) {\r\n              clearInterval(countdownInterval);\r\n              return 0;\r\n            }\r\n            return prev - 1;\r\n          });\r\n        }, 1000);\r\n      }\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleWritingSubmit = async (userInput: string, feedback: WritingFeedback) => {\r\n    if (!study.currentCard || !study.currentSession) return;\r\n\r\n    setWritingFeedback(feedback);\r\n    setLoading(true);\r\n\r\n    try {\r\n      // Submit answer to session\r\n      await api.submitAnswer({\r\n        sessionId: study.currentSession.id!,\r\n        cardId: study.currentCard.id,\r\n        userAnswer: userInput,\r\n        isCorrect: feedback.isCorrect,\r\n        score: feedback.score,\r\n        timeSpent: Math.round((Date.now() - cardStartTime) / 1000),\r\n      });\r\n\r\n      // Play correct answer if available\r\n      if (speech.isTTSAvailable) {\r\n        setTimeout(() => {\r\n          speech.speak(study.currentCard!.target_en);\r\n        }, 1000);\r\n      }\r\n\r\n      // SRS 시스템에 카드 추가 (Writing 모드)\r\n      try {\r\n        await srsService.addCardToSRS(user.id, study.currentCard.id, {\r\n          level: user.level,\r\n          stage: user.stage,\r\n          difficulty: 'medium'\r\n        });\r\n      } catch (error) {\r\n        console.error('SRS 카드 추가 실패:', error);\r\n      }\r\n    } catch (error) {\r\n      setError('답변 제출 중 오류가 발생했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  const handleStartTraining = () => {\r\n    console.log('🚀 Training 시작');\r\n    setIsTrainingRunning(true);\r\n    setIsTrainingPaused(false);\r\n  };\r\n\r\n  const handlePauseTraining = () => {\r\n    console.log('⏸️ Training 일시정지');\r\n    setIsTrainingPaused(true);\r\n    \r\n    // 자동 진행 타이머 중지\r\n    if (autoNextTimeoutId) {\r\n      clearTimeout(autoNextTimeoutId);\r\n      setAutoNextTimeoutId(null);\r\n    }\r\n    \r\n    // PatternTrainingFlow에 일시정지 신호 전달 (disabled prop을 통해)\r\n    // 실제로는 disabled prop이 true가 되어 PatternTrainingFlow가 일시정지됨\r\n  };\r\n\r\n  const handleResumeTraining = () => {\r\n    console.log('▶️ Training 재개');\r\n    setIsTrainingPaused(false);\r\n    \r\n    // PatternTrainingFlow가 자동으로 재개됨 (disabled가 false가 되고 autoStart가 true이므로)\r\n  };\r\n\r\n  const handleResetTraining = () => {\r\n    console.log('🔄 Training 재시작');\r\n    setIsTrainingRunning(false);\r\n    setIsTrainingPaused(false);\r\n    setFeedback(null);\r\n    setWritingFeedback(null);\r\n    \r\n    // 자동 진행 타이머 중지\r\n    if (autoNextTimeoutId) {\r\n      clearTimeout(autoNextTimeoutId);\r\n      setAutoNextTimeoutId(null);\r\n    }\r\n    \r\n    // 첫 번째 카드로 돌아가기\r\n    if (study.cards?.length && study.cards.length > 0) {\r\n      setCurrentCard(study.cards[0], 0);\r\n      setCardStartTime(Date.now());\r\n      setWritingInputValue('');\r\n    }\r\n  };\r\n\r\n  const handleNextCard = () => {\r\n    console.log('🔄 StudyPage: handleNextCard 호출됨');\r\n    \r\n    // 자동 진행 타이머가 있다면 클리어\r\n    if (autoNextTimeoutId) {\r\n      clearTimeout(autoNextTimeoutId);\r\n      setAutoNextTimeoutId(null);\r\n    }\r\n\r\n    const nextIndex = study.currentIndex + 1;\r\n    \r\n    if (study.cards?.length && nextIndex < study.cards.length) {\r\n      console.log(`🔄 StudyPage: 다음 카드로 이동 (${nextIndex + 1}/${study.cards.length})`);\r\n      \r\n      // 다음 카드로 자동 진행\r\n      setCurrentCard(study.cards[nextIndex], nextIndex);\r\n      setCardStartTime(Date.now());\r\n      setFeedback(null);\r\n      setWritingFeedback(null);\r\n      \r\n      // Speaking 모드 상태 초기화\r\n      setSpeakingFlowState('idle');\r\n      setAutoNextCountdown(0);\r\n      \r\n      // 입력값 자동 클리어\r\n      setWritingInputValue('');\r\n      \r\n      // 음성 인식이 진행 중이라면 중지\r\n      if (speech.isRecording) {\r\n        speech.stopRecording();\r\n      }\r\n    } else {\r\n      // 마지막 카드인 경우 세션 완료\r\n      console.log('🏁 StudyPage: 마지막 카드 도달, 세션 완료');\r\n      finishSession();\r\n    }\r\n  };\r\n\r\n  const handlePreviousCard = () => {\r\n    // 자동 진행 타이머가 있다면 클리어\r\n    if (autoNextTimeoutId) {\r\n      clearTimeout(autoNextTimeoutId);\r\n      setAutoNextTimeoutId(null);\r\n    }\r\n\r\n    const prevIndex = study.currentIndex - 1;\r\n    \r\n    if (study.cards?.length && prevIndex >= 0) {\r\n      setCurrentCard(study.cards[prevIndex], prevIndex);\r\n      setCardStartTime(Date.now());\r\n      setFeedback(null);\r\n      setWritingFeedback(null);\r\n      // 입력값 자동 클리어\r\n      setWritingInputValue('');\r\n    }\r\n  };\r\n\r\n  const finishSession = async () => {\r\n    if (!study.currentSession) return;\r\n\r\n    setLoading(true);\r\n    \r\n    try {\r\n      const response = await api.finishSession(study.currentSession.id!);\r\n      \r\n      if (response.success) {\r\n        // Navigate to results page with session summary\r\n        navigate('/result', { \r\n          state: { \r\n            summary: response.data?.summary,\r\n            level: user.level,\r\n            stage: user.stage,\r\n          }\r\n        });\r\n      } else {\r\n        setError(response.error || '세션 종료에 실패했습니다');\r\n      }\r\n    } catch (error) {\r\n      setError('세션 종료 중 오류가 발생했습니다');\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  };\r\n\r\n  if (ui.isLoading && !study.currentCard) {\r\n    return (\r\n      <div className=\"min-h-screen flex items-center justify-center\">\r\n        <div className=\"text-center\">\r\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4\"></div>\r\n          <p className=\"text-gray-600\">로딩 중...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (ui.error) {\r\n    return (\r\n      <div className=\"min-h-screen flex items-center justify-center p-4\">\r\n        <div className=\"max-w-md w-full bg-red-50 border border-red-200 rounded-lg p-6 text-center\">\r\n          <div className=\"text-red-500 text-4xl mb-4\">⚠️</div>\r\n          <h2 className=\"text-lg font-semibold text-red-800 mb-2\">오류 발생</h2>\r\n          <p className=\"text-red-600 mb-4\">{ui.error}</p>\r\n          <div className=\"space-x-2\">\r\n            <button\r\n              onClick={loadCards}\r\n              className=\"px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600\"\r\n            >\r\n              다시 시도\r\n            </button>\r\n            <button\r\n              onClick={() => navigate('/')}\r\n              className=\"px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600\"\r\n            >\r\n              돌아가기\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (!study.currentCard) {\r\n    return (\r\n      <div className=\"min-h-screen flex items-center justify-center p-4\">\r\n        <div className=\"text-center\">\r\n          <p className=\"text-gray-600 mb-4\">학습할 카드가 없습니다</p>\r\n          <button\r\n            onClick={() => navigate('/')}\r\n            className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600\"\r\n          >\r\n            홈으로 돌아가기\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gray-50\">\r\n      {/* Header */}\r\n      <div className=\"bg-white shadow-sm border-b\">\r\n        <div className=\"max-w-2xl mx-auto px-4 py-3\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <button\r\n              onClick={() => navigate('/')}\r\n              className=\"text-gray-600 hover:text-gray-800\"\r\n            >\r\n              ← 뒤로\r\n            </button>\r\n            <div className=\"text-center\">\r\n              <h1 className=\"text-lg font-semibold\">\r\n                Level {user.level}.{user.stage}\r\n              </h1>\r\n            </div>\r\n            <div className=\"text-sm text-gray-500\">\r\n              {study.currentIndex + 1}/{study.cards?.length || 0}\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Progress Bar */}\r\n      <div className=\"bg-white border-b\">\r\n        <div className=\"max-w-2xl mx-auto px-4 py-2\">\r\n          <div className=\"bg-gray-200 rounded-full h-2\">\r\n            <div \r\n              className=\"bg-blue-500 h-2 rounded-full transition-all duration-300\"\r\n              style={{ \r\n                width: `${study.cards?.length ? ((study.currentIndex + 1) / study.cards.length) * 100 : 0}%`\r\n              }}\r\n            />\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      {/* Main Content */}\r\n      <div className=\"max-w-2xl mx-auto px-4 py-8\">\r\n        {/* Korean Prompt Card - Only show in Writing mode */}\r\n        {learningMode.mode === 'writing' && (\r\n          <div className=\"bg-white rounded-lg shadow-lg p-8 mb-8\">\r\n            <div className=\"text-center\">\r\n              <h2 className=\"text-sm font-medium text-gray-500 mb-2\">한국어를 영어로</h2>\r\n              <p className=\"text-2xl font-bold text-gray-800 mb-6\">\r\n                {study.currentCard.front_ko}\r\n              </p>\r\n              \r\n              {/* Expected Answer (shown after feedback) */}\r\n              {study.feedback && (\r\n                <div className=\"text-sm text-gray-600 bg-gray-50 rounded p-3\">\r\n                  <span className=\"font-medium\">정답: </span>\r\n                  {study.currentCard.target_en}\r\n                </div>\r\n              )}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n\r\n\r\n        {/* Input Section - Conditional Rendering Based on Learning Mode */}\r\n        <div className=\"mb-8\">\r\n          {learningMode.mode === 'writing' ? (\r\n            <div className=\"bg-white rounded-lg shadow-lg p-8\">\r\n              <div className=\"text-center\">\r\n                <WritingModeInput\r\n                  question={{\r\n                    id: study.currentCard.id,\r\n                    front_ko: study.currentCard.front_ko,\r\n                    target_en: study.currentCard.target_en,\r\n                    level: user.level,\r\n                    stage: user.stage,\r\n                    difficulty: 'medium'\r\n                  }}\r\n                  value={writingInputValue}\r\n                  onInputChange={setWritingInputValue}\r\n                  onSubmit={handleWritingSubmit}\r\n                  onAutoNext={handleNextCard}\r\n                  disabled={ui.isLoading || !!writingFeedback}\r\n                />\r\n              </div>\r\n            </div>\r\n          ) : (\r\n            <div className=\"bg-white rounded-lg shadow-lg p-8\">\r\n              <PatternTrainingFlowFinal\r\n                koreanText={study.currentCard.front_ko}\r\n                expectedEnglish={study.currentCard.target_en}\r\n                onResult={handlePatternTrainingResult}\r\n                onError={(error) => setError(error)}\r\n                stage={speakingStage.stage}\r\n                disabled={ui.isLoading || !!study.feedback || !isTrainingRunning || isTrainingPaused}\r\n                autoStart={isTrainingRunning && !isTrainingPaused && !study.feedback}\r\n                className=\"text-center\"\r\n                showCorrectAnswer={true}\r\n                mistakeId={undefined}\r\n              />\r\n            </div>\r\n          )}\r\n        </div>\r\n\r\n        {/* Feedback Section - Conditional Rendering Based on Learning Mode */}\r\n        {learningMode.mode === 'writing' && writingFeedback && (\r\n          <WritingModeFeedback\r\n            feedback={writingFeedback}\r\n            targetAnswer={study.currentCard.target_en}\r\n            onPlayAnswer={() => speech.speak(study.currentCard!.target_en)}\r\n            canPlayAnswer={speech.isTTSAvailable}\r\n          />\r\n        )}\r\n\r\n        {learningMode.mode === 'speaking' && study.feedback && (\r\n          <>\r\n            <FeedbackPanel\r\n              feedback={study.feedback}\r\n              onPlayAnswer={() => speech.speak(study.currentCard!.target_en)}\r\n              canPlayAnswer={speech.isTTSAvailable}\r\n            />\r\n            \r\n            {/* 자동 진행 안내 */}\r\n            {autoNextCountdown > 0 && (\r\n              <div className=\"bg-green-50 border border-green-200 rounded-lg p-4 text-center mb-6\">\r\n                <div className=\"text-green-800\">\r\n                  <div className=\"text-lg font-semibold mb-2\">✅ 답변 완료!</div>\r\n                  <div className=\"text-sm\">\r\n                    {autoNextCountdown}초 후 다음 문제로 이동합니다...\r\n                  </div>\r\n                  <div className=\"mt-2\">\r\n                    <button\r\n                      onClick={handleNextCard}\r\n                      className=\"px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 text-sm\"\r\n                    >\r\n                      지금 이동하기\r\n                    </button>\r\n                  </div>\r\n                </div>\r\n              </div>\r\n            )}\r\n          </>\r\n        )}\r\n\r\n        {/* Training Controls - Speaking 모드에서만 표시하되, PatternTrainingFlow가 idle 상태일 때만 */}\r\n        {learningMode.mode === 'speaking' && (\r\n          <div className=\"flex justify-center gap-4 mb-6\">\r\n            {!isTrainingRunning ? (\r\n              <button\r\n                onClick={handleStartTraining}\r\n                className=\"px-6 py-3 bg-gradient-to-r from-green-500 to-green-600 text-white font-bold rounded-lg hover:from-green-600 hover:to-green-700 transition-all duration-200 transform hover:scale-105 shadow-lg\"\r\n              >\r\n                🚀 시작하기\r\n              </button>\r\n            ) : (\r\n              <div className=\"flex gap-4\">\r\n                {!isTrainingPaused ? (\r\n                  <button\r\n                    onClick={handlePauseTraining}\r\n                    className=\"px-6 py-3 bg-gradient-to-r from-yellow-500 to-orange-500 text-white font-bold rounded-lg hover:from-yellow-600 hover:to-orange-600 transition-all duration-200 transform hover:scale-105 shadow-lg\"\r\n                  >\r\n                    ⏸️ 일시정지\r\n                  </button>\r\n                ) : (\r\n                  <button\r\n                    onClick={handleResumeTraining}\r\n                    className=\"px-6 py-3 bg-gradient-to-r from-green-500 to-green-600 text-white font-bold rounded-lg hover:from-green-600 hover:to-green-700 transition-all duration-200 transform hover:scale-105 shadow-lg\"\r\n                  >\r\n                    ▶️ 재개\r\n                  </button>\r\n                )}\r\n                <button\r\n                  onClick={handleResetTraining}\r\n                  className=\"px-6 py-3 bg-gradient-to-r from-red-500 to-red-600 text-white font-bold rounded-lg hover:from-red-600 hover:to-red-700 transition-all duration-200 transform hover:scale-105 shadow-lg\"\r\n                >\r\n                  🔄 다시하기\r\n                </button>\r\n              </div>\r\n            )}\r\n          </div>\r\n        )}\r\n\r\n        {/* Navigation Controls */}\r\n        <div className=\"flex justify-between items-center\">\r\n          <button\r\n            onClick={handlePreviousCard}\r\n            disabled={study.currentIndex === 0}\r\n            className=\"px-6 py-3 bg-gray-500 text-white rounded-lg disabled:bg-gray-300 disabled:cursor-not-allowed hover:bg-gray-600 transition-colors\"\r\n          >\r\n            ← 이전 카드\r\n          </button>\r\n\r\n          <div className=\"flex space-x-2\">\r\n            {(study.feedback || writingFeedback) && (\r\n              <button\r\n                onClick={() => speech.speak(study.currentCard!.target_en)}\r\n                disabled={!speech.isTTSAvailable}\r\n                className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:bg-gray-300 text-sm\"\r\n              >\r\n                🔊 정답 듣기\r\n              </button>\r\n            )}\r\n          </div>\r\n\r\n          {study.cards?.length && study.currentIndex < study.cards.length - 1 ? (\r\n            <button\r\n              onClick={handleNextCard}\r\n              className=\"px-6 py-3 bg-green-500 text-white rounded-lg hover:bg-green-600 transition-colors\"\r\n            >\r\n              다음 카드 →\r\n            </button>\r\n          ) : (\r\n            <button\r\n              onClick={handleNextCard}\r\n              className=\"px-6 py-3 bg-purple-500 text-white rounded-lg hover:bg-purple-600 transition-colors\"\r\n            >\r\n              세션 완료\r\n            </button>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\pages\\VocabularyPage.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isPlaying' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":17,"column":56,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'vocabularyWords' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":20,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":20,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onStatusChange' is defined but never used. Allowed unused args must match /^_/u.","line":355,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":355,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'onPlayExample' is defined but never used. Allowed unused args must match /^_/u.","line":358,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":358,"endColumn":16},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":371,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":371,"endColumn":28},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":375,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":375,"endColumn":36},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":377,"column":18,"nodeType":"Identifier","messageId":"undef","endLine":377,"endColumn":27},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":425,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":425,"endColumn":30},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":429,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":429,"endColumn":38},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":431,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":431,"endColumn":29},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":492,"column":21,"nodeType":"Identifier","messageId":"undef","endLine":492,"endColumn":30},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":496,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":496,"endColumn":38},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":498,"column":20,"nodeType":"Identifier","messageId":"undef","endLine":498,"endColumn":29},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":576,"column":27,"nodeType":"Identifier","messageId":"undef","endLine":576,"endColumn":36},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":580,"column":35,"nodeType":"Identifier","messageId":"undef","endLine":580,"endColumn":44},{"ruleId":"no-undef","severity":1,"message":"'isPlaying' is not defined.","line":582,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":582,"endColumn":35}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":16,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * VocabularyPage - 단어장 메인 페이지\r\n * - 레벨별/카테고리별 단어 목록 표시\r\n * - 검색, 필터링, 정렬 기능\r\n * - 단어 학습 상태 관리 및 즐겨찾기\r\n * - SRS 기반 복습 단어 추천\r\n */\r\n\r\nimport React, { useState, useMemo } from 'react';\r\nimport { useNavigate } from 'react-router-dom';\r\nimport { useVocabulary } from '@/hooks/useVocabulary';\r\nimport { useAudioManager } from '@/hooks/useAudioManager';\r\nimport { VocabularyWord, UserVocabularyProgress } from '@/services/vocabularyService';\r\n\r\nexport const VocabularyPage: React.FC = () => {\r\n  const navigate = useNavigate();\r\n  const { playEnglishTTS, playKoreanTTS, stopAllAudio, isPlaying } = useAudioManager();\r\n  \r\n  const {\r\n    vocabularyWords,\r\n    filteredWords,\r\n    stats,\r\n    isLoading,\r\n    error,\r\n    filters,\r\n    setFilters,\r\n    clearFilters,\r\n    searchWords,\r\n    updateWordStatus,\r\n    toggleFavorite,\r\n    getWordsForReview,\r\n    getNewWordsToLearn,\r\n    refreshVocabulary\r\n  } = useVocabulary();\r\n\r\n  // 로컬 상태\r\n  const [selectedWord, setSelectedWord] = useState<VocabularyWord | null>(null);\r\n  const [viewMode, setViewMode] = useState<'list' | 'cards'>('list');\r\n  const [sortBy, setSortBy] = useState<'frequency' | 'alphabetical' | 'level'>('frequency');\r\n\r\n  // 복습 및 신규 단어\r\n  const reviewWords = useMemo(() => getWordsForReview(), [getWordsForReview]);\r\n  const newWords = useMemo(() => getNewWordsToLearn(20), [getNewWordsToLearn]);\r\n\r\n  // 정렬된 단어 목록\r\n  const sortedWords = useMemo(() => {\r\n    const sorted = [...filteredWords];\r\n    switch (sortBy) {\r\n      case 'alphabetical':\r\n        return sorted.sort((a, b) => a.word.localeCompare(b.word));\r\n      case 'level':\r\n        return sorted.sort((a, b) => a.level - b.level || b.frequency - a.frequency);\r\n      case 'frequency':\r\n      default:\r\n        return sorted.sort((a, b) => b.frequency - a.frequency);\r\n    }\r\n  }, [filteredWords, sortBy]);\r\n\r\n  // 단어 발음 재생 (중복 방지)\r\n  const playWordPronunciation = async (word: VocabularyWord) => {\r\n    stopAllAudio(); // 기존 음성 중단\r\n    setTimeout(() => playEnglishTTS(word.word), 50);\r\n  };\r\n\r\n  // 예문 발음 재생 (중복 방지)\r\n  const playExample = async (sentence: string, translation: string) => {\r\n    stopAllAudio(); // 기존 음성 중단\r\n    setTimeout(async () => {\r\n      await playEnglishTTS(sentence);\r\n      setTimeout(() => playKoreanTTS(translation), 2000);\r\n    }, 50);\r\n  };\r\n\r\n  // 단어 상태 변경 핸들러\r\n  const handleWordStatusChange = (wordId: string, status: UserVocabularyProgress['status']) => {\r\n    updateWordStatus(wordId, status);\r\n  };\r\n\r\n  // 즐겨찾기 토글\r\n  const handleToggleFavorite = (wordId: string) => {\r\n    toggleFavorite(wordId);\r\n  };\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\r\n        <div className=\"text-center\">\r\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-blue-500 mx-auto mb-4\"></div>\r\n          <p className=\"text-gray-600 dark:text-gray-300\">단어장을 불러오는 중...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (error) {\r\n    return (\r\n      <div className=\"min-h-screen bg-gray-50 flex items-center justify-center\">\r\n        <div className=\"text-center\">\r\n          <div className=\"text-red-500 text-6xl mb-4\">⚠️</div>\r\n          <h2 className=\"text-xl font-semibold text-gray-800 dark:text-white mb-2\">오류 발생</h2>\r\n          <p className=\"text-gray-600 dark:text-gray-300 mb-4\">{error}</p>\r\n          <button\r\n            onClick={refreshVocabulary}\r\n            className=\"px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors\"\r\n          >\r\n            다시 시도\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"min-h-screen bg-gray-50\">\r\n      {/* Header */}\r\n      <div className=\"bg-white shadow-sm border-b\">\r\n        <div className=\"max-w-6xl mx-auto px-4 py-4\">\r\n          <div className=\"flex items-center justify-between\">\r\n            <div className=\"flex items-center gap-4\">\r\n              <button\r\n                onClick={() => navigate('/')}\r\n                className=\"p-2 hover:bg-gray-100 rounded-lg transition-colors\"\r\n              >\r\n                <svg className=\"w-6 h-6 text-gray-600 dark:text-gray-300\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 19l-7-7 7-7\" />\r\n                </svg>\r\n              </button>\r\n              <div>\r\n                <h1 className=\"text-2xl font-bold text-gray-800 dark:text-white\">📖 단어장</h1>\r\n                <p className=\"text-sm text-gray-600 dark:text-gray-300\">패턴 학습 기반 어휘 관리</p>\r\n              </div>\r\n            </div>\r\n            \r\n            {/* 통계 요약 */}\r\n            <div className=\"flex items-center gap-6 text-sm\">\r\n              <div className=\"text-center\">\r\n                <div className=\"text-lg font-bold text-blue-600\">{stats.totalWords}</div>\r\n                <div className=\"text-gray-600 dark:text-gray-300\">전체</div>\r\n              </div>\r\n              <div className=\"text-center\">\r\n                <div className=\"text-lg font-bold text-green-600\">{stats.knownWords}</div>\r\n                <div className=\"text-gray-600 dark:text-gray-300\">학습완료</div>\r\n              </div>\r\n              <div className=\"text-center\">\r\n                <div className=\"text-lg font-bold text-orange-600\">{reviewWords.length}</div>\r\n                <div className=\"text-gray-600 dark:text-gray-300\">복습필요</div>\r\n              </div>\r\n              <div className=\"text-center\">\r\n                <div className=\"text-lg font-bold text-purple-600\">{newWords.length}</div>\r\n                <div className=\"text-gray-600 dark:text-gray-300\">신규학습</div>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n      </div>\r\n\r\n      <div className=\"max-w-6xl mx-auto px-4 py-6\">\r\n        {/* 빠른 액션 버튼 */}\r\n        {(reviewWords.length > 0 || newWords.length > 0) && (\r\n          <div className=\"mb-6\">\r\n            <h2 className=\"text-lg font-semibold text-gray-800 dark:text-white mb-3\">📚 추천 학습</h2>\r\n            <div className=\"flex gap-4\">\r\n              {reviewWords.length > 0 && (\r\n                <button className=\"flex-1 p-4 bg-orange-50 border border-orange-200 rounded-lg hover:bg-orange-100 transition-colors\">\r\n                  <div className=\"text-left\">\r\n                    <div className=\"text-orange-800 font-semibold\">복습하기</div>\r\n                    <div className=\"text-orange-600 text-sm\">{reviewWords.length}개 단어가 복습을 기다리고 있습니다</div>\r\n                  </div>\r\n                </button>\r\n              )}\r\n              {newWords.length > 0 && (\r\n                <button className=\"flex-1 p-4 bg-blue-50 border border-blue-200 rounded-lg hover:bg-blue-100 transition-colors\">\r\n                  <div className=\"text-left\">\r\n                    <div className=\"text-blue-800 font-semibold\">새 단어 학습</div>\r\n                    <div className=\"text-blue-600 text-sm\">{newWords.length}개 새 단어를 학습할 수 있습니다</div>\r\n                  </div>\r\n                </button>\r\n              )}\r\n            </div>\r\n          </div>\r\n        )}\r\n\r\n        {/* 검색 및 필터 */}\r\n        <div className=\"bg-white dark:bg-gray-800 rounded-lg transition-colors duration-300 shadow p-4 mb-6\">\r\n          <div className=\"flex flex-col lg:flex-row gap-4\">\r\n            {/* 검색창 */}\r\n            <div className=\"flex-1\">\r\n              <div className=\"relative\">\r\n                <input\r\n                  type=\"text\"\r\n                  placeholder=\"단어 검색... (영어 또는 한국어)\"\r\n                  value={filters.searchQuery || ''}\r\n                  onChange={(e) => searchWords(e.target.value)}\r\n                  className=\"w-full pl-10 pr-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n                />\r\n                <svg className=\"w-5 h-5 text-gray-400 absolute left-3 top-1/2 transform -translate-y-1/2\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                  <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z\" />\r\n                </svg>\r\n              </div>\r\n            </div>\r\n\r\n            {/* 필터 */}\r\n            <div className=\"flex gap-2\">\r\n              <select\r\n                value={filters.level || ''}\r\n                onChange={(e) => setFilters({ level: e.target.value ? parseInt(e.target.value) : undefined })}\r\n                className=\"px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n              >\r\n                <option value=\"\">모든 레벨</option>\r\n                {Array.from({length: 10}, (_, i) => (\r\n                  <option key={i + 1} value={i + 1}>Level {i + 1}</option>\r\n                ))}\r\n              </select>\r\n\r\n              <select\r\n                value={filters.category || ''}\r\n                onChange={(e) => setFilters({ category: e.target.value as VocabularyWord['category'] || undefined })}\r\n                className=\"px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n              >\r\n                <option value=\"\">모든 품사</option>\r\n                <option value=\"noun\">명사</option>\r\n                <option value=\"verb\">동사</option>\r\n                <option value=\"adjective\">형용사</option>\r\n                <option value=\"adverb\">부사</option>\r\n                <option value=\"pronoun\">대명사</option>\r\n                <option value=\"preposition\">전치사</option>\r\n              </select>\r\n\r\n              <select\r\n                value={filters.status || ''}\r\n                onChange={(e) => setFilters({ status: e.target.value as UserVocabularyProgress['status'] || undefined })}\r\n                className=\"px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500\"\r\n              >\r\n                <option value=\"\">모든 상태</option>\r\n                <option value=\"unknown\">모름</option>\r\n                <option value=\"learning\">학습중</option>\r\n                <option value=\"known\">알고 있음</option>\r\n                <option value=\"review\">복습 필요</option>\r\n              </select>\r\n\r\n              <button\r\n                onClick={() => setFilters({ onlyFavorites: !filters.onlyFavorites })}\r\n                className={`px-3 py-2 border rounded-lg transition-colors ${\r\n                  filters.onlyFavorites \r\n                    ? 'bg-yellow-100 border-yellow-300 text-yellow-800' \r\n                    : 'border-gray-300 text-gray-600 dark:text-gray-300 hover:bg-gray-50'\r\n                }`}\r\n              >\r\n                ⭐ 즐겨찾기\r\n              </button>\r\n\r\n              <button\r\n                onClick={clearFilters}\r\n                className=\"px-3 py-2 text-gray-600 dark:text-gray-300 hover:text-gray-800 dark:text-white transition-colors\"\r\n              >\r\n                초기화\r\n              </button>\r\n            </div>\r\n          </div>\r\n\r\n          {/* 정렬 및 뷰 모드 */}\r\n          <div className=\"flex justify-between items-center mt-4 pt-4 border-t border-gray-200\">\r\n            <div className=\"flex items-center gap-2\">\r\n              <span className=\"text-sm text-gray-600 dark:text-gray-300\">정렬:</span>\r\n              <select\r\n                value={sortBy}\r\n                onChange={(e) => setSortBy(e.target.value as typeof sortBy)}\r\n                className=\"text-sm border border-gray-300 rounded px-2 py-1\"\r\n              >\r\n                <option value=\"frequency\">빈도순</option>\r\n                <option value=\"alphabetical\">알파벳순</option>\r\n                <option value=\"level\">레벨순</option>\r\n              </select>\r\n            </div>\r\n\r\n            <div className=\"flex items-center gap-2\">\r\n              <span className=\"text-sm text-gray-600 dark:text-gray-300\">{sortedWords.length}개 단어</span>\r\n              <div className=\"flex border border-gray-300 rounded overflow-hidden\">\r\n                <button\r\n                  onClick={() => setViewMode('list')}\r\n                  className={`px-3 py-1 text-sm ${viewMode === 'list' ? 'bg-blue-500 text-white' : 'text-gray-600 dark:text-gray-300 hover:bg-gray-50'}`}\r\n                >\r\n                  목록\r\n                </button>\r\n                <button\r\n                  onClick={() => setViewMode('cards')}\r\n                  className={`px-3 py-1 text-sm ${viewMode === 'cards' ? 'bg-blue-500 text-white' : 'text-gray-600 dark:text-gray-300 hover:bg-gray-50'}`}\r\n                >\r\n                  카드\r\n                </button>\r\n              </div>\r\n            </div>\r\n          </div>\r\n        </div>\r\n\r\n        {/* 단어 목록 */}\r\n        {sortedWords.length === 0 ? (\r\n          <div className=\"text-center py-12\">\r\n            <div className=\"text-gray-400 text-6xl mb-4\">📝</div>\r\n            <p className=\"text-gray-600 dark:text-gray-300\">조건에 맞는 단어를 찾을 수 없습니다.</p>\r\n            <button\r\n              onClick={clearFilters}\r\n              className=\"mt-4 px-4 py-2 text-blue-600 hover:text-blue-800 transition-colors\"\r\n            >\r\n              필터 초기화\r\n            </button>\r\n          </div>\r\n        ) : (\r\n          <div className={`grid gap-4 ${viewMode === 'cards' ? 'grid-cols-1 md:grid-cols-2 lg:grid-cols-3' : 'grid-cols-1'}`}>\r\n            {sortedWords.map((word) => (\r\n              <VocabularyWordItem\r\n                key={word.id}\r\n                word={word}\r\n                viewMode={viewMode}\r\n                onStatusChange={handleWordStatusChange}\r\n                onToggleFavorite={handleToggleFavorite}\r\n                onPlayWord={() => playWordPronunciation(word)}\r\n                onPlayExample={playExample}\r\n                onSelectWord={() => setSelectedWord(word)}\r\n              />\r\n            ))}\r\n          </div>\r\n        )}\r\n      </div>\r\n\r\n      {/* 단어 상세 모달 */}\r\n      {selectedWord && (\r\n        <VocabularyWordModal\r\n          word={selectedWord}\r\n          onClose={() => setSelectedWord(null)}\r\n          onStatusChange={handleWordStatusChange}\r\n          onToggleFavorite={handleToggleFavorite}\r\n          onPlayWord={() => playWordPronunciation(selectedWord)}\r\n          onPlayExample={playExample}\r\n        />\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\n// 단어 아이템 컴포넌트\r\ninterface VocabularyWordItemProps {\r\n  word: VocabularyWord;\r\n  viewMode: 'list' | 'cards';\r\n  onStatusChange: (wordId: string, status: UserVocabularyProgress['status']) => void;\r\n  onToggleFavorite: (wordId: string) => void;\r\n  onPlayWord: () => void;\r\n  onPlayExample: (sentence: string, translation: string) => void;\r\n  onSelectWord: () => void;\r\n}\r\n\r\nconst VocabularyWordItem: React.FC<VocabularyWordItemProps> = ({\r\n  word,\r\n  viewMode,\r\n  onStatusChange,\r\n  onToggleFavorite,\r\n  onPlayWord,\r\n  onPlayExample,\r\n  onSelectWord\r\n}) => {\r\n  if (viewMode === 'cards') {\r\n    return (\r\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg transition-colors duration-300 shadow hover:shadow-md transition-shadow p-4 cursor-pointer\" onClick={onSelectWord}>\r\n        <div className=\"flex justify-between items-start mb-3\">\r\n          <div className=\"flex-1\">\r\n            <div className=\"flex items-center gap-2\">\r\n              <h3 className=\"text-lg font-semibold text-gray-800 dark:text-white\">{word.word}</h3>\r\n              <button \r\n                onClick={(e) => { e.stopPropagation(); onPlayWord(); }}\r\n                className={`p-1 transition-colors ${\r\n                  isPlaying \r\n                    ? 'text-gray-400 cursor-not-allowed' \r\n                    : 'text-blue-500 hover:text-blue-700'\r\n                }`}\r\n                disabled={isPlaying}\r\n              >\r\n                {isPlaying ? '⏸️' : '🔊'}\r\n              </button>\r\n            </div>\r\n            <p className=\"text-gray-600 dark:text-gray-300\">{word.translation}</p>\r\n            <div className=\"flex items-center gap-2 mt-2\">\r\n              <span className={`px-2 py-1 text-xs rounded ${\r\n                word.difficulty === 'basic' ? 'bg-green-100 text-green-800' :\r\n                word.difficulty === 'intermediate' ? 'bg-yellow-100 text-yellow-800' :\r\n                'bg-red-100 text-red-800'\r\n              }`}>\r\n                {word.difficulty}\r\n              </span>\r\n              <span className=\"px-2 py-1 text-xs bg-gray-100 text-gray-800 dark:text-white rounded\">\r\n                Lv.{word.level}\r\n              </span>\r\n              <span className=\"px-2 py-1 text-xs bg-blue-100 text-blue-800 rounded\">\r\n                {word.category}\r\n              </span>\r\n            </div>\r\n          </div>\r\n          <button\r\n            onClick={(e) => { e.stopPropagation(); onToggleFavorite(word.id); }}\r\n            className=\"text-yellow-500 hover:text-yellow-600 transition-colors\"\r\n          >\r\n            ⭐\r\n          </button>\r\n        </div>\r\n        {word.examples.length > 0 && (\r\n          <div className=\"border-t pt-3\">\r\n            <p className=\"text-sm text-gray-600 dark:text-gray-300\">{word.examples[0].sentence}</p>\r\n            <p className=\"text-sm text-gray-500\">{word.examples[0].translation}</p>\r\n          </div>\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"bg-white dark:bg-gray-800 rounded-lg transition-colors duration-300 shadow hover:shadow-md transition-shadow p-4\">\r\n      <div className=\"flex items-center justify-between\">\r\n        <div className=\"flex-1 cursor-pointer\" onClick={onSelectWord}>\r\n          <div className=\"flex items-center gap-3\">\r\n            <div>\r\n              <div className=\"flex items-center gap-2\">\r\n                <h3 className=\"text-lg font-semibold text-gray-800 dark:text-white\">{word.word}</h3>\r\n                <button \r\n                  onClick={(e) => { e.stopPropagation(); onPlayWord(); }}\r\n                  className={`p-1 transition-colors ${\r\n                    isPlaying \r\n                      ? 'text-gray-400 cursor-not-allowed' \r\n                      : 'text-blue-500 hover:text-blue-700'\r\n                  }`}\r\n                  disabled={isPlaying}\r\n                >\r\n                  {isPlaying ? '⏸️' : '🔊'}\r\n                </button>\r\n              </div>\r\n              <p className=\"text-gray-600 dark:text-gray-300\">{word.translation}</p>\r\n            </div>\r\n          </div>\r\n        </div>\r\n        \r\n        <div className=\"flex items-center gap-2\">\r\n          <span className={`px-2 py-1 text-xs rounded ${\r\n            word.difficulty === 'basic' ? 'bg-green-100 text-green-800' :\r\n            word.difficulty === 'intermediate' ? 'bg-yellow-100 text-yellow-800' :\r\n            'bg-red-100 text-red-800'\r\n          }`}>\r\n            {word.difficulty}\r\n          </span>\r\n          <span className=\"px-2 py-1 text-xs bg-gray-100 text-gray-800 dark:text-white rounded\">\r\n            Lv.{word.level}\r\n          </span>\r\n          <button\r\n            onClick={() => onToggleFavorite(word.id)}\r\n            className=\"text-yellow-500 hover:text-yellow-600 transition-colors\"\r\n          >\r\n            ⭐\r\n          </button>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\n// 단어 상세 모달 컴포넌트\r\ninterface VocabularyWordModalProps {\r\n  word: VocabularyWord;\r\n  onClose: () => void;\r\n  onStatusChange: (wordId: string, status: UserVocabularyProgress['status']) => void;\r\n  onToggleFavorite: (wordId: string) => void;\r\n  onPlayWord: () => void;\r\n  onPlayExample: (sentence: string, translation: string) => void;\r\n}\r\n\r\nconst VocabularyWordModal: React.FC<VocabularyWordModalProps> = ({\r\n  word,\r\n  onClose,\r\n  onStatusChange,\r\n  onToggleFavorite,\r\n  onPlayWord,\r\n  onPlayExample\r\n}) => {\r\n  return (\r\n    <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\r\n      <div className=\"bg-white dark:bg-gray-800 rounded-lg transition-colors duration-300 max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto\">\r\n        <div className=\"p-6\">\r\n          {/* 헤더 */}\r\n          <div className=\"flex justify-between items-start mb-4\">\r\n            <div className=\"flex-1\">\r\n              <div className=\"flex items-center gap-3 mb-2\">\r\n                <h2 className=\"text-2xl font-bold text-gray-800 dark:text-white\">{word.word}</h2>\r\n                <button \r\n                  onClick={onPlayWord}\r\n                  className={`p-2 transition-colors ${\r\n                    isPlaying \r\n                      ? 'text-gray-400 cursor-not-allowed' \r\n                      : 'text-blue-500 hover:text-blue-700'\r\n                  }`}\r\n                  disabled={isPlaying}\r\n                >\r\n                  {isPlaying ? '⏸️' : '🔊'}\r\n                </button>\r\n                <button\r\n                  onClick={() => onToggleFavorite(word.id)}\r\n                  className=\"text-yellow-500 hover:text-yellow-600 transition-colors\"\r\n                >\r\n                  ⭐\r\n                </button>\r\n              </div>\r\n              <p className=\"text-xl text-gray-600 dark:text-gray-300 mb-4\">{word.translation}</p>\r\n              \r\n              <div className=\"flex flex-wrap gap-2\">\r\n                <span className={`px-3 py-1 text-sm rounded-full ${\r\n                  word.difficulty === 'basic' ? 'bg-green-100 text-green-800' :\r\n                  word.difficulty === 'intermediate' ? 'bg-yellow-100 text-yellow-800' :\r\n                  'bg-red-100 text-red-800'\r\n                }`}>\r\n                  {word.difficulty}\r\n                </span>\r\n                <span className=\"px-3 py-1 text-sm bg-gray-100 text-gray-800 dark:text-white rounded-full\">\r\n                  Level {word.level}\r\n                </span>\r\n                <span className=\"px-3 py-1 text-sm bg-blue-100 text-blue-800 rounded-full\">\r\n                  {word.category}\r\n                </span>\r\n                <span className=\"px-3 py-1 text-sm bg-purple-100 text-purple-800 rounded-full\">\r\n                  빈도: {word.frequency}회\r\n                </span>\r\n              </div>\r\n            </div>\r\n            \r\n            <button\r\n              onClick={onClose}\r\n              className=\"text-gray-400 hover:text-gray-600 dark:text-gray-300 transition-colors\"\r\n            >\r\n              <svg className=\"w-6 h-6\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n                <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\r\n              </svg>\r\n            </button>\r\n          </div>\r\n\r\n          {/* 학습 상태 설정 */}\r\n          <div className=\"mb-6\">\r\n            <h3 className=\"font-semibold text-gray-800 dark:text-white mb-3\">학습 상태</h3>\r\n            <div className=\"grid grid-cols-2 md:grid-cols-4 gap-2\">\r\n              {[\r\n                { status: 'unknown' as const, label: '모름', color: 'gray' },\r\n                { status: 'learning' as const, label: '학습중', color: 'yellow' },\r\n                { status: 'known' as const, label: '알고 있음', color: 'green' },\r\n                { status: 'review' as const, label: '복습 필요', color: 'orange' }\r\n              ].map(({ status, label, color }) => (\r\n                <button\r\n                  key={status}\r\n                  onClick={() => onStatusChange(word.id, status)}\r\n                  className={`px-4 py-2 text-sm font-medium rounded-lg transition-colors\r\n                    ${color === 'gray' ? 'bg-gray-100 text-gray-800 dark:text-white hover:bg-gray-200' :\r\n                      color === 'yellow' ? 'bg-yellow-100 text-yellow-800 hover:bg-yellow-200' :\r\n                      color === 'green' ? 'bg-green-100 text-green-800 hover:bg-green-200' :\r\n                      'bg-orange-100 text-orange-800 hover:bg-orange-200'}`}\r\n                >\r\n                  {label}\r\n                </button>\r\n              ))}\r\n            </div>\r\n          </div>\r\n\r\n          {/* 예문 */}\r\n          {word.examples.length > 0 && (\r\n            <div>\r\n              <h3 className=\"font-semibold text-gray-800 dark:text-white mb-3\">예문</h3>\r\n              <div className=\"space-y-4\">\r\n                {word.examples.map((example, index) => (\r\n                  <div key={index} className=\"p-4 bg-gray-50 rounded-lg\">\r\n                    <div className=\"flex items-start gap-2 mb-2\">\r\n                      <p className=\"flex-1 text-gray-800 dark:text-white\">{example.sentence}</p>\r\n                      <button\r\n                        onClick={() => onPlayExample(example.sentence, example.translation)}\r\n                        className={`transition-colors ${\r\n                          isPlaying \r\n                            ? 'text-gray-400 cursor-not-allowed' \r\n                            : 'text-blue-500 hover:text-blue-700'\r\n                        }`}\r\n                        disabled={isPlaying}\r\n                      >\r\n                        {isPlaying ? '⏸️' : '🔊'}\r\n                      </button>\r\n                    </div>\r\n                    <p className=\"text-gray-600 dark:text-gray-300\">{example.translation}</p>\r\n                    <p className=\"text-xs text-gray-500 mt-2\">출처: {example.stageId}</p>\r\n                  </div>\r\n                ))}\r\n              </div>\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default VocabularyPage;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\PluginManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PluginConfigEntry' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'loadedInfo' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":267,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":267,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 통합 플러그인 매니저 (Facade Pattern)\r\n * @description 모든 플러그인 기능을 통합하여 간단한 API 제공\r\n */\r\n\r\nimport { IPlugin, IPluginFactory, PluginStatus } from './core/IPlugin';\r\nimport { pluginRegistry } from './core/PluginRegistry';\r\nimport { pluginLifecycle } from './core/PluginLifecycleManager';\r\nimport { pluginConfig, PluginConfigEntry } from './config/PluginConfig';\r\nimport { ISpeechPlugin } from './speech/ISpeechPlugin';\r\nimport { WebSpeechPluginFactory } from './speech/WebSpeechPluginFactory';\r\nimport { ISpeedTrainingPlugin } from './speed/ISpeedTrainingPlugin';\r\nimport { SpeedTrainingPluginFactory } from './speed/SpeedTrainingPluginFactory';\r\nimport { IPerformancePlugin } from './performance/IPerformancePlugin';\r\nimport { PerformancePluginFactory } from './performance/PerformancePluginFactory';\r\nimport { NonEmptyString, Result, Ok, Err, assertNonEmptyString, isNonEmptyString } from '@/types/core';\r\n\r\n// 플러그인 초기화 옵션\r\nexport interface PluginManagerOptions {\r\n  readonly environment?: 'development' | 'production' | 'test';\r\n  readonly autoLoad?: boolean;\r\n  readonly enableMetrics?: boolean;\r\n  readonly loadTimeout?: number;\r\n}\r\n\r\n// 플러그인 조회 결과\r\nexport interface PluginInfo {\r\n  readonly name: NonEmptyString;\r\n  readonly status: PluginStatus;\r\n  readonly implementation: string;\r\n  readonly enabled: boolean;\r\n  readonly loadTime?: number;\r\n  readonly errorCount?: number;\r\n}\r\n\r\n/**\r\n * 통합 플러그인 매니저\r\n * @description 플러그인 시스템의 모든 기능을 통합한 단일 인터페이스\r\n */\r\nexport class PluginManager {\r\n  private static instance: PluginManager;\r\n  private initialized = false;\r\n\r\n  private constructor() {}\r\n\r\n  static getInstance(): PluginManager {\r\n    if (!PluginManager.instance) {\r\n      PluginManager.instance = new PluginManager();\r\n    }\r\n    return PluginManager.instance;\r\n  }\r\n\r\n  /**\r\n   * 플러그인 시스템 초기화\r\n   */\r\n  async initialize(options: PluginManagerOptions = {}): Promise<Result<void>> {\r\n    if (this.initialized) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    try {\r\n      console.log('🔌 Initializing Plugin System...');\r\n\r\n      // 1. 기본 플러그인 팩토리들 등록\r\n      await this.registerBuiltinPlugins();\r\n\r\n      // 2. 설정에서 로컬 스토리지 로드\r\n      const loadConfigResult = pluginConfig.loadFromStorage();\r\n      if (loadConfigResult.success) {\r\n        console.log('📋 Plugin configuration loaded from storage');\r\n      }\r\n\r\n      // 3. 자동 로드 활성화된 플러그인들 로드\r\n      if (options.autoLoad !== false) {\r\n        await this.autoLoadPlugins();\r\n      }\r\n\r\n      // 4. 메트릭스 수집 시작\r\n      if (options.enableMetrics !== false) {\r\n        this.startMetricsCollection();\r\n      }\r\n\r\n      this.initialized = true;\r\n      console.log('✅ Plugin System initialized successfully');\r\n      \r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      console.error('❌ Plugin System initialization failed:', error);\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 내장 플러그인들 등록\r\n   */\r\n  private async registerBuiltinPlugins(): Promise<void> {\r\n    const builtinPlugins: Array<{\r\n      name: NonEmptyString;\r\n      factory: IPluginFactory;\r\n    }> = [\r\n      {\r\n        name: assertNonEmptyString('speech', 'plugin name'),\r\n        factory: new WebSpeechPluginFactory()\r\n      },\r\n      {\r\n        name: assertNonEmptyString('speed-training', 'plugin name'),\r\n        factory: new SpeedTrainingPluginFactory()\r\n      },\r\n      {\r\n        name: assertNonEmptyString('performance', 'plugin name'),\r\n        factory: new PerformancePluginFactory()\r\n      }\r\n      // 향후 다른 플러그인들 추가\r\n    ];\r\n\r\n    for (const { name, factory } of builtinPlugins) {\r\n      const result = await pluginLifecycle.registerPlugin(name, factory);\r\n      if (result.success) {\r\n        console.log(`📦 Registered plugin: ${name}`);\r\n      } else {\r\n        console.warn(`⚠️ Failed to register plugin ${name}:`, result.error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 자동 로드 대상 플러그인들 로드\r\n   */\r\n  private async autoLoadPlugins(): Promise<void> {\r\n    const enabledPlugins = pluginConfig.getEnabledPlugins();\r\n    const autoLoadPlugins = enabledPlugins.filter(({ config }) => !config.loadOnDemand);\r\n\r\n    console.log(`🚀 Auto-loading ${autoLoadPlugins.length} plugins...`);\r\n\r\n    for (const { name } of autoLoadPlugins) {\r\n      const result = await pluginLifecycle.loadPlugin(name as NonEmptyString);\r\n      if (result.success) {\r\n        console.log(`✅ Auto-loaded plugin: ${name}`);\r\n      } else {\r\n        console.warn(`⚠️ Failed to auto-load plugin ${name}:`, result.error);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 메트릭스 수집 시작\r\n   */\r\n  private startMetricsCollection(): void {\r\n    // 주기적으로 메트릭스 수집 (개발용)\r\n    if (pluginConfig.getEnvironment() === 'development') {\r\n      setInterval(() => {\r\n        const metrics = pluginLifecycle.getSystemMetrics();\r\n        console.debug('📊 Plugin Metrics:', metrics);\r\n      }, 30000); // 30초마다\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Speech 플러그인 가져오기 (타입 안전)\r\n   */\r\n  async getSpeechPlugin(): Promise<Result<ISpeechPlugin>> {\r\n    return this.getPlugin<ISpeechPlugin>('speech');\r\n  }\r\n\r\n  /**\r\n   * Speed Training 플러그인 가져오기 (타입 안전)\r\n   */\r\n  async getSpeedTrainingPlugin(): Promise<Result<ISpeedTrainingPlugin>> {\r\n    return this.getPlugin<ISpeedTrainingPlugin>('speed-training');\r\n  }\r\n\r\n  /**\r\n   * Performance 플러그인 가져오기 (타입 안전)\r\n   */\r\n  async getPerformancePlugin(): Promise<Result<IPerformancePlugin>> {\r\n    return this.getPlugin<IPerformancePlugin>('performance');\r\n  }\r\n\r\n  /**\r\n   * 특정 타입의 플러그인 가져오기\r\n   */\r\n  async getPlugin<T extends IPlugin>(name: string): Promise<Result<T>> {\r\n    if (!isNonEmptyString(name)) {\r\n      return Err(new Error('Plugin name must be non-empty'));\r\n    }\r\n\r\n    const pluginName = name as NonEmptyString;\r\n    \r\n    // 이미 로드된 경우\r\n    const loadedPlugins = pluginLifecycle.getLoadedPlugins();\r\n    const loadedPlugin = loadedPlugins.get(pluginName);\r\n    \r\n    if (loadedPlugin?.instance) {\r\n      return Ok(loadedPlugin.instance as T);\r\n    }\r\n\r\n    // 온디맨드 로딩\r\n    const config = pluginConfig.getPluginConfig(name);\r\n    if (config?.enabled) {\r\n      const loadResult = await pluginLifecycle.loadPlugin(pluginName);\r\n      if (loadResult.success) {\r\n        return Ok(loadResult.data as T);\r\n      }\r\n      return Err(loadResult.error);\r\n    }\r\n\r\n    return Err(new Error(`Plugin '${name}' is not enabled or not found`));\r\n  }\r\n\r\n  /**\r\n   * 플러그인 활성화/비활성화\r\n   */\r\n  async setPluginEnabled(name: string, enabled: boolean): Promise<Result<void>> {\r\n    if (!isNonEmptyString(name)) {\r\n      return Err(new Error('Plugin name must be non-empty'));\r\n    }\r\n\r\n    const pluginName = name as NonEmptyString;\r\n    \r\n    // 설정 업데이트\r\n    const configResult = pluginConfig.setPluginEnabled(name, enabled);\r\n    if (!configResult.success) {\r\n      return configResult;\r\n    }\r\n\r\n    // 활성화: 로드하기\r\n    if (enabled) {\r\n      const loadResult = await pluginLifecycle.loadPlugin(pluginName);\r\n      if (!loadResult.success) {\r\n        return Err(loadResult.error);\r\n      }\r\n    } \r\n    // 비활성화: 언로드하기\r\n    else {\r\n      const unloadResult = await pluginLifecycle.unloadPlugin(pluginName);\r\n      if (!unloadResult.success) {\r\n        return Err(unloadResult.error);\r\n      }\r\n    }\r\n\r\n    // 설정 저장\r\n    pluginConfig.saveToStorage();\r\n\r\n    return Ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * 플러그인 재시작\r\n   */\r\n  async restartPlugin(name: string): Promise<Result<IPlugin>> {\r\n    if (!isNonEmptyString(name)) {\r\n      return Err(new Error('Plugin name must be non-empty'));\r\n    }\r\n\r\n    return pluginLifecycle.restartPlugin(name as NonEmptyString);\r\n  }\r\n\r\n  /**\r\n   * 모든 플러그인 정보 조회\r\n   */\r\n  getAllPlugins(): readonly PluginInfo[] {\r\n    const registered = pluginRegistry.getRegisteredPlugins();\r\n    const loaded = pluginLifecycle.getLoadedPlugins();\r\n\r\n    return registered.map(name => {\r\n      const config = pluginConfig.getPluginConfig(name);\r\n      const loadedInfo = loaded.get(name);\r\n      const status = pluginLifecycle.getPluginStatus(name);\r\n      const metrics = pluginLifecycle.getPluginMetrics(name);\r\n\r\n      return {\r\n        name,\r\n        status: status || 'unloaded',\r\n        implementation: config?.implementation || 'unknown',\r\n        enabled: config?.enabled || false,\r\n        loadTime: metrics.loadTime || undefined,\r\n        errorCount: metrics.errorCount || undefined\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 활성화된 플러그인들만 조회\r\n   */\r\n  getActivePlugins(): readonly PluginInfo[] {\r\n    return this.getAllPlugins().filter(plugin => \r\n      plugin.enabled && plugin.status !== 'unloaded'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * 플러그인 상태 조회\r\n   */\r\n  getPluginStatus(name: string): PluginStatus | null {\r\n    if (!isNonEmptyString(name)) return null;\r\n    return pluginLifecycle.getPluginStatus(name as NonEmptyString);\r\n  }\r\n\r\n  /**\r\n   * 시스템 메트릭스 조회\r\n   */\r\n  getSystemMetrics() {\r\n    return pluginLifecycle.getSystemMetrics();\r\n  }\r\n\r\n  /**\r\n   * 플러그인 설정 업데이트\r\n   */\r\n  async updatePluginConfig(\r\n    name: string, \r\n    config: Record<string, unknown>\r\n  ): Promise<Result<void>> {\r\n    if (!isNonEmptyString(name)) {\r\n      return Err(new Error('Plugin name must be non-empty'));\r\n    }\r\n\r\n    const pluginName = name as NonEmptyString;\r\n    \r\n    // 설정 업데이트\r\n    const updateResult = pluginConfig.updatePluginConfig(name, { config });\r\n    if (!updateResult.success) {\r\n      return updateResult;\r\n    }\r\n\r\n    // 로드된 플러그인이 있으면 설정 적용\r\n    const loadedPlugins = pluginLifecycle.getLoadedPlugins();\r\n    const loadedPlugin = loadedPlugins.get(pluginName);\r\n    \r\n    if (loadedPlugin?.instance) {\r\n      const configUpdateResult = await loadedPlugin.instance.updateConfig(config);\r\n      if (!configUpdateResult.success) {\r\n        return Err(configUpdateResult.error);\r\n      }\r\n    }\r\n\r\n    // 설정 저장\r\n    pluginConfig.saveToStorage();\r\n\r\n    return Ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * 플러그인 설정 내보내기\r\n   */\r\n  exportConfig(): string {\r\n    return pluginConfig.exportConfig();\r\n  }\r\n\r\n  /**\r\n   * 플러그인 설정 가져오기\r\n   */\r\n  async importConfig(configJson: string): Promise<Result<void>> {\r\n    const importResult = pluginConfig.importConfig(configJson);\r\n    if (!importResult.success) {\r\n      return importResult;\r\n    }\r\n\r\n    // 설정 저장\r\n    pluginConfig.saveToStorage();\r\n\r\n    // 변경된 설정에 따라 플러그인 재로드\r\n    await this.reloadAllPlugins();\r\n\r\n    return Ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * 모든 플러그인 재로드\r\n   */\r\n  private async reloadAllPlugins(): Promise<void> {\r\n    // 모든 플러그인 언로드\r\n    await pluginLifecycle.unloadAllPlugins();\r\n    \r\n    // 자동 로드 플러그인들 다시 로드\r\n    await this.autoLoadPlugins();\r\n  }\r\n\r\n  /**\r\n   * 특정 타입의 플러그인들 검색\r\n   */\r\n  getPluginsByType(type: string): readonly PluginInfo[] {\r\n    if (!isNonEmptyString(type)) return [];\r\n    \r\n    const pluginNames = pluginRegistry.getPluginsByType(type as NonEmptyString);\r\n    return this.getAllPlugins().filter(plugin => \r\n      pluginNames.includes(plugin.name)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * 플러그인이 사용 가능한지 확인\r\n   */\r\n  isPluginAvailable(name: string): boolean {\r\n    if (!isNonEmptyString(name)) return false;\r\n    \r\n    const config = pluginConfig.getPluginConfig(name);\r\n    const status = pluginLifecycle.getPluginStatus(name as NonEmptyString);\r\n    \r\n    return config?.enabled === true && status === 'ready';\r\n  }\r\n\r\n  /**\r\n   * 시스템 종료 시 정리\r\n   */\r\n  async dispose(): Promise<Result<void>> {\r\n    console.log('🔌 Shutting down Plugin System...');\r\n    \r\n    try {\r\n      // 설정 저장\r\n      pluginConfig.saveToStorage();\r\n      \r\n      // 모든 플러그인 정리\r\n      const result = await pluginLifecycle.dispose();\r\n      \r\n      this.initialized = false;\r\n      console.log('✅ Plugin System shut down successfully');\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      console.error('❌ Plugin System shutdown failed:', error);\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n}\r\n\r\n// 전역 플러그인 매니저 인스턴스\r\nexport const pluginManager = PluginManager.getInstance();\r\n\r\n// 편의 함수들\r\nexport const getSpeechPlugin = () => pluginManager.getSpeechPlugin();\r\nexport const getSpeedTrainingPlugin = () => pluginManager.getSpeedTrainingPlugin();\r\nexport const getPerformancePlugin = () => pluginManager.getPerformancePlugin();\r\nexport const getPlugin = <T extends IPlugin>(name: string) => pluginManager.getPlugin<T>(name);\r\nexport const isPluginAvailable = (name: string) => pluginManager.isPluginAvailable(name);","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\config\\PluginConfig.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'NonEmptyString' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 플러그인 설정 관리 시스템\r\n * @description 설정 기반 플러그인 활성화/비활성화 및 구성 관리\r\n */\r\n\r\nimport { NonEmptyString, Result, Ok, Err, isNonEmptyString } from '@/types/core';\r\n\r\n// 플러그인 설정 타입\r\nexport interface PluginConfigEntry {\r\n  readonly enabled: boolean;\r\n  readonly implementation: string;\r\n  readonly config: Record<string, unknown>;\r\n  readonly priority?: number;\r\n  readonly loadOnDemand?: boolean;\r\n}\r\n\r\n// 전역 플러그인 설정\r\nexport interface GlobalPluginConfig {\r\n  readonly plugins: Record<string, PluginConfigEntry>;\r\n  readonly environment: 'development' | 'production' | 'test';\r\n  readonly features: {\r\n    readonly autoLoad: boolean;\r\n    readonly lazyLoading: boolean;\r\n    readonly hotReload: boolean;\r\n    readonly debugging: boolean;\r\n  };\r\n  readonly performance: {\r\n    readonly maxConcurrentLoads: number;\r\n    readonly loadTimeoutMs: number;\r\n    readonly enableMetrics: boolean;\r\n  };\r\n}\r\n\r\n// 기본 설정\r\nconst DEFAULT_CONFIG: GlobalPluginConfig = {\r\n  plugins: {\r\n    speech: {\r\n      enabled: true,\r\n      implementation: 'web',\r\n      config: {\r\n        recognitionLanguage: 'ko-KR',\r\n        synthesisLanguage: 'ko-KR',\r\n        speechRate: 1.0,\r\n        enableContinuous: false,\r\n        enableInterimResults: true,\r\n        autoRestart: false\r\n      },\r\n      priority: 1,\r\n      loadOnDemand: false\r\n    },\r\n    audioProcessor: {\r\n      enabled: true,\r\n      implementation: 'advanced',\r\n      config: {\r\n        sampleRate: 44100,\r\n        bufferSize: 2048,\r\n        enableNoiseReduction: true,\r\n        enableEcho: false\r\n      },\r\n      priority: 2,\r\n      loadOnDemand: true\r\n    },\r\n    analytics: {\r\n      enabled: false, // 기본적으로 비활성화\r\n      implementation: 'google',\r\n      config: {\r\n        trackingId: '',\r\n        anonymizeIp: true,\r\n        enableEvents: true\r\n      },\r\n      priority: 10,\r\n      loadOnDemand: true\r\n    }\r\n  },\r\n  environment: 'development',\r\n  features: {\r\n    autoLoad: true,\r\n    lazyLoading: true,\r\n    hotReload: false, // 개발 환경에서만 true\r\n    debugging: true\r\n  },\r\n  performance: {\r\n    maxConcurrentLoads: 3,\r\n    loadTimeoutMs: 10000,\r\n    enableMetrics: false\r\n  }\r\n};\r\n\r\n// 환경별 설정 오버라이드\r\nconst ENVIRONMENT_OVERRIDES: Record<string, Partial<GlobalPluginConfig>> = {\r\n  production: {\r\n    features: {\r\n      autoLoad: true,\r\n      lazyLoading: true,\r\n      hotReload: false,\r\n      debugging: false\r\n    },\r\n    performance: {\r\n      maxConcurrentLoads: 5,\r\n      loadTimeoutMs: 5000,\r\n      enableMetrics: true\r\n    },\r\n    plugins: {\r\n      analytics: {\r\n        enabled: true,\r\n        implementation: 'google',\r\n        config: {\r\n          trackingId: import.meta.env.VITE_GA_TRACKING_ID || '',\r\n          anonymizeIp: true,\r\n          enableEvents: true\r\n        },\r\n        priority: 10,\r\n        loadOnDemand: true\r\n      }\r\n    }\r\n  },\r\n  test: {\r\n    plugins: {\r\n      speech: {\r\n        enabled: true,\r\n        implementation: 'mock',\r\n        config: {\r\n          mockResponses: true,\r\n          simulateLatency: false\r\n        },\r\n        priority: 1,\r\n        loadOnDemand: false\r\n      },\r\n      audioProcessor: {\r\n        enabled: false,\r\n        implementation: 'mock',\r\n        config: {},\r\n        priority: 2,\r\n        loadOnDemand: false\r\n      },\r\n      analytics: {\r\n        enabled: false,\r\n        implementation: 'mock',\r\n        config: {},\r\n        priority: 10,\r\n        loadOnDemand: false\r\n      }\r\n    },\r\n    features: {\r\n      autoLoad: false,\r\n      lazyLoading: false,\r\n      hotReload: false,\r\n      debugging: true\r\n    },\r\n    performance: {\r\n      maxConcurrentLoads: 1,\r\n      loadTimeoutMs: 1000,\r\n      enableMetrics: false\r\n    }\r\n  }\r\n};\r\n\r\n/**\r\n * 플러그인 설정 매니저\r\n */\r\nexport class PluginConfigManager {\r\n  private static instance: PluginConfigManager;\r\n  private config: GlobalPluginConfig;\r\n  private listeners = new Set<(config: GlobalPluginConfig) => void>();\r\n\r\n  private constructor(environment?: string) {\r\n    this.config = this.buildConfig(environment);\r\n  }\r\n\r\n  static getInstance(environment?: string): PluginConfigManager {\r\n    if (!PluginConfigManager.instance) {\r\n      PluginConfigManager.instance = new PluginConfigManager(environment);\r\n    }\r\n    return PluginConfigManager.instance;\r\n  }\r\n\r\n  private buildConfig(environment?: string): GlobalPluginConfig {\r\n    const env = environment || import.meta.env.MODE || 'development';\r\n    const override = ENVIRONMENT_OVERRIDES[env] || {};\r\n    \r\n    return this.deepMerge(DEFAULT_CONFIG, override);\r\n  }\r\n\r\n  private deepMerge<T extends Record<string, any>>(target: T, source: Partial<T>): T {\r\n    const result = { ...target };\r\n    \r\n    for (const [key, value] of Object.entries(source)) {\r\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\r\n        result[key as keyof T] = this.deepMerge(\r\n          result[key as keyof T] as any, \r\n          value\r\n        );\r\n      } else {\r\n        result[key as keyof T] = value;\r\n      }\r\n    }\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 전체 설정 반환\r\n   */\r\n  getConfig(): GlobalPluginConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * 특정 플러그인 설정 반환\r\n   */\r\n  getPluginConfig(pluginName: string): PluginConfigEntry | null {\r\n    return this.config.plugins[pluginName] || null;\r\n  }\r\n\r\n  /**\r\n   * 플러그인이 활성화되어 있는지 확인\r\n   */\r\n  isPluginEnabled(pluginName: string): boolean {\r\n    const pluginConfig = this.getPluginConfig(pluginName);\r\n    return pluginConfig?.enabled ?? false;\r\n  }\r\n\r\n  /**\r\n   * 활성화된 플러그인 목록 반환\r\n   */\r\n  getEnabledPlugins(): Array<{ name: string; config: PluginConfigEntry }> {\r\n    return Object.entries(this.config.plugins)\r\n      .filter(([_, config]) => config.enabled)\r\n      .map(([name, config]) => ({ name, config }))\r\n      .sort((a, b) => (a.config.priority || 999) - (b.config.priority || 999));\r\n  }\r\n\r\n  /**\r\n   * 플러그인 구현체 반환\r\n   */\r\n  getPluginImplementation(pluginName: string): string | null {\r\n    const pluginConfig = this.getPluginConfig(pluginName);\r\n    return pluginConfig?.implementation || null;\r\n  }\r\n\r\n  /**\r\n   * 플러그인 설정 업데이트\r\n   */\r\n  updatePluginConfig(\r\n    pluginName: string, \r\n    updates: Partial<PluginConfigEntry>\r\n  ): Result<void> {\r\n    try {\r\n      if (!isNonEmptyString(pluginName)) {\r\n        return Err(new Error('Plugin name must be a non-empty string'));\r\n      }\r\n\r\n      const currentConfig = this.config.plugins[pluginName] || {\r\n        enabled: false,\r\n        implementation: 'default',\r\n        config: {}\r\n      };\r\n\r\n      this.config = {\r\n        ...this.config,\r\n        plugins: {\r\n          ...this.config.plugins,\r\n          [pluginName]: {\r\n            ...currentConfig,\r\n            ...updates,\r\n            config: {\r\n              ...currentConfig.config,\r\n              ...(updates.config || {})\r\n            }\r\n          }\r\n        }\r\n      };\r\n\r\n      this.notifyListeners();\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플러그인 활성화/비활성화\r\n   */\r\n  setPluginEnabled(pluginName: string, enabled: boolean): Result<void> {\r\n    return this.updatePluginConfig(pluginName, { enabled });\r\n  }\r\n\r\n  /**\r\n   * 플러그인 구현체 변경\r\n   */\r\n  setPluginImplementation(\r\n    pluginName: string, \r\n    implementation: string\r\n  ): Result<void> {\r\n    return this.updatePluginConfig(pluginName, { implementation });\r\n  }\r\n\r\n  /**\r\n   * 환경 설정 반환\r\n   */\r\n  getEnvironment(): string {\r\n    return this.config.environment;\r\n  }\r\n\r\n  /**\r\n   * 기능 설정 반환\r\n   */\r\n  getFeatures(): GlobalPluginConfig['features'] {\r\n    return { ...this.config.features };\r\n  }\r\n\r\n  /**\r\n   * 성능 설정 반환\r\n   */\r\n  getPerformanceConfig(): GlobalPluginConfig['performance'] {\r\n    return { ...this.config.performance };\r\n  }\r\n\r\n  /**\r\n   * 설정 변경 리스너 등록\r\n   */\r\n  addChangeListener(listener: (config: GlobalPluginConfig) => void): void {\r\n    this.listeners.add(listener);\r\n  }\r\n\r\n  /**\r\n   * 설정 변경 리스너 제거\r\n   */\r\n  removeChangeListener(listener: (config: GlobalPluginConfig) => void): void {\r\n    this.listeners.delete(listener);\r\n  }\r\n\r\n  /**\r\n   * 리스너들에게 변경 알림\r\n   */\r\n  private notifyListeners(): void {\r\n    this.listeners.forEach(listener => {\r\n      try {\r\n        listener(this.getConfig());\r\n      } catch (error) {\r\n        console.error('Plugin config listener error:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 설정을 JSON으로 내보내기\r\n   */\r\n  exportConfig(): string {\r\n    return JSON.stringify(this.config, null, 2);\r\n  }\r\n\r\n  /**\r\n   * JSON에서 설정 가져오기\r\n   */\r\n  importConfig(configJson: string): Result<void> {\r\n    try {\r\n      const importedConfig = JSON.parse(configJson);\r\n      \r\n      // 기본 구조 검증\r\n      if (!importedConfig.plugins || typeof importedConfig.plugins !== 'object') {\r\n        return Err(new Error('Invalid config format: missing plugins'));\r\n      }\r\n\r\n      this.config = this.deepMerge(DEFAULT_CONFIG, importedConfig);\r\n      this.notifyListeners();\r\n      \r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(new Error(`Failed to import config: ${error}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 로컬 스토리지에 설정 저장\r\n   */\r\n  saveToStorage(key = 'pluginConfig'): Result<void> {\r\n    try {\r\n      const configJson = this.exportConfig();\r\n      localStorage.setItem(key, configJson);\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(new Error(`Failed to save config to storage: ${error}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 로컬 스토리지에서 설정 로드\r\n   */\r\n  loadFromStorage(key = 'pluginConfig'): Result<void> {\r\n    try {\r\n      const configJson = localStorage.getItem(key);\r\n      if (!configJson) {\r\n        return Ok(undefined); // 저장된 설정이 없음 (정상)\r\n      }\r\n\r\n      return this.importConfig(configJson);\r\n    } catch (error) {\r\n      return Err(new Error(`Failed to load config from storage: ${error}`));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 설정 초기화 (기본값으로 복원)\r\n   */\r\n  reset(): void {\r\n    this.config = this.buildConfig();\r\n    this.notifyListeners();\r\n  }\r\n}\r\n\r\n// 전역 설정 매니저 인스턴스\r\nexport const pluginConfig = PluginConfigManager.getInstance();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\core\\BasePlugin.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":227,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":227,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":235,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":235,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 기본 플러그인 베이스 클래스\r\n * @description 모든 플러그인이 상속받을 수 있는 기본 구현체\r\n */\r\n\r\nimport { \r\n  IPlugin, \r\n  PluginMetadata, \r\n  PluginConfig, \r\n  PluginStatus, \r\n  PluginEvent,\r\n  PluginEventHandler \r\n} from './IPlugin';\r\nimport { NonEmptyString, Result, Ok, Err } from '@/types/core';\r\n\r\n/**\r\n * 추상 기본 플러그인 클래스\r\n */\r\nexport abstract class BasePlugin implements IPlugin {\r\n  private _status: PluginStatus = 'unloaded';\r\n  private _config: PluginConfig = {};\r\n  private readonly _eventHandlers = new Map<string, Set<PluginEventHandler>>();\r\n\r\n  constructor(\r\n    public readonly metadata: PluginMetadata\r\n  ) {}\r\n\r\n  get status(): PluginStatus {\r\n    return this._status;\r\n  }\r\n\r\n  protected setStatus(status: PluginStatus): void {\r\n    if (this._status !== status) {\r\n      const previousStatus = this._status;\r\n      this._status = status;\r\n      \r\n      this.emit({\r\n        type: 'statusChange',\r\n        pluginName: this.metadata.name,\r\n        timestamp: Date.now(),\r\n        data: { \r\n          previousStatus, \r\n          newStatus: status \r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플러그인 초기화 - 하위 클래스에서 구현\r\n   */\r\n  async initialize(config: PluginConfig = {}): Promise<Result<void>> {\r\n    try {\r\n      this.setStatus('initializing');\r\n      \r\n      // 설정 검증\r\n      const configValidation = this.validateConfig(config);\r\n      if (!configValidation.success) {\r\n        this.setStatus('error');\r\n        return configValidation;\r\n      }\r\n\r\n      this._config = { ...this._config, ...config };\r\n\r\n      // 하위 클래스의 초기화 로직 실행\r\n      const initResult = await this.onInitialize(this._config);\r\n      if (!initResult.success) {\r\n        this.setStatus('error');\r\n        return initResult;\r\n      }\r\n\r\n      this.setStatus('ready');\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      this.setStatus('error');\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플러그인 정리 - 하위 클래스에서 구현\r\n   */\r\n  async dispose(): Promise<Result<void>> {\r\n    try {\r\n      this.setStatus('disposing');\r\n      \r\n      const disposeResult = await this.onDispose();\r\n      if (!disposeResult.success) {\r\n        return disposeResult;\r\n      }\r\n\r\n      // 이벤트 핸들러 정리\r\n      this._eventHandlers.clear();\r\n      \r\n      this.setStatus('unloaded');\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      this.setStatus('error');\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 설정 업데이트\r\n   */\r\n  async updateConfig(config: Partial<PluginConfig>): Promise<Result<void>> {\r\n    try {\r\n      const newConfig = { ...this._config, ...config };\r\n      \r\n      const configValidation = this.validateConfig(newConfig);\r\n      if (!configValidation.success) {\r\n        return configValidation;\r\n      }\r\n\r\n      const updateResult = await this.onConfigUpdate(newConfig);\r\n      if (!updateResult.success) {\r\n        return updateResult;\r\n      }\r\n\r\n      this._config = newConfig;\r\n      \r\n      this.emit({\r\n        type: 'configChange',\r\n        pluginName: this.metadata.name,\r\n        timestamp: Date.now(),\r\n        data: { config: newConfig }\r\n      });\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 현재 설정 반환\r\n   */\r\n  getConfig(): PluginConfig {\r\n    return { ...this._config };\r\n  }\r\n\r\n  /**\r\n   * 호환성 검사 - 기본 구현\r\n   */\r\n  isCompatible(systemVersion: NonEmptyString): boolean {\r\n    const { minSystemVersion } = this.metadata;\r\n    if (!minSystemVersion) return true;\r\n\r\n    // 간단한 버전 비교 (semver 방식)\r\n    const parseVersion = (version: string) => \r\n      version.split('.').map(n => parseInt(n, 10));\r\n    \r\n    try {\r\n      const minVer = parseVersion(minSystemVersion);\r\n      const sysVer = parseVersion(systemVersion);\r\n      \r\n      for (let i = 0; i < Math.max(minVer.length, sysVer.length); i++) {\r\n        const minPart = minVer[i] || 0;\r\n        const sysPart = sysVer[i] || 0;\r\n        \r\n        if (sysPart < minPart) return false;\r\n        if (sysPart > minPart) return true;\r\n      }\r\n      \r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 이벤트 핸들러 등록\r\n   */\r\n  on(event: string, handler: PluginEventHandler): void {\r\n    if (!this._eventHandlers.has(event)) {\r\n      this._eventHandlers.set(event, new Set());\r\n    }\r\n    this._eventHandlers.get(event)!.add(handler);\r\n  }\r\n\r\n  /**\r\n   * 이벤트 핸들러 제거\r\n   */\r\n  off(event: string, handler: PluginEventHandler): void {\r\n    const handlers = this._eventHandlers.get(event);\r\n    if (handlers) {\r\n      handlers.delete(handler);\r\n      if (handlers.size === 0) {\r\n        this._eventHandlers.delete(event);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 이벤트 발생\r\n   */\r\n  emit(event: PluginEvent): void {\r\n    const handlers = this._eventHandlers.get(event.type);\r\n    if (handlers) {\r\n      handlers.forEach(handler => {\r\n        try {\r\n          handler(event);\r\n        } catch (error) {\r\n          console.error(`Plugin ${this.metadata.name} event handler error:`, error);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 보호된 메서드들 - 하위 클래스에서 구현\r\n   */\r\n  \r\n  /**\r\n   * 초기화 로직 구현\r\n   */\r\n  protected abstract onInitialize(config: PluginConfig): Promise<Result<void>>;\r\n\r\n  /**\r\n   * 정리 로직 구현\r\n   */\r\n  protected abstract onDispose(): Promise<Result<void>>;\r\n\r\n  /**\r\n   * 설정 업데이트 로직 구현\r\n   */\r\n  protected async onConfigUpdate(config: PluginConfig): Promise<Result<void>> {\r\n    // 기본적으로는 아무것도 하지 않음 - 필요시 오버라이드\r\n    return Ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * 설정 검증 로직 - 하위 클래스에서 오버라이드 가능\r\n   */\r\n  protected validateConfig(config: PluginConfig): Result<void> {\r\n    // 기본적으로는 항상 성공 - 필요시 오버라이드\r\n    return Ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * 유틸리티 메서드들\r\n   */\r\n  \r\n  /**\r\n   * 안전한 비동기 작업 실행\r\n   */\r\n  protected async safeAsync<T>(\r\n    operation: () => Promise<T>,\r\n    errorMessage?: string\r\n  ): Promise<Result<T>> {\r\n    try {\r\n      const result = await operation();\r\n      return Ok(result);\r\n    } catch (error) {\r\n      const message = errorMessage || 'Plugin operation failed';\r\n      console.error(`${this.metadata.name}: ${message}`, error);\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 의존성 검사\r\n   */\r\n  protected checkDependencies(availablePlugins: readonly string[]): Result<void> {\r\n    const { dependencies = [] } = this.metadata;\r\n    \r\n    const missingDeps = dependencies.filter(dep => \r\n      !availablePlugins.includes(dep)\r\n    );\r\n\r\n    if (missingDeps.length > 0) {\r\n      return Err(new Error(\r\n        `Missing dependencies: ${missingDeps.join(', ')}`\r\n      ));\r\n    }\r\n\r\n    return Ok(undefined);\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\core\\IPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\core\\PluginLifecycleManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PluginEvent' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PluginEventHandler' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNonEmptyString' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":59},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'newConfig' is defined but never used. Allowed unused args must match /^_/u.","line":476,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":476,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 플러그인 라이프사이클 매니저\r\n * @description 플러그인의 전체 라이프사이클을 관리 (로드, 초기화, 실행, 정리)\r\n */\r\n\r\nimport { \r\n  IPlugin, \r\n  IPluginFactory, \r\n  PluginStatus, \r\n  PluginEvent,\r\n  PluginEventHandler \r\n} from './IPlugin';\r\nimport { pluginRegistry } from './PluginRegistry';\r\nimport { pluginConfig, PluginConfigEntry } from '@/plugins/config/PluginConfig';\r\nimport { NonEmptyString, Result, Ok, Err, isNonEmptyString } from '@/types/core';\r\n\r\n// 라이프사이클 이벤트\r\ninterface LifecycleEvent {\r\n  readonly type: 'load' | 'initialize' | 'start' | 'stop' | 'error' | 'metrics';\r\n  readonly pluginName: NonEmptyString;\r\n  readonly timestamp: number;\r\n  readonly data?: unknown;\r\n}\r\n\r\ntype LifecycleEventHandler = (event: LifecycleEvent) => void;\r\n\r\n// 플러그인 메트릭스\r\ninterface PluginMetrics {\r\n  readonly loadTime: number;\r\n  readonly initTime: number;\r\n  readonly errorCount: number;\r\n  readonly restartCount: number;\r\n  readonly lastActivity: number;\r\n  readonly memoryUsage?: number;\r\n}\r\n\r\n// 로드된 플러그인 정보\r\ninterface LoadedPluginInfo {\r\n  readonly factory: IPluginFactory;\r\n  readonly instance?: IPlugin;\r\n  readonly status: PluginStatus;\r\n  readonly config: PluginConfigEntry;\r\n  readonly metrics: PluginMetrics;\r\n  readonly dependencies: readonly string[];\r\n  readonly dependents: readonly string[];\r\n}\r\n\r\n/**\r\n * 플러그인 라이프사이클 매니저\r\n */\r\nexport class PluginLifecycleManager {\r\n  private static instance: PluginLifecycleManager;\r\n  \r\n  private readonly loadedPlugins = new Map<NonEmptyString, LoadedPluginInfo>();\r\n  private readonly loadPromises = new Map<NonEmptyString, Promise<Result<IPlugin>>>();\r\n  private readonly lifecycleHandlers = new Set<LifecycleEventHandler>();\r\n  \r\n  private readonly maxConcurrentLoads: number;\r\n  private readonly loadTimeoutMs: number;\r\n  private currentConcurrentLoads = 0;\r\n  \r\n  private constructor() {\r\n    const performanceConfig = pluginConfig.getPerformanceConfig();\r\n    this.maxConcurrentLoads = performanceConfig.maxConcurrentLoads;\r\n    this.loadTimeoutMs = performanceConfig.loadTimeoutMs;\r\n    \r\n    // 설정 변경 감지\r\n    pluginConfig.addChangeListener(this.onConfigChange.bind(this));\r\n  }\r\n\r\n  static getInstance(): PluginLifecycleManager {\r\n    if (!PluginLifecycleManager.instance) {\r\n      PluginLifecycleManager.instance = new PluginLifecycleManager();\r\n    }\r\n    return PluginLifecycleManager.instance;\r\n  }\r\n\r\n  /**\r\n   * 플러그인 팩토리 등록 및 자동 로드\r\n   */\r\n  async registerPlugin<T extends IPlugin>(\r\n    name: NonEmptyString,\r\n    factory: IPluginFactory<T>\r\n  ): Promise<Result<void>> {\r\n    try {\r\n      // 레지스트리에 등록\r\n      const registerResult = pluginRegistry.register(name, factory);\r\n      if (!registerResult.success) {\r\n        return registerResult;\r\n      }\r\n\r\n      // 설정 확인하여 자동 로드 여부 결정\r\n      const config = pluginConfig.getPluginConfig(name);\r\n      if (config?.enabled && !config.loadOnDemand) {\r\n        const loadResult = await this.loadPlugin(name);\r\n        if (!loadResult.success) {\r\n          console.warn(`Failed to auto-load plugin ${name}:`, loadResult.error);\r\n        }\r\n      }\r\n\r\n      this.emitLifecycleEvent({\r\n        type: 'load',\r\n        pluginName: name,\r\n        timestamp: Date.now(),\r\n        data: { action: 'registered' }\r\n      });\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플러그인 로드 (팩토리에서 인스턴스 생성)\r\n   */\r\n  async loadPlugin(name: NonEmptyString): Promise<Result<IPlugin>> {\r\n    // 이미 로드 중이면 기존 Promise 반환\r\n    if (this.loadPromises.has(name)) {\r\n      return this.loadPromises.get(name)!;\r\n    }\r\n\r\n    // 동시 로드 제한\r\n    if (this.currentConcurrentLoads >= this.maxConcurrentLoads) {\r\n      return Err(new Error('Maximum concurrent plugin loads exceeded'));\r\n    }\r\n\r\n    const loadPromise = this.performLoad(name);\r\n    this.loadPromises.set(name, loadPromise);\r\n    \r\n    try {\r\n      const result = await loadPromise;\r\n      return result;\r\n    } finally {\r\n      this.loadPromises.delete(name);\r\n    }\r\n  }\r\n\r\n  private async performLoad(name: NonEmptyString): Promise<Result<IPlugin>> {\r\n    const startTime = Date.now();\r\n    this.currentConcurrentLoads++;\r\n\r\n    try {\r\n      // 설정 확인\r\n      const config = pluginConfig.getPluginConfig(name);\r\n      if (!config?.enabled) {\r\n        return Err(new Error(`Plugin ${name} is not enabled`));\r\n      }\r\n\r\n      // 의존성 확인\r\n      const dependencyCheck = await this.checkAndLoadDependencies(name);\r\n      if (!dependencyCheck.success) {\r\n        return dependencyCheck;\r\n      }\r\n\r\n      // 타임아웃 설정\r\n      const timeoutPromise = new Promise<Result<IPlugin>>((_, reject) => {\r\n        setTimeout(() => {\r\n          reject(new Error(`Plugin ${name} load timeout`));\r\n        }, this.loadTimeoutMs);\r\n      });\r\n\r\n      // 실제 로드 작업\r\n      const loadPromise = this.doLoad(name, config);\r\n      \r\n      const result = await Promise.race([loadPromise, timeoutPromise]);\r\n      \r\n      if (result.success) {\r\n        const loadTime = Date.now() - startTime;\r\n        this.updatePluginInfo(name, {\r\n          instance: result.data,\r\n          status: result.data.status,\r\n          metrics: {\r\n            ...this.getPluginMetrics(name),\r\n            loadTime,\r\n            lastActivity: Date.now()\r\n          }\r\n        });\r\n\r\n        this.emitLifecycleEvent({\r\n          type: 'load',\r\n          pluginName: name,\r\n          timestamp: Date.now(),\r\n          data: { \r\n            action: 'loaded', \r\n            loadTime,\r\n            status: result.data.status \r\n          }\r\n        });\r\n      }\r\n\r\n      return result;\r\n    } catch (error) {\r\n      this.emitLifecycleEvent({\r\n        type: 'error',\r\n        pluginName: name,\r\n        timestamp: Date.now(),\r\n        data: { \r\n          action: 'load', \r\n          error: error instanceof Error ? error.message : String(error) \r\n        }\r\n      });\r\n      \r\n      return Err(error as Error);\r\n    } finally {\r\n      this.currentConcurrentLoads--;\r\n    }\r\n  }\r\n\r\n  private async doLoad(\r\n    name: NonEmptyString, \r\n    config: PluginConfigEntry\r\n  ): Promise<Result<IPlugin>> {\r\n    // 레지스트리에서 인스턴스 생성\r\n    const instanceResult = await pluginRegistry.getInstance(name, config.config);\r\n    if (!instanceResult.success) {\r\n      return instanceResult;\r\n    }\r\n\r\n    const instance = instanceResult.data;\r\n\r\n    // 플러그인 정보 업데이트\r\n    const factory = this.getRegisteredFactory(name);\r\n    if (factory) {\r\n      const metrics: PluginMetrics = {\r\n        loadTime: 0, // 나중에 업데이트됨\r\n        initTime: 0,\r\n        errorCount: 0,\r\n        restartCount: 0,\r\n        lastActivity: Date.now()\r\n      };\r\n\r\n      this.loadedPlugins.set(name, {\r\n        factory,\r\n        instance,\r\n        status: instance.status,\r\n        config,\r\n        metrics,\r\n        dependencies: [],\r\n        dependents: []\r\n      });\r\n    }\r\n\r\n    return Ok(instance);\r\n  }\r\n\r\n  /**\r\n   * 플러그인 언로드\r\n   */\r\n  async unloadPlugin(name: NonEmptyString): Promise<Result<void>> {\r\n    try {\r\n      const pluginInfo = this.loadedPlugins.get(name);\r\n      if (!pluginInfo?.instance) {\r\n        return Ok(undefined); // 이미 언로드됨\r\n      }\r\n\r\n      // 의존하는 플러그인들 먼저 언로드\r\n      for (const dependentName of pluginInfo.dependents) {\r\n        await this.unloadPlugin(dependentName as NonEmptyString);\r\n      }\r\n\r\n      // 플러그인 정리\r\n      const disposeResult = await pluginInfo.instance.dispose();\r\n      if (!disposeResult.success) {\r\n        return disposeResult;\r\n      }\r\n\r\n      // 정보 제거\r\n      this.loadedPlugins.delete(name);\r\n\r\n      // 레지스트리에서 제거\r\n      await pluginRegistry.unregister(name);\r\n\r\n      this.emitLifecycleEvent({\r\n        type: 'stop',\r\n        pluginName: name,\r\n        timestamp: Date.now(),\r\n        data: { action: 'unloaded' }\r\n      });\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 모든 활성 플러그인 언로드\r\n   */\r\n  async unloadAllPlugins(): Promise<Result<void>> {\r\n    try {\r\n      const loadedNames = Array.from(this.loadedPlugins.keys());\r\n      \r\n      // 의존성 순서를 고려하여 역순으로 언로드\r\n      const sortedNames = this.sortPluginsByDependencies(loadedNames).reverse();\r\n      \r\n      for (const name of sortedNames) {\r\n        const result = await this.unloadPlugin(name);\r\n        if (!result.success) {\r\n          console.error(`Failed to unload plugin ${name}:`, result.error);\r\n        }\r\n      }\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플러그인 재시작\r\n   */\r\n  async restartPlugin(name: NonEmptyString): Promise<Result<IPlugin>> {\r\n    try {\r\n      // 언로드\r\n      const unloadResult = await this.unloadPlugin(name);\r\n      if (!unloadResult.success) {\r\n        return Err(unloadResult.error);\r\n      }\r\n\r\n      // 재시작 카운트 증가\r\n      const metrics = this.getPluginMetrics(name);\r\n      this.updatePluginMetrics(name, {\r\n        ...metrics,\r\n        restartCount: metrics.restartCount + 1\r\n      });\r\n\r\n      // 다시 로드\r\n      const loadResult = await this.loadPlugin(name);\r\n      \r\n      this.emitLifecycleEvent({\r\n        type: 'start',\r\n        pluginName: name,\r\n        timestamp: Date.now(),\r\n        data: { action: 'restarted' }\r\n      });\r\n\r\n      return loadResult;\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플러그인 상태 조회\r\n   */\r\n  getPluginStatus(name: NonEmptyString): PluginStatus | null {\r\n    const pluginInfo = this.loadedPlugins.get(name);\r\n    return pluginInfo?.status || null;\r\n  }\r\n\r\n  /**\r\n   * 로드된 모든 플러그인 조회\r\n   */\r\n  getLoadedPlugins(): ReadonlyMap<NonEmptyString, LoadedPluginInfo> {\r\n    return new Map(this.loadedPlugins);\r\n  }\r\n\r\n  /**\r\n   * 플러그인 메트릭스 조회\r\n   */\r\n  getPluginMetrics(name: NonEmptyString): PluginMetrics {\r\n    const pluginInfo = this.loadedPlugins.get(name);\r\n    return pluginInfo?.metrics || {\r\n      loadTime: 0,\r\n      initTime: 0,\r\n      errorCount: 0,\r\n      restartCount: 0,\r\n      lastActivity: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 전체 시스템 메트릭스 조회\r\n   */\r\n  getSystemMetrics(): {\r\n    totalPlugins: number;\r\n    loadedPlugins: number;\r\n    errorCount: number;\r\n    averageLoadTime: number;\r\n    memoryUsage: number;\r\n  } {\r\n    const loaded = Array.from(this.loadedPlugins.values());\r\n    const totalErrors = loaded.reduce((sum, info) => sum + info.metrics.errorCount, 0);\r\n    const avgLoadTime = loaded.length > 0 \r\n      ? loaded.reduce((sum, info) => sum + info.metrics.loadTime, 0) / loaded.length \r\n      : 0;\r\n\r\n    return {\r\n      totalPlugins: pluginRegistry.getRegisteredPlugins().length,\r\n      loadedPlugins: loaded.length,\r\n      errorCount: totalErrors,\r\n      averageLoadTime: avgLoadTime,\r\n      memoryUsage: this.estimateMemoryUsage()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 의존성 확인 및 로드\r\n   */\r\n  private async checkAndLoadDependencies(name: NonEmptyString): Promise<Result<void>> {\r\n    const factory = this.getRegisteredFactory(name);\r\n    if (!factory) {\r\n      return Err(new Error(`Plugin factory ${name} not found`));\r\n    }\r\n\r\n    // 의존성 정보가 메타데이터에 있다면 확인\r\n    const metadata = (factory as any).metadata;\r\n    const dependencies = metadata?.dependencies || [];\r\n\r\n    for (const depName of dependencies) {\r\n      if (!this.isPluginLoaded(depName as NonEmptyString)) {\r\n        const loadResult = await this.loadPlugin(depName as NonEmptyString);\r\n        if (!loadResult.success) {\r\n          return Err(new Error(`Failed to load dependency ${depName}: ${loadResult.error}`));\r\n        }\r\n      }\r\n    }\r\n\r\n    return Ok(undefined);\r\n  }\r\n\r\n  private isPluginLoaded(name: NonEmptyString): boolean {\r\n    const pluginInfo = this.loadedPlugins.get(name);\r\n    return pluginInfo?.instance != null;\r\n  }\r\n\r\n  private getRegisteredFactory(name: NonEmptyString): IPluginFactory | null {\r\n    // pluginRegistry에서 팩토리 조회 (내부 구현에 접근)\r\n    return (pluginRegistry as any).plugins.get(name)?.factory || null;\r\n  }\r\n\r\n  private sortPluginsByDependencies(names: NonEmptyString[]): NonEmptyString[] {\r\n    // 단순한 토폴로지 정렬 (실제로는 더 복잡한 구현 필요)\r\n    return names.sort((a, b) => {\r\n      const aInfo = this.loadedPlugins.get(a);\r\n      const bInfo = this.loadedPlugins.get(b);\r\n      return (aInfo?.dependencies.length || 0) - (bInfo?.dependencies.length || 0);\r\n    });\r\n  }\r\n\r\n  private updatePluginInfo(\r\n    name: NonEmptyString, \r\n    updates: Partial<LoadedPluginInfo>\r\n  ): void {\r\n    const current = this.loadedPlugins.get(name);\r\n    if (current) {\r\n      this.loadedPlugins.set(name, { ...current, ...updates });\r\n    }\r\n  }\r\n\r\n  private updatePluginMetrics(name: NonEmptyString, metrics: PluginMetrics): void {\r\n    const current = this.loadedPlugins.get(name);\r\n    if (current) {\r\n      this.loadedPlugins.set(name, { ...current, metrics });\r\n    }\r\n  }\r\n\r\n  private estimateMemoryUsage(): number {\r\n    // 간단한 메모리 사용량 추정\r\n    if (performance.memory) {\r\n      return performance.memory.usedJSHeapSize;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  private onConfigChange(newConfig: any): void {\r\n    // 설정 변경 시 플러그인 재로드 처리\r\n    const features = newConfig.features;\r\n    if (features.hotReload) {\r\n      // Hot reload 로직 구현\r\n      this.handleHotReload(newConfig);\r\n    }\r\n  }\r\n\r\n  private async handleHotReload(newConfig: any): Promise<void> {\r\n    // Hot reload 구현 (개발 환경에서만)\r\n    console.log('Hot reloading plugins with new config...');\r\n  }\r\n\r\n  /**\r\n   * 라이프사이클 이벤트 핸들러 등록\r\n   */\r\n  onLifecycleEvent(handler: LifecycleEventHandler): void {\r\n    this.lifecycleHandlers.add(handler);\r\n  }\r\n\r\n  offLifecycleEvent(handler: LifecycleEventHandler): void {\r\n    this.lifecycleHandlers.delete(handler);\r\n  }\r\n\r\n  private emitLifecycleEvent(event: LifecycleEvent): void {\r\n    this.lifecycleHandlers.forEach(handler => {\r\n      try {\r\n        handler(event);\r\n      } catch (error) {\r\n        console.error('Lifecycle event handler error:', error);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 시스템 정리 (앱 종료 시)\r\n   */\r\n  async dispose(): Promise<Result<void>> {\r\n    const result = await this.unloadAllPlugins();\r\n    this.lifecycleHandlers.clear();\r\n    return result;\r\n  }\r\n}\r\n\r\n// 전역 라이프사이클 매니저\r\nexport const pluginLifecycle = PluginLifecycleManager.getInstance();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\core\\PluginRegistry.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isNonEmptyString' is defined but never used. Allowed unused vars must match /^_/u.","line":15,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":15,"endColumn":59}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 플러그인 레지스트리 - 중앙 집중식 플러그인 관리\r\n * @description Registry Pattern을 구현하여 플러그인들을 관리\r\n */\r\n\r\nimport { \r\n  IPlugin, \r\n  IPluginFactory, \r\n  PluginMetadata, \r\n  PluginConfig, \r\n  PluginEvent,\r\n  PluginEventHandler,\r\n  PluginStatus \r\n} from './IPlugin';\r\nimport { NonEmptyString, Result, Ok, Err, isNonEmptyString } from '@/types/core';\r\n\r\n// 등록된 플러그인 정보\r\ninterface RegisteredPlugin {\r\n  readonly factory: IPluginFactory;\r\n  readonly instance?: IPlugin;\r\n  readonly config?: PluginConfig;\r\n  readonly registeredAt: number;\r\n}\r\n\r\n// 플러그인 검색 쿼리\r\ninterface PluginQuery {\r\n  readonly type?: NonEmptyString;\r\n  readonly name?: NonEmptyString;\r\n  readonly status?: PluginStatus;\r\n  readonly tags?: readonly string[];\r\n}\r\n\r\n/**\r\n * 플러그인 레지스트리 - 싱글톤\r\n */\r\nexport class PluginRegistry {\r\n  private static instance: PluginRegistry;\r\n  \r\n  private readonly plugins = new Map<NonEmptyString, RegisteredPlugin>();\r\n  private readonly typeIndex = new Map<NonEmptyString, Set<NonEmptyString>>();\r\n  private readonly eventHandlers = new Map<string, Set<PluginEventHandler>>();\r\n  \r\n  private constructor() {}\r\n  \r\n  static getInstance(): PluginRegistry {\r\n    if (!PluginRegistry.instance) {\r\n      PluginRegistry.instance = new PluginRegistry();\r\n    }\r\n    return PluginRegistry.instance;\r\n  }\r\n\r\n  /**\r\n   * 플러그인 팩토리 등록\r\n   */\r\n  register<T extends IPlugin>(\r\n    name: NonEmptyString,\r\n    factory: IPluginFactory<T>\r\n  ): Result<void> {\r\n    try {\r\n      if (this.plugins.has(name)) {\r\n        return Err(new Error(`Plugin '${name}' is already registered`));\r\n      }\r\n\r\n      const registered: RegisteredPlugin = {\r\n        factory,\r\n        registeredAt: Date.now()\r\n      };\r\n\r\n      this.plugins.set(name, registered);\r\n      \r\n      // 타입별 인덱스 업데이트\r\n      const pluginType = factory.pluginType;\r\n      if (!this.typeIndex.has(pluginType)) {\r\n        this.typeIndex.set(pluginType, new Set());\r\n      }\r\n      this.typeIndex.get(pluginType)!.add(name);\r\n\r\n      this.emit({\r\n        type: 'statusChange',\r\n        pluginName: name,\r\n        timestamp: Date.now(),\r\n        data: { status: 'registered' }\r\n      });\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플러그인 등록 해제\r\n   */\r\n  async unregister(name: NonEmptyString): Promise<Result<void>> {\r\n    try {\r\n      const registered = this.plugins.get(name);\r\n      if (!registered) {\r\n        return Err(new Error(`Plugin '${name}' is not registered`));\r\n      }\r\n\r\n      // 인스턴스가 있으면 정리\r\n      if (registered.instance) {\r\n        const disposeResult = await registered.instance.dispose();\r\n        if (!disposeResult.success) {\r\n          return disposeResult;\r\n        }\r\n      }\r\n\r\n      // 타입 인덱스에서 제거\r\n      const pluginType = registered.factory.pluginType;\r\n      const typeSet = this.typeIndex.get(pluginType);\r\n      if (typeSet) {\r\n        typeSet.delete(name);\r\n        if (typeSet.size === 0) {\r\n          this.typeIndex.delete(pluginType);\r\n        }\r\n      }\r\n\r\n      this.plugins.delete(name);\r\n\r\n      this.emit({\r\n        type: 'statusChange',\r\n        pluginName: name,\r\n        timestamp: Date.now(),\r\n        data: { status: 'unregistered' }\r\n      });\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플러그인 인스턴스 생성 또는 반환\r\n   */\r\n  async getInstance<T extends IPlugin>(\r\n    name: NonEmptyString,\r\n    config?: PluginConfig\r\n  ): Promise<Result<T>> {\r\n    try {\r\n      const registered = this.plugins.get(name);\r\n      if (!registered) {\r\n        return Err(new Error(`Plugin '${name}' is not registered`));\r\n      }\r\n\r\n      // 이미 인스턴스가 있고 설정이 동일하면 재사용\r\n      if (registered.instance && \r\n          JSON.stringify(registered.config) === JSON.stringify(config)) {\r\n        return Ok(registered.instance as T);\r\n      }\r\n\r\n      // 새 인스턴스 생성\r\n      const createResult = await registered.factory.create(config);\r\n      if (!createResult.success) {\r\n        return createResult;\r\n      }\r\n\r\n      const instance = createResult.data;\r\n      \r\n      // 초기화\r\n      const initResult = await instance.initialize(config);\r\n      if (!initResult.success) {\r\n        return Err(initResult.error);\r\n      }\r\n\r\n      // 등록 정보 업데이트\r\n      const updatedRegistered: RegisteredPlugin = {\r\n        ...registered,\r\n        instance,\r\n        config\r\n      };\r\n      this.plugins.set(name, updatedRegistered);\r\n\r\n      return Ok(instance as T);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 타입별 플러그인 검색\r\n   */\r\n  getPluginsByType(pluginType: NonEmptyString): readonly NonEmptyString[] {\r\n    const typeSet = this.typeIndex.get(pluginType);\r\n    return typeSet ? Array.from(typeSet) : [];\r\n  }\r\n\r\n  /**\r\n   * 플러그인 검색\r\n   */\r\n  search(query: PluginQuery): readonly NonEmptyString[] {\r\n    const results: NonEmptyString[] = [];\r\n\r\n    for (const [name, registered] of this.plugins) {\r\n      let matches = true;\r\n\r\n      // 타입 필터\r\n      if (query.type && registered.factory.pluginType !== query.type) {\r\n        matches = false;\r\n      }\r\n\r\n      // 이름 필터\r\n      if (query.name && name !== query.name) {\r\n        matches = false;\r\n      }\r\n\r\n      // 상태 필터\r\n      if (query.status && registered.instance?.status !== query.status) {\r\n        matches = false;\r\n      }\r\n\r\n      // 태그 필터\r\n      if (query.tags && query.tags.length > 0) {\r\n        const metadata = registered.instance?.metadata || \r\n                        (registered.factory as any).metadata;\r\n        const pluginTags = metadata?.tags || [];\r\n        const hasMatchingTag = query.tags.some(tag => \r\n          pluginTags.includes(tag)\r\n        );\r\n        if (!hasMatchingTag) {\r\n          matches = false;\r\n        }\r\n      }\r\n\r\n      if (matches) {\r\n        results.push(name);\r\n      }\r\n    }\r\n\r\n    return results;\r\n  }\r\n\r\n  /**\r\n   * 등록된 모든 플러그인 조회\r\n   */\r\n  getRegisteredPlugins(): readonly NonEmptyString[] {\r\n    return Array.from(this.plugins.keys());\r\n  }\r\n\r\n  /**\r\n   * 플러그인 메타데이터 조회\r\n   */\r\n  getMetadata(name: NonEmptyString): PluginMetadata | null {\r\n    const registered = this.plugins.get(name);\r\n    if (!registered) return null;\r\n    \r\n    return registered.instance?.metadata || \r\n           (registered.factory as any).metadata || null;\r\n  }\r\n\r\n  /**\r\n   * 플러그인 상태 조회\r\n   */\r\n  getStatus(name: NonEmptyString): PluginStatus | null {\r\n    const registered = this.plugins.get(name);\r\n    if (!registered) return null;\r\n    \r\n    return registered.instance?.status || 'unloaded';\r\n  }\r\n\r\n  /**\r\n   * 이벤트 핸들러 등록\r\n   */\r\n  on(event: string, handler: PluginEventHandler): void {\r\n    if (!this.eventHandlers.has(event)) {\r\n      this.eventHandlers.set(event, new Set());\r\n    }\r\n    this.eventHandlers.get(event)!.add(handler);\r\n  }\r\n\r\n  /**\r\n   * 이벤트 핸들러 제거\r\n   */\r\n  off(event: string, handler: PluginEventHandler): void {\r\n    const handlers = this.eventHandlers.get(event);\r\n    if (handlers) {\r\n      handlers.delete(handler);\r\n      if (handlers.size === 0) {\r\n        this.eventHandlers.delete(event);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 이벤트 발생\r\n   */\r\n  private emit(event: PluginEvent): void {\r\n    const handlers = this.eventHandlers.get(event.type);\r\n    if (handlers) {\r\n      handlers.forEach(handler => {\r\n        try {\r\n          handler(event);\r\n        } catch (error) {\r\n          console.error('Plugin event handler error:', error);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 레지스트리 초기화 (테스트용)\r\n   */\r\n  async clear(): Promise<void> {\r\n    const disposePromises = Array.from(this.plugins.values())\r\n      .filter(registered => registered.instance)\r\n      .map(registered => registered.instance!.dispose());\r\n\r\n    await Promise.all(disposePromises);\r\n\r\n    this.plugins.clear();\r\n    this.typeIndex.clear();\r\n    this.eventHandlers.clear();\r\n  }\r\n}\r\n\r\n// 전역 레지스트리 인스턴스\r\nexport const pluginRegistry = PluginRegistry.getInstance();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\index.ts","messages":[{"ruleId":"no-undef","severity":1,"message":"'PluginManagerOptions' is not defined.","line":56,"column":51,"nodeType":"Identifier","messageId":"undef","endLine":56,"endColumn":71},{"ruleId":"no-undef","severity":1,"message":"'pluginManager' is not defined.","line":57,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":57,"endColumn":23},{"ruleId":"no-undef","severity":1,"message":"'pluginManager' is not defined.","line":61,"column":10,"nodeType":"Identifier","messageId":"undef","endLine":61,"endColumn":23},{"ruleId":"no-undef","severity":1,"message":"'pluginManager' is not defined.","line":66,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":66,"endColumn":32},{"ruleId":"no-undef","severity":1,"message":"'pluginManager' is not defined.","line":67,"column":25,"nodeType":"Identifier","messageId":"undef","endLine":67,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 플러그인 시스템 진입점\r\n * @description 모든 플러그인 관련 기능의 중앙 진입점\r\n */\r\n\r\n// Core exports\r\nexport type { \r\n  IPlugin, \r\n  PluginMetadata, \r\n  PluginConfig as BasePluginConfig,\r\n  PluginStatus,\r\n  PluginEvent,\r\n  PluginEventHandler,\r\n  IPluginFactory \r\n} from './core/IPlugin';\r\n\r\nexport { BasePlugin } from './core/BasePlugin';\r\nexport { pluginRegistry } from './core/PluginRegistry';\r\nexport { pluginLifecycle } from './core/PluginLifecycleManager';\r\n\r\n// Config exports\r\nexport type { \r\n  PluginConfigEntry, \r\n  GlobalPluginConfig \r\n} from './config/PluginConfig';\r\nexport { pluginConfig } from './config/PluginConfig';\r\n\r\n// Speech plugin exports\r\nexport type { \r\n  ISpeechPlugin, \r\n  SpeechPluginConfig,\r\n  SpeechProcessingState,\r\n  SpeechPluginEvent,\r\n  SpeechEventHandler,\r\n  ISpeechPluginFactory \r\n} from './speech/ISpeechPlugin';\r\n\r\nexport { WebSpeechPlugin } from './speech/WebSpeechPlugin';\r\nexport { WebSpeechPluginFactory } from './speech/WebSpeechPluginFactory';\r\n\r\n// Main manager exports\r\nexport type { \r\n  PluginManagerOptions, \r\n  PluginInfo \r\n} from './PluginManager';\r\n\r\nexport { \r\n  PluginManager,\r\n  pluginManager,\r\n  getSpeechPlugin,\r\n  getPlugin,\r\n  isPluginAvailable \r\n} from './PluginManager';\r\n\r\n// Utility functions for easy initialization\r\nexport const initializePlugins = async (options?: PluginManagerOptions) => {\r\n  return pluginManager.initialize(options);\r\n};\r\n\r\nexport const shutdownPlugins = async () => {\r\n  return pluginManager.dispose();\r\n};\r\n\r\n// Plugin system health check\r\nexport const checkPluginSystemHealth = () => {\r\n  const metrics = pluginManager.getSystemMetrics();\r\n  const activePlugins = pluginManager.getActivePlugins();\r\n  \r\n  return {\r\n    isHealthy: metrics.errorCount === 0 && activePlugins.length > 0,\r\n    metrics,\r\n    activePlugins: activePlugins.length,\r\n    totalPlugins: metrics.totalPlugins\r\n  };\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\performance\\IPerformancePlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\performance\\PerformancePlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\performance\\PerformancePluginFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\simple\\AdvancedIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AdvancedSpeechPlugin' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":30}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Advanced Plugin System Integration\r\n * @description Complete integration example with all advanced features\r\n */\r\n\r\nimport {\r\n  dynamicPluginRegistry,\r\n  registerPluginLoader,\r\n  IAdvancedSpeechPlugin\r\n} from './AdvancedPluginSystem';\r\n\r\nimport { bundlingManager } from './BundlingStrategy';\r\nimport { AdvancedSpeechPlugin } from './AdvancedSpeechPlugin';\r\n\r\n// ===== Complete System Initialization =====\r\n\r\nexport async function initializeAdvancedPluginSystem(): Promise<{\r\n  success: boolean;\r\n  loadedPlugins: string[];\r\n  bundleAnalysis: any;\r\n  error?: string;\r\n}> {\r\n  try {\r\n    console.log('🚀 Initializing Advanced Plugin System...');\r\n\r\n    // Step 1: Initialize bundling strategy\r\n    await bundlingManager.initializePluginLoading();\r\n\r\n    // Step 2: Register plugins with dynamic loading\r\n    await registerAdvancedPlugins();\r\n\r\n    // Step 3: Preload critical plugins\r\n    const preloadResult = await dynamicPluginRegistry.preloadPlugins([\r\n      'speech/advanced'\r\n    ]);\r\n\r\n    if (!preloadResult.ok) {\r\n      console.warn('Preload warning:', preloadResult.cause);\r\n    }\r\n\r\n    // Step 4: Get system metrics\r\n    const systemMetrics = dynamicPluginRegistry.getSystemMetrics();\r\n    const bundleAnalysis = bundlingManager.getBundleAnalysis();\r\n\r\n    console.log('✅ Advanced Plugin System Ready!');\r\n    console.log('📊 System Metrics:', systemMetrics);\r\n    console.log('📦 Bundle Analysis:', bundleAnalysis);\r\n\r\n    return {\r\n      success: true,\r\n      loadedPlugins: dynamicPluginRegistry.listRegistrations().map(r => r.name),\r\n      bundleAnalysis\r\n    };\r\n\r\n  } catch (error) {\r\n    console.error('❌ Advanced Plugin System initialization failed:', error);\r\n    return {\r\n      success: false,\r\n      loadedPlugins: [],\r\n      bundleAnalysis: null,\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    };\r\n  }\r\n}\r\n\r\n// ===== Plugin Registration =====\r\n\r\nasync function registerAdvancedPlugins(): Promise<void> {\r\n  // Advanced Speech Plugin with dynamic loading\r\n  registerPluginLoader(\r\n    'speech/advanced',\r\n    async () => {\r\n      // Track chunk loading\r\n      bundlingManager.trackChunkLoaded('speech-advanced-chunk');\r\n      \r\n      // Dynamic import with chunk name\r\n      const module = await import(\r\n        /* webpackChunkName: \"speech-advanced\" */\r\n        './AdvancedSpeechPlugin'\r\n      );\r\n      \r\n      return { default: module.AdvancedSpeechPlugin };\r\n    },\r\n    'lazy',\r\n    'speech-advanced-chunk',\r\n    // Preload condition: load if device supports advanced speech features\r\n    () => 'speechSynthesis' in window && 'webkitSpeechRecognition' in window\r\n  );\r\n\r\n  // Future plugin examples with different loading strategies\r\n  registerFuturePlugins();\r\n}\r\n\r\nfunction registerFuturePlugins(): void {\r\n  // Example: Analytics Plugin (lazy loaded)\r\n  registerPluginLoader(\r\n    'analytics/google',\r\n    async () => {\r\n      bundlingManager.trackChunkLoaded('analytics-chunk');\r\n      \r\n      // Simulate analytics plugin\r\n      return {\r\n        default: class GoogleAnalyticsPlugin {\r\n          name = 'google-analytics';\r\n          version = '1.0.0';\r\n          \r\n          async initialize() {\r\n            console.log('📊 Google Analytics Plugin initialized');\r\n            return { ok: true, data: undefined };\r\n          }\r\n          \r\n          async dispose() {\r\n            return { ok: true, data: undefined };\r\n          }\r\n          \r\n          getMetrics() {\r\n            return {\r\n              errorCount: 0,\r\n              lastActivity: new Date(),\r\n              activeOperations: 0\r\n            };\r\n          }\r\n          \r\n          stopAll() {\r\n            return { ok: true, data: undefined };\r\n          }\r\n          \r\n          getQueueSize() { return 0; }\r\n          clearQueue() { return { ok: true, data: undefined }; }\r\n          getActiveOperations() { return []; }\r\n        }\r\n      };\r\n    },\r\n    'lazy',\r\n    'analytics-chunk'\r\n  );\r\n}\r\n\r\n// ===== Advanced Usage Hook =====\r\n\r\nimport { useState, useEffect, useCallback } from 'react';\r\n\r\nexport interface UseAdvancedSpeechResult {\r\n  // State\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  isProcessing: boolean;\r\n  queueSize: number;\r\n  activeOperations: string[];\r\n  \r\n  // Enhanced Methods with Concurrency Control\r\n  speakText: (\r\n    text: string, \r\n    options?: {\r\n      priority?: number;\r\n      timeout?: number;\r\n      onCancel?: (reason: string) => void;\r\n      language?: string;\r\n      rate?: number;\r\n    }\r\n  ) => Promise<{ success: boolean; queuePosition?: number }>;\r\n  \r\n  recognizeSpeech: (\r\n    options?: {\r\n      priority?: number;\r\n      timeout?: number;\r\n      onCancel?: (reason: string) => void;\r\n      language?: string;\r\n      maxDuration?: number;\r\n    }\r\n  ) => Promise<{ \r\n    success: boolean; \r\n    transcript?: string; \r\n    confidence?: number;\r\n    queuePosition?: number;\r\n  }>;\r\n  \r\n  playBeep: (\r\n    frequency?: number,\r\n    duration?: number,\r\n    options?: {\r\n      priority?: number;\r\n      onCancel?: () => void;\r\n    }\r\n  ) => Promise<boolean>;\r\n  \r\n  // Control Methods\r\n  stopAll: (reason?: 'user' | 'navigate' | 'error') => boolean;\r\n  clearQueue: () => boolean;\r\n  \r\n  // Metrics\r\n  getMetrics: () => any;\r\n  getBundleAnalysis: () => any;\r\n}\r\n\r\nexport function useAdvancedSpeech(): UseAdvancedSpeechResult {\r\n  const [state, setState] = useState({\r\n    isLoading: true,\r\n    error: null as string | null,\r\n    plugin: null as IAdvancedSpeechPlugin | null,\r\n    queueSize: 0,\r\n    activeOperations: [] as string[]\r\n  });\r\n\r\n  // Initialize plugin\r\n  useEffect(() => {\r\n    let mounted = true;\r\n    \r\n    const initPlugin = async () => {\r\n      try {\r\n        const result = await dynamicPluginRegistry.getPlugin<IAdvancedSpeechPlugin>('speech/advanced');\r\n        \r\n        if (!mounted) return;\r\n        \r\n        if (result.ok) {\r\n          setState(prev => ({\r\n            ...prev,\r\n            isLoading: false,\r\n            plugin: result.data,\r\n            error: null\r\n          }));\r\n        } else {\r\n          setState(prev => ({\r\n            ...prev,\r\n            isLoading: false,\r\n            error: result.cause || 'Failed to load speech plugin'\r\n          }));\r\n        }\r\n      } catch (error) {\r\n        if (!mounted) return;\r\n        setState(prev => ({\r\n          ...prev,\r\n          isLoading: false,\r\n          error: error instanceof Error ? error.message : 'Unknown error'\r\n        }));\r\n      }\r\n    };\r\n\r\n    initPlugin();\r\n    \r\n    return () => { mounted = false; };\r\n  }, []);\r\n\r\n  // Update queue metrics periodically\r\n  useEffect(() => {\r\n    if (!state.plugin) return;\r\n    \r\n    const interval = setInterval(() => {\r\n      if (state.plugin) {\r\n        setState(prev => ({\r\n          ...prev,\r\n          queueSize: prev.plugin?.getQueueSize() || 0,\r\n          activeOperations: prev.plugin?.getActiveOperations() || []\r\n        }));\r\n      }\r\n    }, 1000); // Update every second\r\n    \r\n    return () => clearInterval(interval);\r\n  }, [state.plugin]);\r\n\r\n  // Enhanced speech methods\r\n  const speakText = useCallback(async (\r\n    text: string, \r\n    options: {\r\n      priority?: number;\r\n      timeout?: number;\r\n      onCancel?: (reason: string) => void;\r\n      language?: string;\r\n      rate?: number;\r\n    } = {}\r\n  ) => {\r\n    if (!state.plugin) return { success: false };\r\n    \r\n    const controller = new AbortController();\r\n    \r\n    const result = await state.plugin.speakText(text, {\r\n      priority: options.priority,\r\n      timeout: options.timeout,\r\n      onCancel: options.onCancel,\r\n      language: options.language,\r\n      rate: options.rate,\r\n      signal: controller.signal\r\n    });\r\n    \r\n    if (result.ok) {\r\n      return {\r\n        success: true,\r\n        queuePosition: result.data.queuePosition\r\n      };\r\n    } else {\r\n      setState(prev => ({ ...prev, error: result.cause || 'Speech failed' }));\r\n      return { success: false };\r\n    }\r\n  }, [state.plugin]);\r\n\r\n  const recognizeSpeech = useCallback(async (\r\n    options: {\r\n      priority?: number;\r\n      timeout?: number;\r\n      onCancel?: (reason: string) => void;\r\n      language?: string;\r\n      maxDuration?: number;\r\n    } = {}\r\n  ) => {\r\n    if (!state.plugin) return { success: false };\r\n    \r\n    const controller = new AbortController();\r\n    \r\n    const result = await state.plugin.recognizeSpeech({\r\n      priority: options.priority,\r\n      timeout: options.timeout,\r\n      onCancel: options.onCancel,\r\n      language: options.language,\r\n      maxDuration: options.maxDuration,\r\n      signal: controller.signal\r\n    });\r\n    \r\n    if (result.ok) {\r\n      return {\r\n        success: true,\r\n        transcript: result.data.transcript,\r\n        confidence: result.data.confidence,\r\n        queuePosition: result.data.queuePosition\r\n      };\r\n    } else {\r\n      setState(prev => ({ ...prev, error: result.cause || 'Recognition failed' }));\r\n      return { success: false };\r\n    }\r\n  }, [state.plugin]);\r\n\r\n  const playBeep = useCallback(async (\r\n    frequency = 800,\r\n    duration = 200,\r\n    options: {\r\n      priority?: number;\r\n      onCancel?: () => void;\r\n    } = {}\r\n  ) => {\r\n    if (!state.plugin) return false;\r\n    \r\n    const controller = new AbortController();\r\n    \r\n    const result = await state.plugin.playBeep(frequency, duration, {\r\n      priority: options.priority,\r\n      signal: controller.signal,\r\n      onCancel: options.onCancel\r\n    });\r\n    \r\n    if (!result.ok) {\r\n      setState(prev => ({ ...prev, error: result.cause || 'Beep failed' }));\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }, [state.plugin]);\r\n\r\n  const stopAll = useCallback((reason: 'user' | 'navigate' | 'error' = 'user') => {\r\n    if (!state.plugin) return false;\r\n    \r\n    const result = state.plugin.stopAll(reason);\r\n    if (!result.ok) {\r\n      setState(prev => ({ ...prev, error: result.cause || 'Stop failed' }));\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }, [state.plugin]);\r\n\r\n  const clearQueue = useCallback(() => {\r\n    if (!state.plugin) return false;\r\n    \r\n    const result = state.plugin.clearQueue();\r\n    if (!result.ok) {\r\n      setState(prev => ({ ...prev, error: result.cause || 'Clear queue failed' }));\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }, [state.plugin]);\r\n\r\n  const getMetrics = useCallback(() => {\r\n    return state.plugin?.getMetrics();\r\n  }, [state.plugin]);\r\n\r\n  const getBundleAnalysis = useCallback(() => {\r\n    return bundlingManager.getBundleAnalysis();\r\n  }, []);\r\n\r\n  return {\r\n    // State\r\n    isLoading: state.isLoading,\r\n    error: state.error,\r\n    isProcessing: state.activeOperations.length > 0,\r\n    queueSize: state.queueSize,\r\n    activeOperations: state.activeOperations,\r\n    \r\n    // Methods\r\n    speakText,\r\n    recognizeSpeech,\r\n    playBeep,\r\n    stopAll,\r\n    clearQueue,\r\n    getMetrics,\r\n    getBundleAnalysis\r\n  };\r\n}\r\n\r\n// ===== System Health & Monitoring =====\r\n\r\nexport function getAdvancedPluginSystemHealth(): {\r\n  systemStatus: 'healthy' | 'degraded' | 'critical';\r\n  pluginCount: number;\r\n  memoryUsage: number;\r\n  averageLoadTime: number;\r\n  errorRate: number;\r\n  recommendations: string[];\r\n} {\r\n  const metrics = dynamicPluginRegistry.getSystemMetrics();\r\n  const bundleAnalysis = bundlingManager.getBundleAnalysis();\r\n  \r\n  let systemStatus: 'healthy' | 'degraded' | 'critical' = 'healthy';\r\n  const recommendations: string[] = [];\r\n  \r\n  // Assess system health\r\n  if (metrics.averageLoadTime > 1000) {\r\n    systemStatus = 'degraded';\r\n    recommendations.push('Plugin load times are high - consider code splitting');\r\n  }\r\n  \r\n  if (metrics.totalMemoryUsage > 50 * 1024 * 1024) { // 50MB\r\n    systemStatus = 'critical';\r\n    recommendations.push('High memory usage - consider unloading unused plugins');\r\n  }\r\n  \r\n  return {\r\n    systemStatus,\r\n    pluginCount: metrics.loadedPlugins,\r\n    memoryUsage: metrics.totalMemoryUsage,\r\n    averageLoadTime: metrics.averageLoadTime,\r\n    errorRate: 0, // Would need to track errors over time\r\n    recommendations: [...recommendations, ...bundleAnalysis.recommendations]\r\n  };\r\n}\r\n\r\n// ===== Development Tools =====\r\n\r\nif (import.meta.env.DEV) {\r\n  // Export for dev console access\r\n  (window as any).__advancedPluginSystem = {\r\n    registry: dynamicPluginRegistry,\r\n    bundling: bundlingManager,\r\n    health: getAdvancedPluginSystemHealth,\r\n    init: initializeAdvancedPluginSystem\r\n  };\r\n  \r\n  console.log('🛠️ Advanced Plugin System dev tools available at window.__advancedPluginSystem');\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\simple\\AdvancedPluginSystem.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Err' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":6},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ErrCode' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":10}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 고급 플러그인 시스템 - Dynamic Loading & Concurrency Control\r\n * @description Discovery/Loading Strategy + Cancellation/Concurrency 개선\r\n */\r\n\r\nimport { \r\n  Result, \r\n  Ok, \r\n  Err, \r\n  ErrCode, \r\n  CommonErrors,\r\n  ISimplePlugin \r\n} from './SimplePluginSystem';\r\n\r\n// ===== Enhanced Plugin Interfaces =====\r\n\r\nexport type PluginLoadingStrategy = 'static' | 'lazy' | 'preload';\r\nexport type QueuePolicy = 'fifo' | 'lifo' | 'priority' | 'concurrent';\r\nexport type StopReason = 'user' | 'navigate' | 'error' | 'dispose' | 'timeout' | 'memory';\r\n\r\nexport interface PluginMetrics {\r\n  loadTime?: number;\r\n  memoryUsage?: number;\r\n  errorCount: number;\r\n  lastActivity: Date;\r\n  activeOperations: number;\r\n}\r\n\r\nexport interface ConcurrencyConfig {\r\n  readonly maxConcurrency: number;\r\n  readonly queuePolicy: QueuePolicy;\r\n  readonly timeout?: number;\r\n}\r\n\r\nexport interface IAdvancedPlugin extends ISimplePlugin {\r\n  // Concurrency Control\r\n  readonly concurrencyConfig?: ConcurrencyConfig;\r\n  \r\n  // Enhanced Lifecycle with Metrics\r\n  getMetrics(): PluginMetrics;\r\n  \r\n  // Enhanced Stop Control\r\n  stopAll(reason: StopReason): Result<void>;\r\n  \r\n  // Queue Management\r\n  getQueueSize(): number;\r\n  clearQueue(): Result<void>;\r\n}\r\n\r\n// ===== Enhanced Speech Plugin Interface =====\r\n\r\nexport interface SpeechOptionsAdvanced {\r\n  readonly language?: string;\r\n  readonly rate?: number;\r\n  readonly priority?: number; // 0-10, 10 = highest\r\n  readonly signal?: AbortSignal;\r\n  readonly onCancel?: (reason: string) => void;\r\n  readonly timeout?: number;\r\n}\r\n\r\nexport interface RecognitionOptionsAdvanced {\r\n  readonly language?: string;\r\n  readonly maxDuration?: number;\r\n  readonly continuous?: boolean;\r\n  readonly priority?: number;\r\n  readonly signal?: AbortSignal;\r\n  readonly onCancel?: (reason: string) => void;\r\n  readonly timeout?: number;\r\n}\r\n\r\nexport interface IAdvancedSpeechPlugin extends IAdvancedPlugin {\r\n  // Enhanced TTS with concurrency\r\n  speakText(\r\n    text: string, \r\n    opts?: SpeechOptionsAdvanced\r\n  ): Promise<Result<{ duration: number; queuePosition?: number }>>;\r\n  \r\n  // Enhanced STT with concurrency\r\n  recognizeSpeech(\r\n    opts?: RecognitionOptionsAdvanced\r\n  ): Promise<Result<{ transcript: string; confidence: number; queuePosition?: number }>>;\r\n  \r\n  // Beep with concurrency\r\n  playBeep(\r\n    frequency?: number, \r\n    duration?: number,\r\n    opts?: { priority?: number; signal?: AbortSignal; onCancel?: () => void }\r\n  ): Promise<Result<void>>;\r\n  \r\n  // Queue inspection\r\n  getActiveOperations(): string[];\r\n  getSpeechQueue(): Array<{ id: string; text: string; priority: number }>;\r\n}\r\n\r\n// ===== Plugin Factory & Loader System =====\r\n\r\nexport type PluginFactory<T extends IAdvancedPlugin> = () => Promise<T>;\r\nexport type PluginLoader<T extends IAdvancedPlugin> = () => Promise<{ default: new() => T }>;\r\n\r\nexport interface PluginRegistration<T extends IAdvancedPlugin> {\r\n  readonly name: string;\r\n  readonly factory?: PluginFactory<T>;\r\n  readonly loader?: PluginLoader<T>;\r\n  readonly strategy: PluginLoadingStrategy;\r\n  readonly bundleChunk?: string; // For code-splitting\r\n  readonly preloadCondition?: () => boolean;\r\n}\r\n\r\n// ===== Dynamic Plugin Registry =====\r\n\r\nexport class DynamicPluginRegistry {\r\n  private registrations = new Map<string, PluginRegistration<any>>();\r\n  private loadedPlugins = new Map<string, IAdvancedPlugin>();\r\n  private loadingPromises = new Map<string, Promise<IAdvancedPlugin>>();\r\n  private metrics = new Map<string, PluginMetrics>();\r\n\r\n  /**\r\n   * Register plugin with dynamic loading capability\r\n   */\r\n  register<T extends IAdvancedPlugin>(\r\n    registration: PluginRegistration<T>\r\n  ): Result<void> {\r\n    if (this.registrations.has(registration.name)) {\r\n      return CommonErrors.INVALID_INPUT(`Plugin '${registration.name}' already registered`);\r\n    }\r\n\r\n    // Validate registration\r\n    if (!registration.factory && !registration.loader) {\r\n      return CommonErrors.INVALID_INPUT('Either factory or loader must be provided');\r\n    }\r\n\r\n    this.registrations.set(registration.name, registration);\r\n\r\n    // Handle preload strategy\r\n    if (registration.strategy === 'preload') {\r\n      const shouldPreload = registration.preloadCondition?.() ?? true;\r\n      if (shouldPreload) {\r\n        // Start loading in background (don't await)\r\n        this.loadPlugin(registration.name).catch(error => {\r\n          console.warn(`Preload failed for ${registration.name}:`, error);\r\n        });\r\n      }\r\n    }\r\n\r\n    return Ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Dynamic plugin loading with caching\r\n   */\r\n  async loadPlugin<T extends IAdvancedPlugin>(name: string): Promise<Result<T>> {\r\n    // Return cached instance if available\r\n    const cached = this.loadedPlugins.get(name);\r\n    if (cached) {\r\n      return Ok(cached as T);\r\n    }\r\n\r\n    // Return in-flight loading promise if exists\r\n    const inFlight = this.loadingPromises.get(name);\r\n    if (inFlight) {\r\n      try {\r\n        const plugin = await inFlight;\r\n        return Ok(plugin as T);\r\n      } catch (error) {\r\n        return CommonErrors.INTERNAL(`Loading failed: ${error}`);\r\n      }\r\n    }\r\n\r\n    // Start new loading process\r\n    const registration = this.registrations.get(name);\r\n    if (!registration) {\r\n      return CommonErrors.INVALID_INPUT(`Plugin '${name}' not registered`);\r\n    }\r\n\r\n    const loadingPromise = this.createLoadingPromise<T>(registration);\r\n    this.loadingPromises.set(name, loadingPromise);\r\n\r\n    try {\r\n      const startTime = Date.now();\r\n      const plugin = await loadingPromise;\r\n      \r\n      // Initialize plugin\r\n      const initResult = await plugin.initialize?.();\r\n      if (initResult && !initResult.ok) {\r\n        throw new Error(`Initialization failed: ${initResult.cause}`);\r\n      }\r\n\r\n      // Cache the loaded plugin\r\n      this.loadedPlugins.set(name, plugin);\r\n      \r\n      // Record metrics\r\n      this.metrics.set(name, {\r\n        loadTime: Date.now() - startTime,\r\n        errorCount: 0,\r\n        lastActivity: new Date(),\r\n        activeOperations: 0\r\n      });\r\n\r\n      return Ok(plugin as T);\r\n\r\n    } catch (error) {\r\n      this.loadingPromises.delete(name);\r\n      return CommonErrors.INTERNAL(`Plugin loading failed: ${error}`);\r\n    } finally {\r\n      this.loadingPromises.delete(name);\r\n    }\r\n  }\r\n\r\n  private async createLoadingPromise<T extends IAdvancedPlugin>(\r\n    registration: PluginRegistration<T>\r\n  ): Promise<T> {\r\n    if (registration.factory) {\r\n      return await registration.factory();\r\n    }\r\n\r\n    if (registration.loader) {\r\n      const module = await registration.loader();\r\n      return new module.default();\r\n    }\r\n\r\n    throw new Error('No factory or loader provided');\r\n  }\r\n\r\n  /**\r\n   * Get plugin with dynamic loading\r\n   */\r\n  async getPlugin<T extends IAdvancedPlugin>(name: string): Promise<Result<T>> {\r\n    return await this.loadPlugin<T>(name);\r\n  }\r\n\r\n  /**\r\n   * Preload specific plugins\r\n   */\r\n  async preloadPlugins(names: string[]): Promise<Result<void>> {\r\n    const failures: string[] = [];\r\n    \r\n    await Promise.allSettled(\r\n      names.map(async (name) => {\r\n        const result = await this.loadPlugin(name);\r\n        if (!result.ok) {\r\n          failures.push(`${name}: ${result.cause}`);\r\n        }\r\n      })\r\n    );\r\n\r\n    if (failures.length > 0) {\r\n      return CommonErrors.INTERNAL(`Preload failures: ${failures.join(', ')}`);\r\n    }\r\n\r\n    return Ok(undefined);\r\n  }\r\n\r\n  /**\r\n   * Unload plugin and free memory\r\n   */\r\n  async unloadPlugin(name: string): Promise<Result<void>> {\r\n    const plugin = this.loadedPlugins.get(name);\r\n    if (!plugin) {\r\n      return CommonErrors.INVALID_INPUT(`Plugin '${name}' not loaded`);\r\n    }\r\n\r\n    try {\r\n      // Stop all operations\r\n      plugin.stopAll('dispose');\r\n      \r\n      // Dispose plugin\r\n      const disposeResult = await plugin.dispose?.();\r\n      if (disposeResult && !disposeResult.ok) {\r\n        console.warn(`Dispose warning for ${name}:`, disposeResult.cause);\r\n      }\r\n\r\n      // Remove from caches\r\n      this.loadedPlugins.delete(name);\r\n      this.metrics.delete(name);\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return CommonErrors.INTERNAL(`Unload failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get system metrics\r\n   */\r\n  getSystemMetrics(): {\r\n    registeredPlugins: number;\r\n    loadedPlugins: number;\r\n    totalMemoryUsage: number;\r\n    averageLoadTime: number;\r\n  } {\r\n    const metricsArray = Array.from(this.metrics.values());\r\n    \r\n    return {\r\n      registeredPlugins: this.registrations.size,\r\n      loadedPlugins: this.loadedPlugins.size,\r\n      totalMemoryUsage: metricsArray.reduce((sum, m) => sum + (m.memoryUsage || 0), 0),\r\n      averageLoadTime: metricsArray.length > 0 \r\n        ? metricsArray.reduce((sum, m) => sum + (m.loadTime || 0), 0) / metricsArray.length\r\n        : 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * List all registered plugins\r\n   */\r\n  listRegistrations(): Array<{\r\n    name: string;\r\n    strategy: PluginLoadingStrategy;\r\n    loaded: boolean;\r\n    bundleChunk?: string;\r\n  }> {\r\n    return Array.from(this.registrations.entries()).map(([name, reg]) => ({\r\n      name,\r\n      strategy: reg.strategy,\r\n      loaded: this.loadedPlugins.has(name),\r\n      bundleChunk: reg.bundleChunk\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Clean up all plugins\r\n   */\r\n  async dispose(): Promise<Result<void>> {\r\n    const names = Array.from(this.loadedPlugins.keys());\r\n    const failures: string[] = [];\r\n\r\n    await Promise.allSettled(\r\n      names.map(async (name) => {\r\n        const result = await this.unloadPlugin(name);\r\n        if (!result.ok) {\r\n          failures.push(`${name}: ${result.cause}`);\r\n        }\r\n      })\r\n    );\r\n\r\n    // Clear all maps\r\n    this.registrations.clear();\r\n    this.loadedPlugins.clear();\r\n    this.loadingPromises.clear();\r\n    this.metrics.clear();\r\n\r\n    if (failures.length > 0) {\r\n      return CommonErrors.INTERNAL(`Cleanup failures: ${failures.join(', ')}`);\r\n    }\r\n\r\n    return Ok(undefined);\r\n  }\r\n}\r\n\r\n// ===== Global Registry Instance =====\r\nexport const dynamicPluginRegistry = new DynamicPluginRegistry();\r\n\r\n// ===== Convenience Functions =====\r\n\r\n/**\r\n * Register plugin with factory function\r\n */\r\nexport function registerPluginFactory<T extends IAdvancedPlugin>(\r\n  name: string,\r\n  factory: PluginFactory<T>,\r\n  strategy: PluginLoadingStrategy = 'lazy',\r\n  bundleChunk?: string\r\n): Result<void> {\r\n  return dynamicPluginRegistry.register({\r\n    name,\r\n    factory,\r\n    strategy,\r\n    bundleChunk\r\n  });\r\n}\r\n\r\n/**\r\n * Register plugin with dynamic import loader\r\n */\r\nexport function registerPluginLoader<T extends IAdvancedPlugin>(\r\n  name: string,\r\n  loader: PluginLoader<T>,\r\n  strategy: PluginLoadingStrategy = 'lazy',\r\n  bundleChunk?: string,\r\n  preloadCondition?: () => boolean\r\n): Result<void> {\r\n  return dynamicPluginRegistry.register({\r\n    name,\r\n    loader,\r\n    strategy,\r\n    bundleChunk,\r\n    preloadCondition\r\n  });\r\n}\r\n\r\n// ===== Usage Examples in Comments =====\r\n\r\n/*\r\n// Example 1: Static Registration\r\nregisterPluginFactory(\r\n  'speech/simple',\r\n  async () => new SimpleSpeechPlugin(),\r\n  'static'\r\n);\r\n\r\n// Example 2: Dynamic Import with Code Splitting\r\nregisterPluginLoader(\r\n  'speech/web', \r\n  async () => {\r\n    const m = await import('./speech/WebSpeechPlugin');\r\n    return m;\r\n  },\r\n  'lazy',\r\n  'speech-web-chunk'\r\n);\r\n\r\n// Example 3: Preload with Condition\r\nregisterPluginLoader(\r\n  'analytics/google',\r\n  async () => import('./analytics/GoogleAnalyticsPlugin'),\r\n  'preload',\r\n  'analytics-chunk',\r\n  () => import.meta.env.PROD && window.gtag !== undefined\r\n);\r\n\r\n// Example 4: Usage\r\nconst speechPlugin = await dynamicPluginRegistry.getPlugin<IAdvancedSpeechPlugin>('speech/web');\r\nif (speechPlugin.ok) {\r\n  await speechPlugin.data.speakText('Hello', { \r\n    priority: 5,\r\n    timeout: 10000,\r\n    onCancel: (reason) => console.log('Cancelled:', reason)\r\n  });\r\n}\r\n*/","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\simple\\AdvancedSpeechPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\simple\\BundlingStrategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\simple\\MetricsAndSLOs.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalRecognizeSpeech' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":529,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":529,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'originalPlayBeep' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":530,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":530,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Concrete Metrics & SLO Definitions\r\n * @description Real measurements with SLOs, dashboards, and release gates\r\n */\r\n\r\n// ===== SLO Definitions =====\r\n\r\nexport interface SpeechSLO {\r\n  // Latency SLOs\r\n  p50StartLatency: number;    // ms - 50th percentile\r\n  p95StartLatency: number;    // ms - 95th percentile  \r\n  p99StartLatency: number;    // ms - 99th percentile\r\n  \r\n  // Reliability SLOs\r\n  successRate: number;        // % - successful operations\r\n  availabilityRate: number;   // % - service availability\r\n  \r\n  // Quality SLOs\r\n  interruptionRate: number;   // % - operations interrupted\r\n  errorRate: number;          // % - failed operations\r\n  \r\n  // Resource SLOs\r\n  memoryUsageCeiling: number; // bytes - max memory usage\r\n  cpuUsageLimit: number;      // % - max CPU usage\r\n}\r\n\r\nexport const PRODUCTION_SLO: SpeechSLO = {\r\n  // ✅ Latency targets (based on user experience research)\r\n  p50StartLatency: 100,      // 100ms - barely noticeable\r\n  p95StartLatency: 250,      // 250ms - acceptable delay\r\n  p99StartLatency: 500,      // 500ms - maximum tolerable\r\n  \r\n  // ✅ Reliability targets (industry standard)\r\n  successRate: 99.5,         // 99.5% - high reliability\r\n  availabilityRate: 99.9,    // 99.9% - \"three nines\"\r\n  \r\n  // ✅ Quality targets (user satisfaction)\r\n  interruptionRate: 2.0,     // <2% interruption rate\r\n  errorRate: 0.5,            // <0.5% error rate\r\n  \r\n  // ✅ Resource targets (performance)\r\n  memoryUsageCeiling: 50 * 1024 * 1024, // 50MB max\r\n  cpuUsageLimit: 10.0        // <10% CPU usage\r\n};\r\n\r\n// ===== Metrics Collection System =====\r\n\r\nexport interface MetricPoint {\r\n  timestamp: number;\r\n  value: number;\r\n  tags: Record<string, string>;\r\n}\r\n\r\nexport interface OperationMetrics {\r\n  // Timing metrics\r\n  startTime: number;\r\n  endTime?: number;\r\n  duration?: number;\r\n  \r\n  // Outcome metrics\r\n  success: boolean;\r\n  errorCode?: string;\r\n  errorMessage?: string;\r\n  \r\n  // Context metrics\r\n  operationType: 'speakText' | 'recognizeSpeech' | 'playBeep';\r\n  textLength?: number;\r\n  language?: string;\r\n  priority?: number;\r\n  \r\n  // Quality metrics\r\n  interrupted: boolean;\r\n  queueWaitTime?: number;\r\n  retryCount: number;\r\n}\r\n\r\nexport class SpeechMetricsCollector {\r\n  private metrics: OperationMetrics[] = [];\r\n  private memoryUsage: number[] = [];\r\n  private cpuMeasurements: number[] = [];\r\n  \r\n  // ✅ Real-time metric collection\r\n  private currentOperations = new Map<string, OperationMetrics>();\r\n  \r\n  /**\r\n   * Start tracking an operation\r\n   */\r\n  startOperation(\r\n    operationId: string,\r\n    type: 'speakText' | 'recognizeSpeech' | 'playBeep',\r\n    context: {\r\n      textLength?: number;\r\n      language?: string;\r\n      priority?: number;\r\n    }\r\n  ): void {\r\n    const metric: OperationMetrics = {\r\n      startTime: performance.now(),\r\n      success: false,\r\n      operationType: type,\r\n      interrupted: false,\r\n      retryCount: 0,\r\n      ...context\r\n    };\r\n    \r\n    this.currentOperations.set(operationId, metric);\r\n  }\r\n  \r\n  /**\r\n   * Complete an operation with outcome\r\n   */\r\n  completeOperation(\r\n    operationId: string,\r\n    outcome: {\r\n      success: boolean;\r\n      errorCode?: string;\r\n      errorMessage?: string;\r\n      interrupted?: boolean;\r\n      queueWaitTime?: number;\r\n      retryCount?: number;\r\n    }\r\n  ): void {\r\n    const metric = this.currentOperations.get(operationId);\r\n    if (!metric) return;\r\n    \r\n    metric.endTime = performance.now();\r\n    metric.duration = metric.endTime - metric.startTime;\r\n    metric.success = outcome.success;\r\n    metric.errorCode = outcome.errorCode;\r\n    metric.errorMessage = outcome.errorMessage;\r\n    metric.interrupted = outcome.interrupted || false;\r\n    metric.queueWaitTime = outcome.queueWaitTime;\r\n    metric.retryCount = outcome.retryCount || 0;\r\n    \r\n    this.metrics.push(metric);\r\n    this.currentOperations.delete(operationId);\r\n    \r\n    // Cleanup old metrics (keep last 1000)\r\n    if (this.metrics.length > 1000) {\r\n      this.metrics = this.metrics.slice(-1000);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Record memory usage\r\n   */\r\n  recordMemoryUsage(): void {\r\n    if ('memory' in performance) {\r\n      const memory = (performance as any).memory;\r\n      this.memoryUsage.push(memory.usedJSHeapSize);\r\n      \r\n      // Keep last 100 measurements\r\n      if (this.memoryUsage.length > 100) {\r\n        this.memoryUsage = this.memoryUsage.slice(-100);\r\n      }\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Calculate percentile latency\r\n   */\r\n  calculateLatencyPercentile(percentile: number, operationType?: string): number {\r\n    let durations = this.metrics\r\n      .filter(m => m.duration !== undefined && m.success)\r\n      .map(m => m.duration!);\r\n    \r\n    if (operationType) {\r\n      durations = this.metrics\r\n        .filter(m => m.operationType === operationType && m.duration !== undefined && m.success)\r\n        .map(m => m.duration!);\r\n    }\r\n    \r\n    if (durations.length === 0) return 0;\r\n    \r\n    durations.sort((a, b) => a - b);\r\n    const index = Math.ceil(durations.length * (percentile / 100)) - 1;\r\n    return durations[Math.max(0, index)];\r\n  }\r\n  \r\n  /**\r\n   * Calculate success rate\r\n   */\r\n  calculateSuccessRate(operationType?: string, timeWindowMs: number = 300000): number {\r\n    const cutoff = Date.now() - timeWindowMs;\r\n    let relevantMetrics = this.metrics.filter(m => \r\n      m.startTime >= cutoff && m.endTime !== undefined\r\n    );\r\n    \r\n    if (operationType) {\r\n      relevantMetrics = relevantMetrics.filter(m => m.operationType === operationType);\r\n    }\r\n    \r\n    if (relevantMetrics.length === 0) return 100; // No data = assume healthy\r\n    \r\n    const successful = relevantMetrics.filter(m => m.success).length;\r\n    return (successful / relevantMetrics.length) * 100;\r\n  }\r\n  \r\n  /**\r\n   * Calculate interruption rate\r\n   */\r\n  calculateInterruptionRate(timeWindowMs: number = 300000): number {\r\n    const cutoff = Date.now() - timeWindowMs;\r\n    const relevantMetrics = this.metrics.filter(m => \r\n      m.startTime >= cutoff && m.endTime !== undefined\r\n    );\r\n    \r\n    if (relevantMetrics.length === 0) return 0;\r\n    \r\n    const interrupted = relevantMetrics.filter(m => m.interrupted).length;\r\n    return (interrupted / relevantMetrics.length) * 100;\r\n  }\r\n  \r\n  /**\r\n   * Get current memory usage\r\n   */\r\n  getCurrentMemoryUsage(): number {\r\n    if (this.memoryUsage.length === 0) return 0;\r\n    return this.memoryUsage[this.memoryUsage.length - 1];\r\n  }\r\n  \r\n  /**\r\n   * Get error rate by error code\r\n   */\r\n  getErrorBreakdown(timeWindowMs: number = 300000): Record<string, number> {\r\n    const cutoff = Date.now() - timeWindowMs;\r\n    const failures = this.metrics.filter(m => \r\n      m.startTime >= cutoff && !m.success && m.errorCode\r\n    );\r\n    \r\n    const breakdown: Record<string, number> = {};\r\n    failures.forEach(m => {\r\n      breakdown[m.errorCode!] = (breakdown[m.errorCode!] || 0) + 1;\r\n    });\r\n    \r\n    return breakdown;\r\n  }\r\n}\r\n\r\n// ===== SLO Monitoring & Alerting =====\r\n\r\nexport interface SLOViolation {\r\n  metric: keyof SpeechSLO;\r\n  target: number;\r\n  actual: number;\r\n  severity: 'warning' | 'critical';\r\n  timestamp: number;\r\n  details?: string;\r\n}\r\n\r\nexport class SLOMonitor {\r\n  private violations: SLOViolation[] = [];\r\n  \r\n  constructor(\r\n    private metricsCollector: SpeechMetricsCollector,\r\n    private slo: SpeechSLO = PRODUCTION_SLO\r\n  ) {}\r\n  \r\n  /**\r\n   * Check all SLOs and report violations\r\n   */\r\n  checkSLOs(): SLOViolation[] {\r\n    const violations: SLOViolation[] = [];\r\n    const now = Date.now();\r\n    \r\n    // ✅ Check latency SLOs\r\n    const p95Latency = this.metricsCollector.calculateLatencyPercentile(95, 'speakText');\r\n    if (p95Latency > this.slo.p95StartLatency) {\r\n      violations.push({\r\n        metric: 'p95StartLatency',\r\n        target: this.slo.p95StartLatency,\r\n        actual: p95Latency,\r\n        severity: p95Latency > this.slo.p95StartLatency * 2 ? 'critical' : 'warning',\r\n        timestamp: now,\r\n        details: `speakText p95 latency: ${p95Latency}ms > ${this.slo.p95StartLatency}ms`\r\n      });\r\n    }\r\n    \r\n    // ✅ Check success rate SLO\r\n    const successRate = this.metricsCollector.calculateSuccessRate();\r\n    if (successRate < this.slo.successRate) {\r\n      violations.push({\r\n        metric: 'successRate',\r\n        target: this.slo.successRate,\r\n        actual: successRate,\r\n        severity: successRate < this.slo.successRate * 0.95 ? 'critical' : 'warning',\r\n        timestamp: now,\r\n        details: `Success rate: ${successRate.toFixed(2)}% < ${this.slo.successRate}%`\r\n      });\r\n    }\r\n    \r\n    // ✅ Check interruption rate SLO\r\n    const interruptionRate = this.metricsCollector.calculateInterruptionRate();\r\n    if (interruptionRate > this.slo.interruptionRate) {\r\n      violations.push({\r\n        metric: 'interruptionRate',\r\n        target: this.slo.interruptionRate,\r\n        actual: interruptionRate,\r\n        severity: interruptionRate > this.slo.interruptionRate * 2 ? 'critical' : 'warning',\r\n        timestamp: now,\r\n        details: `Interruption rate: ${interruptionRate.toFixed(2)}% > ${this.slo.interruptionRate}%`\r\n      });\r\n    }\r\n    \r\n    // ✅ Check memory usage SLO\r\n    const memoryUsage = this.metricsCollector.getCurrentMemoryUsage();\r\n    if (memoryUsage > this.slo.memoryUsageCeiling) {\r\n      violations.push({\r\n        metric: 'memoryUsageCeiling',\r\n        target: this.slo.memoryUsageCeiling,\r\n        actual: memoryUsage,\r\n        severity: memoryUsage > this.slo.memoryUsageCeiling * 1.2 ? 'critical' : 'warning',\r\n        timestamp: now,\r\n        details: `Memory usage: ${(memoryUsage / 1024 / 1024).toFixed(1)}MB > ${(this.slo.memoryUsageCeiling / 1024 / 1024).toFixed(1)}MB`\r\n      });\r\n    }\r\n    \r\n    // Store violations\r\n    this.violations.push(...violations);\r\n    \r\n    // Cleanup old violations (keep last 24 hours)\r\n    const dayAgo = now - 24 * 60 * 60 * 1000;\r\n    this.violations = this.violations.filter(v => v.timestamp > dayAgo);\r\n    \r\n    return violations;\r\n  }\r\n  \r\n  /**\r\n   * Get SLO compliance report\r\n   */\r\n  getComplianceReport(timeWindowMs: number = 300000): {\r\n    compliant: boolean;\r\n    violations: SLOViolation[];\r\n    summary: {\r\n      latencyP95: number;\r\n      successRate: number;\r\n      interruptionRate: number;\r\n      memoryUsage: number;\r\n      errorBreakdown: Record<string, number>;\r\n    };\r\n  } {\r\n    const violations = this.checkSLOs();\r\n    const summary = {\r\n      latencyP95: this.metricsCollector.calculateLatencyPercentile(95),\r\n      successRate: this.metricsCollector.calculateSuccessRate(),\r\n      interruptionRate: this.metricsCollector.calculateInterruptionRate(timeWindowMs),\r\n      memoryUsage: this.metricsCollector.getCurrentMemoryUsage(),\r\n      errorBreakdown: this.metricsCollector.getErrorBreakdown(timeWindowMs)\r\n    };\r\n    \r\n    return {\r\n      compliant: violations.length === 0,\r\n      violations,\r\n      summary\r\n    };\r\n  }\r\n}\r\n\r\n// ===== Release Gate Implementation =====\r\n\r\nexport interface ReleaseGate {\r\n  name: string;\r\n  check: () => Promise<{ passed: boolean; reason?: string; metrics?: any }>;\r\n  required: boolean;\r\n  timeout: number; // ms\r\n}\r\n\r\nexport class ReleaseGateValidator {\r\n  private gates: ReleaseGate[] = [\r\n    // ✅ Gate 1: SLO Compliance\r\n    {\r\n      name: 'SLO Compliance',\r\n      check: async () => {\r\n        const monitor = new SLOMonitor(metricsCollector);\r\n        const report = monitor.getComplianceReport();\r\n        \r\n        const criticalViolations = report.violations.filter(v => v.severity === 'critical');\r\n        \r\n        return {\r\n          passed: criticalViolations.length === 0,\r\n          reason: criticalViolations.length > 0 \r\n            ? `Critical SLO violations: ${criticalViolations.map(v => v.details).join(', ')}`\r\n            : undefined,\r\n          metrics: report.summary\r\n        };\r\n      },\r\n      required: true,\r\n      timeout: 5000\r\n    },\r\n    \r\n    // ✅ Gate 2: Memory Leak Check\r\n    {\r\n      name: 'Memory Leak Check',\r\n      check: async () => {\r\n        // Simulate heavy usage and check memory growth\r\n        const initialMemory = metricsCollector.getCurrentMemoryUsage();\r\n        \r\n        // Simulate 100 operations\r\n        for (let i = 0; i < 100; i++) {\r\n          const opId = `test-${i}`;\r\n          metricsCollector.startOperation(opId, 'speakText', { textLength: 50 });\r\n          metricsCollector.completeOperation(opId, { success: true });\r\n        }\r\n        \r\n        await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1s\r\n        \r\n        const finalMemory = metricsCollector.getCurrentMemoryUsage();\r\n        const memoryGrowth = finalMemory - initialMemory;\r\n        const maxAllowedGrowth = 5 * 1024 * 1024; // 5MB\r\n        \r\n        return {\r\n          passed: memoryGrowth < maxAllowedGrowth,\r\n          reason: memoryGrowth >= maxAllowedGrowth \r\n            ? `Memory leak detected: grew by ${(memoryGrowth / 1024 / 1024).toFixed(1)}MB`\r\n            : undefined,\r\n          metrics: { initialMemory, finalMemory, memoryGrowth }\r\n        };\r\n      },\r\n      required: true,\r\n      timeout: 10000\r\n    },\r\n    \r\n    // ✅ Gate 3: Error Rate Threshold\r\n    {\r\n      name: 'Error Rate Threshold',\r\n      check: async () => {\r\n        const errorRate = 100 - metricsCollector.calculateSuccessRate();\r\n        const maxErrorRate = 1.0; // 1% max error rate\r\n        \r\n        return {\r\n          passed: errorRate <= maxErrorRate,\r\n          reason: errorRate > maxErrorRate \r\n            ? `Error rate too high: ${errorRate.toFixed(2)}% > ${maxErrorRate}%`\r\n            : undefined,\r\n          metrics: { errorRate, maxErrorRate }\r\n        };\r\n      },\r\n      required: true,\r\n      timeout: 3000\r\n    }\r\n  ];\r\n  \r\n  /**\r\n   * Run all release gates\r\n   */\r\n  async runReleaseGates(): Promise<{\r\n    passed: boolean;\r\n    results: Array<{\r\n      gate: string;\r\n      passed: boolean;\r\n      reason?: string;\r\n      metrics?: any;\r\n      duration: number;\r\n    }>;\r\n    overallMetrics: any;\r\n  }> {\r\n    const results = [];\r\n    let allPassed = true;\r\n    \r\n    for (const gate of this.gates) {\r\n      const startTime = Date.now();\r\n      \r\n      try {\r\n        // Run gate with timeout\r\n        const result = await Promise.race([\r\n          gate.check(),\r\n          new Promise<{ passed: boolean; reason: string }>((_, reject) =>\r\n            setTimeout(() => reject(new Error('Gate timeout')), gate.timeout)\r\n          )\r\n        ]);\r\n        \r\n        const duration = Date.now() - startTime;\r\n        \r\n        results.push({\r\n          gate: gate.name,\r\n          passed: result.passed,\r\n          reason: result.reason,\r\n          metrics: result.metrics,\r\n          duration\r\n        });\r\n        \r\n        if (gate.required && !result.passed) {\r\n          allPassed = false;\r\n        }\r\n        \r\n      } catch (error) {\r\n        const duration = Date.now() - startTime;\r\n        \r\n        results.push({\r\n          gate: gate.name,\r\n          passed: false,\r\n          reason: `Gate execution failed: ${error}`,\r\n          duration\r\n        });\r\n        \r\n        if (gate.required) {\r\n          allPassed = false;\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Collect overall metrics\r\n    const monitor = new SLOMonitor(metricsCollector);\r\n    const complianceReport = monitor.getComplianceReport();\r\n    \r\n    return {\r\n      passed: allPassed,\r\n      results,\r\n      overallMetrics: {\r\n        ...complianceReport.summary,\r\n        sloViolations: complianceReport.violations.length,\r\n        totalOperations: metricsCollector['metrics'].length\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n// ===== Global Metrics Instance =====\r\nexport const metricsCollector = new SpeechMetricsCollector();\r\nexport const sloMonitor = new SLOMonitor(metricsCollector);\r\nexport const releaseGateValidator = new ReleaseGateValidator();\r\n\r\n// ===== Integration with Speech Plugin =====\r\n\r\nexport function instrumentSpeechPlugin<T extends { speakText: any; recognizeSpeech: any; playBeep: any }>(\r\n  plugin: T\r\n): T {\r\n  const originalSpeakText = plugin.speakText.bind(plugin);\r\n  const originalRecognizeSpeech = plugin.recognizeSpeech.bind(plugin);\r\n  const originalPlayBeep = plugin.playBeep.bind(plugin);\r\n  \r\n  plugin.speakText = async (text: string, opts: any = {}) => {\r\n    const operationId = `speak-${Date.now()}-${Math.random()}`;\r\n    \r\n    metricsCollector.startOperation(operationId, 'speakText', {\r\n      textLength: text.length,\r\n      language: opts.language,\r\n      priority: opts.priority\r\n    });\r\n    \r\n    try {\r\n      const result = await originalSpeakText(text, opts);\r\n      \r\n      metricsCollector.completeOperation(operationId, {\r\n        success: result.ok || result.success,\r\n        errorCode: !result.ok ? result.code : undefined,\r\n        errorMessage: !result.ok ? result.cause : undefined,\r\n        interrupted: false // Would need to track this from plugin\r\n      });\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      metricsCollector.completeOperation(operationId, {\r\n        success: false,\r\n        errorCode: 'E_EXCEPTION',\r\n        errorMessage: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      throw error;\r\n    }\r\n  };\r\n  \r\n  // Similar instrumentation for recognizeSpeech and playBeep...\r\n  \r\n  return plugin;\r\n}\r\n\r\n// ===== Export for dashboard integration =====\r\nexport function getMetricsDashboardData(): {\r\n  realTimeMetrics: {\r\n    p95Latency: number;\r\n    successRate: number;\r\n    interruptionRate: number;\r\n    memoryUsage: number;\r\n    activeOperations: number;\r\n  };\r\n  sloCompliance: {\r\n    compliant: boolean;\r\n    violations: SLOViolation[];\r\n  };\r\n  errorBreakdown: Record<string, number>;\r\n  historicalTrends: {\r\n    timestamps: number[];\r\n    latencies: number[];\r\n    successRates: number[];\r\n  };\r\n} {\r\n  const report = sloMonitor.getComplianceReport();\r\n  \r\n  return {\r\n    realTimeMetrics: {\r\n      p95Latency: report.summary.latencyP95,\r\n      successRate: report.summary.successRate,\r\n      interruptionRate: report.summary.interruptionRate,\r\n      memoryUsage: report.summary.memoryUsage,\r\n      activeOperations: metricsCollector['currentOperations'].size\r\n    },\r\n    sloCompliance: {\r\n      compliant: report.compliant,\r\n      violations: report.violations\r\n    },\r\n    errorBreakdown: report.summary.errorBreakdown,\r\n    historicalTrends: {\r\n      // Would need to implement time-series storage for real historical data\r\n      timestamps: [Date.now() - 60000, Date.now() - 30000, Date.now()],\r\n      latencies: [120, 115, 108],\r\n      successRates: [99.8, 99.7, 99.9]\r\n    }\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\simple\\SimplePluginSystem.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\simple\\SimpleSpeechPlugin.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TimeoutController' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 단순화된 Speech 플러그인\r\n * @description 과도한 추상화 제거, 취소 지원, 표준 에러 처리\r\n */\r\n\r\nimport { \r\n  ISpeechPlugin, \r\n  SpeechOptions, \r\n  RecognitionOptions,\r\n  SpeechResult, \r\n  RecognitionResult,\r\n  Result,\r\n  Ok,\r\n  CommonErrors,\r\n  withTimeout,\r\n  TimeoutController\r\n} from './SimplePluginSystem';\r\n\r\n/**\r\n * 웹 브라우저 Speech API를 사용하는 단순한 구현\r\n */\r\nexport class SimpleSpeechPlugin implements ISpeechPlugin {\r\n  readonly name = 'simple-speech';\r\n  readonly version = '1.0.0';\r\n  \r\n  private synthesis?: SpeechSynthesis;\r\n  private recognition?: SpeechRecognition;\r\n  private audioContext?: AudioContext;\r\n  \r\n  // 현재 실행 중인 작업들 (취소용)\r\n  private currentSpeech?: {\r\n    utterance: SpeechSynthesisUtterance;\r\n    controller: AbortController;\r\n  };\r\n  \r\n  private currentRecognition?: {\r\n    recognition: SpeechRecognition;\r\n    controller: AbortController;\r\n  };\r\n\r\n  /**\r\n   * 초기화\r\n   */\r\n  async initialize(): Promise<Result<void>> {\r\n    try {\r\n      // Speech Synthesis 확인\r\n      if (!window.speechSynthesis) {\r\n        return CommonErrors.UNSUPPORTED('speechSynthesis');\r\n      }\r\n      this.synthesis = window.speechSynthesis;\r\n\r\n      // Speech Recognition 확인 (선택적)\r\n      const SpeechRecognition = window.SpeechRecognition || \r\n                               (window as any).webkitSpeechRecognition;\r\n      if (SpeechRecognition) {\r\n        this.recognition = new SpeechRecognition();\r\n      }\r\n\r\n      // AudioContext 확인 (신호음용)\r\n      const AudioContext = window.AudioContext || \r\n                           (window as any).webkitAudioContext;\r\n      if (AudioContext) {\r\n        this.audioContext = new AudioContext();\r\n      }\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return CommonErrors.INTERNAL(`Initialization failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 정리\r\n   */\r\n  async dispose(): Promise<Result<void>> {\r\n    try {\r\n      // 모든 작업 중지\r\n      this.stopAll('dispose');\r\n      \r\n      // AudioContext 정리\r\n      if (this.audioContext && this.audioContext.state !== 'closed') {\r\n        await this.audioContext.close();\r\n      }\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return CommonErrors.INTERNAL(`Dispose failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 텍스트 음성 변환 (취소 지원)\r\n   */\r\n  async speakText(text: string, opts: SpeechOptions = {}): Promise<Result<SpeechResult>> {\r\n    if (!this.synthesis) {\r\n      return CommonErrors.UNSUPPORTED('speechSynthesis');\r\n    }\r\n\r\n    if (!text.trim()) {\r\n      return CommonErrors.INVALID_INPUT('text cannot be empty');\r\n    }\r\n\r\n    // 기존 음성 중지\r\n    if (this.currentSpeech) {\r\n      this.currentSpeech.controller.abort('new-request');\r\n    }\r\n\r\n    const controller = new AbortController();\r\n    const utterance = new SpeechSynthesisUtterance(text);\r\n    \r\n    // 설정 적용\r\n    if (opts.language) utterance.lang = opts.language;\r\n    if (opts.rate) utterance.rate = Math.max(0.1, Math.min(10, opts.rate));\r\n\r\n    this.currentSpeech = { utterance, controller };\r\n\r\n    return new Promise((resolve) => {\r\n      const startTime = Date.now();\r\n      let resolved = false;\r\n\r\n      const cleanup = () => {\r\n        if (this.currentSpeech?.utterance === utterance) {\r\n          this.currentSpeech = undefined;\r\n        }\r\n        resolved = true;\r\n      };\r\n\r\n      // 취소 처리\r\n      const handleAbort = () => {\r\n        if (resolved) return;\r\n        cleanup();\r\n        this.synthesis!.cancel();\r\n        resolve(CommonErrors.ABORTED(controller.signal.reason || 'unknown'));\r\n      };\r\n\r\n      // 외부 signal 연결\r\n      if (opts.signal) {\r\n        opts.signal.addEventListener('abort', handleAbort);\r\n      }\r\n      \r\n      controller.signal.addEventListener('abort', handleAbort);\r\n\r\n      // 음성 이벤트 처리\r\n      utterance.onstart = () => {\r\n        if (resolved) return;\r\n        console.log(`[Speech] Started: \"${text}\"`);\r\n      };\r\n\r\n      utterance.onend = () => {\r\n        if (resolved) return;\r\n        cleanup();\r\n        \r\n        const duration = Date.now() - startTime;\r\n        resolve(Ok({\r\n          duration,\r\n          actualText: text\r\n        }));\r\n      };\r\n\r\n      utterance.onerror = (event) => {\r\n        if (resolved) return;\r\n        cleanup();\r\n        \r\n        const errorMap: Record<string, typeof CommonErrors[keyof typeof CommonErrors]> = {\r\n          'not-allowed': CommonErrors.PERMISSION_DENIED,\r\n          'network': CommonErrors.NETWORK,\r\n          'synthesis-unavailable': CommonErrors.UNSUPPORTED,\r\n          'synthesis-failed': CommonErrors.INTERNAL,\r\n          'language-unavailable': () => CommonErrors.UNSUPPORTED(`language: ${opts.language}`),\r\n          'voice-unavailable': CommonErrors.UNSUPPORTED,\r\n          'text-too-long': () => CommonErrors.INVALID_INPUT('text too long'),\r\n          'rate-not-supported': () => CommonErrors.INVALID_INPUT(`rate: ${opts.rate}`),\r\n          'interrupted': CommonErrors.ABORTED,\r\n          'paused': CommonErrors.ABORTED\r\n        };\r\n\r\n        const errorFn = errorMap[event.error] || CommonErrors.INTERNAL;\r\n        resolve(typeof errorFn === 'function' ? errorFn() : errorFn(`TTS error: ${event.error}`));\r\n      };\r\n\r\n      try {\r\n        this.synthesis!.speak(utterance);\r\n      } catch (error) {\r\n        if (resolved) return;\r\n        cleanup();\r\n        resolve(CommonErrors.INTERNAL(`Speech failed: ${error}`));\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 음성 인식 (취소 지원)\r\n   */\r\n  async recognizeSpeech(opts: RecognitionOptions = {}): Promise<Result<RecognitionResult>> {\r\n    if (!this.recognition) {\r\n      return CommonErrors.UNSUPPORTED('speechRecognition');\r\n    }\r\n\r\n    // 기존 인식 중지\r\n    if (this.currentRecognition) {\r\n      this.currentRecognition.controller.abort('new-request');\r\n    }\r\n\r\n    const controller = new AbortController();\r\n    const recognition = new (window.SpeechRecognition || \r\n                            (window as any).webkitSpeechRecognition)();\r\n    \r\n    // 설정 적용\r\n    recognition.lang = opts.language || 'ko-KR';\r\n    recognition.continuous = opts.continuous || false;\r\n    recognition.interimResults = true;\r\n\r\n    this.currentRecognition = { recognition, controller };\r\n\r\n    const recognitionPromise = new Promise<RecognitionResult>((resolve, reject) => {\r\n      let finalTranscript = '';\r\n      let maxConfidence = 0;\r\n      let resolved = false;\r\n\r\n      const cleanup = () => {\r\n        if (this.currentRecognition?.recognition === recognition) {\r\n          this.currentRecognition = undefined;\r\n        }\r\n        resolved = true;\r\n      };\r\n\r\n      // 취소 처리\r\n      const handleAbort = () => {\r\n        if (resolved) return;\r\n        cleanup();\r\n        try { recognition.stop(); } catch {}\r\n        reject(new Error('aborted'));\r\n      };\r\n\r\n      if (opts.signal) {\r\n        opts.signal.addEventListener('abort', handleAbort);\r\n      }\r\n      \r\n      controller.signal.addEventListener('abort', handleAbort);\r\n\r\n      // 타임아웃 처리\r\n      let timeoutId: NodeJS.Timeout | undefined;\r\n      if (opts.maxDuration && opts.maxDuration > 0) {\r\n        timeoutId = setTimeout(() => {\r\n          if (resolved) return;\r\n          cleanup();\r\n          try { recognition.stop(); } catch {}\r\n          reject(new Error('timeout'));\r\n        }, opts.maxDuration);\r\n      }\r\n\r\n      recognition.onstart = () => {\r\n        console.log('[Speech Recognition] Started');\r\n      };\r\n\r\n      recognition.onresult = (event) => {\r\n        if (resolved) return;\r\n        \r\n        for (let i = event.resultIndex; i < event.results.length; i++) {\r\n          const result = event.results[i];\r\n          if (result.isFinal) {\r\n            finalTranscript += result[0].transcript;\r\n            maxConfidence = Math.max(maxConfidence, result[0].confidence);\r\n          }\r\n        }\r\n      };\r\n\r\n      recognition.onend = () => {\r\n        if (resolved) return;\r\n        cleanup();\r\n        if (timeoutId) clearTimeout(timeoutId);\r\n        \r\n        if (finalTranscript.trim()) {\r\n          resolve({\r\n            transcript: finalTranscript.trim(),\r\n            confidence: maxConfidence,\r\n            isFinal: true\r\n          });\r\n        } else {\r\n          reject(new Error('no-speech'));\r\n        }\r\n      };\r\n\r\n      recognition.onerror = (event) => {\r\n        if (resolved) return;\r\n        cleanup();\r\n        if (timeoutId) clearTimeout(timeoutId);\r\n        \r\n        reject(new Error(event.error));\r\n      };\r\n\r\n      try {\r\n        recognition.start();\r\n      } catch (error) {\r\n        cleanup();\r\n        if (timeoutId) clearTimeout(timeoutId);\r\n        reject(error);\r\n      }\r\n    });\r\n\r\n    // withTimeout으로 감싸서 표준 Result 반환\r\n    return withTimeout(recognitionPromise, opts.maxDuration || 30000, opts.signal)\r\n      .then(result => {\r\n        if (!result.ok) {\r\n          // 에러 타입별 매핑\r\n          if (result.code === 'E_TIMEOUT') return result;\r\n          if (result.code === 'E_ABORTED') return result;\r\n          \r\n          const cause = result.cause || 'unknown';\r\n          if (cause.includes('not-allowed')) return CommonErrors.PERMISSION_DENIED();\r\n          if (cause.includes('network')) return CommonErrors.NETWORK();\r\n          if (cause.includes('no-speech')) return CommonErrors.INVALID_INPUT('no speech detected');\r\n          \r\n          return CommonErrors.INTERNAL(cause);\r\n        }\r\n        return result;\r\n      });\r\n  }\r\n\r\n  /**\r\n   * 신호음 재생 (취소 지원)\r\n   */\r\n  async playBeep(frequency = 800, duration = 200): Promise<Result<void>> {\r\n    if (!this.audioContext) {\r\n      return CommonErrors.UNSUPPORTED('audioContext');\r\n    }\r\n\r\n    try {\r\n      const context = this.audioContext;\r\n      \r\n      // AudioContext 활성화\r\n      if (context.state === 'suspended') {\r\n        await context.resume();\r\n      }\r\n\r\n      const oscillator = context.createOscillator();\r\n      const gainNode = context.createGain();\r\n      \r\n      oscillator.connect(gainNode);\r\n      gainNode.connect(context.destination);\r\n      \r\n      oscillator.frequency.value = frequency;\r\n      oscillator.type = 'sine';\r\n      \r\n      // 부드러운 페이드 인/아웃\r\n      const now = context.currentTime;\r\n      gainNode.gain.setValueAtTime(0, now);\r\n      gainNode.gain.linearRampToValueAtTime(0.3, now + 0.01);\r\n      gainNode.gain.exponentialRampToValueAtTime(0.01, now + duration / 1000);\r\n      \r\n      oscillator.start(now);\r\n      oscillator.stop(now + duration / 1000);\r\n      \r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return CommonErrors.INTERNAL(`Beep failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 모든 작업 중지\r\n   */\r\n  stopAll(reason: 'user' | 'navigate' | 'error' = 'user'): Result<void> {\r\n    try {\r\n      // TTS 중지\r\n      if (this.currentSpeech) {\r\n        this.currentSpeech.controller.abort(reason);\r\n        this.synthesis?.cancel();\r\n      }\r\n\r\n      // STT 중지\r\n      if (this.currentRecognition) {\r\n        this.currentRecognition.controller.abort(reason);\r\n      }\r\n\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return CommonErrors.INTERNAL(`Stop failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 처리 중인지 확인\r\n   */\r\n  isProcessing(): boolean {\r\n    return !!(this.currentSpeech || this.currentRecognition);\r\n  }\r\n}\r\n\r\n// ===== React Hook (단순화된 버전) =====\r\nimport { useState, useEffect, useCallback } from 'react';\r\nimport { simplePluginManager } from './SimplePluginSystem';\r\n\r\nexport function useSimpleSpeech() {\r\n  const [plugin, setPlugin] = useState<SimpleSpeechPlugin | null>(null);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n  const [error, setError] = useState<string | null>(null);\r\n\r\n  useEffect(() => {\r\n    const init = async () => {\r\n      try {\r\n        setIsLoading(true);\r\n        \r\n        // 플러그인 생성 및 등록 (한 번만)\r\n        let speechPlugin = simplePluginManager.get<SimpleSpeechPlugin>('speech');\r\n        if (!speechPlugin.ok) {\r\n          const newPlugin = new SimpleSpeechPlugin();\r\n          const registerResult = simplePluginManager.register('speech', newPlugin);\r\n          if (!registerResult.ok) {\r\n            throw new Error(registerResult.cause);\r\n          }\r\n          \r\n          const initResult = await newPlugin.initialize();\r\n          if (!initResult.ok) {\r\n            throw new Error(initResult.cause);\r\n          }\r\n          \r\n          setPlugin(newPlugin);\r\n        } else {\r\n          setPlugin(speechPlugin.data);\r\n        }\r\n        \r\n        setError(null);\r\n      } catch (err) {\r\n        setError(err instanceof Error ? err.message : 'Unknown error');\r\n      } finally {\r\n        setIsLoading(false);\r\n      }\r\n    };\r\n\r\n    init();\r\n  }, []);\r\n\r\n  const speakText = useCallback(async (\r\n    text: string, \r\n    options?: SpeechOptions\r\n  ): Promise<boolean> => {\r\n    if (!plugin) return false;\r\n    \r\n    const result = await plugin.speakText(text, options);\r\n    if (!result.ok) {\r\n      setError(result.cause || result.code);\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }, [plugin]);\r\n\r\n  const recognizeSpeech = useCallback(async (\r\n    options?: RecognitionOptions\r\n  ): Promise<{ success: boolean; transcript?: string; confidence?: number }> => {\r\n    if (!plugin) return { success: false };\r\n    \r\n    const result = await plugin.recognizeSpeech(options);\r\n    if (!result.ok) {\r\n      setError(result.cause || result.code);\r\n      return { success: false };\r\n    }\r\n    \r\n    return {\r\n      success: true,\r\n      transcript: result.data.transcript,\r\n      confidence: result.data.confidence\r\n    };\r\n  }, [plugin]);\r\n\r\n  const playBeep = useCallback(async (): Promise<boolean> => {\r\n    if (!plugin) return false;\r\n    \r\n    const result = await plugin.playBeep();\r\n    if (!result.ok) {\r\n      setError(result.cause || result.code);\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }, [plugin]);\r\n\r\n  const stopAll = useCallback((): boolean => {\r\n    if (!plugin) return false;\r\n    \r\n    const result = plugin.stopAll('user');\r\n    if (!result.ok) {\r\n      setError(result.cause || result.code);\r\n      return false;\r\n    }\r\n    \r\n    return true;\r\n  }, [plugin]);\r\n\r\n  return {\r\n    // 상태\r\n    isLoading,\r\n    error,\r\n    isProcessing: plugin?.isProcessing() || false,\r\n    \r\n    // 메서드\r\n    speakText,\r\n    recognizeSpeech,\r\n    playBeep,\r\n    stopAll,\r\n    \r\n    // 직접 플러그인 접근 (고급 사용)\r\n    plugin\r\n  };\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\speech\\ISpeechPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\speech\\SpeechFeatureChunk.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\speech\\WebSpeechPlugin.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'assertPositiveNumber' is defined but never used. Allowed unused vars must match /^_/u.","line":26,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":23},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'config' is defined but never used. Allowed unused args must match /^_/u.","line":70,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":38}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Web Speech API 플러그인 구현\r\n * @description 브라우저의 Web Speech API를 사용하는 플러그인\r\n */\r\n\r\nimport { BasePlugin } from '@/plugins/core/BasePlugin';\r\nimport { \r\n  ISpeechPlugin, \r\n  SpeechPluginConfig, \r\n  SpeechProcessingState,\r\n  SpeechPluginEvent,\r\n  SpeechEventHandler \r\n} from './ISpeechPlugin';\r\nimport { \r\n  SpeechResult, \r\n  SpeechRecognitionResult,\r\n  SpeechResultCallback \r\n} from '@/types/services';\r\nimport { \r\n  NonEmptyString, \r\n  PositiveNumber, \r\n  Result, \r\n  Ok, \r\n  Err,\r\n  assertNonEmptyString,\r\n  assertPositiveNumber \r\n} from '@/types/core';\r\n\r\n/**\r\n * Web Speech API 플러그인\r\n */\r\nexport class WebSpeechPlugin extends BasePlugin implements ISpeechPlugin {\r\n  private _processingState: SpeechProcessingState = 'idle';\r\n  private speechSynthesis?: SpeechSynthesis;\r\n  private speechRecognition?: SpeechRecognition;\r\n  private audioContext?: AudioContext;\r\n  \r\n  // 현재 처리 중인 작업들\r\n  private currentUtterance?: SpeechSynthesisUtterance;\r\n  private currentRecognition?: SpeechRecognition;\r\n  \r\n  // 이벤트 핸들러들\r\n  private speechEventHandlers = new Set<SpeechEventHandler>();\r\n  \r\n  constructor() {\r\n    super({\r\n      name: assertNonEmptyString('web-speech', 'plugin name'),\r\n      version: assertNonEmptyString('1.0.0', 'plugin version'),\r\n      description: 'Web Speech API plugin for TTS and Speech Recognition',\r\n      author: 'DaSi Team',\r\n      tags: ['speech', 'tts', 'recognition', 'web-api']\r\n    });\r\n  }\r\n\r\n  get processingState(): SpeechProcessingState {\r\n    return this._processingState;\r\n  }\r\n\r\n  private setProcessingState(state: SpeechProcessingState): void {\r\n    if (this._processingState !== state) {\r\n      this._processingState = state;\r\n      this.emitSpeechEvent({\r\n        type: 'stateChange',\r\n        timestamp: Date.now(),\r\n        data: { state }\r\n      });\r\n    }\r\n  }\r\n\r\n  protected async onInitialize(config: SpeechPluginConfig): Promise<Result<void>> {\r\n    return this.safeAsync(async () => {\r\n      // Web Speech API 지원 확인\r\n      if (!window.speechSynthesis) {\r\n        throw new Error('SpeechSynthesis not supported');\r\n      }\r\n\r\n      // SpeechRecognition 지원 확인 (선택적)\r\n      const SpeechRecognitionConstructor = \r\n        window.SpeechRecognition || \r\n        (window as any).webkitSpeechRecognition;\r\n      \r\n      if (!SpeechRecognitionConstructor) {\r\n        console.warn('SpeechRecognition not supported - TTS only mode');\r\n      }\r\n\r\n      this.speechSynthesis = window.speechSynthesis;\r\n      \r\n      if (SpeechRecognitionConstructor) {\r\n        this.speechRecognition = new SpeechRecognitionConstructor();\r\n        this.setupRecognition();\r\n      }\r\n\r\n      // AudioContext for beep sounds\r\n      if (window.AudioContext || (window as any).webkitAudioContext) {\r\n        const AudioContextConstructor = window.AudioContext || \r\n                                       (window as any).webkitAudioContext;\r\n        this.audioContext = new AudioContextConstructor();\r\n      }\r\n\r\n      console.log('WebSpeechPlugin initialized successfully');\r\n    }, 'Failed to initialize WebSpeechPlugin');\r\n  }\r\n\r\n  protected async onDispose(): Promise<Result<void>> {\r\n    return this.safeAsync(async () => {\r\n      // 모든 처리 중지\r\n      this.stopAll();\r\n      \r\n      // AudioContext 정리\r\n      if (this.audioContext && this.audioContext.state !== 'closed') {\r\n        await this.audioContext.close();\r\n      }\r\n\r\n      // 이벤트 핸들러 정리\r\n      this.speechEventHandlers.clear();\r\n      \r\n      this.speechSynthesis = undefined;\r\n      this.speechRecognition = undefined;\r\n      this.audioContext = undefined;\r\n      \r\n      console.log('WebSpeechPlugin disposed successfully');\r\n    }, 'Failed to dispose WebSpeechPlugin');\r\n  }\r\n\r\n  protected validateConfig(config: SpeechPluginConfig): Result<void> {\r\n    try {\r\n      if (config.speechRate && (config.speechRate <= 0 || config.speechRate > 3)) {\r\n        return Err(new Error('speechRate must be between 0 and 3'));\r\n      }\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  private setupRecognition(): void {\r\n    if (!this.speechRecognition) return;\r\n\r\n    const config = this.getConfig() as SpeechPluginConfig;\r\n    \r\n    this.speechRecognition.continuous = config.enableContinuous ?? false;\r\n    this.speechRecognition.interimResults = config.enableInterimResults ?? true;\r\n    this.speechRecognition.lang = config.recognitionLanguage || 'ko-KR';\r\n  }\r\n\r\n  /**\r\n   * TTS 구현\r\n   */\r\n  async speakText(\r\n    text: NonEmptyString, \r\n    options: {\r\n      language?: NonEmptyString;\r\n      rate?: PositiveNumber;\r\n      volume?: number;\r\n      pitch?: number;\r\n    } = {}\r\n  ): Promise<Result<SpeechResult>> {\r\n    if (!this.speechSynthesis) {\r\n      return Err(new Error('Speech synthesis not available'));\r\n    }\r\n\r\n    if (this._processingState === 'speaking') {\r\n      return Err(new Error('Already speaking'));\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n      try {\r\n        const utterance = new SpeechSynthesisUtterance(text);\r\n        const config = this.getConfig() as SpeechPluginConfig;\r\n        \r\n        // 설정 적용\r\n        utterance.lang = options.language || config.synthesisLanguage || 'ko-KR';\r\n        utterance.rate = options.rate || config.speechRate || 1.0;\r\n        utterance.volume = options.volume ?? 1.0;\r\n        utterance.pitch = options.pitch ?? 1.0;\r\n\r\n        const startTime = Date.now();\r\n        \r\n        utterance.onstart = () => {\r\n          this.setProcessingState('speaking');\r\n          this.emitSpeechEvent({\r\n            type: 'start',\r\n            timestamp: Date.now()\r\n          });\r\n        };\r\n\r\n        utterance.onend = () => {\r\n          this.setProcessingState('idle');\r\n          const duration = Date.now() - startTime;\r\n          \r\n          this.emitSpeechEvent({\r\n            type: 'end',\r\n            timestamp: Date.now()\r\n          });\r\n\r\n          resolve(Ok({\r\n            success: true,\r\n            duration: duration as PositiveNumber\r\n          }));\r\n        };\r\n\r\n        utterance.onerror = (event) => {\r\n          this.setProcessingState('error');\r\n          const error = `TTS error: ${event.error}`;\r\n          \r\n          this.emitSpeechEvent({\r\n            type: 'error',\r\n            timestamp: Date.now(),\r\n            data: { error }\r\n          });\r\n\r\n          resolve(Err(new Error(error)));\r\n        };\r\n\r\n        this.currentUtterance = utterance;\r\n        this.speechSynthesis!.speak(utterance);\r\n        \r\n      } catch (error) {\r\n        this.setProcessingState('error');\r\n        resolve(Err(error as Error));\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 음성 인식 구현\r\n   */\r\n  async recognizeSpeech(\r\n    options: {\r\n      language?: NonEmptyString;\r\n      maxDuration?: PositiveNumber;\r\n      continuous?: boolean;\r\n      interimResults?: boolean;\r\n    } = {}\r\n  ): Promise<Result<SpeechRecognitionResult>> {\r\n    if (!this.speechRecognition) {\r\n      return Err(new Error('Speech recognition not available'));\r\n    }\r\n\r\n    if (this._processingState === 'listening') {\r\n      return Err(new Error('Already listening'));\r\n    }\r\n\r\n    return new Promise((resolve) => {\r\n      try {\r\n        const recognition = this.speechRecognition!;\r\n        const config = this.getConfig() as SpeechPluginConfig;\r\n        \r\n        // 설정 적용\r\n        recognition.lang = options.language || config.recognitionLanguage || 'ko-KR';\r\n        recognition.continuous = options.continuous ?? false;\r\n        recognition.interimResults = options.interimResults ?? true;\r\n\r\n        let finalTranscript = '';\r\n        let maxConfidence = 0;\r\n        let hasResult = false;\r\n        \r\n        const cleanup = () => {\r\n          this.setProcessingState('idle');\r\n          this.currentRecognition = undefined;\r\n        };\r\n\r\n        recognition.onstart = () => {\r\n          this.setProcessingState('listening');\r\n          this.emitSpeechEvent({\r\n            type: 'start',\r\n            timestamp: Date.now()\r\n          });\r\n        };\r\n\r\n        recognition.onresult = (event) => {\r\n          for (let i = event.resultIndex; i < event.results.length; i++) {\r\n            const result = event.results[i];\r\n            \r\n            if (result.isFinal) {\r\n              finalTranscript += result[0].transcript;\r\n              maxConfidence = Math.max(maxConfidence, result[0].confidence);\r\n              hasResult = true;\r\n            }\r\n\r\n            this.emitSpeechEvent({\r\n              type: 'result',\r\n              timestamp: Date.now(),\r\n              data: {\r\n                transcript: result[0].transcript as NonEmptyString,\r\n                confidence: result[0].confidence\r\n              }\r\n            });\r\n          }\r\n        };\r\n\r\n        recognition.onend = () => {\r\n          cleanup();\r\n          \r\n          this.emitSpeechEvent({\r\n            type: 'end',\r\n            timestamp: Date.now()\r\n          });\r\n\r\n          if (hasResult && finalTranscript.trim()) {\r\n            resolve(Ok({\r\n              success: true,\r\n              transcript: finalTranscript.trim() as NonEmptyString,\r\n              confidence: maxConfidence,\r\n              isFinal: true\r\n            }));\r\n          } else {\r\n            resolve(Ok({\r\n              success: false,\r\n              error: 'No speech detected'\r\n            }));\r\n          }\r\n        };\r\n\r\n        recognition.onerror = (event) => {\r\n          cleanup();\r\n          const error = `Speech recognition error: ${event.error}`;\r\n          \r\n          this.emitSpeechEvent({\r\n            type: 'error',\r\n            timestamp: Date.now(),\r\n            data: { error }\r\n          });\r\n\r\n          resolve(Err(new Error(error)));\r\n        };\r\n\r\n        // 타임아웃 처리\r\n        if (options.maxDuration) {\r\n          setTimeout(() => {\r\n            if (this._processingState === 'listening') {\r\n              recognition.stop();\r\n            }\r\n          }, options.maxDuration);\r\n        }\r\n\r\n        this.currentRecognition = recognition;\r\n        recognition.start();\r\n        \r\n      } catch (error) {\r\n        this.setProcessingState('error');\r\n        resolve(Err(error as Error));\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 실시간 음성 인식 시작\r\n   */\r\n  startListening(\r\n    onResult: SpeechResultCallback,\r\n    options: {\r\n      language?: NonEmptyString;\r\n      continuous?: boolean;\r\n      interimResults?: boolean;\r\n    } = {}\r\n  ): Result<void> {\r\n    if (!this.speechRecognition) {\r\n      return Err(new Error('Speech recognition not available'));\r\n    }\r\n\r\n    if (this._processingState === 'listening') {\r\n      return Err(new Error('Already listening'));\r\n    }\r\n\r\n    try {\r\n      const recognition = this.speechRecognition;\r\n      const config = this.getConfig() as SpeechPluginConfig;\r\n      \r\n      recognition.lang = options.language || config.recognitionLanguage || 'ko-KR';\r\n      recognition.continuous = options.continuous ?? true;\r\n      recognition.interimResults = options.interimResults ?? true;\r\n\r\n      recognition.onresult = (event) => {\r\n        for (let i = event.resultIndex; i < event.results.length; i++) {\r\n          const result = event.results[i];\r\n          onResult(\r\n            result[0].transcript as NonEmptyString,\r\n            result[0].confidence\r\n          );\r\n        }\r\n      };\r\n\r\n      recognition.onstart = () => {\r\n        this.setProcessingState('listening');\r\n      };\r\n\r\n      recognition.onend = () => {\r\n        this.setProcessingState('idle');\r\n        // 자동 재시작 (continuous 모드에서)\r\n        if (options.continuous && config.autoRestart) {\r\n          setTimeout(() => {\r\n            if (this._processingState === 'idle') {\r\n              recognition.start();\r\n            }\r\n          }, 100);\r\n        }\r\n      };\r\n\r\n      recognition.onerror = (event) => {\r\n        this.setProcessingState('error');\r\n        console.error('Speech recognition error:', event.error);\r\n      };\r\n\r\n      this.currentRecognition = recognition;\r\n      recognition.start();\r\n      \r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 음성 인식 중지\r\n   */\r\n  stopListening(): Result<void> {\r\n    if (!this.currentRecognition) {\r\n      return Ok(undefined);\r\n    }\r\n\r\n    try {\r\n      this.currentRecognition.stop();\r\n      this.currentRecognition = undefined;\r\n      this.setProcessingState('idle');\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 신호음 재생\r\n   */\r\n  async playBeep(\r\n    options: {\r\n      frequency?: PositiveNumber;\r\n      duration?: PositiveNumber;\r\n      volume?: number;\r\n    } = {}\r\n  ): Promise<Result<void>> {\r\n    if (!this.audioContext) {\r\n      return Err(new Error('AudioContext not available'));\r\n    }\r\n\r\n    return this.safeAsync(async () => {\r\n      const context = this.audioContext!;\r\n      const frequency = options.frequency || (800 as PositiveNumber);\r\n      const duration = options.duration || (200 as PositiveNumber);\r\n      const volume = options.volume ?? 0.3;\r\n\r\n      // AudioContext가 suspended 상태면 resume\r\n      if (context.state === 'suspended') {\r\n        await context.resume();\r\n      }\r\n\r\n      const oscillator = context.createOscillator();\r\n      const gainNode = context.createGain();\r\n      \r\n      oscillator.connect(gainNode);\r\n      gainNode.connect(context.destination);\r\n      \r\n      oscillator.frequency.value = frequency;\r\n      oscillator.type = 'sine';\r\n      \r\n      gainNode.gain.setValueAtTime(0, context.currentTime);\r\n      gainNode.gain.linearRampToValueAtTime(volume, context.currentTime + 0.01);\r\n      gainNode.gain.exponentialRampToValueAtTime(0.01, context.currentTime + duration / 1000);\r\n      \r\n      oscillator.start(context.currentTime);\r\n      oscillator.stop(context.currentTime + duration / 1000);\r\n      \r\n      return new Promise<void>((resolve) => {\r\n        oscillator.onended = () => resolve();\r\n      });\r\n    }, 'Failed to play beep');\r\n  }\r\n\r\n  /**\r\n   * 모든 처리 중지 - 브라우저 호환성 강화\r\n   */\r\n  stopAll(): Result<void> {\r\n    try {\r\n      // TTS 중지 - 다중 취소 시도로 브라우저 호환성 확보\r\n      if (this.speechSynthesis) {\r\n        this.speechSynthesis.cancel();\r\n        this.currentUtterance = undefined;\r\n        \r\n        // 브라우저별 안전을 위해 여러 번 시도\r\n        setTimeout(() => {\r\n          if (this.speechSynthesis && this.speechSynthesis.speaking) {\r\n            this.speechSynthesis.cancel();\r\n          }\r\n        }, 10);\r\n        \r\n        setTimeout(() => {\r\n          if (this.speechSynthesis && this.speechSynthesis.speaking) {\r\n            this.speechSynthesis.cancel();\r\n          }\r\n        }, 100);\r\n      }\r\n\r\n      // 음성 인식 중지\r\n      if (this.currentRecognition && this._processingState === 'listening') {\r\n        this.currentRecognition.stop();\r\n        this.currentRecognition = undefined;\r\n      }\r\n\r\n      this.setProcessingState('idle');\r\n      \r\n      this.emitSpeechEvent({\r\n        type: 'end',\r\n        timestamp: Date.now(),\r\n        data: { state: 'idle' }\r\n      });\r\n      \r\n      console.log('🔇 모든 음성 처리 중단 (플러그인)');\r\n      return Ok(undefined);\r\n    } catch (error) {\r\n      console.error('❌ 음성 중단 오류 (플러그인):', error);\r\n      return Err(error as Error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 처리 중인지 확인\r\n   */\r\n  isProcessing(): boolean {\r\n    return this._processingState !== 'idle';\r\n  }\r\n\r\n  /**\r\n   * 지원 언어 목록\r\n   */\r\n  async getSupportedLanguages(): Promise<Result<readonly string[]>> {\r\n    return this.safeAsync(async () => {\r\n      // Web Speech API는 정확한 언어 목록을 제공하지 않으므로 일반적인 언어들 반환\r\n      return [\r\n        'ko-KR', 'en-US', 'en-GB', 'ja-JP', 'zh-CN', 'zh-TW',\r\n        'es-ES', 'fr-FR', 'de-DE', 'it-IT', 'pt-PT', 'ru-RU'\r\n      ];\r\n    }, 'Failed to get supported languages');\r\n  }\r\n\r\n  /**\r\n   * 사용 가능한 음성 목록\r\n   */\r\n  async getAvailableVoices(): Promise<Result<readonly SpeechSynthesisVoice[]>> {\r\n    if (!this.speechSynthesis) {\r\n      return Err(new Error('Speech synthesis not available'));\r\n    }\r\n\r\n    return this.safeAsync(async () => {\r\n      return new Promise<readonly SpeechSynthesisVoice[]>((resolve) => {\r\n        const getVoices = () => {\r\n          const voices = this.speechSynthesis!.getVoices();\r\n          if (voices.length > 0) {\r\n            resolve(voices);\r\n          } else {\r\n            // 일부 브라우저에서는 비동기적으로 로드됨\r\n            setTimeout(getVoices, 100);\r\n          }\r\n        };\r\n        getVoices();\r\n      });\r\n    }, 'Failed to get available voices');\r\n  }\r\n\r\n  /**\r\n   * Speech 이벤트 핸들러 등록\r\n   */\r\n  onSpeechEvent(handler: SpeechEventHandler): void {\r\n    this.speechEventHandlers.add(handler);\r\n  }\r\n\r\n  /**\r\n   * Speech 이벤트 핸들러 제거\r\n   */\r\n  offSpeechEvent(handler: SpeechEventHandler): void {\r\n    this.speechEventHandlers.delete(handler);\r\n  }\r\n\r\n  /**\r\n   * Speech 이벤트 발생\r\n   */\r\n  private emitSpeechEvent(event: SpeechPluginEvent): void {\r\n    this.speechEventHandlers.forEach(handler => {\r\n      try {\r\n        handler(event);\r\n      } catch (error) {\r\n        console.error('Speech event handler error:', error);\r\n      }\r\n    });\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\speech\\WebSpeechPluginFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\speed\\ISpeedTrainingPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\speed\\SpeedTrainingPlugin.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\plugins\\speed\\SpeedTrainingPluginFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\AudioFlowOrchestrator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AdapterResult' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AudioFlowOrchestrator - 오디오 플로우 전체 조율 서비스\r\n * 목적: TTS → Beep → Recording → Processing 플로우를 중앙에서 관리\r\n */\r\n\r\nimport { SpeechProcessingService, ProcessingResult } from './SpeechProcessingService';\r\nimport { AudioTimerService } from './AudioTimerService';\r\nimport { \r\n  IAudioContextAdapter, \r\n  BeepOptions, \r\n  AdapterResult \r\n} from '@/adapters/BrowserAPIAdapter';\r\n\r\nexport type FlowState = 'idle' | 'tts' | 'beep' | 'recording' | 'processing' | 'timeout';\r\n\r\nexport interface FlowOptions {\r\n  recordingDuration?: number;\r\n  beepOptions?: BeepOptions;\r\n  ttsOptions?: {\r\n    questionLanguage?: string;\r\n    answerLanguage?: string;\r\n    speechRate?: number;\r\n  };\r\n}\r\n\r\nexport interface FlowCallbacks {\r\n  onStateChange: (state: FlowState) => void;\r\n  onTimeUpdate: (remainingTime: number) => void;\r\n  onSpeechResult: (transcript: string, confidence: number) => void;\r\n  onTimeout: () => void;\r\n  onError?: (error: string) => void;\r\n}\r\n\r\nexport interface FlowStatus {\r\n  currentState: FlowState;\r\n  remainingTime: number;\r\n  isPaused: boolean;\r\n  canPause: boolean;\r\n  canResume: boolean;\r\n  canStop: boolean;\r\n}\r\n\r\nexport class AudioFlowOrchestrator {\r\n  private speechService: SpeechProcessingService;\r\n  private timerService: AudioTimerService;\r\n  private audioContextAdapter: IAudioContextAdapter;\r\n  \r\n  private currentState: FlowState = 'idle';\r\n  private isPaused = false;\r\n  private callbacks: FlowCallbacks;\r\n  private options: FlowOptions;\r\n  \r\n  // 기본 설정\r\n  private defaultOptions: Required<FlowOptions> = {\r\n    recordingDuration: 10,\r\n    beepOptions: {\r\n      frequency: 800,\r\n      duration: 0.5,\r\n      volume: 0.3,\r\n      waveType: 'sine'\r\n    },\r\n    ttsOptions: {\r\n      questionLanguage: 'ko-KR',\r\n      answerLanguage: 'en-US',\r\n      speechRate: 0.9\r\n    }\r\n  };\r\n\r\n  constructor(\r\n    speechService: SpeechProcessingService,\r\n    timerService: AudioTimerService,\r\n    audioContextAdapter: IAudioContextAdapter,\r\n    callbacks: FlowCallbacks,\r\n    options: FlowOptions = {}\r\n  ) {\r\n    this.speechService = speechService;\r\n    this.timerService = timerService;\r\n    this.audioContextAdapter = audioContextAdapter;\r\n    this.callbacks = callbacks;\r\n    this.options = { ...this.defaultOptions, ...options };\r\n    \r\n    console.log('[AudioFlowOrchestrator] Initialized with options:', this.options);\r\n  }\r\n\r\n  /**\r\n   * 메인 플로우 시작: TTS → Beep → Recording\r\n   */\r\n  async startFlow(questionText: string): Promise<ProcessingResult> {\r\n    try {\r\n      const validationResult = this.validateFlowStart(questionText);\r\n      if (!validationResult.success) {\r\n        return validationResult;\r\n      }\r\n\r\n      this.initializeFlow();\r\n      \r\n      return await this.executeFlowSequence(questionText);\r\n\r\n    } catch (error) {\r\n      return this.handleFlowError(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플로우 시작 전 검증\r\n   */\r\n  private validateFlowStart(questionText: string): ProcessingResult {\r\n    console.log('[AudioFlowOrchestrator] Starting flow with:', questionText);\r\n    \r\n    if (!questionText.trim()) {\r\n      return {\r\n        success: false,\r\n        error: 'Question text cannot be empty'\r\n      };\r\n    }\r\n\r\n    if (this.currentState !== 'idle') {\r\n      return {\r\n        success: false,\r\n        error: 'Flow already in progress'\r\n      };\r\n    }\r\n\r\n    return { success: true };\r\n  }\r\n\r\n  /**\r\n   * 플로우 초기화\r\n   */\r\n  private initializeFlow(): void {\r\n    this.setState('tts');\r\n    this.setPaused(false);\r\n  }\r\n\r\n  /**\r\n   * 순차적 플로우 실행: TTS → Beep → Recording\r\n   */\r\n  private async executeFlowSequence(questionText: string): Promise<ProcessingResult> {\r\n    // 1단계: TTS 재생\r\n    const ttsResult = await this.executeTTSPhase(questionText);\r\n    if (!ttsResult.success) {\r\n      return ttsResult;\r\n    }\r\n\r\n    // 2단계: Beep 재생\r\n    const beepResult = await this.executeBeepPhase();\r\n    if (!beepResult.success) {\r\n      return beepResult;\r\n    }\r\n\r\n    // 3단계: 녹음 시작\r\n    const recordingResult = await this.executeRecordingPhase();\r\n    if (!recordingResult.success) {\r\n      return recordingResult;\r\n    }\r\n\r\n    return { success: true };\r\n  }\r\n\r\n  /**\r\n   * TTS 단계 실행\r\n   */\r\n  private async executeTTSPhase(questionText: string): Promise<ProcessingResult> {\r\n    const ttsResult = await this.playQuestion(questionText);\r\n    \r\n    if (!ttsResult.success) {\r\n      return ttsResult;\r\n    }\r\n    \r\n    if (this.isPaused) {\r\n      return {\r\n        success: false,\r\n        error: 'Flow paused during TTS phase'\r\n      };\r\n    }\r\n\r\n    return { success: true };\r\n  }\r\n\r\n  /**\r\n   * Beep 단계 실행\r\n   */\r\n  private async executeBeepPhase(): Promise<ProcessingResult> {\r\n    const beepResult = await this.playBeep();\r\n    \r\n    if (!beepResult.success) {\r\n      return beepResult;\r\n    }\r\n    \r\n    if (this.isPaused) {\r\n      return {\r\n        success: false,\r\n        error: 'Flow paused during beep phase'\r\n      };\r\n    }\r\n\r\n    return { success: true };\r\n  }\r\n\r\n  /**\r\n   * 녹음 단계 실행\r\n   */\r\n  private async executeRecordingPhase(): Promise<ProcessingResult> {\r\n    return await this.startRecording();\r\n  }\r\n\r\n  /**\r\n   * 플로우 에러 처리\r\n   */\r\n  private handleFlowError(error: unknown): ProcessingResult {\r\n    console.error('[AudioFlowOrchestrator] Flow error:', error);\r\n    \r\n    this.setState('idle');\r\n    \r\n    const errorMessage = error instanceof Error ? error.message : 'Unknown flow error';\r\n    this.callbacks.onError?.(errorMessage);\r\n    \r\n    return {\r\n      success: false,\r\n      error: errorMessage\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 1단계: 문제 음성 재생 (한국어)\r\n   */\r\n  private async playQuestion(questionText: string): Promise<ProcessingResult> {\r\n    console.log('[AudioFlowOrchestrator] Playing question TTS');\r\n    \r\n    const result = await this.speechService.speakQuestion(questionText, {\r\n      lang: this.options.ttsOptions?.questionLanguage,\r\n      rate: this.options.ttsOptions?.speechRate\r\n    });\r\n\r\n    if (!result.success) {\r\n      this.callbacks.onError?.(result.error || 'Failed to play question');\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 2단계: Beep 재생\r\n   */\r\n  private async playBeep(): Promise<ProcessingResult> {\r\n    try {\r\n      console.log('[AudioFlowOrchestrator] Playing beep');\r\n      this.setState('beep');\r\n\r\n      const result = await this.audioContextAdapter.createBeep(this.options.beepOptions);\r\n      \r\n      if (result.success) {\r\n        return { success: true };\r\n      } else {\r\n        return {\r\n          success: false,\r\n          error: result.error || 'Failed to play beep'\r\n        };\r\n      }\r\n\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Beep creation error';\r\n      return {\r\n        success: false,\r\n        error: errorMessage\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 3단계: 녹음 및 타이머 시작\r\n   */\r\n  private async startRecording(): Promise<ProcessingResult> {\r\n    try {\r\n      console.log('[AudioFlowOrchestrator] Starting recording phase');\r\n      this.setState('recording');\r\n\r\n      // 타이머 시작\r\n      this.timerService.start(\r\n        this.options.recordingDuration!,\r\n        (remainingTime) => this.callbacks.onTimeUpdate(remainingTime),\r\n        () => this.handleTimeout()\r\n      );\r\n\r\n      // 음성 인식 시작\r\n      const result = await this.speechService.recognizeSpeech(\r\n        (transcript, confidence) => this.handleSpeechResult(transcript, confidence),\r\n        (error) => this.callbacks.onError?.(error)\r\n      );\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Recording start error';\r\n      return {\r\n        success: false,\r\n        error: errorMessage\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 음성 인식 결과 처리\r\n   */\r\n  private handleSpeechResult(transcript: string, confidence: number): void {\r\n    console.log('[AudioFlowOrchestrator] Speech result received:', { transcript, confidence });\r\n    \r\n    this.timerService.stop();\r\n    this.setState('processing');\r\n    \r\n    // 잠시 후 결과 전달 및 상태 초기화\r\n    setTimeout(() => {\r\n      this.callbacks.onSpeechResult(transcript, confidence);\r\n      this.setState('idle');\r\n    }, 100);\r\n  }\r\n\r\n  /**\r\n   * 타임아웃 처리\r\n   */\r\n  private handleTimeout(): void {\r\n    console.log('[AudioFlowOrchestrator] Handling timeout');\r\n    \r\n    this.setState('timeout');\r\n    this.speechService.stopRecognition();\r\n    \r\n    // 1.5초 후 타임아웃 콜백 호출\r\n    setTimeout(() => {\r\n      this.callbacks.onTimeout();\r\n      this.setState('idle');\r\n    }, 1500);\r\n  }\r\n\r\n  /**\r\n   * 정답 재생 및 다음 단계 진행\r\n   */\r\n  async playAnswerAndNext(answerText?: string): Promise<void> {\r\n    if (answerText) {\r\n      try {\r\n        console.log('[AudioFlowOrchestrator] Playing answer:', answerText);\r\n        this.setState('processing');\r\n        \r\n        const result = await this.speechService.speakAnswer(answerText, {\r\n          lang: this.options.ttsOptions?.answerLanguage,\r\n          rate: this.options.ttsOptions?.speechRate\r\n        });\r\n\r\n        if (!result.success) {\r\n          console.error('[AudioFlowOrchestrator] Answer TTS error:', result.error);\r\n        }\r\n\r\n        // 1초 후 다음 문제로\r\n        setTimeout(() => {\r\n          this.setState('idle');\r\n          this.callbacks.onTimeout();\r\n        }, 1000);\r\n\r\n      } catch (error) {\r\n        console.error('[AudioFlowOrchestrator] Answer playback error:', error);\r\n        this.setState('idle');\r\n        this.callbacks.onTimeout();\r\n      }\r\n    } else {\r\n      this.setState('idle');\r\n      this.callbacks.onTimeout();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 플로우 일시정지\r\n   */\r\n  pauseFlow(): void {\r\n    console.log(`[AudioFlowOrchestrator] Pausing flow at state: ${this.currentState}`);\r\n    \r\n    switch (this.currentState) {\r\n      case 'tts':\r\n        this.speechService.pauseSpeech();\r\n        break;\r\n      case 'beep':\r\n        this.audioContextAdapter.stopBeep();\r\n        break;\r\n      case 'recording':\r\n        this.timerService.pause();\r\n        break;\r\n    }\r\n    \r\n    this.setPaused(true);\r\n  }\r\n\r\n  /**\r\n   * 플로우 재개\r\n   */\r\n  resumeFlow(): void {\r\n    console.log(`[AudioFlowOrchestrator] Resuming flow at state: ${this.currentState}`);\r\n    \r\n    switch (this.currentState) {\r\n      case 'tts':\r\n        this.speechService.resumeSpeech();\r\n        break;\r\n      case 'recording':\r\n        this.timerService.resume();\r\n        break;\r\n    }\r\n    \r\n    this.setPaused(false);\r\n  }\r\n\r\n  /**\r\n   * 플로우 중지\r\n   */\r\n  stopFlow(): void {\r\n    console.log('[AudioFlowOrchestrator] Stopping flow');\r\n    \r\n    this.timerService.stop();\r\n    this.speechService.stopAllSpeech();\r\n    this.audioContextAdapter.stopBeep();\r\n    \r\n    this.setState('idle');\r\n    this.setPaused(false);\r\n  }\r\n\r\n  /**\r\n   * 현재 상태 조회\r\n   */\r\n  getStatus(): FlowStatus {\r\n    return {\r\n      currentState: this.currentState,\r\n      remainingTime: this.timerService.getRemainingTime(),\r\n      isPaused: this.isPaused,\r\n      canPause: this.currentState !== 'idle' && !this.isPaused,\r\n      canResume: this.isPaused,\r\n      canStop: this.currentState !== 'idle'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 옵션 업데이트\r\n   */\r\n  updateOptions(newOptions: Partial<FlowOptions>): void {\r\n    this.options = { ...this.options, ...newOptions };\r\n    console.log('[AudioFlowOrchestrator] Options updated:', this.options);\r\n  }\r\n\r\n  /**\r\n   * 상태 변경 내부 메서드\r\n   */\r\n  private setState(newState: FlowState): void {\r\n    if (this.currentState !== newState) {\r\n      console.log(`[AudioFlowOrchestrator] State change: ${this.currentState} → ${newState}`);\r\n      this.currentState = newState;\r\n      this.callbacks.onStateChange(newState);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 일시정지 상태 변경 내부 메서드\r\n   */\r\n  private setPaused(paused: boolean): void {\r\n    if (this.isPaused !== paused) {\r\n      this.isPaused = paused;\r\n      console.log(`[AudioFlowOrchestrator] Pause state changed: ${paused}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 리소스 정리\r\n   */\r\n  cleanup(): void {\r\n    console.log('[AudioFlowOrchestrator] Cleaning up...');\r\n    this.stopFlow();\r\n    console.log('[AudioFlowOrchestrator] Cleanup completed');\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\AudioTimerService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\ScoreCalculationService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isCorrect' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":70,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":22},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'responseTime' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":70,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":70,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * ScoreCalculationService - SM-2 알고리즘 기반 학습 품질 점수 계산\r\n * 목적: 사용자 답변의 정확도와 신뢰도를 SM-2 알고리즘 품질 점수로 변환\r\n */\r\n\r\nexport interface ScoreInput {\r\n  isCorrect: boolean;\r\n  confidence: number;\r\n  score: number;\r\n  responseTime?: number;\r\n}\r\n\r\nexport interface QualityResult {\r\n  quality: 0 | 1 | 2 | 3 | 4 | 5;\r\n  reasoning: string;\r\n  category: 'perfect' | 'good' | 'acceptable' | 'poor' | 'failed';\r\n}\r\n\r\nexport interface DetailedScoreAnalysis {\r\n  quality: 0 | 1 | 2 | 3 | 4 | 5;\r\n  category: 'perfect' | 'good' | 'acceptable' | 'poor' | 'failed';\r\n  reasoning: string;\r\n  confidenceLevel: 'high' | 'medium' | 'low';\r\n  scoreLevel: 'excellent' | 'good' | 'fair' | 'poor';\r\n  recommendations: string[];\r\n}\r\n\r\nexport class ScoreCalculationService {\r\n  // SM-2 품질 점수 임계값 설정\r\n  private readonly QUALITY_THRESHOLDS = {\r\n    PERFECT_SCORE: 90,\r\n    GOOD_SCORE: 80,\r\n    HIGH_CONFIDENCE: 0.7,\r\n    MEDIUM_CONFIDENCE: 0.4\r\n  };\r\n\r\n  // 응답 시간 기반 보너스/페널티\r\n  private readonly TIME_THRESHOLDS = {\r\n    FAST_RESPONSE: 3, // 3초 이내 빠른 응답\r\n    SLOW_RESPONSE: 15, // 15초 이상 느린 응답\r\n    VERY_SLOW_RESPONSE: 30 // 30초 이상 매우 느린 응답\r\n  };\r\n\r\n  /**\r\n   * SM-2 알고리즘 품질 점수 계산 (0-5)\r\n   * 0: 완전한 실패 (blackout)\r\n   * 1: 잘못된 응답, 정답을 기억했음\r\n   * 2: 잘못된 응답, 정답이 쉽게 기억남\r\n   * 3: 정확한 응답, 어려움을 겪음\r\n   * 4: 정확한 응답, 약간의 망설임\r\n   * 5: 완벽한 응답\r\n   */\r\n  calculateQuality(input: ScoreInput): QualityResult {\r\n    const { isCorrect, confidence, score, responseTime } = input;\r\n\r\n    console.log('[ScoreCalculationService] Calculating quality for:', input);\r\n\r\n    if (!isCorrect) {\r\n      return this.calculateIncorrectQuality(confidence);\r\n    }\r\n\r\n    return this.calculateCorrectQuality(score, confidence, responseTime);\r\n  }\r\n\r\n  /**\r\n   * 상세한 점수 분석 제공\r\n   */\r\n  getDetailedAnalysis(input: ScoreInput): DetailedScoreAnalysis {\r\n    const qualityResult = this.calculateQuality(input);\r\n    const { isCorrect, confidence, score, responseTime } = input;\r\n\r\n    const confidenceLevel = this.getConfidenceLevel(confidence);\r\n    const scoreLevel = this.getScoreLevel(score);\r\n    const recommendations = this.generateRecommendations(input, qualityResult);\r\n\r\n    return {\r\n      ...qualityResult,\r\n      confidenceLevel,\r\n      scoreLevel,\r\n      recommendations\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 틀린 답변에 대한 품질 점수 계산\r\n   */\r\n  private calculateIncorrectQuality(confidence: number): QualityResult {\r\n    if (confidence > this.QUALITY_THRESHOLDS.HIGH_CONFIDENCE) {\r\n      return {\r\n        quality: 2,\r\n        reasoning: '틀렸지만 높은 신뢰도로 답변 - 정답을 쉽게 기억할 수 있음',\r\n        category: 'acceptable'\r\n      };\r\n    }\r\n\r\n    if (confidence > this.QUALITY_THRESHOLDS.MEDIUM_CONFIDENCE) {\r\n      return {\r\n        quality: 1,\r\n        reasoning: '틀렸고 중간 정도 신뢰도 - 정답을 기억하고 있음',\r\n        category: 'poor'\r\n      };\r\n    }\r\n\r\n    return {\r\n      quality: 0,\r\n      reasoning: '틀렸고 낮은 신뢰도 - 완전한 실패 (blackout)',\r\n      category: 'failed'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 맞은 답변에 대한 품질 점수 계산\r\n   */\r\n  private calculateCorrectQuality(\r\n    score: number, \r\n    confidence: number, \r\n    responseTime?: number\r\n  ): QualityResult {\r\n    // 기본 품질 점수 결정\r\n    const baseResult = this.determineBaseQuality(score);\r\n\r\n    // 응답 시간 조정 적용\r\n    if (responseTime) {\r\n      return this.applyTimeAdjustment(baseResult, responseTime);\r\n    }\r\n\r\n    // 신뢰도 조정 적용\r\n    return this.applyConfidenceAdjustment(baseResult, confidence);\r\n  }\r\n\r\n  /**\r\n   * 점수 기반 기본 품질 결정\r\n   */\r\n  private determineBaseQuality(score: number): {\r\n    quality: 3 | 4 | 5;\r\n    reasoning: string;\r\n    category: 'perfect' | 'good' | 'acceptable';\r\n  } {\r\n    if (score >= this.QUALITY_THRESHOLDS.PERFECT_SCORE) {\r\n      return {\r\n        quality: 5,\r\n        reasoning: '완벽한 점수',\r\n        category: 'perfect'\r\n      };\r\n    }\r\n    \r\n    if (score >= this.QUALITY_THRESHOLDS.GOOD_SCORE) {\r\n      return {\r\n        quality: 4,\r\n        reasoning: '좋은 점수',\r\n        category: 'good'\r\n      };\r\n    }\r\n    \r\n    return {\r\n      quality: 3,\r\n      reasoning: '정확하지만 어려움을 겪음',\r\n      category: 'acceptable'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 응답 시간 기반 품질 조정 적용\r\n   */\r\n  private applyTimeAdjustment(\r\n    baseResult: { quality: 3 | 4 | 5; reasoning: string; category: 'perfect' | 'good' | 'acceptable' },\r\n    responseTime: number\r\n  ): QualityResult {\r\n    const timeAdjustment = this.getTimeAdjustment(responseTime, baseResult.quality);\r\n    const adjustedQuality = Math.max(3, Math.min(5, baseResult.quality + timeAdjustment)) as 3 | 4 | 5;\r\n    \r\n    if (adjustedQuality !== baseResult.quality) {\r\n      const timeDescription = this.getTimeDescription(responseTime);\r\n      const adjustedReasoning = baseResult.reasoning + ` (${timeDescription})`;\r\n      const adjustedCategory = this.getCategoryFromQuality(adjustedQuality);\r\n      \r\n      return {\r\n        quality: adjustedQuality,\r\n        reasoning: adjustedReasoning,\r\n        category: adjustedCategory\r\n      };\r\n    }\r\n    \r\n    return {\r\n      quality: baseResult.quality,\r\n      reasoning: baseResult.reasoning,\r\n      category: baseResult.category\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 신뢰도 기반 품질 조정 적용\r\n   */\r\n  private applyConfidenceAdjustment(\r\n    baseResult: { quality: 3 | 4 | 5; reasoning: string; category: 'perfect' | 'good' | 'acceptable' },\r\n    confidence: number\r\n  ): QualityResult {\r\n    if (confidence < this.QUALITY_THRESHOLDS.MEDIUM_CONFIDENCE && baseResult.quality > 3) {\r\n      return {\r\n        quality: 3,\r\n        reasoning: baseResult.reasoning + ' (낮은 신뢰도로 조정)',\r\n        category: 'acceptable'\r\n      };\r\n    }\r\n\r\n    return {\r\n      quality: baseResult.quality,\r\n      reasoning: baseResult.reasoning,\r\n      category: baseResult.category\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 품질 점수로부터 카테고리 결정\r\n   */\r\n  private getCategoryFromQuality(quality: 3 | 4 | 5): 'perfect' | 'good' | 'acceptable' {\r\n    if (quality === 5) return 'perfect';\r\n    if (quality === 4) return 'good';\r\n    return 'acceptable';\r\n  }\r\n\r\n  /**\r\n   * 응답 시간 기반 조정값 계산\r\n   */\r\n  private getTimeAdjustment(responseTime: number, baseQuality: number): number {\r\n    if (responseTime <= this.TIME_THRESHOLDS.FAST_RESPONSE && baseQuality < 5) {\r\n      return 1; // 빠른 응답 보너스\r\n    }\r\n    \r\n    if (responseTime >= this.TIME_THRESHOLDS.VERY_SLOW_RESPONSE) {\r\n      return -1; // 매우 느린 응답 페널티\r\n    }\r\n    \r\n    if (responseTime >= this.TIME_THRESHOLDS.SLOW_RESPONSE && baseQuality > 3) {\r\n      return -1; // 느린 응답 페널티\r\n    }\r\n\r\n    return 0; // 조정 없음\r\n  }\r\n\r\n  /**\r\n   * 응답 시간 설명 생성\r\n   */\r\n  private getTimeDescription(responseTime: number): string {\r\n    if (responseTime <= this.TIME_THRESHOLDS.FAST_RESPONSE) {\r\n      return `빠른 응답 ${responseTime.toFixed(1)}초`;\r\n    }\r\n    \r\n    if (responseTime >= this.TIME_THRESHOLDS.VERY_SLOW_RESPONSE) {\r\n      return `매우 느린 응답 ${responseTime.toFixed(1)}초`;\r\n    }\r\n    \r\n    if (responseTime >= this.TIME_THRESHOLDS.SLOW_RESPONSE) {\r\n      return `느린 응답 ${responseTime.toFixed(1)}초`;\r\n    }\r\n\r\n    return `보통 응답 ${responseTime.toFixed(1)}초`;\r\n  }\r\n\r\n  /**\r\n   * 신뢰도 레벨 분류\r\n   */\r\n  private getConfidenceLevel(confidence: number): 'high' | 'medium' | 'low' {\r\n    if (confidence >= this.QUALITY_THRESHOLDS.HIGH_CONFIDENCE) return 'high';\r\n    if (confidence >= this.QUALITY_THRESHOLDS.MEDIUM_CONFIDENCE) return 'medium';\r\n    return 'low';\r\n  }\r\n\r\n  /**\r\n   * 점수 레벨 분류\r\n   */\r\n  private getScoreLevel(score: number): 'excellent' | 'good' | 'fair' | 'poor' {\r\n    if (score >= this.QUALITY_THRESHOLDS.PERFECT_SCORE) return 'excellent';\r\n    if (score >= this.QUALITY_THRESHOLDS.GOOD_SCORE) return 'good';\r\n    if (score >= 60) return 'fair';\r\n    return 'poor';\r\n  }\r\n\r\n  /**\r\n   * 개선 권장사항 생성\r\n   */\r\n  private generateRecommendations(input: ScoreInput, result: QualityResult): string[] {\r\n    const recommendations: string[] = [];\r\n    const { isCorrect, confidence, score, responseTime } = input;\r\n\r\n    if (!isCorrect) {\r\n      recommendations.push('정답을 다시 한번 확인하고 연습하세요');\r\n      \r\n      if (confidence < this.QUALITY_THRESHOLDS.MEDIUM_CONFIDENCE) {\r\n        recommendations.push('해당 문법이나 표현을 기초부터 다시 학습하세요');\r\n      }\r\n    } else {\r\n      if (score < this.QUALITY_THRESHOLDS.GOOD_SCORE) {\r\n        recommendations.push('발음이나 문법을 더 정확하게 연습하세요');\r\n      }\r\n      \r\n      if (confidence < this.QUALITY_THRESHOLDS.HIGH_CONFIDENCE) {\r\n        recommendations.push('더 자신감 있게 답변할 수 있도록 반복 연습하세요');\r\n      }\r\n    }\r\n\r\n    if (responseTime && responseTime > this.TIME_THRESHOLDS.SLOW_RESPONSE) {\r\n      recommendations.push('더 빠른 반응 속도를 위해 자주 사용하는 표현을 암기하세요');\r\n    }\r\n\r\n    if (result.quality >= 4) {\r\n      recommendations.push('훌륭합니다! 이 수준을 유지하세요');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  /**\r\n   * 품질 점수 설명 제공\r\n   */\r\n  getQualityDescription(quality: 0 | 1 | 2 | 3 | 4 | 5): string {\r\n    const descriptions = {\r\n      0: '완전한 실패 - 정답을 전혀 기억하지 못함',\r\n      1: '실패 후 정답 확인 - 정답을 기억하고 있음',\r\n      2: '실패 후 쉬운 정답 확인 - 정답을 쉽게 기억할 수 있음',\r\n      3: '성공하지만 어려움 - 정확한 응답이지만 어려움을 겪음',\r\n      4: '성공하지만 망설임 - 정확한 응답이지만 약간의 망설임',\r\n      5: '완벽한 성공 - 즉시 정확한 응답'\r\n    };\r\n\r\n    return descriptions[quality];\r\n  }\r\n\r\n  /**\r\n   * 현재 설정된 임계값 조회\r\n   */\r\n  getThresholds() {\r\n    return {\r\n      quality: this.QUALITY_THRESHOLDS,\r\n      time: this.TIME_THRESHOLDS\r\n    };\r\n  }\r\n\r\n  /**\r\n   * 임계값 업데이트 (설정 변경용)\r\n   */\r\n  updateThresholds(newThresholds: Partial<typeof this.QUALITY_THRESHOLDS>): void {\r\n    Object.assign(this.QUALITY_THRESHOLDS, newThresholds);\r\n    console.log('[ScoreCalculationService] Thresholds updated:', this.QUALITY_THRESHOLDS);\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\SpeechProcessingService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\adaptivePackService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ReviewCard' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":25},{"ruleId":"no-undef","severity":1,"message":"'SRSCard' is not defined.","line":34,"column":13,"nodeType":"Identifier","messageId":"undef","endLine":34,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'srsStats' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":112,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":112,"endColumn":21},{"ruleId":"no-undef","severity":1,"message":"'srsService' is not defined.","line":112,"column":30,"nodeType":"Identifier","messageId":"undef","endLine":112,"endColumn":40},{"ruleId":"no-undef","severity":1,"message":"'SRSCard' is not defined.","line":114,"column":26,"nodeType":"Identifier","messageId":"undef","endLine":114,"endColumn":33},{"ruleId":"no-undef","severity":1,"message":"'SRSCard' is not defined.","line":150,"column":58,"nodeType":"Identifier","messageId":"undef","endLine":150,"endColumn":65},{"ruleId":"no-undef","severity":1,"message":"'SRSCard' is not defined.","line":191,"column":52,"nodeType":"Identifier","messageId":"undef","endLine":191,"endColumn":59},{"ruleId":"no-undef","severity":1,"message":"'SRSCard' is not defined.","line":205,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":205,"endColumn":36},{"ruleId":"no-undef","severity":1,"message":"'SRSCard' is not defined.","line":248,"column":46,"nodeType":"Identifier","messageId":"undef","endLine":248,"endColumn":53},{"ruleId":"no-undef","severity":1,"message":"'SRSCard' is not defined.","line":264,"column":47,"nodeType":"Identifier","messageId":"undef","endLine":264,"endColumn":54},{"ruleId":"no-undef","severity":1,"message":"'srsService' is not defined.","line":298,"column":42,"nodeType":"Identifier","messageId":"undef","endLine":298,"endColumn":52},{"ruleId":"no-undef","severity":1,"message":"'SRSCard' is not defined.","line":351,"column":24,"nodeType":"Identifier","messageId":"undef","endLine":351,"endColumn":31},{"ruleId":"no-undef","severity":1,"message":"'SRSCard' is not defined.","line":431,"column":22,"nodeType":"Identifier","messageId":"undef","endLine":431,"endColumn":29}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Adaptive Pack Service - 오답 + 망각곡선 + 패턴 완전 자동화\r\n\r\n// import { srsService, type SRSCard } from './srsService';\r\n// TODO: Migrate to new SRS Engine system\r\nimport type { ReviewCard } from './srs/SRSEngine';\r\nimport { api } from '@/lib/api';\r\nimport type { DrillCard } from '@/types';\r\n\r\nexport interface WeaknessPattern {\r\n  id: string;\r\n  patternType: 'grammar' | 'vocabulary' | 'structure' | 'pronunciation';\r\n  pattern: string;\r\n  description: string;\r\n  errorCount: number;\r\n  lastErrorDate: Date;\r\n  examples: string[];\r\n  level: number;\r\n  stage: number;\r\n}\r\n\r\nexport interface AdaptivePackCard {\r\n  id: string;\r\n  cardId: string;\r\n  cardData: DrillCard;\r\n  \r\n  // 선택 이유\r\n  reason: 'wrong_answer' | 'forgetting_curve' | 'weakness_pattern' | 'difficulty_spike';\r\n  reasonDetail: string;\r\n  \r\n  // 우선순위 점수\r\n  priorityScore: number;\r\n  \r\n  // SRS 정보\r\n  srsInfo?: SRSCard;\r\n  \r\n  // 약점 패턴 정보\r\n  weaknessPatterns?: WeaknessPattern[];\r\n  \r\n  // 메타데이터\r\n  selectedAt: Date;\r\n  expectedDifficulty: 'easy' | 'medium' | 'hard';\r\n}\r\n\r\nexport interface AdaptivePack {\r\n  id: string;\r\n  userId: string;\r\n  title: string;\r\n  description: string;\r\n  \r\n  // 구성 정보\r\n  cards: AdaptivePackCard[];\r\n  totalCards: number;\r\n  estimatedTime: number; // 분\r\n  \r\n  // 분석 정보\r\n  weaknessAnalysis: {\r\n    grammarWeaknesses: WeaknessPattern[];\r\n    vocabularyGaps: WeaknessPattern[];\r\n    structuralIssues: WeaknessPattern[];\r\n    pronunciationProblems: WeaknessPattern[];\r\n  };\r\n  \r\n  // 학습 목표\r\n  learningObjectives: string[];\r\n  \r\n  // 생성 정보\r\n  generatedAt: Date;\r\n  algorithm: 'standard' | 'intensive' | 'review_focused';\r\n}\r\n\r\nexport interface LearningAnalytics {\r\n  userId: string;\r\n  \r\n  // 전체 통계\r\n  totalAnswered: number;\r\n  correctRate: number;\r\n  averageResponseTime: number;\r\n  \r\n  // 레벨별 성과\r\n  levelPerformance: Record<number, {\r\n    accuracy: number;\r\n    averageTime: number;\r\n    completedStages: number;\r\n  }>;\r\n  \r\n  // 약점 패턴\r\n  identifiedWeaknesses: WeaknessPattern[];\r\n  \r\n  // 학습 패턴\r\n  learningPattern: {\r\n    bestTimeOfDay: number; // 시간 (0-23)\r\n    preferredSessionLength: number; // 분\r\n    optimalDifficulty: 'easy' | 'medium' | 'hard';\r\n  };\r\n  \r\n  // 추세 분석\r\n  trend: {\r\n    improvementRate: number; // 주간 개선율\r\n    consistencyScore: number; // 학습 일관성 점수\r\n    challengeReadiness: number; // 다음 레벨 준비도\r\n  };\r\n}\r\n\r\nclass AdaptivePackService {\r\n  \r\n  /**\r\n   * 사용자별 학습 분석 수행\r\n   */\r\n  async analyzeLearningData(userId: string): Promise<LearningAnalytics> {\r\n    try {\r\n      // SRS 데이터 가져오기\r\n      const srsStats = await srsService.getSRSStats(userId);\r\n      const storedCards = localStorage.getItem(`srs_cards_${userId}`);\r\n      const allSRSCards: SRSCard[] = storedCards ? JSON.parse(storedCards) : [];\r\n      \r\n      // 학습 기록 분석\r\n      const totalAnswered = allSRSCards.reduce((sum, card) => sum + card.correctCount + card.incorrectCount, 0);\r\n      const totalCorrect = allSRSCards.reduce((sum, card) => sum + card.correctCount, 0);\r\n      const correctRate = totalAnswered > 0 ? (totalCorrect / totalAnswered) * 100 : 0;\r\n      \r\n      // 평균 응답 시간 계산\r\n      const averageResponseTime = allSRSCards.length > 0 \r\n        ? allSRSCards.reduce((sum, card) => sum + card.averageResponseTime, 0) / allSRSCards.length \r\n        : 0;\r\n      \r\n      // 레벨별 성과 분석\r\n      const levelPerformance: Record<number, any> = {};\r\n      allSRSCards.forEach(card => {\r\n        if (!levelPerformance[card.level]) {\r\n          levelPerformance[card.level] = {\r\n            cards: [],\r\n            totalCorrect: 0,\r\n            totalAnswered: 0,\r\n            totalTime: 0\r\n          };\r\n        }\r\n        \r\n        levelPerformance[card.level].cards.push(card);\r\n        levelPerformance[card.level].totalCorrect += card.correctCount;\r\n        levelPerformance[card.level].totalAnswered += card.correctCount + card.incorrectCount;\r\n        levelPerformance[card.level].totalTime += card.averageResponseTime;\r\n      });\r\n      \r\n      // 레벨별 통계 정리\r\n      Object.keys(levelPerformance).forEach(level => {\r\n        const data = levelPerformance[parseInt(level)];\r\n        levelPerformance[parseInt(level)] = {\r\n          accuracy: data.totalAnswered > 0 ? (data.totalCorrect / data.totalAnswered) * 100 : 0,\r\n          averageTime: data.cards.length > 0 ? data.totalTime / data.cards.length : 0,\r\n          completedStages: new Set(data.cards.map((card: SRSCard) => card.stage)).size\r\n        };\r\n      });\r\n      \r\n      // 약점 패턴 식별\r\n      const identifiedWeaknesses = await this.identifyWeaknessPatterns(allSRSCards);\r\n      \r\n      // 학습 패턴 분석\r\n      const learningPattern = {\r\n        bestTimeOfDay: 14, // 기본값: 오후 2시\r\n        preferredSessionLength: 20, // 기본값: 20분\r\n        optimalDifficulty: correctRate > 80 ? 'hard' : correctRate > 60 ? 'medium' : 'easy' as const\r\n      };\r\n      \r\n      // 추세 분석\r\n      const trend = {\r\n        improvementRate: this.calculateImprovementRate(allSRSCards),\r\n        consistencyScore: this.calculateConsistencyScore(allSRSCards),\r\n        challengeReadiness: correctRate > 75 ? 0.8 : correctRate > 60 ? 0.6 : 0.4\r\n      };\r\n      \r\n      return {\r\n        userId,\r\n        totalAnswered,\r\n        correctRate: Math.round(correctRate),\r\n        averageResponseTime: Math.round(averageResponseTime * 10) / 10,\r\n        levelPerformance,\r\n        identifiedWeaknesses,\r\n        learningPattern,\r\n        trend\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('학습 분석 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 약점 패턴 식별\r\n   */\r\n  private async identifyWeaknessPatterns(srsCards: SRSCard[]): Promise<WeaknessPattern[]> {\r\n    const weaknesses: WeaknessPattern[] = [];\r\n    \r\n    // 정답률이 낮은 카드들 분석\r\n    const difficultCards = srsCards.filter(card => {\r\n      const total = card.correctCount + card.incorrectCount;\r\n      return total > 0 && (card.correctCount / total) < 0.6;\r\n    });\r\n    \r\n    // 레벨별 그룹화\r\n    const levelGroups = difficultCards.reduce((groups, card) => {\r\n      if (!groups[card.level]) groups[card.level] = [];\r\n      groups[card.level].push(card);\r\n      return groups;\r\n    }, {} as Record<number, SRSCard[]>);\r\n    \r\n    // 각 레벨별 약점 패턴 생성\r\n    Object.entries(levelGroups).forEach(([level, cards]) => {\r\n      if (cards.length >= 3) { // 최소 3개 이상일 때만 패턴으로 인식\r\n        const levelNum = parseInt(level);\r\n        \r\n        weaknesses.push({\r\n          id: `level_${level}_weakness`,\r\n          patternType: levelNum <= 2 ? 'grammar' : levelNum <= 4 ? 'vocabulary' : 'structure',\r\n          pattern: `Level ${level} 전반적 어려움`,\r\n          description: `Level ${level}에서 지속적인 어려움을 보이고 있습니다. 기초 개념 재학습이 필요합니다.`,\r\n          errorCount: cards.reduce((sum, card) => sum + card.incorrectCount, 0),\r\n          lastErrorDate: new Date(Math.max(...cards.map(card => new Date(card.lastReviewDate).getTime()))),\r\n          examples: cards.slice(0, 3).map(card => `Card ID: ${card.cardId}`),\r\n          level: levelNum,\r\n          stage: Math.round(cards.reduce((sum, card) => sum + card.stage, 0) / cards.length)\r\n        });\r\n      }\r\n    });\r\n    \r\n    // easeFactor가 낮은 카드들 (어려운 카드들)\r\n    const hardCards = srsCards.filter(card => card.easeFactor < 2.0);\r\n    if (hardCards.length >= 5) {\r\n      weaknesses.push({\r\n        id: 'difficult_cards_pattern',\r\n        patternType: 'structure',\r\n        pattern: '복잡한 구조 문제',\r\n        description: '복잡한 문법 구조나 고급 어휘에서 어려움을 보이고 있습니다.',\r\n        errorCount: hardCards.reduce((sum, card) => sum + card.incorrectCount, 0),\r\n        lastErrorDate: new Date(Math.max(...hardCards.map(card => new Date(card.lastReviewDate).getTime()))),\r\n        examples: hardCards.slice(0, 3).map(card => `Card ID: ${card.cardId}`),\r\n        level: Math.round(hardCards.reduce((sum, card) => sum + card.level, 0) / hardCards.length),\r\n        stage: Math.round(hardCards.reduce((sum, card) => sum + card.stage, 0) / hardCards.length)\r\n      });\r\n    }\r\n    \r\n    return weaknesses;\r\n  }\r\n  \r\n  /**\r\n   * 개선율 계산\r\n   */\r\n  private calculateImprovementRate(srsCards: SRSCard[]): number {\r\n    // 최근 학습한 카드들의 repetitions 평균으로 개선율 추정\r\n    const recentCards = srsCards.filter(card => {\r\n      const daysSince = (Date.now() - new Date(card.lastReviewDate).getTime()) / (24 * 60 * 60 * 1000);\r\n      return daysSince <= 7; // 최근 7일\r\n    });\r\n    \r\n    if (recentCards.length === 0) return 0;\r\n    \r\n    const averageRepetitions = recentCards.reduce((sum, card) => sum + card.repetitions, 0) / recentCards.length;\r\n    return Math.min(100, averageRepetitions * 20); // 0-100 점수로 변환\r\n  }\r\n  \r\n  /**\r\n   * 일관성 점수 계산\r\n   */\r\n  private calculateConsistencyScore(srsCards: SRSCard[]): number {\r\n    if (srsCards.length === 0) return 0;\r\n    \r\n    // 학습 간격의 일관성 측정\r\n    const intervals = srsCards.map(card => {\r\n      const daysSince = (Date.now() - new Date(card.lastReviewDate).getTime()) / (24 * 60 * 60 * 1000);\r\n      return Math.min(daysSince, 30); // 최대 30일로 제한\r\n    });\r\n    \r\n    const avgInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;\r\n    const variance = intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length;\r\n    const standardDeviation = Math.sqrt(variance);\r\n    \r\n    // 일관성 점수 (표준편차가 낮을수록 높은 점수)\r\n    return Math.max(0, 100 - (standardDeviation * 10));\r\n  }\r\n  \r\n  /**\r\n   * Adaptive Pack 생성\r\n   */\r\n  async generateAdaptivePack(\r\n    userId: string, \r\n    targetSize: number = 15,\r\n    algorithm: 'standard' | 'intensive' | 'review_focused' = 'standard'\r\n  ): Promise<AdaptivePack> {\r\n    \r\n    try {\r\n      // 1. 학습 분석 수행\r\n      const analytics = await this.analyzeLearningData(userId);\r\n      \r\n      // 2. 오답 카드 수집\r\n      const wrongAnswerCards = await this.getWrongAnswerCards(userId);\r\n      \r\n      // 3. 망각곡선 복습 카드 수집\r\n      const forgettingCurveCards = await srsService.getCardsForReview(userId, 50);\r\n      \r\n      // 4. 약점 패턴 기반 추가 카드 수집\r\n      const patternCards = await this.getPatternReinforcementCards(analytics.identifiedWeaknesses);\r\n      \r\n      // 5. 우선순위 점수 계산 및 카드 선별\r\n      const candidateCards = await this.prioritizeAndSelectCards(\r\n        wrongAnswerCards,\r\n        forgettingCurveCards,\r\n        patternCards,\r\n        targetSize,\r\n        algorithm\r\n      );\r\n      \r\n      // 6. 학습 목표 생성\r\n      const learningObjectives = this.generateLearningObjectives(analytics, candidateCards);\r\n      \r\n      // 7. Adaptive Pack 생성\r\n      const adaptivePack: AdaptivePack = {\r\n        id: `adaptive_pack_${Date.now()}`,\r\n        userId,\r\n        title: this.generatePackTitle(analytics, algorithm),\r\n        description: this.generatePackDescription(analytics, candidateCards.length),\r\n        cards: candidateCards,\r\n        totalCards: candidateCards.length,\r\n        estimatedTime: Math.ceil(candidateCards.length * 1.5), // 카드당 1.5분 추정\r\n        weaknessAnalysis: {\r\n          grammarWeaknesses: analytics.identifiedWeaknesses.filter(w => w.patternType === 'grammar'),\r\n          vocabularyGaps: analytics.identifiedWeaknesses.filter(w => w.patternType === 'vocabulary'),\r\n          structuralIssues: analytics.identifiedWeaknesses.filter(w => w.patternType === 'structure'),\r\n          pronunciationProblems: analytics.identifiedWeaknesses.filter(w => w.patternType === 'pronunciation')\r\n        },\r\n        learningObjectives,\r\n        generatedAt: new Date(),\r\n        algorithm\r\n      };\r\n      \r\n      // 8. 로컬 저장\r\n      this.saveAdaptivePack(userId, adaptivePack);\r\n      \r\n      return adaptivePack;\r\n      \r\n    } catch (error) {\r\n      console.error('Adaptive Pack 생성 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 오답 카드 수집\r\n   */\r\n  private async getWrongAnswerCards(userId: string): Promise<AdaptivePackCard[]> {\r\n    const storedCards = localStorage.getItem(`srs_cards_${userId}`);\r\n    const allSRSCards: SRSCard[] = storedCards ? JSON.parse(storedCards) : [];\r\n    \r\n    // 오답률이 높은 카드들 (최소 2번 이상 시도)\r\n    const wrongCards = allSRSCards.filter(card => {\r\n      const total = card.correctCount + card.incorrectCount;\r\n      return total >= 2 && (card.incorrectCount / total) > 0.4;\r\n    });\r\n    \r\n    const adaptiveCards: AdaptivePackCard[] = [];\r\n    \r\n    for (const srsCard of wrongCards) {\r\n      try {\r\n        // 실제 카드 데이터 로드\r\n        const response = await api.getCards(srsCard.level, srsCard.stage);\r\n        if (response.success && response.data) {\r\n          const cardData = response.data.cards.find(card => card.id === srsCard.cardId);\r\n          if (cardData) {\r\n            adaptiveCards.push({\r\n              id: `wrong_${srsCard.cardId}`,\r\n              cardId: srsCard.cardId,\r\n              cardData,\r\n              reason: 'wrong_answer',\r\n              reasonDetail: `오답률 ${Math.round((srsCard.incorrectCount / (srsCard.correctCount + srsCard.incorrectCount)) * 100)}%`,\r\n              priorityScore: srsCard.incorrectCount * 2,\r\n              srsInfo: srsCard,\r\n              selectedAt: new Date(),\r\n              expectedDifficulty: 'hard'\r\n            });\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`카드 로드 실패: ${srsCard.cardId}`, error);\r\n      }\r\n    }\r\n    \r\n    return adaptiveCards;\r\n  }\r\n  \r\n  /**\r\n   * 패턴 보강 카드 수집\r\n   */\r\n  private async getPatternReinforcementCards(weaknesses: WeaknessPattern[]): Promise<AdaptivePackCard[]> {\r\n    const adaptiveCards: AdaptivePackCard[] = [];\r\n    \r\n    for (const weakness of weaknesses) {\r\n      try {\r\n        // 약점 패턴과 관련된 레벨/스테이지에서 추가 카드 수집\r\n        const response = await api.getCards(weakness.level, weakness.stage);\r\n        if (response.success && response.data) {\r\n          // 랜덤하게 2-3개 카드 선택\r\n          const shuffled = response.data.cards.sort(() => 0.5 - Math.random());\r\n          const selectedCards = shuffled.slice(0, 3);\r\n          \r\n          selectedCards.forEach(cardData => {\r\n            adaptiveCards.push({\r\n              id: `pattern_${cardData.id}`,\r\n              cardId: cardData.id,\r\n              cardData,\r\n              reason: 'weakness_pattern',\r\n              reasonDetail: `${weakness.pattern} 보강`,\r\n              priorityScore: weakness.errorCount,\r\n              weaknessPatterns: [weakness],\r\n              selectedAt: new Date(),\r\n              expectedDifficulty: 'medium'\r\n            });\r\n          });\r\n        }\r\n      } catch (error) {\r\n        console.error(`패턴 카드 로드 실패: Level ${weakness.level}`, error);\r\n      }\r\n    }\r\n    \r\n    return adaptiveCards;\r\n  }\r\n  \r\n  /**\r\n   * 카드 우선순위 계산 및 선별\r\n   */\r\n  private async prioritizeAndSelectCards(\r\n    wrongCards: AdaptivePackCard[],\r\n    forgettingCards: SRSCard[],\r\n    patternCards: AdaptivePackCard[],\r\n    targetSize: number,\r\n    algorithm: 'standard' | 'intensive' | 'review_focused'\r\n  ): Promise<AdaptivePackCard[]> {\r\n    \r\n    // 망각곡선 카드를 AdaptivePackCard로 변환\r\n    const forgettingAdaptiveCards: AdaptivePackCard[] = [];\r\n    for (const srsCard of forgettingCards) {\r\n      try {\r\n        const response = await api.getCards(srsCard.level, srsCard.stage);\r\n        if (response.success && response.data) {\r\n          const cardData = response.data.cards.find(card => card.id === srsCard.cardId);\r\n          if (cardData) {\r\n            const overdueDays = Math.floor(\r\n              (Date.now() - new Date(srsCard.nextReviewDate).getTime()) / (24 * 60 * 60 * 1000)\r\n            );\r\n            \r\n            forgettingAdaptiveCards.push({\r\n              id: `forgetting_${srsCard.cardId}`,\r\n              cardId: srsCard.cardId,\r\n              cardData,\r\n              reason: 'forgetting_curve',\r\n              reasonDetail: `${overdueDays}일 지연`,\r\n              priorityScore: Math.max(0, overdueDays) + srsCard.incorrectCount,\r\n              srsInfo: srsCard,\r\n              selectedAt: new Date(),\r\n              expectedDifficulty: srsCard.easeFactor < 2.0 ? 'hard' : 'medium'\r\n            });\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.error(`망각곡선 카드 로드 실패: ${srsCard.cardId}`, error);\r\n      }\r\n    }\r\n    \r\n    // 모든 카드 합치기\r\n    const allCards = [...wrongCards, ...forgettingAdaptiveCards, ...patternCards];\r\n    \r\n    // 중복 제거\r\n    const uniqueCards = allCards.filter((card, index, self) => \r\n      index === self.findIndex(c => c.cardId === card.cardId)\r\n    );\r\n    \r\n    // 알고리즘별 가중치 적용\r\n    uniqueCards.forEach(card => {\r\n      switch (algorithm) {\r\n        case 'intensive':\r\n          if (card.reason === 'wrong_answer') card.priorityScore *= 2;\r\n          break;\r\n        case 'review_focused':\r\n          if (card.reason === 'forgetting_curve') card.priorityScore *= 1.5;\r\n          break;\r\n        default: // standard\r\n          // 균형잡힌 가중치 유지\r\n          break;\r\n      }\r\n    });\r\n    \r\n    // 우선순위 정렬 및 선별\r\n    uniqueCards.sort((a, b) => b.priorityScore - a.priorityScore);\r\n    return uniqueCards.slice(0, targetSize);\r\n  }\r\n  \r\n  /**\r\n   * 학습 목표 생성\r\n   */\r\n  private generateLearningObjectives(analytics: LearningAnalytics, cards: AdaptivePackCard[]): string[] {\r\n    const objectives: string[] = [];\r\n    \r\n    // 정답률 기반 목표\r\n    if (analytics.correctRate < 70) {\r\n      objectives.push('기초 정확도 70% 이상 달성');\r\n    } else if (analytics.correctRate < 85) {\r\n      objectives.push('학습 정확도 85% 이상 향상');\r\n    }\r\n    \r\n    // 약점 패턴 기반 목표\r\n    analytics.identifiedWeaknesses.forEach(weakness => {\r\n      objectives.push(`${weakness.pattern} 개선`);\r\n    });\r\n    \r\n    // 카드 구성 기반 목표\r\n    const wrongAnswerCount = cards.filter(c => c.reason === 'wrong_answer').length;\r\n    if (wrongAnswerCount > 0) {\r\n      objectives.push(`오답 문제 ${wrongAnswerCount}개 완전 정복`);\r\n    }\r\n    \r\n    const forgettingCount = cards.filter(c => c.reason === 'forgetting_curve').length;\r\n    if (forgettingCount > 0) {\r\n      objectives.push(`복습 지연 문제 ${forgettingCount}개 해결`);\r\n    }\r\n    \r\n    return objectives.slice(0, 4); // 최대 4개\r\n  }\r\n  \r\n  /**\r\n   * 팩 제목 생성\r\n   */\r\n  private generatePackTitle(analytics: LearningAnalytics, algorithm: string): string {\r\n    const algorithmNames = {\r\n      standard: '맞춤형',\r\n      intensive: '집중',\r\n      review_focused: '복습 중심'\r\n    };\r\n    \r\n    const accuracyLevel = analytics.correctRate > 80 ? '고급' : \r\n                         analytics.correctRate > 60 ? '중급' : '기초';\r\n    \r\n    return `${algorithmNames[algorithm]} ${accuracyLevel} 학습팩`;\r\n  }\r\n  \r\n  /**\r\n   * 팩 설명 생성\r\n   */\r\n  private generatePackDescription(analytics: LearningAnalytics, cardCount: number): string {\r\n    const weaknessCount = analytics.identifiedWeaknesses.length;\r\n    const accuracyText = `현재 정답률 ${analytics.correctRate}%`;\r\n    \r\n    return `${accuracyText}를 바탕으로 ${weaknessCount}개의 약점 패턴을 분석하여 ${cardCount}개의 맞춤형 문제를 선별했습니다. AI가 추천하는 최적의 학습 순서로 구성되었습니다.`;\r\n  }\r\n  \r\n  /**\r\n   * Adaptive Pack 저장\r\n   */\r\n  private saveAdaptivePack(userId: string, pack: AdaptivePack): void {\r\n    try {\r\n      const key = `adaptive_pack_${userId}`;\r\n      const existingPacks = localStorage.getItem(key);\r\n      const packs: AdaptivePack[] = existingPacks ? JSON.parse(existingPacks) : [];\r\n      \r\n      // 최신 팩을 맨 앞에 추가 (최대 5개 유지)\r\n      packs.unshift(pack);\r\n      const limitedPacks = packs.slice(0, 5);\r\n      \r\n      localStorage.setItem(key, JSON.stringify(limitedPacks));\r\n    } catch (error) {\r\n      console.error('Adaptive Pack 저장 실패:', error);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 저장된 Adaptive Pack 조회\r\n   */\r\n  async getSavedAdaptivePacks(userId: string): Promise<AdaptivePack[]> {\r\n    try {\r\n      const key = `adaptive_pack_${userId}`;\r\n      const stored = localStorage.getItem(key);\r\n      return stored ? JSON.parse(stored) : [];\r\n    } catch (error) {\r\n      console.error('Adaptive Pack 조회 실패:', error);\r\n      return [];\r\n    }\r\n  }\r\n}\r\n\r\nexport const adaptivePackService = new AdaptivePackService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\api.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AxiosRequestConfig' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AxiosResponse' is defined but never used. Allowed unused vars must match /^_/u.","line":8,"column":52,"nodeType":null,"messageId":"unusedVar","endLine":8,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'errorHandler' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":15}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview 통합 API 서비스 - 전문적인 에러 처리 및 성능 모니터링 포함\n * @description AI 면접 시뮬레이터의 모든 API 통신을 관리하는 중앙 서비스\n * @author DaSiStart Team\n * @version 2.2.0\n */\n\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse, AxiosError } from 'axios';\nimport { \n  logger,\n  errorHandler,\n  handleApiError\n} from '../utils/index';\nimport { CURRICULUM_CONFIG, getCurriculumPath } from '../config/curriculum';\n\n// ====== 타입 정의 ======\n\nexport interface APIResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  message?: string;\n  timestamp: number;\n}\n\n// Updated to include topic\nexport interface InterviewConfig {\n  level: string;\n  topic: string;\n  position: string;\n  experience: string;\n}\n\nexport interface InterviewStartResponse {\n  interviewId: string;\n  question: string;\n  sessionInfo: {\n    level: string;\n    topic: string;\n  };\n}\n\nexport interface QuestionResponse {\n  question: string | null;\n  isComplete?: boolean;\n}\n\nexport interface EvaluationRequest {\n  interviewId: string;\n  question: string;\n  answer: string;\n}\n\nexport interface EvaluationResponse {\n  score: number;\n  feedback: string;\n  strengths: string[];\n  improvements: string[];\n}\n\n// ====== API 클라이언트 설정 ======\n\nclass APIClient {\n  private axiosInstance: AxiosInstance;\n\n  constructor() {\n    this.axiosInstance = axios.create({\n      baseURL: CURRICULUM_CONFIG.baseUrl + '/api',\n      timeout: 30000,\n      headers: { \n        'Content-Type': 'application/json',\n        'X-Curriculum-Version': CURRICULUM_CONFIG.version \n      },\n    });\n\n    this.axiosInstance.interceptors.response.use(\n      (response) => response.data, // Unwrap the response data\n      (error: AxiosError) => {\n        const structuredError = handleApiError(error, { component: 'APIClient' });\n        return Promise.reject(structuredError);\n      }\n    );\n  }\n\n  public async request<T>(\n    endpoint: string,\n    method: 'GET' | 'POST',\n    data?: any\n  ): Promise<T> {\n    logger.info(`API Request: ${method} ${endpoint}`, 'API');\n    const response = await this.axiosInstance({ method, url: endpoint, data });\n    return response as T;\n  }\n}\n\n// ====== API 서비스 클래스들 ======\n\nclass InterviewAPIService {\n  constructor(private client: APIClient) {}\n\n  start(config: InterviewConfig): Promise<APIResponse<InterviewStartResponse>> {\n    return this.client.request<APIResponse<InterviewStartResponse>>('/interview/start', 'POST', config);\n  }\n\n  getNextQuestion(data: { interviewId: string }): Promise<APIResponse<QuestionResponse>> {\n    return this.client.request<APIResponse<QuestionResponse>>('/interview/question', 'POST', data);\n  }\n\n  evaluate(data: EvaluationRequest): Promise<APIResponse<EvaluationResponse>> {\n    return this.client.request<APIResponse<EvaluationResponse>>('/interview/evaluate', 'POST', data);\n  }\n\n  end(interviewId: string): Promise<APIResponse<any>> {\n    return this.client.request<APIResponse<any>>(`/interview/${interviewId}/end`, 'POST');\n  }\n}\n\nclass CurriculumAPIService {\n  constructor(private client: APIClient) {}\n\n  async getCurriculum(level: number): Promise<APIResponse<any>> {\n    try {\n      const path = getCurriculumPath(level);\n      const response = await fetch(`${CURRICULUM_CONFIG.baseUrl}/${path}`);\n      if (!response.ok) throw new Error(`Failed to fetch curriculum: ${response.statusText}`);\n      const data = await response.json();\n      return { success: true, data, timestamp: Date.now() };\n    } catch (error) {\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Unknown error',\n        timestamp: Date.now() \n      };\n    }\n  }\n\n  async getStage(level: number, stageId: string): Promise<APIResponse<any>> {\n    try {\n      const curriculum = await this.getCurriculum(level);\n      if (!curriculum.success || !curriculum.data) {\n        return { success: false, error: 'Failed to load curriculum', timestamp: Date.now() };\n      }\n      const stage = curriculum.data.stages?.find((s: any) => s.stage_id === stageId);\n      return { \n        success: !!stage, \n        data: stage,\n        error: !stage ? 'Stage not found' : undefined,\n        timestamp: Date.now() \n      };\n    } catch (error) {\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Unknown error',\n        timestamp: Date.now() \n      };\n    }\n  }\n\n  async getAllLevelPatterns(level: number): Promise<APIResponse<any>> {\n    try {\n      const curriculum = await this.getCurriculum(level);\n      if (!curriculum.success || !curriculum.data) {\n        return { success: false, error: 'Failed to load curriculum', timestamp: Date.now() };\n      }\n\n      const allPatterns: any[] = [];\n      \n      // 모든 스테이지의 패턴들을 수집\n      if (curriculum.data.stages) {\n        curriculum.data.stages.forEach((stage: any) => {\n          if (stage.patterns) {\n            stage.patterns.forEach((pattern: any) => {\n              allPatterns.push({\n                ...pattern,\n                stage_id: stage.stage_id,\n                stage_title: stage.title,\n              });\n            });\n          }\n        });\n      }\n\n      // 패턴들을 랜덤하게 섞기\n      const shuffledPatterns = this.shuffleArray([...allPatterns]);\n\n      return { \n        success: true, \n        data: {\n          level,\n          mode: 'ALL',\n          total_patterns: shuffledPatterns.length,\n          patterns: shuffledPatterns,\n          title: `Level ${level} - ALL Mode`,\n          description: `All patterns from Level ${level} in random order`\n        },\n        timestamp: Date.now() \n      };\n    } catch (error) {\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Unknown error',\n        timestamp: Date.now() \n      };\n    }\n  }\n\n  private shuffleArray<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n\n  async validateCurriculum(level: number): Promise<APIResponse<any>> {\n    try {\n      const curriculum = await this.getCurriculum(level);\n      if (!curriculum.success || !curriculum.data) {\n        return { \n          success: false, \n          error: 'Failed to load curriculum for validation',\n          timestamp: Date.now() \n        };\n      }\n\n      const data = curriculum.data;\n      return { \n        success: true, \n        data: {\n          total_stages: data.total_stages || data.stages?.length || 0,\n          total_phases: data.total_phases || data.phases?.length || 0,\n          level: data.level,\n          title: data.title,\n          isRevised: getCurriculumPath(level).includes('_REVISED.json'),\n          stages: data.stages || []\n        },\n        timestamp: Date.now() \n      };\n    } catch (error) {\n      return { \n        success: false, \n        error: error instanceof Error ? error.message : 'Validation failed',\n        timestamp: Date.now() \n      };\n    }\n  }\n}\n\n// ====== 서비스 인스턴스 생성 및 내보내기 ======\n\nconst apiClient = new APIClient();\n\nexport const interviewAPI = new InterviewAPIService(apiClient);\nexport const curriculumAPI = new CurriculumAPIService(apiClient);\n\n// authService에서 사용할 수 있는 기본 API 클라이언트 export\nexport const api = apiClient;\n\nexport default { \n  interview: interviewAPI,\n  curriculum: curriculumAPI,\n  api: apiClient\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\authService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ProgressUpdateParams' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'backendSuccess' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":147,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":147,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useAuth } from '../hooks/useAuth';\r\nimport { api } from './api';\r\n\r\ninterface ExpGainParams {\r\n  amount: number;\r\n  type: 'stage_clear' | 'review_success' | 'streak_bonus' | 'daily_login' | 'perfect_score';\r\n}\r\n\r\ninterface ProgressUpdateParams {\r\n  level?: number;\r\n  stage?: number;\r\n  exp?: number;\r\n  streak?: number;\r\n}\r\n\r\nclass AuthService {\r\n  /**\r\n   * 백엔드 expService와 연동하여 경험치 추가\r\n   */\r\n  async addExpToBackend(userId: string, params: ExpGainParams): Promise<boolean> {\r\n    try {\r\n      console.log('[DEBUG] 📈 백엔드 경험치 추가 요청:', { userId, ...params });\r\n      \r\n      const response = await api.request('/exp/add', 'POST', {\r\n        userId,\r\n        amount: params.amount,\r\n        type: params.type\r\n      });\r\n      \r\n      console.log('[DEBUG] ✅ 백엔드 경험치 추가 성공:', response);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('[DEBUG] ❌ 백엔드 경험치 추가 실패:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 백엔드 스트릭 업데이트\r\n   */\r\n  async updateStreakToBackend(userId: string): Promise<boolean> {\r\n    try {\r\n      console.log('[DEBUG] 🔥 백엔드 스트릭 업데이트 요청:', userId);\r\n      \r\n      const response = await api.request('/exp/streak', 'POST', { userId });\r\n      \r\n      console.log('[DEBUG] ✅ 백엔드 스트릭 업데이트 성공:', response);\r\n      return true;\r\n    } catch (error) {\r\n      console.error('[DEBUG] ❌ 백엔드 스트릭 업데이트 실패:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 학습 완료 시 종합적인 진행도 업데이트\r\n   */\r\n  async handleStudyCompletion(userId: string, completionData: {\r\n    level: number;\r\n    stage: number;\r\n    score: number;\r\n    timeSpent: number;\r\n    mistakes: number;\r\n  }): Promise<boolean> {\r\n    try {\r\n      console.log('[DEBUG] 📚 학습 완료 처리:', { userId, ...completionData });\r\n\r\n      // 1. 경험치 계산 및 추가\r\n      let expGain = 10; // 기본 경험치\r\n      let expType: ExpGainParams['type'] = 'stage_clear';\r\n\r\n      if (completionData.score >= 90) {\r\n        expGain += 5; // 고득점 보너스\r\n        expType = 'perfect_score';\r\n      }\r\n\r\n      if (completionData.mistakes === 0) {\r\n        expGain += 3; // 완벽 보너스\r\n      }\r\n\r\n      // 2. 백엔드 경험치 추가\r\n      const expSuccess = await this.addExpToBackend(userId, {\r\n        amount: expGain,\r\n        type: expType\r\n      });\r\n\r\n      // 3. 스트릭 업데이트\r\n      const streakSuccess = await this.updateStreakToBackend(userId);\r\n\r\n      console.log('[DEBUG] ✅ 학습 완료 처리 결과:', { expSuccess, streakSuccess });\r\n      return expSuccess && streakSuccess;\r\n    } catch (error) {\r\n      console.error('[DEBUG] ❌ 학습 완료 처리 실패:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 프론트엔드와 백엔드 진행도 동기화\r\n   */\r\n  async syncProgress(userId: string): Promise<boolean> {\r\n    try {\r\n      console.log('[DEBUG] 🔄 진행도 동기화 시작:', userId);\r\n      \r\n      // 백엔드에서 최신 사용자 데이터 가져오기\r\n      const response = await api.request(`/users/${userId}`, 'GET');\r\n      const backendUserData = response;\r\n      \r\n      console.log('[DEBUG] 📊 백엔드 사용자 데이터:', backendUserData);\r\n      \r\n      // 필요시 Firestore 업데이트\r\n      // 이 부분은 useAuth hook에서 처리하거나 별도 함수로 분리 가능\r\n      \r\n      return true;\r\n    } catch (error) {\r\n      console.error('[DEBUG] ❌ 진행도 동기화 실패:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// 싱글톤 인스턴스\r\nexport const authService = new AuthService();\r\n\r\n// Hook을 사용하는 커스텀 훅\r\nexport const useAuthService = () => {\r\n  const { user, addExp, updateUserProgress } = useAuth();\r\n\r\n  const handleStudyComplete = async (completionData: {\r\n    level: number;\r\n    stage: number;\r\n    score: number;\r\n    timeSpent: number;\r\n    mistakes: number;\r\n  }) => {\r\n    if (!user) {\r\n      console.warn('[DEBUG] ⚠️ 로그인되지 않은 상태에서 학습 완료 처리 시도');\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      // 1. 프론트엔드 진행도 업데이트 (즉시 반영)\r\n      const expGain = calculateExpGain(completionData);\r\n      const frontendSuccess = await addExp(expGain);\r\n\r\n      // 2. 백엔드 동기화 (백그라운드)\r\n      const backendSuccess = await authService.handleStudyCompletion(user.uid, completionData);\r\n\r\n      // 3. Stage 진행도 업데이트\r\n      if (completionData.score >= 70) { // 70점 이상 시 다음 스테이지로\r\n        const progressSuccess = await updateUserProgress({\r\n          level: completionData.level,\r\n          stage: completionData.stage + 1\r\n        });\r\n        console.log('[DEBUG] 📈 스테이지 진행도 업데이트:', progressSuccess);\r\n      }\r\n\r\n      return frontendSuccess;\r\n    } catch (error) {\r\n      console.error('[DEBUG] ❌ 통합 학습 완료 처리 실패:', error);\r\n      return false;\r\n    }\r\n  };\r\n\r\n  return {\r\n    handleStudyComplete,\r\n    isAuthenticated: !!user,\r\n    userId: user?.uid\r\n  };\r\n};\r\n\r\n// 경험치 계산 헬퍼\r\nfunction calculateExpGain(data: { score: number; timeSpent: number; mistakes: number }): number {\r\n  let exp = 10; // 기본\r\n\r\n  if (data.score >= 90) exp += 5;\r\n  if (data.mistakes === 0) exp += 3;\r\n  if (data.timeSpent < 60000) exp += 2; // 1분 이내\r\n\r\n  return exp;\r\n}\r\n\r\nexport default authService;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\curriculumLint.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\curriculum\\CurriculumDemo.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\curriculum\\CurriculumLoader.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\curriculum\\Level4Service.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\curriculum\\Level4ServiceQuick.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\curriculum\\LevelServiceFactory.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Level4Service' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Level별 서비스를 관리하는 팩토리 클래스\n * 느슨한 결합을 위해 팩토리 패턴 적용\n */\n\nimport { Level4Service } from './Level4Service';\nimport { Level4ServiceQuick } from './Level4ServiceQuick';\nimport { LegacyQuestionItem } from './types/CurriculumTypes';\n\ninterface LevelService {\n  generateLegacyQuestions(stageNumber: number): Promise<LegacyQuestionItem[]>;\n}\n\nexport class LevelServiceFactory {\n  private static services: Map<number, LevelService> = new Map();\n\n  /**\n   * 레벨에 해당하는 서비스 인스턴스 반환\n   */\n  static getService(level: number): LevelService | null {\n    // 캐시된 서비스가 있으면 반환\n    if (this.services.has(level)) {\n      return this.services.get(level)!;\n    }\n\n    // 레벨별 서비스 생성\n    let service: LevelService | null = null;\n    \n    switch (level) {\n      case 4:\n        // 빠른 해결책: 하드코딩된 예문 사용\n        service = {\n          generateLegacyQuestions: Level4ServiceQuick.generateLegacyQuestions.bind(Level4ServiceQuick)\n        };\n        break;\n      case 5:\n        // Level5Service 구현되면 추가\n        service = this.createFallbackService(5);\n        break;\n      case 6:\n        // Level6Service 구현되면 추가  \n        service = this.createFallbackService(6);\n        break;\n      case 7:\n        service = this.createFallbackService(7);\n        break;\n      case 8:\n        service = this.createFallbackService(8);\n        break;\n      case 9:\n        service = this.createFallbackService(9);\n        break;\n      case 10:\n        service = this.createFallbackService(10);\n        break;\n      default:\n        console.warn(`Level ${level} 서비스가 구현되지 않았습니다.`);\n        return null;\n    }\n\n    if (service) {\n      this.services.set(level, service);\n    }\n\n    return service;\n  }\n\n  /**\n   * 아직 구현되지 않은 레벨을 위한 폴백 서비스\n   */\n  private static createFallbackService(level: number): LevelService {\n    return {\n      async generateLegacyQuestions(stageNumber: number): Promise<LegacyQuestionItem[]> {\n        console.warn(`Level ${level} 서비스 미구현. 폴백 데이터 사용.`);\n        \n        // 기본 폴백 문장들 (104개까지 생성)\n        const sentences: LegacyQuestionItem[] = [];\n        const baseTemplates = [\n          { korean: `Level ${level} 기본 문장입니다`, english: `This is a Level ${level} basic sentence` },\n          { korean: `Level ${level} 고급 표현을 연습합니다`, english: `Practicing Level ${level} advanced expressions` },\n          { korean: `Level ${level}에서 배우는 문법입니다`, english: `Grammar learned in Level ${level}` }\n        ];\n\n        for (let i = 0; i < 104; i++) {\n          const template = baseTemplates[i % baseTemplates.length];\n          sentences.push({\n            korean: `${template.korean} (${i + 1})`,\n            english: `${template.english} (${i + 1})`,\n            level: level,\n            stage: stageNumber,\n            pattern: `Level ${level} Pattern`\n          });\n        }\n\n        return sentences;\n      }\n    };\n  }\n\n  /**\n   * 특정 레벨과 스테이지의 문제 생성\n   * 기존 PatternDataManager.generateQuestions 대체용\n   */\n  static async generateQuestions(level: number, stageNumber: number): Promise<LegacyQuestionItem[]> {\n    const service = this.getService(level);\n    if (!service) {\n      console.error(`Level ${level} 서비스를 찾을 수 없습니다.`);\n      return [];\n    }\n\n    try {\n      const questions = await service.generateLegacyQuestions(stageNumber);\n      console.log(`✅ Level ${level} Stage ${stageNumber}: ${questions.length}개 문제 생성`);\n      return questions;\n    } catch (error) {\n      console.error(`Level ${level} Stage ${stageNumber} 문제 생성 실패:`, error);\n      return [];\n    }\n  }\n\n  /**\n   * 모든 서비스 캐시 클리어\n   */\n  static clearCache(): void {\n    this.services.clear();\n  }\n\n  /**\n   * 사용 가능한 레벨 목록 반환\n   */\n  static getAvailableLevels(): number[] {\n    return [4, 5, 6, 7, 8, 9, 10];\n  }\n\n  /**\n   * 특정 레벨이 지원되는지 확인\n   */\n  static isLevelSupported(level: number): boolean {\n    return this.getAvailableLevels().includes(level);\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\curriculum\\types\\CurriculumTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\events\\EventLifecycleManager.ts","messages":[{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":65,"column":75,"nodeType":"Identifier","messageId":"undef","endLine":65,"endColumn":88},{"ruleId":"no-undef","severity":1,"message":"'EventListener' is not defined.","line":83,"column":75,"nodeType":"Identifier","messageId":"undef","endLine":83,"endColumn":88}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * EventLifecycleManager - 이벤트 라이프사이클 관리 모듈\r\n * \r\n * 역할:\r\n * - 완료 알림 중복 방지\r\n * - 이벤트 리스너 중복 등록 방지\r\n * - 컴포넌트 상태 변화에 따른 이벤트 정리\r\n */\r\n\r\nexport type EventType = 'completion' | 'tts' | 'recognition' | 'navigation';\r\n\r\nexport interface EventConfig {\r\n  id: string;\r\n  type: EventType;\r\n  handler: Function;\r\n  element?: EventTarget;\r\n  eventName?: string;\r\n}\r\n\r\nexport interface EventState {\r\n  id: string;\r\n  type: EventType;\r\n  handler: Function;\r\n  element?: EventTarget;\r\n  eventName?: string;\r\n  isActive: boolean;\r\n  registeredAt: number;\r\n}\r\n\r\nclass EventLifecycleManager {\r\n  private events: Map<string, EventState> = new Map();\r\n  private completionHistory: Set<string> = new Set(); // 완료 이벤트 중복 방지\r\n  private static instance: EventLifecycleManager | null = null;\r\n\r\n  // Singleton pattern\r\n  static getInstance(): EventLifecycleManager {\r\n    if (!EventLifecycleManager.instance) {\r\n      EventLifecycleManager.instance = new EventLifecycleManager();\r\n    }\r\n    return EventLifecycleManager.instance;\r\n  }\r\n\r\n  /**\r\n   * 이벤트 등록 (중복 방지)\r\n   */\r\n  registerEvent(config: EventConfig): boolean {\r\n    // 이미 등록된 이벤트는 무시\r\n    if (this.events.has(config.id)) {\r\n      console.log(`⚠️ [EventManager] 이벤트 이미 등록됨: ${config.id}`);\r\n      return false;\r\n    }\r\n\r\n    const state: EventState = {\r\n      id: config.id,\r\n      type: config.type,\r\n      handler: config.handler,\r\n      element: config.element,\r\n      eventName: config.eventName,\r\n      isActive: true,\r\n      registeredAt: Date.now()\r\n    };\r\n\r\n    // DOM 이벤트 리스너 등록\r\n    if (config.element && config.eventName) {\r\n      config.element.addEventListener(config.eventName, config.handler as EventListener);\r\n      console.log(`📡 [EventManager] DOM 이벤트 등록: ${config.eventName} on ${config.element.constructor.name}`);\r\n    }\r\n\r\n    this.events.set(config.id, state);\r\n    console.log(`✅ [EventManager] 이벤트 등록: ${config.id} (타입: ${config.type})`);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 이벤트 제거\r\n   */\r\n  unregisterEvent(id: string): boolean {\r\n    const state = this.events.get(id);\r\n    if (!state) return false;\r\n\r\n    // DOM 이벤트 리스너 제거\r\n    if (state.element && state.eventName) {\r\n      state.element.removeEventListener(state.eventName, state.handler as EventListener);\r\n      console.log(`📡 [EventManager] DOM 이벤트 제거: ${state.eventName}`);\r\n    }\r\n\r\n    state.isActive = false;\r\n    this.events.delete(id);\r\n    console.log(`🗑️ [EventManager] 이벤트 제거: ${id}`);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 특정 타입의 모든 이벤트 제거\r\n   */\r\n  unregisterEventsByType(type: EventType): number {\r\n    let count = 0;\r\n    for (const [id, state] of this.events.entries()) {\r\n      if (state.type === type) {\r\n        this.unregisterEvent(id);\r\n        count++;\r\n      }\r\n    }\r\n    console.log(`🗑️ [EventManager] ${type} 타입 이벤트 ${count}개 제거`);\r\n    return count;\r\n  }\r\n\r\n  /**\r\n   * 완료 이벤트 중복 방지 처리\r\n   */\r\n  handleCompletion(completionId: string, callback: () => void): boolean {\r\n    // 이미 처리된 완료 이벤트는 무시\r\n    if (this.completionHistory.has(completionId)) {\r\n      console.log(`⚠️ [EventManager] 완료 이벤트 중복 무시: ${completionId}`);\r\n      return false;\r\n    }\r\n\r\n    // 완료 이벤트 처리\r\n    this.completionHistory.add(completionId);\r\n    callback();\r\n    \r\n    console.log(`🎉 [EventManager] 완료 이벤트 처리: ${completionId}`);\r\n\r\n    // 5초 후 히스토리에서 제거 (메모리 누수 방지)\r\n    setTimeout(() => {\r\n      this.completionHistory.delete(completionId);\r\n      console.log(`🧹 [EventManager] 완료 히스토리 정리: ${completionId}`);\r\n    }, 5000);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * TTS 이벤트 관리\r\n   */\r\n  manageTTSEvent(utterance: SpeechSynthesisUtterance, eventType: 'start' | 'end' | 'error', handler: Function): void {\r\n    const eventId = `tts-${eventType}-${Date.now()}`;\r\n    \r\n    // 기존 TTS 이벤트 정리\r\n    this.unregisterEventsByType('tts');\r\n\r\n    // 새로운 TTS 이벤트 등록\r\n    const wrappedHandler = (...args: any[]) => {\r\n      handler(...args);\r\n      // TTS 이벤트는 일회성이므로 자동 정리\r\n      this.unregisterEvent(eventId);\r\n    };\r\n\r\n    this.registerEvent({\r\n      id: eventId,\r\n      type: 'tts',\r\n      handler: wrappedHandler\r\n    });\r\n\r\n    // SpeechSynthesisUtterance에 직접 할당\r\n    if (eventType === 'start') {\r\n      utterance.onstart = wrappedHandler;\r\n    } else if (eventType === 'end') {\r\n      utterance.onend = wrappedHandler;\r\n    } else if (eventType === 'error') {\r\n      utterance.onerror = wrappedHandler;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 음성인식 이벤트 관리\r\n   */\r\n  manageRecognitionEvent(recognition: any, eventType: 'result' | 'end' | 'error', handler: Function): void {\r\n    const eventId = `recognition-${eventType}-${Date.now()}`;\r\n    \r\n    // 새로운 음성인식 이벤트 등록\r\n    const wrappedHandler = (...args: any[]) => {\r\n      handler(...args);\r\n      // result 이벤트는 여러 번 발생할 수 있으므로 end/error만 자동 정리\r\n      if (eventType !== 'result') {\r\n        this.unregisterEvent(eventId);\r\n      }\r\n    };\r\n\r\n    this.registerEvent({\r\n      id: eventId,\r\n      type: 'recognition',\r\n      handler: wrappedHandler\r\n    });\r\n\r\n    // Recognition 객체에 직접 할당\r\n    if (eventType === 'result') {\r\n      recognition.onresult = wrappedHandler;\r\n    } else if (eventType === 'end') {\r\n      recognition.onend = wrappedHandler;\r\n    } else if (eventType === 'error') {\r\n      recognition.onerror = wrappedHandler;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 모든 이벤트 정리\r\n   */\r\n  clearAllEvents(): void {\r\n    for (const [id] of this.events.entries()) {\r\n      this.unregisterEvent(id);\r\n    }\r\n    this.completionHistory.clear();\r\n    console.log(`🧹 [EventManager] 모든 이벤트 정리 완료`);\r\n  }\r\n\r\n  /**\r\n   * 이벤트 상태 조회\r\n   */\r\n  getEventState(id: string): EventState | null {\r\n    return this.events.get(id) || null;\r\n  }\r\n\r\n  /**\r\n   * 활성 이벤트 목록\r\n   */\r\n  getActiveEvents(): EventState[] {\r\n    return Array.from(this.events.values()).filter(state => state.isActive);\r\n  }\r\n\r\n  /**\r\n   * 완료 히스토리 조회\r\n   */\r\n  getCompletionHistory(): string[] {\r\n    return Array.from(this.completionHistory);\r\n  }\r\n\r\n  /**\r\n   * 디버그 정보\r\n   */\r\n  debug(): void {\r\n    console.log(`🔍 [EventManager] 활성 이벤트: ${this.events.size}개`);\r\n    console.log(`🔍 [EventManager] 완료 히스토리: ${this.completionHistory.size}개`);\r\n    \r\n    for (const [id, state] of this.events.entries()) {\r\n      const age = Date.now() - state.registeredAt;\r\n      console.log(`  - ${id}: ${state.type} (수명: ${age}ms)`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 오래된 이벤트 정리 (메모리 누수 방지)\r\n   */\r\n  cleanupOldEvents(maxAge: number = 30000): number { // 30초\r\n    let cleaned = 0;\r\n    const now = Date.now();\r\n    \r\n    for (const [id, state] of this.events.entries()) {\r\n      if (now - state.registeredAt > maxAge) {\r\n        this.unregisterEvent(id);\r\n        cleaned++;\r\n      }\r\n    }\r\n    \r\n    if (cleaned > 0) {\r\n      console.log(`🧹 [EventManager] 오래된 이벤트 ${cleaned}개 정리`);\r\n    }\r\n    \r\n    return cleaned;\r\n  }\r\n}\r\n\r\nexport default EventLifecycleManager;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\feedbackService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\firestoreDoD.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\incorrectPriorityService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'record' is defined but never used. Allowed unused args must match /^_/u.","line":347,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":347,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// 오답 우선 알고리즘 - 최근 3일 틀린 문장 가중 재출제\r\n\r\ninterface IncorrectRecord {\r\n  sentenceId: string;\r\n  userId: string;\r\n  level: number;\r\n  stage: number;\r\n  stageId: string;\r\n  incorrectCount: number;\r\n  lastIncorrectDate: Date;\r\n  recentMistakes: Array<{\r\n    timestamp: Date;\r\n    mistakeType: 'grammar' | 'vocabulary' | 'spelling' | 'structure';\r\n    userAnswer: string;\r\n    correctAnswer: string;\r\n  }>;\r\n  weight: number; // 우선순위 가중치\r\n}\r\n\r\ninterface PrioritySession {\r\n  totalSentences: number;\r\n  incorrectPrioritySentences: string[];\r\n  regularSentences: string[];\r\n  sessionType: 'incorrect_focus' | 'mixed' | 'regular';\r\n}\r\n\r\nclass IncorrectPriorityService {\r\n  \r\n  /**\r\n   * 오답 우선 복습 세션 생성\r\n   */\r\n  async createIncorrectPrioritySession(\r\n    userId: string, \r\n    totalSentences: number = 30,\r\n    incorrectRatio: number = 0.7 // 70%는 오답 문장, 30%는 일반 문장\r\n  ): Promise<PrioritySession> {\r\n    \r\n    try {\r\n      // 최근 3일 오답 문장들 조회\r\n      const incorrectSentences = await this.getRecentIncorrectSentences(userId, 3);\r\n      \r\n      // 오답 문장 개수 계산\r\n      const maxIncorrectCount = Math.floor(totalSentences * incorrectRatio);\r\n      const actualIncorrectCount = Math.min(incorrectSentences.length, maxIncorrectCount);\r\n      \r\n      // 세션 타입 결정\r\n      let sessionType: 'incorrect_focus' | 'mixed' | 'regular';\r\n      if (incorrectSentences.length === 0) {\r\n        sessionType = 'regular';\r\n      } else if (actualIncorrectCount >= totalSentences * 0.5) {\r\n        sessionType = 'incorrect_focus';\r\n      } else {\r\n        sessionType = 'mixed';\r\n      }\r\n      \r\n      // 우선순위 기반 오답 문장 선택\r\n      const prioritizedIncorrect = this.selectPriorityIncorrectSentences(\r\n        incorrectSentences, \r\n        actualIncorrectCount\r\n      );\r\n      \r\n      // 나머지는 일반 문장으로 채우기\r\n      const remainingCount = totalSentences - prioritizedIncorrect.length;\r\n      const regularSentences = await this.getRegularSentences(userId, remainingCount, prioritizedIncorrect);\r\n      \r\n      return {\r\n        totalSentences,\r\n        incorrectPrioritySentences: prioritizedIncorrect,\r\n        regularSentences,\r\n        sessionType\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('오답 우선 세션 생성 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 최근 3일 내 틀린 문장들 조회 (가중치 포함)\r\n   */\r\n  async getRecentIncorrectSentences(userId: string, days: number = 3): Promise<IncorrectRecord[]> {\r\n    try {\r\n      const cutoffDate = new Date();\r\n      cutoffDate.setDate(cutoffDate.getDate() - days);\r\n      \r\n      // 실제로는 Firestore에서 조회\r\n      // 임시 데이터로 시뮬레이션\r\n      const mockIncorrectRecords: IncorrectRecord[] = [\r\n        {\r\n          sentenceId: 'Lv3-P2-S09_15',\r\n          userId,\r\n          level: 3,\r\n          stage: 9,\r\n          stageId: 'Lv3-P2-S09',\r\n          incorrectCount: 3,\r\n          lastIncorrectDate: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000), // 1일 전\r\n          recentMistakes: [\r\n            {\r\n              timestamp: new Date(Date.now() - 1 * 24 * 60 * 60 * 1000),\r\n              mistakeType: 'grammar',\r\n              userAnswer: 'If I would have time',\r\n              correctAnswer: 'If I had time'\r\n            }\r\n          ],\r\n          weight: 0\r\n        },\r\n        {\r\n          sentenceId: 'Lv4-B1-S02_08',\r\n          userId,\r\n          level: 4,\r\n          stage: 2,\r\n          stageId: 'Lv4-B1-S02',\r\n          incorrectCount: 2,\r\n          lastIncorrectDate: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000), // 2일 전\r\n          recentMistakes: [\r\n            {\r\n              timestamp: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),\r\n              mistakeType: 'vocabulary',\r\n              userAnswer: 'We must optimize our strategy',\r\n              correctAnswer: 'We need to leverage our strategy'\r\n            }\r\n          ],\r\n          weight: 0\r\n        }\r\n      ];\r\n      \r\n      // 가중치 계산\r\n      return mockIncorrectRecords.map(record => ({\r\n        ...record,\r\n        weight: this.calculatePriorityWeight(record, cutoffDate)\r\n      }));\r\n      \r\n    } catch (error) {\r\n      console.error('최근 오답 문장 조회 실패:', error);\r\n      return [];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 우선순위 가중치 계산\r\n   */\r\n  private calculatePriorityWeight(record: IncorrectRecord, cutoffDate: Date): number {\r\n    const now = new Date();\r\n    const daysSinceLastMistake = Math.floor(\r\n      (now.getTime() - record.lastIncorrectDate.getTime()) / (24 * 60 * 60 * 1000)\r\n    );\r\n    \r\n    // 기본 가중치 (틀린 횟수 기반)\r\n    let weight = record.incorrectCount * 1.0;\r\n    \r\n    // 최근성 가중치 (최근일수록 높은 가중치)\r\n    const recencyMultiplier = Math.max(0.1, 1.0 - (daysSinceLastMistake * 0.2));\r\n    weight *= recencyMultiplier;\r\n    \r\n    // 최근 3일 내 실수 빈도 가중치\r\n    const recentMistakeCount = record.recentMistakes.filter(\r\n      mistake => mistake.timestamp >= cutoffDate\r\n    ).length;\r\n    weight += recentMistakeCount * 0.5;\r\n    \r\n    // 실수 유형별 가중치\r\n    const grammarMistakes = record.recentMistakes.filter(m => m.mistakeType === 'grammar').length;\r\n    const vocabularyMistakes = record.recentMistakes.filter(m => m.mistakeType === 'vocabulary').length;\r\n    \r\n    if (grammarMistakes > 0) weight += 0.3; // 문법 실수는 더 중요\r\n    if (vocabularyMistakes > 0) weight += 0.2; // 어휘 실수\r\n    \r\n    return Math.min(10.0, weight); // 최대 가중치 제한\r\n  }\r\n  \r\n  /**\r\n   * 우선순위 기반 오답 문장 선택\r\n   */\r\n  private selectPriorityIncorrectSentences(\r\n    incorrectRecords: IncorrectRecord[], \r\n    maxCount: number\r\n  ): string[] {\r\n    \r\n    // 가중치 기준으로 정렬\r\n    const sortedRecords = incorrectRecords\r\n      .filter(record => record.weight > 0.5) // 최소 가중치 이상만\r\n      .sort((a, b) => b.weight - a.weight) // 가중치 높은 순\r\n      .slice(0, maxCount);\r\n    \r\n    return sortedRecords.map(record => record.sentenceId);\r\n  }\r\n  \r\n  /**\r\n   * 일반 문장 선택 (오답 문장 제외)\r\n   */\r\n  private async getRegularSentences(\r\n    userId: string, \r\n    count: number, \r\n    excludeSentenceIds: string[]\r\n  ): Promise<string[]> {\r\n    \r\n    try {\r\n      // 사용자 레벨에 맞는 문장들 조회 (오답 문장 제외)\r\n      // 실제로는 Firestore에서 조회하고 excludeSentenceIds를 제외\r\n      \r\n      // 임시 데이터\r\n      const allSentences = [\r\n        'Lv3-P1-S01_01', 'Lv3-P1-S01_02', 'Lv3-P1-S01_03',\r\n        'Lv4-B1-S01_01', 'Lv4-B1-S01_02', 'Lv4-B1-S01_03',\r\n        'Lv5-A1-S01_01', 'Lv5-A1-S01_02', 'Lv5-A1-S01_03'\r\n      ];\r\n      \r\n      const availableSentences = allSentences.filter(\r\n        id => !excludeSentenceIds.includes(id)\r\n      );\r\n      \r\n      // 랜덤하게 선택\r\n      const shuffled = availableSentences.sort(() => Math.random() - 0.5);\r\n      return shuffled.slice(0, count);\r\n      \r\n    } catch (error) {\r\n      console.error('일반 문장 선택 실패:', error);\r\n      return [];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 오답 기록 업데이트\r\n   */\r\n  async recordIncorrectAnswer(\r\n    userId: string,\r\n    sentenceId: string,\r\n    userAnswer: string,\r\n    correctAnswer: string,\r\n    mistakeType: 'grammar' | 'vocabulary' | 'spelling' | 'structure'\r\n  ): Promise<void> {\r\n    \r\n    try {\r\n      // 기존 오답 기록 조회\r\n      const existingRecord = await this.getIncorrectRecord(userId, sentenceId);\r\n      \r\n      const newMistake = {\r\n        timestamp: new Date(),\r\n        mistakeType,\r\n        userAnswer,\r\n        correctAnswer\r\n      };\r\n      \r\n      const updatedRecord: IncorrectRecord = {\r\n        ...existingRecord,\r\n        incorrectCount: existingRecord.incorrectCount + 1,\r\n        lastIncorrectDate: new Date(),\r\n        recentMistakes: [\r\n          ...existingRecord.recentMistakes,\r\n          newMistake\r\n        ].slice(-10) // 최근 10개만 유지\r\n      };\r\n      \r\n      // 가중치 재계산\r\n      const threeDaysAgo = new Date();\r\n      threeDaysAgo.setDate(threeDaysAgo.getDate() - 3);\r\n      updatedRecord.weight = this.calculatePriorityWeight(updatedRecord, threeDaysAgo);\r\n      \r\n      // Firestore에 저장\r\n      await this.saveIncorrectRecord(updatedRecord);\r\n      \r\n    } catch (error) {\r\n      console.error('오답 기록 업데이트 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 오답 통계 조회\r\n   */\r\n  async getIncorrectStatistics(userId: string): Promise<{\r\n    totalIncorrectSentences: number;\r\n    recentIncorrectCount: number;\r\n    mostCommonMistakeType: string;\r\n    improvementRate: number;\r\n    weakLevels: number[];\r\n  }> {\r\n    \r\n    try {\r\n      const allIncorrectRecords = await this.getAllIncorrectRecords(userId);\r\n      const recentRecords = await this.getRecentIncorrectSentences(userId, 7); // 최근 7일\r\n      \r\n      // 실수 유형 분석\r\n      const mistakeTypes = allIncorrectRecords.flatMap(record => \r\n        record.recentMistakes.map(mistake => mistake.mistakeType)\r\n      );\r\n      \r\n      const mistakeTypeCounts = mistakeTypes.reduce((acc, type) => {\r\n        acc[type] = (acc[type] || 0) + 1;\r\n        return acc;\r\n      }, {} as Record<string, number>);\r\n      \r\n      const mostCommonMistakeType = Object.entries(mistakeTypeCounts)\r\n        .sort(([,a], [,b]) => b - a)[0]?.[0] || 'none';\r\n      \r\n      // 취약 레벨 분석\r\n      const levelCounts = allIncorrectRecords.reduce((acc, record) => {\r\n        acc[record.level] = (acc[record.level] || 0) + 1;\r\n        return acc;\r\n      }, {} as Record<number, number>);\r\n      \r\n      const weakLevels = Object.entries(levelCounts)\r\n        .filter(([, count]) => count >= 3) // 3개 이상 틀린 레벨\r\n        .map(([level]) => parseInt(level))\r\n        .sort((a, b) => levelCounts[b] - levelCounts[a]);\r\n      \r\n      // 개선율 계산 (최근 2주 대비 이전 2주)\r\n      const improvementRate = await this.calculateImprovementRate(userId);\r\n      \r\n      return {\r\n        totalIncorrectSentences: allIncorrectRecords.length,\r\n        recentIncorrectCount: recentRecords.length,\r\n        mostCommonMistakeType,\r\n        improvementRate,\r\n        weakLevels\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('오답 통계 조회 실패:', error);\r\n      return {\r\n        totalIncorrectSentences: 0,\r\n        recentIncorrectCount: 0,\r\n        mostCommonMistakeType: 'none',\r\n        improvementRate: 0,\r\n        weakLevels: []\r\n      };\r\n    }\r\n  }\r\n  \r\n  // Private helper methods\r\n  private async getIncorrectRecord(userId: string, sentenceId: string): Promise<IncorrectRecord> {\r\n    // 기본값 반환 (실제로는 Firestore에서 조회)\r\n    return {\r\n      sentenceId,\r\n      userId,\r\n      level: 1,\r\n      stage: 1,\r\n      stageId: '',\r\n      incorrectCount: 0,\r\n      lastIncorrectDate: new Date(),\r\n      recentMistakes: [],\r\n      weight: 0\r\n    };\r\n  }\r\n  \r\n  private async saveIncorrectRecord(record: IncorrectRecord): Promise<void> {\r\n    // Firestore에 저장\r\n  }\r\n  \r\n  private async getAllIncorrectRecords(_userId: string): Promise<IncorrectRecord[]> {\r\n    // 모든 오답 기록 조회\r\n    return [];\r\n  }\r\n  \r\n  private async calculateImprovementRate(_userId: string): Promise<number> {\r\n    // 개선율 계산 (임시값)\r\n    return 0.15; // 15% 개선\r\n  }\r\n}\r\n\r\nexport const incorrectPriorityService = new IncorrectPriorityService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\interviewStorage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\navigationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\patternDataLoader.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":135,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":22}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 🔄 Pattern Data Loader (Firebase Storage)\n * \n * 패턴 데이터를 Firebase Storage에서 로드하는 서비스\n * 기존 로컬 파일 시스템 대신 원격 저장소 사용\n */\n\ninterface Sentence {\n  id: string;\n  kr: string;\n  en: string;\n  form?: string;\n}\n\ninterface BankData {\n  stage_id: string;\n  title?: string;\n  count?: number;\n  sentences?: Sentence[];\n  sample_sentences?: Sentence[];\n  examples?: Sentence[];\n}\n\ninterface LoadResult {\n  data: BankData | null;\n  source: 'cache' | 'storage' | 'fallback';\n  loadTime: number;\n}\n\nclass PatternDataLoader {\n  private cache = new Map<string, BankData>();\n  private readonly CACHE_TTL = 10 * 60 * 1000; // 10분 캐시 (더 길게)\n  private cacheTimestamps = new Map<string, number>();\n  private readonly STORAGE_BASE_URL: string;\n  \n  constructor() {\n    // Vite 환경변수 사용 (REACT_APP -> VITE)\n    this.STORAGE_BASE_URL = import.meta.env.VITE_FIREBASE_STORAGE_URL || \n      'https://storage.googleapis.com/dasi-english-default-rtdb.appspot.com';\n      \n    console.log(`[PatternDataLoader] Storage URL: ${this.STORAGE_BASE_URL}`);\n  }\n\n  /**\n   * 🎯 패턴 데이터 로드 (메인 메서드)\n   */\n  async loadBankData(level: number, stageId: string): Promise<LoadResult> {\n    const startTime = Date.now();\n    const cacheKey = `${level}-${stageId}`;\n    \n    // 1. 캐시 확인\n    if (this.isCacheValid(cacheKey)) {\n      const data = this.cache.get(cacheKey) || null;\n      return {\n        data,\n        source: 'cache',\n        loadTime: Date.now() - startTime\n      };\n    }\n\n    // 2. Firebase Storage에서 로드\n    try {\n      const data = await this.loadFromStorage(level, stageId);\n      if (data) {\n        // 캐시 저장\n        this.cache.set(cacheKey, data);\n        this.cacheTimestamps.set(cacheKey, Date.now());\n        \n        return {\n          data,\n          source: 'storage',\n          loadTime: Date.now() - startTime\n        };\n      }\n    } catch (error) {\n      console.error(`[PatternDataLoader] Storage load failed for ${stageId}:`, error);\n    }\n\n    // 3. 로컬 fallback (마이그레이션 기간 중)\n    try {\n      const data = await this.loadFromLocal(level, stageId);\n      return {\n        data,\n        source: 'fallback',\n        loadTime: Date.now() - startTime\n      };\n    } catch (error) {\n      console.error(`[PatternDataLoader] Fallback load failed for ${stageId}:`, error);\n      return {\n        data: null,\n        source: 'fallback',\n        loadTime: Date.now() - startTime\n      };\n    }\n  }\n\n  /**\n   * 📦 Firebase Storage에서 데이터 로드\n   */\n  private async loadFromStorage(level: number, stageId: string): Promise<BankData | null> {\n    const url = `${this.STORAGE_BASE_URL}/patterns/banks/level_${level}/${stageId}_bank.json`;\n    \n    console.log(`[DEBUG] 🔍 Loading from Storage: ${url}`);\n    \n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(`Storage fetch failed: ${response.status}`);\n    }\n    \n    const data: BankData = await response.json();\n    console.log(`[DEBUG] ✅ Storage load success: ${stageId} (${data.sentences?.length || 0} sentences)`);\n    \n    return data;\n  }\n\n  /**\n   * 💾 로컬 파일에서 데이터 로드 (fallback)\n   */\n  private async loadFromLocal(level: number, stageId: string): Promise<BankData | null> {\n    const paths = [\n      `/patterns/banks/level_${level}/${stageId}_bank.json`,\n      `/patterns/level_${level}_situational/${stageId}_bank.json`,\n      `/patterns/level_${level}_basic_patterns/${stageId}_bank.json`\n    ];\n\n    for (const path of paths) {\n      try {\n        console.log(`[DEBUG] 🔍 Trying local fallback: ${path}`);\n        const response = await fetch(path);\n        if (response.ok) {\n          const data: BankData = await response.json();\n          console.log(`[DEBUG] ✅ Local fallback success: ${path}`);\n          return data;\n        }\n      } catch (_error) {\n        // Continue to next path\n      }\n    }\n    \n    return null;\n  }\n\n  /**\n   * 🕒 캐시 유효성 확인\n   */\n  private isCacheValid(cacheKey: string): boolean {\n    if (!this.cache.has(cacheKey)) {\n      return false;\n    }\n    \n    const timestamp = this.cacheTimestamps.get(cacheKey);\n    if (!timestamp) {\n      return false;\n    }\n    \n    return (Date.now() - timestamp) < this.CACHE_TTL;\n  }\n\n  /**\n   * 🧹 캐시 클리어\n   */\n  clearCache(): void {\n    this.cache.clear();\n    this.cacheTimestamps.clear();\n    console.log('[PatternDataLoader] Cache cleared');\n  }\n\n  /**\n   * 📊 캐시 통계\n   */\n  getCacheStats() {\n    return {\n      size: this.cache.size,\n      ttl: this.CACHE_TTL,\n      entries: Array.from(this.cache.keys())\n    };\n  }\n}\n\n// 싱글톤 인스턴스\nconst patternDataLoader = new PatternDataLoader();\n\nexport { patternDataLoader, PatternDataLoader };\nexport type { BankData, Sentence, LoadResult };","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\personalizedPacks.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\progressManagement.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'currentDate' is defined but never used. Allowed unused args must match /^_/u.","line":179,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":179,"endColumn":75},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'progress' is defined but never used. Allowed unused args must match /^_/u.","line":383,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":383,"endColumn":49},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'incorrectAnswer' is defined but never used. Allowed unused args must match /^_/u.","line":387,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":387,"endColumn":63}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// 진도 관리 시스템 - 스테이지별 완료율과 오답 기록 관리\r\n\r\ninterface UserProgress {\r\n  userId: string;\r\n  level: number;\r\n  stage: number;\r\n  stageId: string;\r\n  completionRate: number; // 0-1\r\n  totalSentences: number;\r\n  correctAnswers: number;\r\n  incorrectAnswers: number;\r\n  lastStudied: Date;\r\n  timeSpent: number; // 총 학습 시간 (분)\r\n  averageAccuracy: number;\r\n  studySessions: number;\r\n  status: 'not_started' | 'in_progress' | 'completed' | 'mastered';\r\n}\r\n\r\ninterface IncorrectAnswer {\r\n  userId: string;\r\n  sentenceId: string;\r\n  level: number;\r\n  stage: number;\r\n  stageId: string;\r\n  incorrectCount: number;\r\n  lastIncorrectDate: Date;\r\n  mistakes: Array<{\r\n    userAnswer: string;\r\n    correctAnswer: string;\r\n    timestamp: Date;\r\n    mistakeType: 'grammar' | 'vocabulary' | 'spelling' | 'structure';\r\n  }>;\r\n  weight: number; // 오답 가중치 (최근 3일 기준)\r\n}\r\n\r\ninterface LevelProgress {\r\n  level: number;\r\n  totalStages: number;\r\n  completedStages: number;\r\n  averageCompletionRate: number;\r\n  totalTimeSpent: number;\r\n  overallAccuracy: number;\r\n  weakStages: string[]; // 완료율이 낮은 스테이지들\r\n  strongStages: string[]; // 완료율이 높은 스테이지들\r\n}\r\n\r\nclass ProgressManagementService {\r\n  \r\n  /**\r\n   * 사용자의 스테이지 진도 업데이트\r\n   */\r\n  async updateStageProgress(\r\n    userId: string, \r\n    stageId: string, \r\n    sessionResult: {\r\n      correct: number;\r\n      total: number;\r\n      timeSpent: number;\r\n      incorrectSentences: string[];\r\n    }\r\n  ): Promise<UserProgress> {\r\n    \r\n    try {\r\n      // 기존 진도 조회\r\n      const existingProgress = await this.getStageProgress(userId, stageId);\r\n      \r\n      // 새로운 완료율 계산 (누적)\r\n      const newCorrect = existingProgress.correctAnswers + sessionResult.correct;\r\n      const newTotal = existingProgress.totalSentences + sessionResult.total;\r\n      const newCompletionRate = newTotal > 0 ? newCorrect / newTotal : 0;\r\n      \r\n      // 평균 정확도 계산 (이동 평균)\r\n      const sessionAccuracy = sessionResult.total > 0 ? sessionResult.correct / sessionResult.total : 0;\r\n      const newAverageAccuracy = existingProgress.studySessions > 0 \r\n        ? (existingProgress.averageAccuracy * existingProgress.studySessions + sessionAccuracy) / (existingProgress.studySessions + 1)\r\n        : sessionAccuracy;\r\n      \r\n      // 상태 결정\r\n      const status = this.determineStageStatus(newCompletionRate, newAverageAccuracy, existingProgress.studySessions + 1);\r\n      \r\n      const updatedProgress: UserProgress = {\r\n        ...existingProgress,\r\n        completionRate: newCompletionRate,\r\n        totalSentences: newTotal,\r\n        correctAnswers: newCorrect,\r\n        incorrectAnswers: existingProgress.incorrectAnswers + (sessionResult.total - sessionResult.correct),\r\n        lastStudied: new Date(),\r\n        timeSpent: existingProgress.timeSpent + sessionResult.timeSpent,\r\n        averageAccuracy: newAverageAccuracy,\r\n        studySessions: existingProgress.studySessions + 1,\r\n        status\r\n      };\r\n      \r\n      // 오답 기록 업데이트\r\n      if (sessionResult.incorrectSentences.length > 0) {\r\n        await this.updateIncorrectAnswers(userId, stageId, sessionResult.incorrectSentences);\r\n      }\r\n      \r\n      // Firestore에 저장 (실제 구현에서)\r\n      await this.saveProgressToFirestore(updatedProgress);\r\n      \r\n      return updatedProgress;\r\n      \r\n    } catch (error) {\r\n      console.error('스테이지 진도 업데이트 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 스테이지 상태 결정\r\n   */\r\n  private determineStageStatus(\r\n    completionRate: number, \r\n    averageAccuracy: number, \r\n    sessions: number\r\n  ): 'not_started' | 'in_progress' | 'completed' | 'mastered' {\r\n    \r\n    if (sessions === 0) return 'not_started';\r\n    \r\n    if (averageAccuracy >= 0.9 && completionRate >= 0.8 && sessions >= 3) {\r\n      return 'mastered';\r\n    } else if (averageAccuracy >= 0.7 && completionRate >= 0.6) {\r\n      return 'completed';\r\n    } else {\r\n      return 'in_progress';\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 오답 기록 업데이트\r\n   */\r\n  async updateIncorrectAnswers(\r\n    userId: string, \r\n    stageId: string, \r\n    incorrectSentenceIds: string[]\r\n  ): Promise<void> {\r\n    \r\n    try {\r\n      const now = new Date();\r\n      const threeDaysAgo = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);\r\n      \r\n      for (const sentenceId of incorrectSentenceIds) {\r\n        // 기존 오답 기록 조회\r\n        const existingRecord = await this.getIncorrectAnswer(userId, sentenceId);\r\n        \r\n        // 최근 3일 가중치 계산\r\n        const recentMistakes = existingRecord.mistakes.filter(m => m.timestamp >= threeDaysAgo);\r\n        const weight = this.calculateIncorrectWeight(recentMistakes.length, now);\r\n        \r\n        const updatedRecord: IncorrectAnswer = {\r\n          ...existingRecord,\r\n          incorrectCount: existingRecord.incorrectCount + 1,\r\n          lastIncorrectDate: now,\r\n          mistakes: [\r\n            ...existingRecord.mistakes,\r\n            {\r\n              userAnswer: '', // 실제로는 세션에서 받아온 사용자 답변\r\n              correctAnswer: '', // 실제로는 정답\r\n              timestamp: now,\r\n              mistakeType: 'grammar' // 실제로는 분석된 실수 유형\r\n            }\r\n          ].slice(-10), // 최근 10개만 유지\r\n          weight\r\n        };\r\n        \r\n        await this.saveIncorrectAnswerToFirestore(updatedRecord);\r\n      }\r\n      \r\n    } catch (error) {\r\n      console.error('오답 기록 업데이트 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 오답 가중치 계산 (최근 3일 기준)\r\n   */\r\n  private calculateIncorrectWeight(recentMistakeCount: number, currentDate: Date): number {\r\n    // 기본 가중치: 1.0\r\n    // 최근 3일 내 실수가 많을수록 가중치 증가\r\n    const baseWeight = 1.0;\r\n    const additionalWeight = recentMistakeCount * 0.5;\r\n    \r\n    // 시간에 따른 감소 (하루당 10% 감소)\r\n    const daysSinceLastMistake = 0; // 현재는 0 (방금 실수)\r\n    const timeDecay = Math.pow(0.9, daysSinceLastMistake);\r\n    \r\n    return Math.min(5.0, (baseWeight + additionalWeight) * timeDecay);\r\n  }\r\n  \r\n  /**\r\n   * 레벨별 전체 진도 조회\r\n   */\r\n  async getLevelProgress(userId: string, level: number): Promise<LevelProgress> {\r\n    try {\r\n      // 해당 레벨의 모든 스테이지 진도 조회\r\n      const stageProgresses = await this.getAllStageProgresses(userId, level);\r\n      \r\n      const totalStages = stageProgresses.length;\r\n      const completedStages = stageProgresses.filter(p => p.status === 'completed' || p.status === 'mastered').length;\r\n      \r\n      const averageCompletionRate = totalStages > 0 \r\n        ? stageProgresses.reduce((sum, p) => sum + p.completionRate, 0) / totalStages \r\n        : 0;\r\n      \r\n      const totalTimeSpent = stageProgresses.reduce((sum, p) => sum + p.timeSpent, 0);\r\n      \r\n      const overallAccuracy = totalStages > 0 \r\n        ? stageProgresses.reduce((sum, p) => sum + p.averageAccuracy, 0) / totalStages \r\n        : 0;\r\n      \r\n      // 취약/강점 스테이지 식별\r\n      const weakStages = stageProgresses\r\n        .filter(p => p.averageAccuracy < 0.7 || p.completionRate < 0.6)\r\n        .map(p => p.stageId)\r\n        .slice(0, 5);\r\n      \r\n      const strongStages = stageProgresses\r\n        .filter(p => p.averageAccuracy >= 0.9 && p.completionRate >= 0.8)\r\n        .map(p => p.stageId)\r\n        .slice(0, 5);\r\n      \r\n      return {\r\n        level,\r\n        totalStages,\r\n        completedStages,\r\n        averageCompletionRate,\r\n        totalTimeSpent,\r\n        overallAccuracy,\r\n        weakStages,\r\n        strongStages\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('레벨 진도 조회 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 오답 우선 문장 조회 (최근 3일 가중치 기준)\r\n   */\r\n  async getIncorrectPrioritySentences(userId: string, maxCount: number = 20): Promise<string[]> {\r\n    try {\r\n      const now = new Date();\r\n      const threeDaysAgo = new Date(now.getTime() - 3 * 24 * 60 * 60 * 1000);\r\n      \r\n      // 최근 3일 내 오답 기록 조회\r\n      const incorrectAnswers = await this.getRecentIncorrectAnswers(userId, threeDaysAgo);\r\n      \r\n      // 가중치 기준으로 정렬\r\n      const sortedIncorrectAnswers = incorrectAnswers\r\n        .filter(ia => ia.weight > 1.0) // 가중치가 있는 것만\r\n        .sort((a, b) => b.weight - a.weight) // 가중치 높은 순\r\n        .slice(0, maxCount);\r\n      \r\n      return sortedIncorrectAnswers.map(ia => ia.sentenceId);\r\n      \r\n    } catch (error) {\r\n      console.error('오답 우선 문장 조회 실패:', error);\r\n      return [];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 전체 학습 진도 요약\r\n   */\r\n  async getOverallProgress(userId: string): Promise<{\r\n    totalLevels: number;\r\n    completedLevels: number;\r\n    currentLevel: number;\r\n    totalTimeSpent: number;\r\n    overallAccuracy: number;\r\n    totalSentencesStudied: number;\r\n    achievementBadges: string[];\r\n  }> {\r\n    \r\n    try {\r\n      const levels = [1, 2, 3, 4, 5, 6]; // 사용 가능한 레벨들\r\n      const levelProgresses = await Promise.all(\r\n        levels.map(level => this.getLevelProgress(userId, level))\r\n      );\r\n      \r\n      const completedLevels = levelProgresses.filter(lp => \r\n        lp.completedStages / lp.totalStages >= 0.8 && lp.overallAccuracy >= 0.7\r\n      ).length;\r\n      \r\n      const currentLevel = this.getCurrentLevel(levelProgresses);\r\n      \r\n      const totalTimeSpent = levelProgresses.reduce((sum, lp) => sum + lp.totalTimeSpent, 0);\r\n      const overallAccuracy = levelProgresses.reduce((sum, lp) => sum + lp.overallAccuracy, 0) / levels.length;\r\n      \r\n      const totalSentencesStudied = await this.getTotalSentencesStudied(userId);\r\n      \r\n      const achievementBadges = this.calculateAchievementBadges(levelProgresses, totalTimeSpent, totalSentencesStudied);\r\n      \r\n      return {\r\n        totalLevels: levels.length,\r\n        completedLevels,\r\n        currentLevel,\r\n        totalTimeSpent,\r\n        overallAccuracy,\r\n        totalSentencesStudied,\r\n        achievementBadges\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('전체 진도 요약 조회 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 성취 배지 계산\r\n   */\r\n  private calculateAchievementBadges(\r\n    levelProgresses: LevelProgress[], \r\n    totalTimeSpent: number, \r\n    totalSentences: number\r\n  ): string[] {\r\n    \r\n    const badges: string[] = [];\r\n    \r\n    // 시간 기반 배지\r\n    if (totalTimeSpent >= 1000) badges.push('🕐 천 시간 학습자');\r\n    else if (totalTimeSpent >= 500) badges.push('⏰ 오백 시간 달성');\r\n    else if (totalTimeSpent >= 100) badges.push('⏱️ 백 시간 학습');\r\n    \r\n    // 문장 수 기반 배지\r\n    if (totalSentences >= 5000) badges.push('📚 문장 마스터');\r\n    else if (totalSentences >= 2000) badges.push('📖 문장 박사');\r\n    else if (totalSentences >= 1000) badges.push('📝 천 문장 달성');\r\n    \r\n    // 정확도 기반 배지\r\n    const highAccuracyLevels = levelProgresses.filter(lp => lp.overallAccuracy >= 0.9).length;\r\n    if (highAccuracyLevels >= 3) badges.push('🎯 정확도 마스터');\r\n    else if (highAccuracyLevels >= 1) badges.push('✨ 정확도 달인');\r\n    \r\n    // 완료도 기반 배지\r\n    const completedLevels = levelProgresses.filter(lp => lp.averageCompletionRate >= 0.8).length;\r\n    if (completedLevels >= 4) badges.push('🏆 레벨 정복자');\r\n    else if (completedLevels >= 2) badges.push('🥇 성실한 학습자');\r\n    \r\n    return badges;\r\n  }\r\n  \r\n  // Private helper methods\r\n  private async getStageProgress(userId: string, stageId: string): Promise<UserProgress> {\r\n    // Firestore에서 스테이지 진도 조회 (기본값 반환)\r\n    return {\r\n      userId,\r\n      level: 1,\r\n      stage: 1,\r\n      stageId,\r\n      completionRate: 0,\r\n      totalSentences: 0,\r\n      correctAnswers: 0,\r\n      incorrectAnswers: 0,\r\n      lastStudied: new Date(),\r\n      timeSpent: 0,\r\n      averageAccuracy: 0,\r\n      studySessions: 0,\r\n      status: 'not_started'\r\n    };\r\n  }\r\n  \r\n  private async getIncorrectAnswer(userId: string, sentenceId: string): Promise<IncorrectAnswer> {\r\n    // 기본값 반환\r\n    return {\r\n      userId,\r\n      sentenceId,\r\n      level: 1,\r\n      stage: 1,\r\n      stageId: '',\r\n      incorrectCount: 0,\r\n      lastIncorrectDate: new Date(),\r\n      mistakes: [],\r\n      weight: 1.0\r\n    };\r\n  }\r\n  \r\n  private async saveProgressToFirestore(progress: UserProgress): Promise<void> {\r\n    // Firestore 저장 로직\r\n  }\r\n  \r\n  private async saveIncorrectAnswerToFirestore(incorrectAnswer: IncorrectAnswer): Promise<void> {\r\n    // Firestore 저장 로직\r\n  }\r\n  \r\n  private async getAllStageProgresses(_userId: string, _level: number): Promise<UserProgress[]> {\r\n    // 해당 레벨의 모든 스테이지 진도 조회\r\n    return [];\r\n  }\r\n  \r\n  private async getRecentIncorrectAnswers(_userId: string, _since: Date): Promise<IncorrectAnswer[]> {\r\n    // 최근 오답 기록 조회\r\n    return [];\r\n  }\r\n  \r\n  private getCurrentLevel(levelProgresses: LevelProgress[]): number {\r\n    // 현재 진행 중인 레벨 계산\r\n    for (let i = 0; i < levelProgresses.length; i++) {\r\n      const lp = levelProgresses[i];\r\n      if (lp.averageCompletionRate < 0.8 || lp.overallAccuracy < 0.7) {\r\n        return lp.level;\r\n      }\r\n    }\r\n    return levelProgresses.length; // 모든 레벨 완료\r\n  }\r\n  \r\n  private async getTotalSentencesStudied(_userId: string): Promise<number> {\r\n    // 총 학습한 문장 수 계산\r\n    return 0;\r\n  }\r\n}\r\n\r\nexport const progressManagementService = new ProgressManagementService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\reviewAlgorithm.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'activity' is defined but never used. Allowed unused args must match /^_/u.","line":295,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":295,"endColumn":72}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @deprecated 이 서비스는 deprecated입니다.\r\n * 새 프로젝트에서는 services/srs/SRSEngine.ts를 사용하세요.\r\n * \r\n * 마이그레이션 가이드:\r\n * - ReviewAlgorithmService → SRSEngine\r\n * - calculateNextReview() → SRSEngine.updateCard() \r\n * - getTodayReviewSentences() → SRSEngine.getCardsForReview()\r\n * \r\n * 2025-01-12: SSOT 시스템으로 통합 중\r\n */\r\n\r\n// 고급 복습 알고리즘 서비스  \r\n// 간격 반복 학습 (Spaced Repetition) + 망각 곡선 기반\r\n\r\ninterface ReviewSession {\r\n  sentenceId: string;\r\n  userId: string;\r\n  accuracy: number; // 0-1 점수\r\n  responseTime: number; // 응답 시간 (ms)\r\n  difficulty: 'easy' | 'medium' | 'hard';\r\n  timestamp: Date;\r\n  reviewCount: number;\r\n  intervalDays: number;\r\n}\r\n\r\ninterface ReviewMetrics {\r\n  totalReviews: number;\r\n  averageAccuracy: number;\r\n  averageResponseTime: number;\r\n  retentionRate: number;\r\n  masteryLevel: 'beginner' | 'intermediate' | 'advanced' | 'mastered';\r\n}\r\n\r\ninterface MemoryStrength {\r\n  sentenceId: string;\r\n  strength: number; // 0-1, 1이 완전히 기억\r\n  lastReviewDate: Date;\r\n  nextReviewDate: Date;\r\n  easeFactor: number; // SuperMemo 알고리즘의 ease factor\r\n  intervalDays: number;\r\n  reviewCount: number;\r\n}\r\n\r\nclass ReviewAlgorithmService {\r\n  \r\n  /**\r\n   * SuperMemo SM-2 알고리즘 기반 간격 반복 계산\r\n   */\r\n  calculateNextReview(session: ReviewSession, currentStrength: MemoryStrength): MemoryStrength {\r\n    const { accuracy, difficulty, responseTime } = session;\r\n    \r\n    // 정확도와 난이도에 따른 품질 점수 계산 (0-5)\r\n    const quality = this.calculateQuality(accuracy, difficulty, responseTime);\r\n    \r\n    let newEaseFactor = currentStrength.easeFactor;\r\n    let newInterval = currentStrength.intervalDays;\r\n    \r\n    if (quality >= 3) {\r\n      // 성공적인 복습\r\n      if (currentStrength.reviewCount === 0) {\r\n        newInterval = 1;\r\n      } else if (currentStrength.reviewCount === 1) {\r\n        newInterval = 6;\r\n      } else {\r\n        newInterval = Math.round(currentStrength.intervalDays * currentStrength.easeFactor);\r\n      }\r\n      \r\n      // ease factor 조정\r\n      newEaseFactor = Math.max(1.3, \r\n        currentStrength.easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))\r\n      );\r\n    } else {\r\n      // 실패한 복습 - 간격 리셋\r\n      newInterval = 1;\r\n      newEaseFactor = Math.max(1.3, currentStrength.easeFactor - 0.2);\r\n    }\r\n    \r\n    const nextReviewDate = new Date();\r\n    nextReviewDate.setDate(nextReviewDate.getDate() + newInterval);\r\n    \r\n    return {\r\n      ...currentStrength,\r\n      strength: this.updateMemoryStrength(currentStrength.strength, quality),\r\n      lastReviewDate: new Date(),\r\n      nextReviewDate,\r\n      easeFactor: newEaseFactor,\r\n      intervalDays: newInterval,\r\n      reviewCount: currentStrength.reviewCount + 1\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * 정확도, 난이도, 응답시간 기반 품질 점수 계산\r\n   */\r\n  private calculateQuality(accuracy: number, difficulty: string, responseTime: number): number {\r\n    // 기본 정확도 점수 (0-5)\r\n    let qualityScore = accuracy * 5;\r\n    \r\n    // 응답 시간 가중치 (빠른 응답은 더 높은 점수)\r\n    const timeWeight = this.getTimeWeight(responseTime);\r\n    qualityScore *= timeWeight;\r\n    \r\n    // 난이도 가중치\r\n    const difficultyWeight = {\r\n      'easy': 0.8,    // 쉬운 문제는 점수 감소\r\n      'medium': 1.0,  // 보통 문제는 그대로\r\n      'hard': 1.2     // 어려운 문제는 점수 증가\r\n    };\r\n    qualityScore *= difficultyWeight[difficulty];\r\n    \r\n    // 0-5 범위로 제한\r\n    return Math.max(0, Math.min(5, Math.round(qualityScore)));\r\n  }\r\n  \r\n  /**\r\n   * 응답 시간 기반 가중치 계산\r\n   */\r\n  private getTimeWeight(responseTime: number): number {\r\n    // 이상적인 응답 시간: 3-7초\r\n    const idealMin = 3000;\r\n    const idealMax = 7000;\r\n    \r\n    if (responseTime < idealMin) {\r\n      // 너무 빠름 - 추측일 가능성\r\n      return 0.8;\r\n    } else if (responseTime <= idealMax) {\r\n      // 이상적 범위\r\n      return 1.0;\r\n    } else if (responseTime <= 15000) {\r\n      // 조금 느림 - 점진적 감소\r\n      return 1.0 - (responseTime - idealMax) / 20000;\r\n    } else {\r\n      // 매우 느림\r\n      return 0.6;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 기억 강도 업데이트 (망각 곡선 적용)\r\n   */\r\n  private updateMemoryStrength(currentStrength: number, quality: number): number {\r\n    // 성공적인 복습 (quality >= 3)\r\n    if (quality >= 3) {\r\n      // 기억 강도 증가, 최대 1.0\r\n      const increase = (quality / 5) * 0.3;\r\n      return Math.min(1.0, currentStrength + increase);\r\n    } else {\r\n      // 실패한 복습 - 기억 강도 감소\r\n      const decrease = (3 - quality) / 5 * 0.4;\r\n      return Math.max(0.1, currentStrength - decrease);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 오늘 복습할 문장들 선정\r\n   */\r\n  async getTodayReviewSentences(userId: string, maxCount: number = 50): Promise<string[]> {\r\n    const today = new Date();\r\n    \r\n    // 1. 복습 일정이 된 문장들\r\n    const scheduledReviews = await this.getScheduledReviews(userId, today);\r\n    \r\n    // 2. 취약한 문장들 (강도가 낮은 순)\r\n    const weakSentences = await this.getWeakSentences(userId, maxCount - scheduledReviews.length);\r\n    \r\n    // 3. 새로운 문장들 (아직 한 번도 복습하지 않은 것)\r\n    const newSentences = await this.getNewSentences(userId, maxCount - scheduledReviews.length - weakSentences.length);\r\n    \r\n    // 우선순위: 예정된 복습 > 취약한 문장 > 새로운 문장\r\n    return [...scheduledReviews, ...weakSentences, ...newSentences].slice(0, maxCount);\r\n  }\r\n  \r\n  /**\r\n   * 개인별 복습 패턴 분석\r\n   */\r\n  async analyzeReviewPattern(userId: string): Promise<ReviewMetrics> {\r\n    const recentSessions = await this.getRecentSessions(userId, 30); // 최근 30일\r\n    \r\n    if (recentSessions.length === 0) {\r\n      return {\r\n        totalReviews: 0,\r\n        averageAccuracy: 0,\r\n        averageResponseTime: 0,\r\n        retentionRate: 0,\r\n        masteryLevel: 'beginner'\r\n      };\r\n    }\r\n    \r\n    const totalReviews = recentSessions.length;\r\n    const averageAccuracy = recentSessions.reduce((sum, s) => sum + s.accuracy, 0) / totalReviews;\r\n    const averageResponseTime = recentSessions.reduce((sum, s) => sum + s.responseTime, 0) / totalReviews;\r\n    \r\n    // 유지율 계산 (7일 후 재복습 시 성공률)\r\n    const retentionRate = await this.calculateRetentionRate(userId);\r\n    \r\n    // 숙련도 레벨 결정\r\n    const masteryLevel = this.determineMasteryLevel(averageAccuracy, retentionRate, totalReviews);\r\n    \r\n    return {\r\n      totalReviews,\r\n      averageAccuracy,\r\n      averageResponseTime,\r\n      retentionRate,\r\n      masteryLevel\r\n    };\r\n  }\r\n  \r\n  /**\r\n   * 적응형 난이도 조정\r\n   */\r\n  async adaptiveDifficultyAdjustment(userId: string): Promise<'easier' | 'maintain' | 'harder'> {\r\n    const metrics = await this.analyzeReviewPattern(userId);\r\n    \r\n    if (metrics.averageAccuracy > 0.9 && metrics.retentionRate > 0.8) {\r\n      return 'harder'; // 더 어려운 문장 제공\r\n    } else if (metrics.averageAccuracy < 0.6 || metrics.retentionRate < 0.5) {\r\n      return 'easier'; // 더 쉬운 문장 제공\r\n    } else {\r\n      return 'maintain'; // 현재 수준 유지\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 개인 맞춤 복습 스케줄 생성\r\n   */\r\n  async generatePersonalizedSchedule(userId: string): Promise<{\r\n    daily: number;\r\n    weekly: number;\r\n    monthlyGoal: number;\r\n    optimalTimes: string[];\r\n  }> {\r\n    const pattern = await this.analyzeReviewPattern(userId);\r\n    const userActivity = await this.getUserActivityPattern(userId);\r\n    \r\n    // 개인별 최적 복습 횟수 계산\r\n    const dailyTarget = this.calculateOptimalDailyReviews(pattern, userActivity);\r\n    \r\n    return {\r\n      daily: dailyTarget,\r\n      weekly: dailyTarget * 7,\r\n      monthlyGoal: dailyTarget * 30,\r\n      optimalTimes: userActivity.peakHours || ['09:00', '19:00'] // 기본값\r\n    };\r\n  }\r\n  \r\n  // Private helper methods\r\n  private async getScheduledReviews(_userId: string, _date: Date): Promise<string[]> {\r\n    // Firestore에서 오늘 복습 예정인 문장들 조회\r\n    // 실제 구현에서는 Firestore 쿼리 사용\r\n    return [];\r\n  }\r\n  \r\n  private async getWeakSentences(_userId: string, _count: number): Promise<string[]> {\r\n    // 기억 강도가 낮은 문장들 조회\r\n    return [];\r\n  }\r\n  \r\n  private async getNewSentences(_userId: string, _count: number): Promise<string[]> {\r\n    // 아직 복습하지 않은 새로운 문장들 조회\r\n    return [];\r\n  }\r\n  \r\n  private async getRecentSessions(_userId: string, _days: number): Promise<ReviewSession[]> {\r\n    // 최근 복습 세션들 조회\r\n    return [];\r\n  }\r\n  \r\n  private async calculateRetentionRate(_userId: string): Promise<number> {\r\n    // 7일 후 복습 성공률 계산\r\n    return 0.7; // 임시값\r\n  }\r\n  \r\n  private determineMasteryLevel(accuracy: number, retention: number, totalReviews: number): 'beginner' | 'intermediate' | 'advanced' | 'mastered' {\r\n    if (totalReviews < 50) return 'beginner';\r\n    if (accuracy > 0.9 && retention > 0.85) return 'mastered';\r\n    if (accuracy > 0.75 && retention > 0.7) return 'advanced';\r\n    if (accuracy > 0.6 && retention > 0.6) return 'intermediate';\r\n    return 'beginner';\r\n  }\r\n  \r\n  private async getUserActivityPattern(_userId: string): Promise<{\r\n    peakHours: string[];\r\n    preferredDuration: number;\r\n    consistency: number;\r\n  }> {\r\n    // 사용자 활동 패턴 분석\r\n    return {\r\n      peakHours: ['09:00', '19:00'],\r\n      preferredDuration: 20, // 분\r\n      consistency: 0.7\r\n    };\r\n  }\r\n  \r\n  private calculateOptimalDailyReviews(pattern: ReviewMetrics, activity: any): number {\r\n    // 개인별 최적 일일 복습 횟수 계산\r\n    const baseTarget = 30;\r\n    \r\n    if (pattern.masteryLevel === 'beginner') return Math.max(15, baseTarget * 0.5);\r\n    if (pattern.masteryLevel === 'intermediate') return baseTarget;\r\n    if (pattern.masteryLevel === 'advanced') return baseTarget * 1.5;\r\n    if (pattern.masteryLevel === 'mastered') return baseTarget * 0.7; // 유지 모드\r\n    \r\n    return baseTarget;\r\n  }\r\n}\r\n\r\n/**\r\n * @deprecated reviewAlgorithmService는 deprecated입니다.\r\n * 대신 services/srs/SRSEngine.ts를 사용하세요:\r\n * \r\n * import { SRSEngine } from '@/services/srs/SRSEngine';\r\n * const srsEngine = new SRSEngine();\r\n */\r\nexport const reviewAlgorithmService = new ReviewAlgorithmService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\scenarioDialogue.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userInput' is defined but never used. Allowed unused args must match /^_/u.","line":372,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":372,"endColumn":40}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// 시나리오 기반 대화 모드 서비스\r\nimport { api } from '../lib/api';\r\n\r\nexport interface DialogueTurn {\r\n  id: string;\r\n  turnNumber: number;\r\n  speaker: 'user' | 'ai';\r\n  text_kr: string;\r\n  text_en: string;\r\n  context?: string;\r\n  options?: string[];\r\n  expectedResponse?: string;\r\n  grammarFocus?: string[];\r\n  vocabularyFocus?: string[];\r\n}\r\n\r\nexport interface DialogueScenario {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  category: string;\r\n  difficulty: 'beginner' | 'intermediate' | 'advanced';\r\n  estimatedTime: number; // minutes\r\n  totalTurns: number;\r\n  context: string;\r\n  objective: string;\r\n  turns: DialogueTurn[];\r\n  completionCriteria: {\r\n    minTurns: number;\r\n    maxTurns: number;\r\n    requiredTopics: string[];\r\n  };\r\n}\r\n\r\nexport interface DialogueSession {\r\n  sessionId: string;\r\n  scenarioId: string;\r\n  userId: string;\r\n  startedAt: Date;\r\n  currentTurn: number;\r\n  userTurns: Array<{\r\n    turnNumber: number;\r\n    userInput: string;\r\n    aiResponse: string;\r\n    feedback?: string;\r\n    score?: number;\r\n    timestamp: Date;\r\n  }>;\r\n  isCompleted: boolean;\r\n  finalScore?: number;\r\n  summary?: string;\r\n}\r\n\r\nexport interface ScenarioCategory {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  icon: string;\r\n  scenarios: DialogueScenario[];\r\n}\r\n\r\nclass ScenarioDialogueService {\r\n  private readonly API_BASE = '/api/scenario';\r\n\r\n  // 시나리오 카테고리 목록 조회\r\n  async getScenarioCategories(): Promise<ScenarioCategory[]> {\r\n    try {\r\n      const response = await api.get(`${this.API_BASE}/categories`);\r\n      return response.data.categories;\r\n    } catch (error) {\r\n      console.error('Failed to get scenario categories:', error);\r\n      return this.getMockCategories();\r\n    }\r\n  }\r\n\r\n  // 특정 카테고리의 시나리오들 조회\r\n  async getScenariosByCategory(categoryId: string): Promise<DialogueScenario[]> {\r\n    try {\r\n      const response = await api.get(`${this.API_BASE}/category/${categoryId}`);\r\n      return response.data.scenarios;\r\n    } catch (error) {\r\n      console.error('Failed to get scenarios by category:', error);\r\n      return this.getMockScenarios(categoryId);\r\n    }\r\n  }\r\n\r\n  // 시나리오 상세 정보 조회\r\n  async getScenarioDetails(scenarioId: string): Promise<DialogueScenario> {\r\n    try {\r\n      const response = await api.get(`${this.API_BASE}/scenario/${scenarioId}`);\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Failed to get scenario details:', error);\r\n      return this.getMockScenarioDetails(scenarioId);\r\n    }\r\n  }\r\n\r\n  // 대화 세션 시작\r\n  async startDialogueSession(userId: string, scenarioId: string): Promise<DialogueSession> {\r\n    try {\r\n      const response = await api.post(`${this.API_BASE}/session/start`, {\r\n        userId,\r\n        scenarioId\r\n      });\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Failed to start dialogue session:', error);\r\n      return this.createMockSession(userId, scenarioId);\r\n    }\r\n  }\r\n\r\n  // 사용자 응답 처리 및 AI 응답 생성\r\n  async processUserTurn(sessionId: string, userInput: string): Promise<{\r\n    aiResponse: string;\r\n    feedback?: string;\r\n    score: number;\r\n    isCompleted: boolean;\r\n    nextTurn?: DialogueTurn;\r\n  }> {\r\n    try {\r\n      const response = await api.post(`${this.API_BASE}/session/${sessionId}/turn`, {\r\n        userInput\r\n      });\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Failed to process user turn:', error);\r\n      return this.getMockTurnResponse(userInput);\r\n    }\r\n  }\r\n\r\n  // 대화 세션 완료\r\n  async completeDialogueSession(sessionId: string): Promise<{\r\n    finalScore: number;\r\n    summary: string;\r\n    achievements: string[];\r\n    recommendations: string[];\r\n  }> {\r\n    try {\r\n      const response = await api.post(`${this.API_BASE}/session/${sessionId}/complete`);\r\n      return response.data;\r\n    } catch (error) {\r\n      console.error('Failed to complete dialogue session:', error);\r\n      return this.getMockSessionSummary();\r\n    }\r\n  }\r\n\r\n  // 사용자 대화 기록 조회\r\n  async getUserDialogueHistory(userId: string): Promise<DialogueSession[]> {\r\n    try {\r\n      const response = await api.get(`${this.API_BASE}/user/${userId}/history`);\r\n      return response.data.sessions;\r\n    } catch (error) {\r\n      console.error('Failed to get user dialogue history:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Mock Data Methods\r\n  private getMockCategories(): ScenarioCategory[] {\r\n    return [\r\n      {\r\n        id: 'daily-life',\r\n        name: '일상 대화',\r\n        description: '일상생활에서 자주 발생하는 대화 상황',\r\n        icon: '🏠',\r\n        scenarios: this.getMockScenarios('daily-life')\r\n      },\r\n      {\r\n        id: 'business',\r\n        name: '비즈니스',\r\n        description: '업무 환경에서의 전문적인 대화',\r\n        icon: '💼',\r\n        scenarios: this.getMockScenarios('business')\r\n      },\r\n      {\r\n        id: 'travel',\r\n        name: '여행',\r\n        description: '여행 중 마주치는 다양한 상황',\r\n        icon: '✈️',\r\n        scenarios: this.getMockScenarios('travel')\r\n      },\r\n      {\r\n        id: 'social',\r\n        name: '사교 모임',\r\n        description: '파티, 모임에서의 사교적 대화',\r\n        icon: '🎉',\r\n        scenarios: this.getMockScenarios('social')\r\n      },\r\n      {\r\n        id: 'academic',\r\n        name: '학술/교육',\r\n        description: '학교, 대학, 학회에서의 학술적 대화',\r\n        icon: '🎓',\r\n        scenarios: this.getMockScenarios('academic')\r\n      },\r\n      {\r\n        id: 'emergency',\r\n        name: '응급 상황',\r\n        description: '응급 상황에서의 빠르고 정확한 의사소통',\r\n        icon: '🚨',\r\n        scenarios: this.getMockScenarios('emergency')\r\n      }\r\n    ];\r\n  }\r\n\r\n  private getMockScenarios(categoryId: string): DialogueScenario[] {\r\n    const scenarios = {\r\n      'daily-life': [\r\n        {\r\n          id: 'dl-restaurant',\r\n          title: '레스토랑에서 주문하기',\r\n          description: '웨이터와의 대화를 통해 음식을 주문하는 상황',\r\n          category: 'daily-life',\r\n          difficulty: 'beginner' as const,\r\n          estimatedTime: 10,\r\n          totalTurns: 8,\r\n          context: '현지 레스토랑에서 저녁 식사를 위해 메뉴를 보고 주문하는 상황',\r\n          objective: '원하는 음식을 성공적으로 주문하고 필요한 정보를 확인하기',\r\n          turns: this.getMockRestaurantTurns(),\r\n          completionCriteria: {\r\n            minTurns: 6,\r\n            maxTurns: 10,\r\n            requiredTopics: ['greeting', 'menu-inquiry', 'ordering', 'payment']\r\n          }\r\n        },\r\n        {\r\n          id: 'dl-shopping',\r\n          title: '쇼핑몰에서 옷 구매하기',\r\n          description: '매장 직원과 대화하며 원하는 옷을 찾고 구매하는 상황',\r\n          category: 'daily-life',\r\n          difficulty: 'intermediate' as const,\r\n          estimatedTime: 12,\r\n          totalTurns: 10,\r\n          context: '백화점에서 특별한 행사를 위한 옷을 찾는 상황',\r\n          objective: '사이즈, 색상, 가격 등을 확인하고 만족스러운 구매하기',\r\n          turns: [],\r\n          completionCriteria: {\r\n            minTurns: 8,\r\n            maxTurns: 12,\r\n            requiredTopics: ['size-inquiry', 'color-preference', 'price-check', 'trying-on']\r\n          }\r\n        }\r\n      ],\r\n      'business': [\r\n        {\r\n          id: 'biz-meeting',\r\n          title: '팀 미팅 진행하기',\r\n          description: '프로젝트 진행 상황을 논의하는 팀 미팅',\r\n          category: 'business',\r\n          difficulty: 'advanced' as const,\r\n          estimatedTime: 15,\r\n          totalTurns: 12,\r\n          context: '새로운 프로젝트의 중간 점검을 위한 팀 미팅',\r\n          objective: '프로젝트 현황 공유, 문제점 논의, 다음 단계 계획 수립',\r\n          turns: [],\r\n          completionCriteria: {\r\n            minTurns: 10,\r\n            maxTurns: 15,\r\n            requiredTopics: ['status-report', 'problem-discussion', 'solution-proposal', 'next-steps']\r\n          }\r\n        }\r\n      ],\r\n      'travel': [\r\n        {\r\n          id: 'tr-airport',\r\n          title: '공항에서 체크인하기',\r\n          description: '국제선 항공편 체크인 및 수하물 처리',\r\n          category: 'travel',\r\n          difficulty: 'intermediate' as const,\r\n          estimatedTime: 10,\r\n          totalTurns: 8,\r\n          context: '해외여행을 위해 공항 체크인 카운터에서 수속을 밟는 상황',\r\n          objective: '체크인 완료, 좌석 선택, 수하물 처리, 탑승권 수령',\r\n          turns: [],\r\n          completionCriteria: {\r\n            minTurns: 6,\r\n            maxTurns: 10,\r\n            requiredTopics: ['check-in', 'seat-selection', 'baggage', 'boarding-pass']\r\n          }\r\n        }\r\n      ]\r\n    };\r\n\r\n    return scenarios[categoryId as keyof typeof scenarios] || [];\r\n  }\r\n\r\n  private getMockRestaurantTurns(): DialogueTurn[] {\r\n    return [\r\n      {\r\n        id: 'turn-1',\r\n        turnNumber: 1,\r\n        speaker: 'ai',\r\n        text_kr: '안녕하세요! 환영합니다. 메뉴 보실까요?',\r\n        text_en: 'Hello! Welcome. Would you like to see the menu?',\r\n        context: '웨이터가 친근하게 인사하며 메뉴를 권한다',\r\n        options: [\r\n          'Yes, please.',\r\n          'What do you recommend?',\r\n          'I need a few more minutes.'\r\n        ]\r\n      },\r\n      {\r\n        id: 'turn-2',\r\n        turnNumber: 2,\r\n        speaker: 'user',\r\n        text_kr: '네, 메뉴를 보여주세요.',\r\n        text_en: 'Yes, please show me the menu.',\r\n        expectedResponse: 'Yes, please',\r\n        grammarFocus: ['polite-requests'],\r\n        vocabularyFocus: ['restaurant-vocabulary']\r\n      },\r\n      {\r\n        id: 'turn-3',\r\n        turnNumber: 3,\r\n        speaker: 'ai',\r\n        text_kr: '오늘의 특선 요리는 연어 스테이크입니다. 추천해드려요!',\r\n        text_en: 'Today\\'s special is salmon steak. I highly recommend it!',\r\n        context: '웨이터가 오늘의 특선을 추천한다'\r\n      },\r\n      {\r\n        id: 'turn-4',\r\n        turnNumber: 4,\r\n        speaker: 'user',\r\n        text_kr: '연어 스테이크가 얼마나 매운가요?',\r\n        text_en: 'How spicy is the salmon steak?',\r\n        expectedResponse: 'How spicy is the salmon steak?',\r\n        grammarFocus: ['question-formation', 'degree-adverbs'],\r\n        vocabularyFocus: ['food-descriptions', 'taste-vocabulary']\r\n      }\r\n    ];\r\n  }\r\n\r\n  private getMockScenarioDetails(scenarioId: string): DialogueScenario {\r\n    const scenarios = this.getMockCategories();\r\n    for (const category of scenarios) {\r\n      const scenario = category.scenarios.find(s => s.id === scenarioId);\r\n      if (scenario) return scenario;\r\n    }\r\n    \r\n    // Fallback\r\n    return {\r\n      id: scenarioId,\r\n      title: 'Sample Scenario',\r\n      description: 'A sample dialogue scenario',\r\n      category: 'daily-life',\r\n      difficulty: 'intermediate',\r\n      estimatedTime: 10,\r\n      totalTurns: 8,\r\n      context: 'Sample context',\r\n      objective: 'Complete the conversation',\r\n      turns: [],\r\n      completionCriteria: {\r\n        minTurns: 5,\r\n        maxTurns: 10,\r\n        requiredTopics: ['greeting', 'conversation', 'closing']\r\n      }\r\n    };\r\n  }\r\n\r\n  private createMockSession(userId: string, scenarioId: string): DialogueSession {\r\n    return {\r\n      sessionId: `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n      scenarioId,\r\n      userId,\r\n      startedAt: new Date(),\r\n      currentTurn: 0,\r\n      userTurns: [],\r\n      isCompleted: false\r\n    };\r\n  }\r\n\r\n  private getMockTurnResponse(userInput: string): {\r\n    aiResponse: string;\r\n    feedback?: string;\r\n    score: number;\r\n    isCompleted: boolean;\r\n    nextTurn?: DialogueTurn;\r\n  } {\r\n    return {\r\n      aiResponse: 'Thank you for your response. Let me help you with the next part of our conversation.',\r\n      feedback: 'Great job! Your grammar and vocabulary usage were very natural.',\r\n      score: Math.floor(Math.random() * 30) + 70, // 70-100\r\n      isCompleted: false,\r\n      nextTurn: {\r\n        id: 'next-turn',\r\n        turnNumber: 2,\r\n        speaker: 'ai',\r\n        text_kr: '다음 단계로 넘어가겠습니다.',\r\n        text_en: 'Let\\'s move on to the next step.',\r\n        context: 'Continuing the conversation'\r\n      }\r\n    };\r\n  }\r\n\r\n  private getMockSessionSummary() {\r\n    return {\r\n      finalScore: 85,\r\n      summary: '훌륭한 대화 실력을 보여주셨습니다! 자연스러운 표현과 적절한 문법 사용이 인상적이었습니다.',\r\n      achievements: [\r\n        '완벽한 인사말 구사',\r\n        '자연스러운 질문 형성',\r\n        '적절한 어휘 선택',\r\n        '대화 흐름 유지'\r\n      ],\r\n      recommendations: [\r\n        '좀 더 다양한 접속사 사용하기',\r\n        '감정 표현 어휘 늘리기',\r\n        '복문 구조 연습하기'\r\n      ]\r\n    };\r\n  }\r\n}\r\n\r\nexport const scenarioDialogueService = new ScenarioDialogueService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\sentenceService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\speedDifficultyModes.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userLevel' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":169,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":169,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'settings' is defined but never used. Allowed unused args must match /^_/u.","line":216,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":216,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'level' is defined but never used. Allowed unused args must match /^_/u.","line":478,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":478,"endColumn":43}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// 속도/난이도 조절 모드 서비스\r\n\r\nexport type DifficultyMode = 'fast' | 'explanation' | 'mixed_levels';\r\n\r\nexport interface SpeedModeSettings {\r\n  timeLimit: number; // 초\r\n  showTimer: boolean;\r\n  earlyFinishBonus: boolean;\r\n  pressureLevel: 'low' | 'medium' | 'high';\r\n}\r\n\r\nexport interface ExplanationModeSettings {\r\n  showDetailedFeedback: boolean;\r\n  includeGrammarNotes: boolean;\r\n  includeExamples: boolean;\r\n  audioExplanation: boolean;\r\n  pauseAfterEachQuestion: boolean;\r\n}\r\n\r\nexport interface MixedLevelSettings {\r\n  includedLevels: number[];\r\n  randomOrder: boolean;\r\n  balanceByDifficulty: boolean;\r\n  adaptiveSelection: boolean; // 실력에 맞춰 문제 선택\r\n}\r\n\r\nexport interface SpeedSession {\r\n  sessionId: string;\r\n  userId: string;\r\n  mode: DifficultyMode;\r\n  settings: SpeedModeSettings | ExplanationModeSettings | MixedLevelSettings;\r\n  questions: SpeedQuestion[];\r\n  results: SpeedResult[];\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  totalScore: number;\r\n  averageResponseTime: number;\r\n}\r\n\r\nexport interface SpeedQuestion {\r\n  questionId: string;\r\n  content: string;\r\n  level: number;\r\n  stage: number;\r\n  timeLimit?: number;\r\n  difficulty: 'easy' | 'medium' | 'hard';\r\n  tags: string[];\r\n}\r\n\r\nexport interface SpeedResult {\r\n  questionId: string;\r\n  userAnswer: string;\r\n  correctAnswer: string;\r\n  isCorrect: boolean;\r\n  responseTime: number;\r\n  timeExceeded: boolean;\r\n  bonusPoints: number;\r\n  explanation?: string;\r\n}\r\n\r\nclass SpeedDifficultyService {\r\n  \r\n  /**\r\n   * 빠른 모드 세션 생성 (2-3초 제한)\r\n   */\r\n  async createFastSession(\r\n    userId: string,\r\n    settings: SpeedModeSettings,\r\n    questionCount: number = 20\r\n  ): Promise<SpeedSession> {\r\n    \r\n    try {\r\n      const questions = await this.generateFastModeQuestions(userId, questionCount, settings);\r\n      \r\n      const session: SpeedSession = {\r\n        sessionId: `fast-${Date.now()}-${userId}`,\r\n        userId,\r\n        mode: 'fast',\r\n        settings,\r\n        questions,\r\n        results: [],\r\n        startTime: new Date(),\r\n        totalScore: 0,\r\n        averageResponseTime: 0\r\n      };\r\n      \r\n      return session;\r\n      \r\n    } catch (error) {\r\n      console.error('빠른 모드 세션 생성 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 해설 모드 세션 생성\r\n   */\r\n  async createExplanationSession(\r\n    userId: string,\r\n    settings: ExplanationModeSettings,\r\n    questionCount: number = 15\r\n  ): Promise<SpeedSession> {\r\n    \r\n    try {\r\n      const questions = await this.generateExplanationModeQuestions(userId, questionCount, settings);\r\n      \r\n      const session: SpeedSession = {\r\n        sessionId: `explanation-${Date.now()}-${userId}`,\r\n        userId,\r\n        mode: 'explanation',\r\n        settings,\r\n        questions,\r\n        results: [],\r\n        startTime: new Date(),\r\n        totalScore: 0,\r\n        averageResponseTime: 0\r\n      };\r\n      \r\n      return session;\r\n      \r\n    } catch (error) {\r\n      console.error('해설 모드 세션 생성 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 레벨 혼합 모드 세션 생성\r\n   */\r\n  async createMixedLevelSession(\r\n    userId: string,\r\n    settings: MixedLevelSettings,\r\n    questionCount: number = 25\r\n  ): Promise<SpeedSession> {\r\n    \r\n    try {\r\n      const questions = await this.generateMixedLevelQuestions(userId, questionCount, settings);\r\n      \r\n      const session: SpeedSession = {\r\n        sessionId: `mixed-${Date.now()}-${userId}`,\r\n        userId,\r\n        mode: 'mixed_levels',\r\n        settings,\r\n        questions,\r\n        results: [],\r\n        startTime: new Date(),\r\n        totalScore: 0,\r\n        averageResponseTime: 0\r\n      };\r\n      \r\n      return session;\r\n      \r\n    } catch (error) {\r\n      console.error('레벨 혼합 모드 세션 생성 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 빠른 모드 문제 생성\r\n   */\r\n  private async generateFastModeQuestions(\r\n    userId: string,\r\n    count: number,\r\n    settings: SpeedModeSettings\r\n  ): Promise<SpeedQuestion[]> {\r\n    \r\n    // 사용자 현재 레벨 기준으로 적절한 난이도 문제 선택\r\n    const userLevel = await this.getUserLevel(userId);\r\n    \r\n    const mockQuestions: SpeedQuestion[] = [\r\n      {\r\n        questionId: 'fast-L3-001',\r\n        content: 'If I _____ time, I would go to the movies.',\r\n        level: 3,\r\n        stage: 1,\r\n        timeLimit: settings.timeLimit,\r\n        difficulty: 'medium',\r\n        tags: ['conditional', 'grammar']\r\n      },\r\n      {\r\n        questionId: 'fast-L3-002',\r\n        content: 'She _____ working when I called her.',\r\n        level: 3,\r\n        stage: 2,\r\n        timeLimit: settings.timeLimit,\r\n        difficulty: 'easy',\r\n        tags: ['past-continuous', 'grammar']\r\n      },\r\n      {\r\n        questionId: 'fast-L4-001',\r\n        content: 'We need to _____ our marketing strategy.',\r\n        level: 4,\r\n        stage: 1,\r\n        timeLimit: settings.timeLimit,\r\n        difficulty: 'hard',\r\n        tags: ['business', 'vocabulary']\r\n      }\r\n    ];\r\n    \r\n    // 압박 수준에 따라 시간 제한 조정\r\n    const adjustedQuestions = mockQuestions.map(q => ({\r\n      ...q,\r\n      timeLimit: this.adjustTimeLimitByPressure(settings.timeLimit, settings.pressureLevel)\r\n    }));\r\n    \r\n    return adjustedQuestions.slice(0, count);\r\n  }\r\n  \r\n  /**\r\n   * 해설 모드 문제 생성\r\n   */\r\n  private async generateExplanationModeQuestions(\r\n    userId: string,\r\n    count: number,\r\n    settings: ExplanationModeSettings\r\n  ): Promise<SpeedQuestion[]> {\r\n    \r\n    const mockQuestions: SpeedQuestion[] = [\r\n      {\r\n        questionId: 'exp-L3-001',\r\n        content: 'If I had known, I _____ differently.',\r\n        level: 3,\r\n        stage: 9,\r\n        difficulty: 'hard',\r\n        tags: ['third-conditional', 'grammar', 'complex']\r\n      },\r\n      {\r\n        questionId: 'exp-L4-001',\r\n        content: 'The proposal _____ be reviewed by the committee.',\r\n        level: 4,\r\n        stage: 5,\r\n        difficulty: 'medium',\r\n        tags: ['passive-voice', 'business', 'formal']\r\n      }\r\n    ];\r\n    \r\n    return mockQuestions.slice(0, count);\r\n  }\r\n  \r\n  /**\r\n   * 레벨 혼합 모드 문제 생성\r\n   */\r\n  private async generateMixedLevelQuestions(\r\n    userId: string,\r\n    count: number,\r\n    settings: MixedLevelSettings\r\n  ): Promise<SpeedQuestion[]> {\r\n    \r\n    const allQuestions: SpeedQuestion[] = [];\r\n    \r\n    // 각 레벨에서 문제 선택\r\n    for (const level of settings.includedLevels) {\r\n      const levelQuestions = await this.getQuestionsForLevel(level);\r\n      allQuestions.push(...levelQuestions);\r\n    }\r\n    \r\n    // 랜덤 순서 또는 난이도 균형\r\n    let selectedQuestions = allQuestions;\r\n    \r\n    if (settings.randomOrder) {\r\n      selectedQuestions = this.shuffleArray(allQuestions);\r\n    } else if (settings.balanceByDifficulty) {\r\n      selectedQuestions = this.balanceByDifficulty(allQuestions);\r\n    }\r\n    \r\n    return selectedQuestions.slice(0, count);\r\n  }\r\n  \r\n  /**\r\n   * 답변 처리 및 점수 계산\r\n   */\r\n  async processAnswer(\r\n    sessionId: string,\r\n    questionId: string,\r\n    userAnswer: string,\r\n    responseTime: number\r\n  ): Promise<SpeedResult> {\r\n    \r\n    try {\r\n      const question = await this.getQuestionById(questionId);\r\n      const correctAnswer = await this.getCorrectAnswer(questionId);\r\n      \r\n      const isCorrect = this.validateAnswer(userAnswer, correctAnswer);\r\n      const timeExceeded = question.timeLimit ? responseTime > (question.timeLimit * 1000) : false;\r\n      \r\n      // 보너스 점수 계산 (빠른 정답)\r\n      let bonusPoints = 0;\r\n      if (isCorrect && question.timeLimit) {\r\n        const timeRatio = responseTime / (question.timeLimit * 1000);\r\n        if (timeRatio < 0.5) bonusPoints = 50; // 절반 시간 내 정답\r\n        else if (timeRatio < 0.7) bonusPoints = 30;\r\n        else if (timeRatio < 0.9) bonusPoints = 10;\r\n      }\r\n      \r\n      const result: SpeedResult = {\r\n        questionId,\r\n        userAnswer,\r\n        correctAnswer,\r\n        isCorrect,\r\n        responseTime,\r\n        timeExceeded,\r\n        bonusPoints\r\n      };\r\n      \r\n      // 해설 모드인 경우 설명 추가\r\n      const session = await this.getSession(sessionId);\r\n      if (session.mode === 'explanation') {\r\n        result.explanation = await this.generateExplanation(question, isCorrect);\r\n      }\r\n      \r\n      return result;\r\n      \r\n    } catch (error) {\r\n      console.error('답변 처리 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 상세 설명 생성\r\n   */\r\n  private async generateExplanation(question: SpeedQuestion, isCorrect: boolean): Promise<string> {\r\n    \r\n    const explanations: Record<string, string> = {\r\n      'exp-L3-001': `\r\n        🎯 **Third Conditional (3차 조건문)**\r\n        \r\n        **구조**: If + had + past participle, would have + past participle\r\n        **의미**: 과거의 가정적 상황과 그 결과\r\n        \r\n        ${isCorrect ? '✅ 정답입니다!' : '❌ 다시 생각해보세요.'}\r\n        \r\n        **정답**: would have acted\r\n        **이유**: 과거에 일어나지 않은 가정과 그 결과를 표현할 때 사용합니다.\r\n        \r\n        **비슷한 예문**:\r\n        - If I had studied harder, I would have passed the exam.\r\n        - If she had left earlier, she wouldn't have been late.\r\n      `,\r\n      'exp-L4-001': `\r\n        🎯 **Passive Voice in Business Context**\r\n        \r\n        **구조**: will + be + past participle\r\n        **의미**: 미래의 수동태 표현\r\n        \r\n        ${isCorrect ? '✅ 정답입니다!' : '❌ 다시 생각해보세요.'}\r\n        \r\n        **정답**: will\r\n        **이유**: 공식적인 비즈니스 문서에서 미래 계획을 수동태로 표현할 때 사용합니다.\r\n        \r\n        **비슷한 예문**:\r\n        - The contract will be signed next week.\r\n        - New policies will be implemented in January.\r\n      `\r\n    };\r\n    \r\n    return explanations[question.questionId] || '해설 정보를 불러올 수 없습니다.';\r\n  }\r\n  \r\n  /**\r\n   * 세션 완료 및 통계 계산\r\n   */\r\n  async completeSession(sessionId: string): Promise<{\r\n    totalScore: number;\r\n    accuracy: number;\r\n    averageResponseTime: number;\r\n    bonusPoints: number;\r\n    improvementAreas: string[];\r\n    nextRecommendation: string;\r\n  }> {\r\n    \r\n    try {\r\n      const session = await this.getSession(sessionId);\r\n      session.endTime = new Date();\r\n      \r\n      const results = session.results;\r\n      const correctAnswers = results.filter(r => r.isCorrect).length;\r\n      const totalQuestions = results.length;\r\n      \r\n      const accuracy = (correctAnswers / totalQuestions) * 100;\r\n      const averageResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / totalQuestions;\r\n      const bonusPoints = results.reduce((sum, r) => sum + r.bonusPoints, 0);\r\n      const totalScore = (correctAnswers * 100) + bonusPoints;\r\n      \r\n      // 개선 영역 분석\r\n      const incorrectTags = results\r\n        .filter(r => !r.isCorrect)\r\n        .map(r => this.getQuestionTags(r.questionId))\r\n        .flat()\r\n        .reduce((acc, tag) => {\r\n          acc[tag] = (acc[tag] || 0) + 1;\r\n          return acc;\r\n        }, {} as Record<string, number>);\r\n      \r\n      const improvementAreas = Object.entries(incorrectTags)\r\n        .sort(([,a], [,b]) => b - a)\r\n        .slice(0, 3)\r\n        .map(([tag]) => tag);\r\n      \r\n      // 다음 추천 모드\r\n      let nextRecommendation = '';\r\n      if (session.mode === 'fast') {\r\n        if (accuracy >= 80) {\r\n          nextRecommendation = '높은 정확도를 보이고 있습니다! 해설 모드로 더 깊이 학습해보세요.';\r\n        } else {\r\n          nextRecommendation = '기본 학습을 더 진행한 후 다시 도전해보세요.';\r\n        }\r\n      } else if (session.mode === 'explanation') {\r\n        nextRecommendation = '충분히 학습하셨습니다. 빠른 모드로 반응속도를 테스트해보세요.';\r\n      } else {\r\n        nextRecommendation = '다양한 레벨의 문제를 잘 풀고 있습니다. 계속 도전하세요!';\r\n      }\r\n      \r\n      return {\r\n        totalScore,\r\n        accuracy,\r\n        averageResponseTime,\r\n        bonusPoints,\r\n        improvementAreas,\r\n        nextRecommendation\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('세션 완료 처리 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // Private helper methods\r\n  \r\n  private adjustTimeLimitByPressure(baseTime: number, pressure: 'low' | 'medium' | 'high'): number {\r\n    switch (pressure) {\r\n      case 'low': return baseTime * 1.5;\r\n      case 'medium': return baseTime;\r\n      case 'high': return baseTime * 0.7;\r\n      default: return baseTime;\r\n    }\r\n  }\r\n  \r\n  private shuffleArray<T>(array: T[]): T[] {\r\n    const shuffled = [...array];\r\n    for (let i = shuffled.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\r\n    }\r\n    return shuffled;\r\n  }\r\n  \r\n  private balanceByDifficulty(questions: SpeedQuestion[]): SpeedQuestion[] {\r\n    const easy = questions.filter(q => q.difficulty === 'easy');\r\n    const medium = questions.filter(q => q.difficulty === 'medium');\r\n    const hard = questions.filter(q => q.difficulty === 'hard');\r\n    \r\n    const balanced: SpeedQuestion[] = [];\r\n    const maxLength = Math.max(easy.length, medium.length, hard.length);\r\n    \r\n    for (let i = 0; i < maxLength; i++) {\r\n      if (easy[i]) balanced.push(easy[i]);\r\n      if (medium[i]) balanced.push(medium[i]);\r\n      if (hard[i]) balanced.push(hard[i]);\r\n    }\r\n    \r\n    return balanced;\r\n  }\r\n  \r\n  private validateAnswer(userAnswer: string, correctAnswer: string): boolean {\r\n    const normalize = (str: string) => str.toLowerCase().trim().replace(/[.,!?]/g, '');\r\n    return normalize(userAnswer) === normalize(correctAnswer);\r\n  }\r\n  \r\n  // Mock data methods (실제로는 DB에서 조회)\r\n  \r\n  private async getUserLevel(_userId: string): Promise<number> {\r\n    return 3; // Mock\r\n  }\r\n  \r\n  private async getQuestionsForLevel(level: number): Promise<SpeedQuestion[]> {\r\n    return []; // Mock\r\n  }\r\n  \r\n  private async getQuestionById(questionId: string): Promise<SpeedQuestion> {\r\n    return {\r\n      questionId,\r\n      content: '',\r\n      level: 1,\r\n      stage: 1,\r\n      difficulty: 'medium',\r\n      tags: []\r\n    }; // Mock\r\n  }\r\n  \r\n  private async getCorrectAnswer(questionId: string): Promise<string> {\r\n    const answers: Record<string, string> = {\r\n      'fast-L3-001': 'had',\r\n      'fast-L3-002': 'was',\r\n      'fast-L4-001': 'leverage',\r\n      'exp-L3-001': 'would have acted',\r\n      'exp-L4-001': 'will'\r\n    };\r\n    return answers[questionId] || 'answer';\r\n  }\r\n  \r\n  private async getSession(sessionId: string): Promise<SpeedSession> {\r\n    // Mock session 반환\r\n    return {\r\n      sessionId,\r\n      userId: 'user-1',\r\n      mode: 'fast',\r\n      settings: { timeLimit: 3, showTimer: true, earlyFinishBonus: true, pressureLevel: 'medium' },\r\n      questions: [],\r\n      results: [],\r\n      startTime: new Date(),\r\n      totalScore: 0,\r\n      averageResponseTime: 0\r\n    };\r\n  }\r\n  \r\n  private getQuestionTags(questionId: string): string[] {\r\n    const tags: Record<string, string[]> = {\r\n      'fast-L3-001': ['conditional', 'grammar'],\r\n      'fast-L3-002': ['past-continuous', 'grammar'],\r\n      'fast-L4-001': ['business', 'vocabulary']\r\n    };\r\n    return tags[questionId] || [];\r\n  }\r\n}\r\n\r\nexport const speedDifficultyService = new SpeedDifficultyService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\SRSEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\adapters\\storage\\LocalStorageAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\adapters\\storage\\MemoryStorageAdapter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\algorithms\\ForgettingCurve.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\algorithms\\MockSM2Algorithm.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'timeSinceLastReview' is defined but never used. Allowed unused args must match /^_/u.","line":65,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":24}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Mock SuperMemo SM-2 알고리즘 (테스트용)\r\n * ISRSAlgorithm 인터페이스 구현체\r\n * \r\n * 결정적이고 예측 가능한 결과를 제공\r\n */\r\n\r\nimport { ISRSAlgorithm } from '../interfaces/ISRSEngine';\r\n\r\nexport class MockSM2Algorithm implements ISRSAlgorithm {\r\n  readonly name = 'Mock SuperMemo SM-2';\r\n  readonly version = 'test-1.0';\r\n\r\n  private readonly config = {\r\n    minEaseFactor: 1.3,\r\n    maxEaseFactor: 2.5,\r\n    initialEaseFactor: 1.8,\r\n    easeFactorStep: 0.1,\r\n    failureThreshold: 3,\r\n    maxInterval: 10 // 테스트용으로 축소\r\n  };\r\n\r\n  calculateNextInterval(\r\n    currentInterval: number,\r\n    easeFactor: number,\r\n    quality: number,\r\n    reviewCount: number\r\n  ): number {\r\n    // 간단하고 예측 가능한 로직\r\n    if (quality < this.config.failureThreshold) {\r\n      return 1; // 실패시 1일\r\n    }\r\n\r\n    if (reviewCount === 0) {\r\n      return 1;\r\n    }\r\n\r\n    if (reviewCount === 1) {\r\n      return 3;\r\n    }\r\n\r\n    // 성공시 간단한 곱셈\r\n    const nextInterval = Math.round(currentInterval * Math.max(1.2, easeFactor));\r\n    return Math.min(nextInterval, this.config.maxInterval);\r\n  }\r\n\r\n  updateEaseFactor(currentEaseFactor: number, quality: number): number {\r\n    // 간단한 조정\r\n    let adjustment = 0;\r\n    \r\n    if (quality >= 4) {\r\n      adjustment = 0.1;\r\n    } else if (quality <= 2) {\r\n      adjustment = -0.1;\r\n    }\r\n    \r\n    const newEF = currentEaseFactor + adjustment;\r\n    return Math.max(this.config.minEaseFactor, \r\n           Math.min(this.config.maxEaseFactor, newEF));\r\n  }\r\n\r\n  updateMemoryStrength(\r\n    currentStrength: number,\r\n    quality: number,\r\n    timeSinceLastReview: number\r\n  ): number {\r\n    // 간단한 강화/약화 로직\r\n    const reviewBonus = quality / 5; // 0-1 범위\r\n    const timeDecayFactor = 0.9; // 단순 감소\r\n    \r\n    const decayedStrength = currentStrength * timeDecayFactor;\r\n    const reinforcement = reviewBonus * 0.3;\r\n    \r\n    const newStrength = Math.min(1.0, decayedStrength + reinforcement);\r\n    return Math.max(0.1, newStrength);\r\n  }\r\n\r\n  /**\r\n   * 테스트용 - 결정적 품질 점수 반환\r\n   */\r\n  getDeterministicQuality(isCorrect: boolean, responseTime: number): number {\r\n    if (!isCorrect) return 2;\r\n    \r\n    // 응답 시간에 따른 간단한 품질 점수\r\n    if (responseTime < 3000) return 5; // 빠른 응답\r\n    if (responseTime < 7000) return 4; // 적절한 응답\r\n    if (responseTime < 12000) return 3; // 느린 응답\r\n    return 2; // 너무 느림\r\n  }\r\n\r\n  /**\r\n   * 테스트용 - 예측 가능한 간격 계산\r\n   */\r\n  getPredictableInterval(reviewCount: number, isCorrect: boolean): number {\r\n    if (!isCorrect) return 1;\r\n    \r\n    const intervals = [1, 3, 6, 10]; // 예측 가능한 시퀀스\r\n    return intervals[Math.min(reviewCount, intervals.length - 1)];\r\n  }\r\n\r\n  /**\r\n   * 테스트용 - 설정 덮어쓰기\r\n   */\r\n  overrideConfigForTest(config: Partial<typeof this.config>): void {\r\n    Object.assign(this.config, config);\r\n  }\r\n\r\n  /**\r\n   * 테스트용 - 기본 설정으로 재설정\r\n   */\r\n  resetConfigForTest(): void {\r\n    this.config.minEaseFactor = 1.3;\r\n    this.config.maxEaseFactor = 2.5;\r\n    this.config.initialEaseFactor = 1.8;\r\n    this.config.maxInterval = 10;\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\algorithms\\SuperMemoSM2.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\algorithms\\SuperMemoSM2Strategy.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\config\\DefaultConfigProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\config\\MockConfigProvider.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\container\\SRSContainer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\engines\\ModularSRSEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cardId' is defined but never used. Allowed unused args must match /^_/u.","line":183,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":183,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * 모듈형 SRS 엔진 - 느슨한 결합 구현\r\n * 의존성 주입을 통해 모든 구성요소를 교체 가능\r\n * \r\n * 기존 SRSEngine.ts를 대체하는 새로운 아키텍처\r\n */\r\n\r\nimport { \r\n  ISRSEngine, \r\n  ISRSStorage, \r\n  ISRSAlgorithm, \r\n  ISRSConfigProvider,\r\n  ISRSEventBus,\r\n  ReviewCard, \r\n  ReviewSession, \r\n  SRSConfig, \r\n  SRSStats,\r\n  PerformanceAnalysis,\r\n  SRSEvent\r\n} from '../interfaces/ISRSEngine';\r\n\r\nexport class ModularSRSEngine implements ISRSEngine {\r\n  \r\n  constructor(\r\n    private storage: ISRSStorage,\r\n    private algorithm: ISRSAlgorithm,\r\n    private configProvider: ISRSConfigProvider,\r\n    private eventBus?: ISRSEventBus\r\n  ) {}\r\n\r\n  // ============= 설정 관리 =============\r\n  \r\n  getConfig(): SRSConfig {\r\n    return this.configProvider.getDefaultConfig();\r\n  }\r\n\r\n  updateConfig(config: Partial<SRSConfig>): void {\r\n    // 설정 업데이트 로직\r\n    console.log('Updating SRS config:', config);\r\n    \r\n    try {\r\n      // configProvider를 통해 변경사항 저장\r\n      this.configProvider.updateConfig(config);\r\n      \r\n      // 설정 변경 이벤트 발생\r\n      this.emitEvent({\r\n        type: 'config_updated',\r\n        timestamp: new Date(),\r\n        data: { updatedFields: Object.keys(config), config }\r\n      });\r\n      \r\n      console.log('✅ SRS config updated successfully');\r\n    } catch (error) {\r\n      console.error('❌ Failed to update SRS config:', error);\r\n      this.emitEvent({\r\n        type: 'config_update_failed', \r\n        timestamp: new Date(),\r\n        data: { error: error.message, attemptedConfig: config }\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // ============= 카드 생명주기 =============\r\n\r\n  createCard(content: ReviewCard['content']): ReviewCard {\r\n    const config = this.getConfig();\r\n    \r\n    const newCard: ReviewCard = {\r\n      id: this.generateCardId(),\r\n      content,\r\n      memory: {\r\n        strength: config.initialMemoryStrength,\r\n        easeFactor: config.initialEaseFactor,\r\n        interval: config.minInterval,\r\n        reviewCount: 0,\r\n        lastReviewed: new Date(),\r\n        nextReview: new Date(Date.now() + config.minInterval * 24 * 60 * 60 * 1000),\r\n        difficulty: 0.5\r\n      },\r\n      performance: {\r\n        accuracy: [],\r\n        responseTime: [],\r\n        streak: 0,\r\n        mistakes: 0\r\n      }\r\n    };\r\n\r\n    // 이벤트 발행\r\n    this.emitEvent({\r\n      type: 'card_created',\r\n      timestamp: new Date(),\r\n      data: { card: newCard }\r\n    });\r\n\r\n    return newCard;\r\n  }\r\n\r\n  updateCard(card: ReviewCard, session: ReviewSession): ReviewCard {\r\n    const config = this.getConfig();\r\n    const quality = this.calculateQuality(session);\r\n    \r\n    // 알고리즘을 통한 업데이트 (Strategy Pattern)\r\n    const newInterval = this.algorithm.calculateNextInterval(\r\n      card.memory.interval,\r\n      card.memory.easeFactor,\r\n      quality,\r\n      card.memory.reviewCount\r\n    );\r\n\r\n    const newEaseFactor = this.algorithm.updateEaseFactor(\r\n      card.memory.easeFactor,\r\n      quality\r\n    );\r\n\r\n    const timeSinceLastReview = session.timestamp.getTime() - card.memory.lastReviewed.getTime();\r\n    const newStrength = this.algorithm.updateMemoryStrength(\r\n      card.memory.strength,\r\n      quality,\r\n      timeSinceLastReview\r\n    );\r\n\r\n    // config를 활용한 추가 검증 및 조정\r\n    let adjustedInterval = newInterval;\r\n    if (config.minInterval && newInterval < config.minInterval) {\r\n      adjustedInterval = config.minInterval;\r\n      console.log(`Adjusted interval from ${newInterval} to ${adjustedInterval} (min constraint)`);\r\n    }\r\n    if (config.maxInterval && newInterval > config.maxInterval) {\r\n      adjustedInterval = config.maxInterval;\r\n      console.log(`Adjusted interval from ${newInterval} to ${adjustedInterval} (max constraint)`);\r\n    }\r\n\r\n    // timeSinceLastReview를 활용한 지연 패널티 적용\r\n    const expectedReviewTime = card.memory.interval * 24 * 60 * 60 * 1000; // 밀리초 변환\r\n    const reviewDelayRatio = timeSinceLastReview / expectedReviewTime;\r\n    \r\n    if (reviewDelayRatio > 1.5) { // 예정보다 50% 이상 늦게 복습\r\n      const delayPenalty = Math.min(reviewDelayRatio - 1, 0.3); // 최대 30% 패널티\r\n      adjustedInterval = Math.round(adjustedInterval * (1 - delayPenalty));\r\n      console.log(`Applied delay penalty: ${(delayPenalty * 100).toFixed(1)}%, interval adjusted to ${adjustedInterval}`);\r\n    }\r\n\r\n    // 성능 히스토리 업데이트\r\n    const updatedCard: ReviewCard = {\r\n      ...card,\r\n      memory: {\r\n        ...card.memory,\r\n        strength: newStrength,\r\n        easeFactor: newEaseFactor,\r\n        interval: adjustedInterval, // config와 지연 패널티가 적용된 간격 사용\r\n        reviewCount: card.memory.reviewCount + 1,\r\n        lastReviewed: session.timestamp,\r\n        nextReview: new Date(session.timestamp.getTime() + adjustedInterval * 24 * 60 * 60 * 1000)\r\n      },\r\n      performance: {\r\n        accuracy: [...card.performance.accuracy.slice(-9), session.isCorrect ? 1 : 0],\r\n        responseTime: [...card.performance.responseTime.slice(-9), session.responseTime],\r\n        streak: session.isCorrect ? card.performance.streak + 1 : 0,\r\n        mistakes: session.isCorrect ? card.performance.mistakes : card.performance.mistakes + 1\r\n      }\r\n    };\r\n\r\n    // 마스터리 체크\r\n    if (this.isMastered(updatedCard)) {\r\n      this.emitEvent({\r\n        type: 'card_mastered',\r\n        timestamp: new Date(),\r\n        data: { card: updatedCard }\r\n      });\r\n    }\r\n\r\n    // 복습 이벤트 발행\r\n    this.emitEvent({\r\n      type: 'card_reviewed',\r\n      timestamp: new Date(),\r\n      data: { card: updatedCard, session }\r\n    });\r\n\r\n    return updatedCard;\r\n  }\r\n\r\n  deleteCard(cardId: string): boolean {\r\n    // 구현체에 따라 다르게 처리\r\n    // 여기서는 논리적 삭제만 수행\r\n    return true;\r\n  }\r\n\r\n  // ============= 복습 스케줄링 =============\r\n\r\n  getCardsForReview(cards: ReviewCard[]): ReviewCard[] {\r\n    const now = new Date();\r\n    \r\n    return cards\r\n      .filter(card => card.memory.nextReview <= now)\r\n      .sort((a, b) => {\r\n        // 우선순위 정렬: 오래된 것부터, 어려운 것부터\r\n        const aOverdue = now.getTime() - a.memory.nextReview.getTime();\r\n        const bOverdue = now.getTime() - b.memory.nextReview.getTime();\r\n        \r\n        if (aOverdue !== bOverdue) {\r\n          return bOverdue - aOverdue; // 더 오래된 것부터\r\n        }\r\n        \r\n        return a.memory.easeFactor - b.memory.easeFactor; // 어려운 것부터\r\n      });\r\n  }\r\n\r\n  calculateNextReview(card: ReviewCard, session: ReviewSession): Date {\r\n    const quality = this.calculateQuality(session);\r\n    const nextInterval = this.algorithm.calculateNextInterval(\r\n      card.memory.interval,\r\n      card.memory.easeFactor,\r\n      quality,\r\n      card.memory.reviewCount\r\n    );\r\n    \r\n    return new Date(session.timestamp.getTime() + nextInterval * 24 * 60 * 60 * 1000);\r\n  }\r\n\r\n  // ============= 통계 및 분석 =============\r\n\r\n  calculateStats(cards: ReviewCard[]): SRSStats {\r\n    const now = new Date();\r\n    const dueCards = cards.filter(card => card.memory.nextReview <= now);\r\n    const masteredCards = cards.filter(card => this.isMastered(card));\r\n    const learningCards = cards.filter(card => card.memory.reviewCount === 0);\r\n\r\n    const totalAccuracy = cards.reduce((sum, card) => {\r\n      const recentAccuracy = card.performance.accuracy.slice(-5);\r\n      return sum + (recentAccuracy.length > 0 \r\n        ? recentAccuracy.reduce((a, b) => a + b, 0) / recentAccuracy.length \r\n        : 0);\r\n    }, 0);\r\n\r\n    const totalResponseTime = cards.reduce((sum, card) => {\r\n      const recentResponseTime = card.performance.responseTime.slice(-5);\r\n      return sum + (recentResponseTime.length > 0\r\n        ? recentResponseTime.reduce((a, b) => a + b, 0) / recentResponseTime.length\r\n        : 0);\r\n    }, 0);\r\n\r\n    return {\r\n      totalCards: cards.length,\r\n      dueForReview: dueCards.length,\r\n      averageMemoryStrength: cards.reduce((sum, card) => sum + card.memory.strength, 0) / cards.length || 0,\r\n      masteredCards: masteredCards.length,\r\n      learningCards: learningCards.length,\r\n      avgAccuracy: totalAccuracy / cards.length || 0,\r\n      avgResponseTime: totalResponseTime / cards.length || 0\r\n    };\r\n  }\r\n\r\n  analyzePerformance(cards: ReviewCard[]): PerformanceAnalysis {\r\n    // 패턴별 성과 분석\r\n    const patternStats = new Map<string, {correct: number, total: number}>();\r\n    \r\n    cards.forEach(card => {\r\n      const pattern = card.content.pattern || 'unknown';\r\n      const stats = patternStats.get(pattern) || {correct: 0, total: 0};\r\n      const recentAccuracy = card.performance.accuracy.slice(-5);\r\n      \r\n      stats.total += recentAccuracy.length;\r\n      stats.correct += recentAccuracy.reduce((sum, acc) => sum + acc, 0);\r\n      patternStats.set(pattern, stats);\r\n    });\r\n\r\n    const weakPatterns = Array.from(patternStats.entries())\r\n      .filter(([_, stats]) => stats.total >= 3 && (stats.correct / stats.total) < 0.6)\r\n      .map(([pattern]) => pattern);\r\n\r\n    const strongPatterns = Array.from(patternStats.entries())\r\n      .filter(([_, stats]) => stats.total >= 3 && (stats.correct / stats.total) > 0.8)\r\n      .map(([pattern]) => pattern);\r\n\r\n    // 추천 포커스 결정\r\n    const avgAccuracy = cards.reduce((sum, card) => \r\n      sum + (card.performance.accuracy.slice(-5).reduce((a, b) => a + b, 0) / \r\n             Math.max(1, card.performance.accuracy.length)), 0) / cards.length;\r\n    \r\n    const avgResponseTime = cards.reduce((sum, card) => \r\n      sum + (card.performance.responseTime.slice(-5).reduce((a, b) => a + b, 0) / \r\n             Math.max(1, card.performance.responseTime.length)), 0) / cards.length;\r\n\r\n    let recommendedFocus: 'accuracy' | 'speed' | 'retention' = 'accuracy';\r\n    if (avgAccuracy > 0.8 && avgResponseTime > 10000) {\r\n      recommendedFocus = 'speed';\r\n    } else if (avgAccuracy > 0.8 && avgResponseTime < 5000) {\r\n      recommendedFocus = 'retention';\r\n    }\r\n\r\n    return {\r\n      weakPatterns,\r\n      strongPatterns,\r\n      recommendedFocus,\r\n      estimatedMasteryTime: this.estimateMasteryTime(cards)\r\n    };\r\n  }\r\n\r\n  // ============= private 메서드들 =============\r\n\r\n  private generateCardId(): string {\r\n    return `card_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\r\n  }\r\n\r\n  private calculateQuality(session: ReviewSession): number {\r\n    // 기본적으로 정확도 기반, 확장 가능\r\n    return session.isCorrect ? 4 : 2;\r\n  }\r\n\r\n  private isMastered(card: ReviewCard): boolean {\r\n    return card.memory.strength > 0.9 && \r\n           card.memory.reviewCount >= 5 &&\r\n           card.performance.streak >= 3;\r\n  }\r\n\r\n  private estimateMasteryTime(cards: ReviewCard[]): number {\r\n    // 간단한 추정 로직 (일 단위)\r\n    const notMastered = cards.filter(card => !this.isMastered(card));\r\n    const avgReviewsNeeded = 8; // 평균적으로 8번 복습 필요\r\n    const avgDaysPerReview = 3; // 평균 3일마다 복습\r\n    \r\n    return notMastered.length * avgReviewsNeeded * avgDaysPerReview;\r\n  }\r\n\r\n  private emitEvent(event: SRSEvent): void {\r\n    this.eventBus?.emit(event);\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\events\\SimpleEventBus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\srs\\interfaces\\ISRSEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\stageFocusMode.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'masteredCount' is defined but never used. Allowed unused args must match /^_/u.","line":459,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":459,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'sessionId' is defined but never used. Allowed unused args must match /^_/u.","line":480,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":480,"endColumn":37}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Stage 집중 모드 - 정밀 연습 서비스\r\n\r\nexport type SpeedLevel = 'slow' | 'medium' | 'fast';\r\nexport type RepeatCount = 5 | 6 | 7 | 8;\r\n\r\nexport interface StageFocusSettings {\r\n  level: number;\r\n  stage: number;\r\n  speedLevel: SpeedLevel; // 3초/2초/1초\r\n  repeatCount: RepeatCount; // 5-8문장\r\n  immediateCorrection: boolean; // 오답 시 즉시 정답 표시\r\n  autoPlayCorrectAnswer: boolean; // 정답 자동 발화\r\n  shuffleQuestions: boolean; // 문장 순서 섞기\r\n}\r\n\r\nexport interface StageFocusQuestion {\r\n  id: string;\r\n  front_ko: string;\r\n  target_en: string;\r\n  difficulty: 'easy' | 'medium' | 'hard';\r\n  tags: string[];\r\n  repeatIndex: number; // 몇 번째 반복인지 (1-8)\r\n}\r\n\r\nexport interface StageFocusResult {\r\n  questionId: string;\r\n  repeatIndex: number;\r\n  userAnswer: string;\r\n  correctAnswer: string;\r\n  isCorrect: boolean;\r\n  responseTime: number;\r\n  needsReview: boolean; // 추가 연습 필요 여부\r\n}\r\n\r\nexport interface StageFocusSession {\r\n  sessionId: string;\r\n  userId: string;\r\n  settings: StageFocusSettings;\r\n  questions: StageFocusQuestion[];\r\n  results: StageFocusResult[];\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  totalAttempts: number;\r\n  correctAttempts: number;\r\n  averageResponseTime: number;\r\n  masteredQuestions: string[]; // 마스터한 문장들\r\n  needsReviewQuestions: string[]; // 추가 연습이 필요한 문장들\r\n}\r\n\r\nclass StageFocusService {\r\n  \r\n  /**\r\n   * Stage 집중 모드 세션 생성\r\n   */\r\n  async createStageFocusSession(\r\n    userId: string,\r\n    settings: StageFocusSettings\r\n  ): Promise<StageFocusSession> {\r\n    \r\n    try {\r\n      // 해당 스테이지의 문장들 조회\r\n      const originalQuestions = await this.getStageQuestions(settings.level, settings.stage);\r\n      \r\n      // repeatCount만큼 문장 선택 (랜덤 또는 순서대로)\r\n      const selectedQuestions = this.selectQuestionsForPractice(originalQuestions, settings.repeatCount);\r\n      \r\n      // 반복 학습을 위한 질문 생성 (각 문장을 여러 번 반복)\r\n      const practiceQuestions = this.generatePracticeQuestions(selectedQuestions, settings);\r\n      \r\n      const session: StageFocusSession = {\r\n        sessionId: `stage-focus-${Date.now()}-${userId}`,\r\n        userId,\r\n        settings,\r\n        questions: practiceQuestions,\r\n        results: [],\r\n        startTime: new Date(),\r\n        totalAttempts: 0,\r\n        correctAttempts: 0,\r\n        averageResponseTime: 0,\r\n        masteredQuestions: [],\r\n        needsReviewQuestions: []\r\n      };\r\n      \r\n      return session;\r\n      \r\n    } catch (error) {\r\n      console.error('Stage 집중 모드 세션 생성 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 특정 스테이지의 문장들 조회\r\n   */\r\n  private async getStageQuestions(level: number, stage: number): Promise<any[]> {\r\n    // 실제로는 Firestore나 API에서 조회\r\n    // 임시 데이터\r\n    const mockQuestions = [\r\n      {\r\n        id: `Lv${level}-P1-S${stage.toString().padStart(2, '0')}_01`,\r\n        front_ko: '내일 비가 올 것 같습니다.',\r\n        target_en: \"It's going to rain tomorrow.\",\r\n        difficulty: 'medium',\r\n        tags: ['future', 'weather']\r\n      },\r\n      {\r\n        id: `Lv${level}-P1-S${stage.toString().padStart(2, '0')}_02`,\r\n        front_ko: '다음 주에 여행을 갈 예정입니다.',\r\n        target_en: \"I'm going to travel next week.\",\r\n        difficulty: 'medium',\r\n        tags: ['future', 'travel']\r\n      },\r\n      {\r\n        id: `Lv${level}-P1-S${stage.toString().padStart(2, '0')}_03`,\r\n        front_ko: '언젠가는 성공할 것입니다.',\r\n        target_en: 'I will succeed someday.',\r\n        difficulty: 'hard',\r\n        tags: ['future', 'motivation']\r\n      },\r\n      {\r\n        id: `Lv${level}-P1-S${stage.toString().padStart(2, '0')}_04`,\r\n        front_ko: '오늘 저녁에 친구를 만날 거예요.',\r\n        target_en: \"I'm meeting a friend tonight.\",\r\n        difficulty: 'easy',\r\n        tags: ['future', 'social']\r\n      },\r\n      {\r\n        id: `Lv${level}-P1-S${stage.toString().padStart(2, '0')}_05`,\r\n        front_ko: '그 일은 쉽지 않을 것입니다.',\r\n        target_en: \"It won't be easy.\",\r\n        difficulty: 'medium',\r\n        tags: ['future', 'difficulty']\r\n      },\r\n      {\r\n        id: `Lv${level}-P1-S${stage.toString().padStart(2, '0')}_06`,\r\n        front_ko: '계획을 바꿀 생각입니다.',\r\n        target_en: \"I'm going to change the plan.\",\r\n        difficulty: 'medium',\r\n        tags: ['future', 'planning']\r\n      },\r\n      {\r\n        id: `Lv${level}-P1-S${stage.toString().padStart(2, '0')}_07`,\r\n        front_ko: '회의는 언제 시작할 예정인가요?',\r\n        target_en: 'When is the meeting going to start?',\r\n        difficulty: 'hard',\r\n        tags: ['future', 'question', 'business']\r\n      },\r\n      {\r\n        id: `Lv${level}-P1-S${stage.toString().padStart(2, '0')}_08`,\r\n        front_ko: '그들은 곧 도착할 것입니다.',\r\n        target_en: 'They will arrive soon.',\r\n        difficulty: 'easy',\r\n        tags: ['future', 'arrival']\r\n      }\r\n    ];\r\n    \r\n    return mockQuestions;\r\n  }\r\n  \r\n  /**\r\n   * 연습할 문장들 선택\r\n   */\r\n  private selectQuestionsForPractice(questions: any[], count: RepeatCount): any[] {\r\n    if (questions.length <= count) {\r\n      return questions;\r\n    }\r\n    \r\n    // 난이도별 균형 선택 (쉬움:보통:어려움 = 2:3:3 비율)\r\n    const easy = questions.filter(q => q.difficulty === 'easy');\r\n    const medium = questions.filter(q => q.difficulty === 'medium');\r\n    const hard = questions.filter(q => q.difficulty === 'hard');\r\n    \r\n    const selected = [];\r\n    const targetEasy = Math.min(Math.floor(count * 0.25), easy.length);\r\n    const targetMedium = Math.min(Math.floor(count * 0.4), medium.length);\r\n    const targetHard = Math.min(count - targetEasy - targetMedium, hard.length);\r\n    \r\n    // 랜덤 선택\r\n    selected.push(...this.shuffleArray(easy).slice(0, targetEasy));\r\n    selected.push(...this.shuffleArray(medium).slice(0, targetMedium));\r\n    selected.push(...this.shuffleArray(hard).slice(0, targetHard));\r\n    \r\n    // 부족한 만큼 나머지에서 채우기\r\n    const remaining = count - selected.length;\r\n    if (remaining > 0) {\r\n      const allRemaining = questions.filter(q => !selected.includes(q));\r\n      selected.push(...this.shuffleArray(allRemaining).slice(0, remaining));\r\n    }\r\n    \r\n    return selected.slice(0, count);\r\n  }\r\n  \r\n  /**\r\n   * 반복 학습용 질문 생성\r\n   */\r\n  private generatePracticeQuestions(\r\n    selectedQuestions: any[], \r\n    settings: StageFocusSettings\r\n  ): StageFocusQuestion[] {\r\n    \r\n    const practiceQuestions: StageFocusQuestion[] = [];\r\n    \r\n    // 각 문장을 2-3번 반복하여 총 연습량 확보\r\n    const repetitionsPerQuestion = Math.ceil(15 / selectedQuestions.length); // 총 15번 정도 연습\r\n    \r\n    for (let repeat = 1; repeat <= repetitionsPerQuestion; repeat++) {\r\n      for (const question of selectedQuestions) {\r\n        practiceQuestions.push({\r\n          id: question.id,\r\n          front_ko: question.front_ko,\r\n          target_en: question.target_en,\r\n          difficulty: question.difficulty,\r\n          tags: question.tags,\r\n          repeatIndex: repeat\r\n        });\r\n      }\r\n    }\r\n    \r\n    // 설정에 따라 섞기\r\n    if (settings.shuffleQuestions) {\r\n      return this.shuffleArray(practiceQuestions);\r\n    }\r\n    \r\n    return practiceQuestions;\r\n  }\r\n  \r\n  /**\r\n   * 답변 처리 및 즉시 피드백\r\n   */\r\n  async processAnswer(\r\n    sessionId: string,\r\n    question: StageFocusQuestion,\r\n    userAnswer: string,\r\n    responseTime: number\r\n  ): Promise<{\r\n    result: StageFocusResult;\r\n    feedback: {\r\n      isCorrect: boolean;\r\n      correctAnswer: string;\r\n      shouldPlayAudio: boolean;\r\n      encouragement: string;\r\n      needsRetry: boolean;\r\n    };\r\n  }> {\r\n    \r\n    try {\r\n      const isCorrect = this.validateAnswer(userAnswer, question.target_en);\r\n      \r\n      const result: StageFocusResult = {\r\n        questionId: question.id,\r\n        repeatIndex: question.repeatIndex,\r\n        userAnswer,\r\n        correctAnswer: question.target_en,\r\n        isCorrect,\r\n        responseTime,\r\n        needsReview: !isCorrect || responseTime > this.getTargetTime(question.difficulty)\r\n      };\r\n      \r\n      // 즉시 피드백 생성\r\n      const feedback = {\r\n        isCorrect,\r\n        correctAnswer: question.target_en,\r\n        shouldPlayAudio: !isCorrect, // 틀렸을 때만 정답 발화\r\n        encouragement: this.generateEncouragement(isCorrect, question.repeatIndex),\r\n        needsRetry: !isCorrect && question.repeatIndex <= 2 // 초기 반복에서 틀리면 재시도\r\n      };\r\n      \r\n      return { result, feedback };\r\n      \r\n    } catch (error) {\r\n      console.error('답변 처리 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 세션 완료 및 마스터 분석\r\n   */\r\n  async completeSession(sessionId: string): Promise<{\r\n    totalAccuracy: number;\r\n    averageResponseTime: number;\r\n    masteredQuestions: string[];\r\n    needsReviewQuestions: string[];\r\n    improvementAreas: string[];\r\n    nextStageRecommendation: string;\r\n    practiceEffectiveness: 'excellent' | 'good' | 'needs_work';\r\n  }> {\r\n    \r\n    try {\r\n      const session = await this.getSession(sessionId);\r\n      \r\n      if (!session) {\r\n        throw new Error('세션을 찾을 수 없습니다');\r\n      }\r\n      \r\n      const totalAttempts = session.results.length;\r\n      const correctAttempts = session.results.filter(r => r.isCorrect).length;\r\n      const totalAccuracy = (correctAttempts / totalAttempts) * 100;\r\n      \r\n      const averageResponseTime = session.results.reduce((sum, r) => sum + r.responseTime, 0) / totalAttempts;\r\n      \r\n      // 문장별 마스터 여부 분석\r\n      const questionResults = this.groupResultsByQuestion(session.results);\r\n      const masteredQuestions: string[] = [];\r\n      const needsReviewQuestions: string[] = [];\r\n      \r\n      Object.entries(questionResults).forEach(([questionId, results]) => {\r\n        const accuracy = results.filter(r => r.isCorrect).length / results.length;\r\n        const avgResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / results.length;\r\n        \r\n        if (accuracy >= 0.8 && avgResponseTime <= this.getTargetTime('medium')) {\r\n          masteredQuestions.push(questionId);\r\n        } else {\r\n          needsReviewQuestions.push(questionId);\r\n        }\r\n      });\r\n      \r\n      // 개선 영역 분석\r\n      const incorrectResults = session.results.filter(r => !r.isCorrect);\r\n      const improvementTags = this.analyzeIncorrectPatterns(incorrectResults);\r\n      \r\n      // 연습 효과성 평가\r\n      let practiceEffectiveness: 'excellent' | 'good' | 'needs_work';\r\n      if (totalAccuracy >= 85 && averageResponseTime <= 4000) {\r\n        practiceEffectiveness = 'excellent';\r\n      } else if (totalAccuracy >= 70 && averageResponseTime <= 6000) {\r\n        practiceEffectiveness = 'good';\r\n      } else {\r\n        practiceEffectiveness = 'needs_work';\r\n      }\r\n      \r\n      // 다음 추천\r\n      const nextStageRecommendation = this.generateNextRecommendation(\r\n        session.settings,\r\n        practiceEffectiveness,\r\n        masteredQuestions.length\r\n      );\r\n      \r\n      return {\r\n        totalAccuracy,\r\n        averageResponseTime,\r\n        masteredQuestions,\r\n        needsReviewQuestions,\r\n        improvementAreas: improvementTags,\r\n        nextStageRecommendation,\r\n        practiceEffectiveness\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('세션 완료 처리 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 사용 가능한 스테이지 목록 조회\r\n   */\r\n  async getAvailableStages(level: number): Promise<{\r\n    stages: Array<{\r\n      stage: number;\r\n      title: string;\r\n      difficulty: string;\r\n      questionCount: number;\r\n      completed: boolean;\r\n      lastPracticed?: Date;\r\n    }>;\r\n    totalStages: number;\r\n  }> {\r\n    \r\n    try {\r\n      // 실제로는 Firestore에서 조회\r\n      // Level 3 기준 임시 데이터\r\n      const stages = Array.from({ length: 30 }, (_, i) => ({\r\n        stage: i + 1,\r\n        title: `Stage ${i + 1} - ${this.getStageTitle(level, i + 1)}`,\r\n        difficulty: i < 10 ? 'easy' : i < 20 ? 'medium' : 'hard',\r\n        questionCount: Math.floor(Math.random() * 20) + 30, // 30-50개\r\n        completed: Math.random() > 0.3, // 70% 완료\r\n        lastPracticed: Math.random() > 0.5 ? new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000) : undefined\r\n      }));\r\n      \r\n      return {\r\n        stages,\r\n        totalStages: stages.length\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('스테이지 목록 조회 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  // Private helper methods\r\n  \r\n  private shuffleArray<T>(array: T[]): T[] {\r\n    const shuffled = [...array];\r\n    for (let i = shuffled.length - 1; i > 0; i--) {\r\n      const j = Math.floor(Math.random() * (i + 1));\r\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\r\n    }\r\n    return shuffled;\r\n  }\r\n  \r\n  private validateAnswer(userAnswer: string, correctAnswer: string): boolean {\r\n    const normalize = (str: string) => str.toLowerCase().trim().replace(/[.,!?]/g, '');\r\n    return normalize(userAnswer) === normalize(correctAnswer);\r\n  }\r\n  \r\n  private getTargetTime(difficulty: 'easy' | 'medium' | 'hard'): number {\r\n    switch (difficulty) {\r\n      case 'easy': return 3000;\r\n      case 'medium': return 4000;\r\n      case 'hard': return 6000;\r\n      default: return 4000;\r\n    }\r\n  }\r\n  \r\n  private generateEncouragement(isCorrect: boolean, _repeatIndex: number): string {\r\n    if (isCorrect) {\r\n      const positive = [\r\n        '정확합니다! 👏',\r\n        '완벽해요! ✨',\r\n        '훌륭합니다! 🎉',\r\n        '잘하고 있어요! 💪',\r\n        '좋습니다! 👍'\r\n      ];\r\n      return positive[Math.floor(Math.random() * positive.length)];\r\n    } else {\r\n      const encouraging = [\r\n        '다시 한번 시도해보세요! 💪',\r\n        '거의 다 왔어요! 🎯',\r\n        '조금 더 연습하면 됩니다! 📚',\r\n        '포기하지 마세요! 🌟',\r\n        '다음번엔 더 잘할 거예요! 🚀'\r\n      ];\r\n      return encouraging[Math.floor(Math.random() * encouraging.length)];\r\n    }\r\n  }\r\n  \r\n  private groupResultsByQuestion(results: StageFocusResult[]): Record<string, StageFocusResult[]> {\r\n    return results.reduce((groups, result) => {\r\n      if (!groups[result.questionId]) {\r\n        groups[result.questionId] = [];\r\n      }\r\n      groups[result.questionId].push(result);\r\n      return groups;\r\n    }, {} as Record<string, StageFocusResult[]>);\r\n  }\r\n  \r\n  private analyzeIncorrectPatterns(_incorrectResults: StageFocusResult[]): string[] {\r\n    // 간단한 패턴 분석 (실제로는 더 정교한 AI 분석)\r\n    const patterns = ['future', 'grammar', 'vocabulary', 'structure'];\r\n    return patterns.slice(0, 2); // 임시로 2개 반환\r\n  }\r\n  \r\n  private generateNextRecommendation(\r\n    settings: StageFocusSettings,\r\n    effectiveness: string,\r\n    masteredCount: number\r\n  ): string {\r\n    \r\n    if (effectiveness === 'excellent') {\r\n      return `완벽한 성과입니다! 다음 스테이지(Stage ${settings.stage + 1})로 진행하거나 속도를 높여보세요.`;\r\n    } else if (effectiveness === 'good') {\r\n      return `좋은 결과입니다! 같은 스테이지를 한 번 더 연습하거나 다음 스테이지로 진행하세요.`;\r\n    } else {\r\n      return `더 연습이 필요합니다. 속도를 낮추고 같은 스테이지를 반복 연습해보세요.`;\r\n    }\r\n  }\r\n  \r\n  private getStageTitle(level: number, stage: number): string {\r\n    const titles = [\r\n      'Basic Patterns', 'Future Forms', 'Past Tense', 'Present Perfect',\r\n      'Conditionals', 'Passive Voice', 'Reported Speech', 'Modal Verbs',\r\n      'Relative Clauses', 'Advanced Grammar'\r\n    ];\r\n    return titles[(stage - 1) % titles.length];\r\n  }\r\n  \r\n  private async getSession(sessionId: string): Promise<StageFocusSession | null> {\r\n    // 실제로는 저장된 세션 조회\r\n    return null; // 임시\r\n  }\r\n}\r\n\r\nexport const stageFocusService = new StageFocusService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\stageMetadataService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\statistics\\StatisticsCalculator.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":43,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":43,"endColumn":20},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'today' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":179,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":179,"endColumn":16}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * 통계 계산 서비스 구현체\n * @description 단일 책임 원칙 - 통계 계산만을 담당\n */\n\nimport {\n  IStatisticsCalculator,\n  UserProgressData,\n  StatisticsMetrics,\n  LevelProgressData,\n  SessionRecord,\n  StatisticsError\n} from './types';\n\nexport class StatisticsCalculator implements IStatisticsCalculator {\n  private readonly TOTAL_LEVELS = 10;\n  private readonly LEVEL_STAGE_COUNTS: Record<number, number> = {\n    1: 19, 2: 30, 3: 44, 4: 32, 5: 30,\n    6: 44, 7: 42, 8: 50, 9: 48, 10: 50\n  };\n\n  /**\n   * 전체 통계 메트릭 계산\n   */\n  calculateOverallMetrics(userData: UserProgressData): StatisticsMetrics {\n    try {\n      const overallProgress = this.calculateOverallProgress(userData);\n      const averageAccuracy = this.calculateAverageAccuracy(userData.sessionHistory);\n      const incorrectCount = this.calculateIncorrectCount(userData.sessionHistory);\n      const streakDays = this.calculateStreakDays(userData.sessionHistory);\n      const totalStudyTime = this.calculateTotalStudyTime(userData.sessionHistory);\n      const weakAreas = this.identifyWeakAreas(userData.sessionHistory);\n\n      return {\n        overallProgress,\n        averageAccuracy,\n        incorrectCount,\n        currentLevel: userData.level,\n        streakDays,\n        totalStudyTime,\n        weakAreas\n      };\n    } catch (_error) {\n      throw new StatisticsError(\n        'Failed to calculate overall metrics',\n        'CALCULATION_ERROR',\n        userData.userId\n      );\n    }\n  }\n\n  /**\n   * 레벨별 진행률 계산\n   */\n  calculateLevelProgress(userData: UserProgressData, level: number): LevelProgressData {\n    if (level < 1 || level > this.TOTAL_LEVELS) {\n      throw new StatisticsError(\n        `Invalid level: ${level}`,\n        'INVALID_INPUT',\n        userData.userId\n      );\n    }\n\n    const totalStages = this.LEVEL_STAGE_COUNTS[level] || 0;\n    const levelSessions = userData.sessionHistory.filter(s => s.level === level);\n    const completedStages = new Set(levelSessions.map(s => s.stage)).size;\n    const progress = totalStages > 0 ? Math.round((completedStages / totalStages) * 100) : 0;\n    const bestAccuracy = levelSessions.length > 0 \n      ? Math.max(...levelSessions.map(s => s.accuracy))\n      : 0;\n\n    return {\n      level,\n      progress,\n      bestAccuracy: Math.round(bestAccuracy),\n      completedStages,\n      totalStages\n    };\n  }\n\n  /**\n   * 정확도 트렌드 계산 (최근 N일)\n   */\n  calculateAccuracyTrend(sessionHistory: SessionRecord[], days: number): number[] {\n    const now = new Date();\n    const cutoffDate = new Date(now.getTime() - (days * 24 * 60 * 60 * 1000));\n    \n    const recentSessions = sessionHistory.filter(session => \n      new Date(session.completedAt) >= cutoffDate\n    );\n\n    if (recentSessions.length === 0) return [];\n\n    // 날짜별로 그룹화하고 평균 계산\n    const dailyAccuracy: Record<string, number[]> = {};\n    recentSessions.forEach(session => {\n      const dateKey = new Date(session.completedAt).toDateString();\n      if (!dailyAccuracy[dateKey]) dailyAccuracy[dateKey] = [];\n      dailyAccuracy[dateKey].push(session.accuracy);\n    });\n\n    return Object.values(dailyAccuracy).map(accuracyList =>\n      Math.round(accuracyList.reduce((sum, acc) => sum + acc, 0) / accuracyList.length)\n    );\n  }\n\n  /**\n   * 약점 영역 식별\n   */\n  identifyWeakAreas(sessionHistory: SessionRecord[]): string[] {\n    if (sessionHistory.length === 0) return [];\n\n    const levelAccuracy: Record<number, number[]> = {};\n    sessionHistory.forEach(session => {\n      if (!levelAccuracy[session.level]) levelAccuracy[session.level] = [];\n      levelAccuracy[session.level].push(session.accuracy);\n    });\n\n    const weakLevels: string[] = [];\n    Object.entries(levelAccuracy).forEach(([level, accuracyList]) => {\n      const avgAccuracy = accuracyList.reduce((sum, acc) => sum + acc, 0) / accuracyList.length;\n      if (avgAccuracy < 70) { // 70% 미만을 약점으로 판단\n        weakLevels.push(`Level ${level}`);\n      }\n    });\n\n    return weakLevels;\n  }\n\n  /**\n   * 전체 진행률 계산 (Private)\n   */\n  private calculateOverallProgress(userData: UserProgressData): number {\n    const totalPossibleStages = Object.values(this.LEVEL_STAGE_COUNTS)\n      .reduce((sum, count) => sum + count, 0);\n    \n    const completedStages = new Set(\n      userData.sessionHistory.map(session => `${session.level}-${session.stage}`)\n    ).size;\n\n    return totalPossibleStages > 0 \n      ? Math.round((completedStages / totalPossibleStages) * 100) \n      : 0;\n  }\n\n  /**\n   * 평균 정확도 계산 (Private)\n   */\n  private calculateAverageAccuracy(sessionHistory: SessionRecord[]): number {\n    if (sessionHistory.length === 0) return 0;\n    \n    const totalAccuracy = sessionHistory.reduce((sum, session) => sum + session.accuracy, 0);\n    return Math.round(totalAccuracy / sessionHistory.length);\n  }\n\n  /**\n   * 틀린 문제 수 계산 (Private)\n   */\n  private calculateIncorrectCount(sessionHistory: SessionRecord[]): number {\n    return sessionHistory.reduce((total, session) => \n      total + (session.totalCards - session.correctAnswers), 0\n    );\n  }\n\n  /**\n   * 연속 학습 일수 계산 (Private)\n   */\n  private calculateStreakDays(sessionHistory: SessionRecord[]): number {\n    if (sessionHistory.length === 0) return 0;\n\n    const sortedSessions = sessionHistory\n      .sort((a, b) => new Date(b.completedAt).getTime() - new Date(a.completedAt).getTime());\n\n    const uniqueDates = [...new Set(\n      sortedSessions.map(session => new Date(session.completedAt).toDateString())\n    )];\n\n    let streak = 0;\n    const today = new Date().toDateString();\n    \n    for (let i = 0; i < uniqueDates.length; i++) {\n      const date = new Date(uniqueDates[i]);\n      const expectedDate = new Date();\n      expectedDate.setDate(expectedDate.getDate() - i);\n      \n      if (date.toDateString() === expectedDate.toDateString()) {\n        streak++;\n      } else {\n        break;\n      }\n    }\n\n    return streak;\n  }\n\n  /**\n   * 총 학습 시간 계산 (Private)\n   */\n  private calculateTotalStudyTime(sessionHistory: SessionRecord[]): number {\n    return Math.round(\n      sessionHistory.reduce((total, session) => total + session.timeSpent, 0) / 60\n    ); // 초를 분으로 변환\n  }\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\statistics\\StatisticsServiceFactory.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\statistics\\UserDataRepository.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\statistics\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\statistics\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\timers\\TimerManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":129,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":129,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'id' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":160,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":160,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * TimerManager - 타이머 라이프사이클 관리 모듈\r\n * \r\n * 역할:\r\n * - 모든 타이머의 중앙집중식 관리\r\n * - 타이머 중복 실행 방지\r\n * - 컴포넌트 언마운트시 자동 정리\r\n * - 일시정지/재개 기능 통합 관리\r\n */\r\n\r\nexport type TimerType = 'countdown' | 'recognition' | 'waiting' | 'tts';\r\n\r\nexport interface TimerConfig {\r\n  id: string;\r\n  type: TimerType;\r\n  interval: number; // milliseconds\r\n  callback: (remainingTime: number) => void;\r\n  onComplete?: () => void;\r\n}\r\n\r\nexport interface TimerState {\r\n  id: string;\r\n  type: TimerType;\r\n  intervalId: number | null;\r\n  startTime: number;\r\n  duration: number;\r\n  remainingTime: number;\r\n  isPaused: boolean;\r\n  isActive: boolean;\r\n}\r\n\r\nclass TimerManager {\r\n  private timers: Map<string, TimerState> = new Map();\r\n  private static instance: TimerManager | null = null;\r\n\r\n  // Singleton pattern\r\n  static getInstance(): TimerManager {\r\n    if (!TimerManager.instance) {\r\n      TimerManager.instance = new TimerManager();\r\n    }\r\n    return TimerManager.instance;\r\n  }\r\n\r\n  /**\r\n   * 새로운 타이머 시작\r\n   */\r\n  startTimer(config: TimerConfig, duration: number): void {\r\n    // 기존 타이머가 있으면 중지\r\n    this.stopTimer(config.id);\r\n\r\n    const now = Date.now();\r\n    const state: TimerState = {\r\n      id: config.id,\r\n      type: config.type,\r\n      intervalId: null,\r\n      startTime: now,\r\n      duration: duration * 1000, // convert to ms\r\n      remainingTime: duration,\r\n      isPaused: false,\r\n      isActive: true\r\n    };\r\n\r\n    // 초기 상태 콜백 실행 (3초부터 시작)\r\n    config.callback(state.remainingTime);\r\n\r\n    // 타이머 실행\r\n    state.intervalId = window.setInterval(() => {\r\n      this.tick(config.id, config);\r\n    }, config.interval);\r\n\r\n    this.timers.set(config.id, state);\r\n    console.log(`⏰ [TimerManager] 타이머 시작: ${config.id} (${duration}초)`);\r\n  }\r\n\r\n  /**\r\n   * 타이머 중지\r\n   */\r\n  stopTimer(id: string): boolean {\r\n    const state = this.timers.get(id);\r\n    if (!state) return false;\r\n\r\n    if (state.intervalId !== null) {\r\n      clearInterval(state.intervalId);\r\n    }\r\n\r\n    this.timers.delete(id);\r\n    console.log(`🛑 [TimerManager] 타이머 중지: ${id}`);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 타이머 일시정지\r\n   */\r\n  pauseTimer(id: string): boolean {\r\n    const state = this.timers.get(id);\r\n    if (!state || state.isPaused) return false;\r\n\r\n    if (state.intervalId !== null) {\r\n      clearInterval(state.intervalId);\r\n      state.intervalId = null;\r\n    }\r\n\r\n    state.isPaused = true;\r\n    console.log(`⏸️ [TimerManager] 타이머 일시정지: ${id}`);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 타이머 재개\r\n   */\r\n  resumeTimer(id: string, config: TimerConfig): boolean {\r\n    const state = this.timers.get(id);\r\n    if (!state || !state.isPaused) return false;\r\n\r\n    // 남은 시간으로 다시 시작\r\n    state.intervalId = window.setInterval(() => {\r\n      this.tick(id, config);\r\n    }, config.interval);\r\n\r\n    state.isPaused = false;\r\n    console.log(`▶️ [TimerManager] 타이머 재개: ${id} (남은시간: ${state.remainingTime}초)`);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * 특정 타입의 모든 타이머 일시정지\r\n   */\r\n  pauseAllTimers(type?: TimerType): void {\r\n    for (const [id, state] of this.timers.entries()) {\r\n      if (!type || state.type === type) {\r\n        if (state.intervalId !== null) {\r\n          clearInterval(state.intervalId);\r\n          state.intervalId = null;\r\n          state.isPaused = true;\r\n        }\r\n      }\r\n    }\r\n    console.log(`⏸️ [TimerManager] 모든 ${type || ''} 타이머 일시정지`);\r\n  }\r\n\r\n  /**\r\n   * 특정 타입의 모든 타이머 재개\r\n   */\r\n  resumeAllTimers(type?: TimerType, configs?: Map<string, TimerConfig>): void {\r\n    for (const [id, state] of this.timers.entries()) {\r\n      if ((!type || state.type === type) && state.isPaused) {\r\n        const config = configs?.get(id);\r\n        if (config) {\r\n          this.resumeTimer(id, config);\r\n        }\r\n      }\r\n    }\r\n    console.log(`▶️ [TimerManager] 모든 ${type || ''} 타이머 재개`);\r\n  }\r\n\r\n  /**\r\n   * 모든 타이머 정리\r\n   */\r\n  clearAllTimers(): void {\r\n    for (const [id, state] of this.timers.entries()) {\r\n      if (state.intervalId !== null) {\r\n        clearInterval(state.intervalId);\r\n      }\r\n    }\r\n    this.timers.clear();\r\n    console.log(`🧹 [TimerManager] 모든 타이머 정리 완료`);\r\n  }\r\n\r\n  /**\r\n   * 타이머 상태 조회\r\n   */\r\n  getTimerState(id: string): TimerState | null {\r\n    return this.timers.get(id) || null;\r\n  }\r\n\r\n  /**\r\n   * 활성 타이머 목록\r\n   */\r\n  getActiveTimers(): TimerState[] {\r\n    return Array.from(this.timers.values()).filter(state => state.isActive);\r\n  }\r\n\r\n  /**\r\n   * 타이머 틱 처리\r\n   */\r\n  private tick(id: string, config: TimerConfig): void {\r\n    const state = this.timers.get(id);\r\n    if (!state || state.isPaused) return;\r\n\r\n    state.remainingTime -= 1;\r\n\r\n    // 콜백 실행\r\n    config.callback(state.remainingTime);\r\n\r\n    // 완료 처리\r\n    if (state.remainingTime <= 0) {\r\n      if (state.intervalId !== null) {\r\n        clearInterval(state.intervalId);\r\n        state.intervalId = null;\r\n      }\r\n      \r\n      state.isActive = false;\r\n      \r\n      // 완료 콜백 실행\r\n      if (config.onComplete) {\r\n        config.onComplete();\r\n      }\r\n      \r\n      // 타이머 제거\r\n      this.timers.delete(id);\r\n      console.log(`✅ [TimerManager] 타이머 완료: ${id}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 디버그 정보\r\n   */\r\n  debug(): void {\r\n    console.log(`🔍 [TimerManager] 활성 타이머: ${this.timers.size}개`);\r\n    for (const [id, state] of this.timers.entries()) {\r\n      console.log(`  - ${id}: ${state.type} (남은시간: ${state.remainingTime}초, 일시정지: ${state.isPaused})`);\r\n    }\r\n  }\r\n}\r\n\r\nexport default TimerManager;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\vocabularyService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'userStage' is defined but never used. Allowed unused args must match /^_/u.","line":335,"column":49,"nodeType":null,"messageId":"unusedVar","endLine":335,"endColumn":58}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * vocabularyService - 패턴 데이터에서 단어 추출 및 관리 서비스\r\n * - 레벨별 패턴 파일에서 단어 자동 추출\r\n * - 사용자 학습 진도에 맞는 단어장 제공\r\n * - 단어 학습 상태 관리 및 복습 추천\r\n */\r\n\r\nexport interface VocabularyWord {\r\n  id: string;\r\n  word: string;\r\n  translation: string;\r\n  level: number;\r\n  stage?: number;\r\n  category: 'pronoun' | 'verb' | 'adjective' | 'noun' | 'adverb' | 'preposition' | 'other';\r\n  difficulty: 'basic' | 'intermediate' | 'advanced';\r\n  frequency: number; // 패턴에서 등장 빈도\r\n  examples: {\r\n    sentence: string;\r\n    translation: string;\r\n    stageId: string;\r\n  }[];\r\n  firstAppeared: string; // 처음 등장한 스테이지 ID\r\n}\r\n\r\nexport interface UserVocabularyProgress {\r\n  wordId: string;\r\n  status: 'unknown' | 'learning' | 'known' | 'review';\r\n  lastStudied?: Date;\r\n  correctCount: number;\r\n  wrongCount: number;\r\n  isFavorite: boolean;\r\n  nextReviewDate?: Date; // SRS 기반 복습일\r\n}\r\n\r\nexport interface VocabularyStats {\r\n  totalWords: number;\r\n  knownWords: number;\r\n  learningWords: number;\r\n  reviewWords: number;\r\n  newWords: number;\r\n  completionRate: number;\r\n}\r\n\r\nclass VocabularyService {\r\n  private vocabularyCache = new Map<string, VocabularyWord[]>();\r\n  private userProgressCache = new Map<string, UserVocabularyProgress>();\r\n\r\n  /**\r\n   * 영어 문장에서 단어 추출 및 분류\r\n   */\r\n  private extractWordsFromSentence(sentence: string): Array<{ word: string; category: string }> {\r\n    // 문장 정리: 구두점 제거, 소문자 변환\r\n    const cleanSentence = sentence.toLowerCase()\r\n      .replace(/[^\\w\\s']/g, ' ')\r\n      .replace(/\\s+/g, ' ')\r\n      .trim();\r\n\r\n    const words = cleanSentence.split(' ').filter(word => word.length > 0);\r\n    \r\n    return words.map(word => ({\r\n      word: word.replace(/'/g, ''), // don't -> dont\r\n      category: this.categorizeWord(word)\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * 단어 카테고리 분류 (기본적인 규칙 기반)\r\n   */\r\n  private categorizeWord(word: string): VocabularyWord['category'] {\r\n    const cleanWord = word.toLowerCase().replace(/'/g, '');\r\n    \r\n    // 대명사\r\n    const pronouns = ['i', 'you', 'he', 'she', 'it', 'we', 'they', 'my', 'your', 'his', 'her', 'its', 'our', 'their'];\r\n    if (pronouns.includes(cleanWord)) return 'pronoun';\r\n    \r\n    // Be 동사 및 기본 동사\r\n    const verbs = ['am', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'can', 'could', 'should', 'may', 'might'];\r\n    if (verbs.includes(cleanWord)) return 'verb';\r\n    \r\n    // 현재진행형 동사 (-ing)\r\n    if (cleanWord.endsWith('ing')) return 'verb';\r\n    \r\n    // 과거형 동사 (-ed)\r\n    if (cleanWord.endsWith('ed')) return 'verb';\r\n    \r\n    // 형용사 (일반적인 패턴)\r\n    const adjectives = ['happy', 'sad', 'big', 'small', 'good', 'bad', 'new', 'old', 'young', 'tall', 'short', 'smart', 'kind', 'pretty', 'tired', 'strong', 'quiet', 'brave', 'funny', 'honest', 'nice', 'fast', 'safe', 'normal', 'special', 'important'];\r\n    if (adjectives.includes(cleanWord)) return 'adjective';\r\n    \r\n    // 전치사\r\n    const prepositions = ['in', 'on', 'at', 'to', 'for', 'with', 'by', 'from', 'of', 'about', 'into', 'through', 'during', 'before', 'after', 'above', 'below', 'under', 'over'];\r\n    if (prepositions.includes(cleanWord)) return 'preposition';\r\n    \r\n    // 부사 (일반적인 패턴)\r\n    if (cleanWord.endsWith('ly')) return 'adverb';\r\n    const adverbs = ['now', 'here', 'there', 'today', 'tomorrow', 'yesterday', 'always', 'never', 'sometimes', 'often', 'usually'];\r\n    if (adverbs.includes(cleanWord)) return 'adverb';\r\n    \r\n    // 나머지는 명사로 분류\r\n    return 'noun';\r\n  }\r\n\r\n  /**\r\n   * 단어 난이도 결정\r\n   */\r\n  private determineDifficulty(word: string, level: number, frequency: number): VocabularyWord['difficulty'] {\r\n    // 레벨과 빈도를 기반으로 난이도 결정\r\n    if (level <= 2 && frequency >= 5) return 'basic';\r\n    if (level <= 5 && frequency >= 3) return 'intermediate';\r\n    return 'advanced';\r\n  }\r\n\r\n  /**\r\n   * 특정 레벨의 패턴 파일에서 단어 추출\r\n   */\r\n  async extractVocabularyFromLevel(level: number): Promise<VocabularyWord[]> {\r\n    const cacheKey = `level_${level}`;\r\n    if (this.vocabularyCache.has(cacheKey)) {\r\n      return this.vocabularyCache.get(cacheKey)!;\r\n    }\r\n\r\n    try {\r\n      console.log(`🔍 Level ${level} 단어 추출 시작...`);\r\n      \r\n      // 레벨 내 모든 스테이지 파일 목록 가져오기\r\n      const stageFiles = await this.getStageFilesForLevel(level);\r\n      if (stageFiles.length === 0) {\r\n        console.warn(`Level ${level} 스테이지 파일이 없습니다.`);\r\n        return [];\r\n      }\r\n\r\n      const wordFrequency = new Map<string, number>();\r\n      const wordExamples = new Map<string, VocabularyWord['examples']>();\r\n      const wordFirstAppeared = new Map<string, string>();\r\n      const wordCategories = new Map<string, VocabularyWord['category']>();\r\n\r\n      // 각 스테이지 파일에서 단어 추출\r\n      for (const stageFile of stageFiles) {\r\n        try {\r\n          // console.log(`📄 ${stageFile} 처리 중...`); // 로그 제거\r\n          const stageResponse = await fetch(`/patterns/banks/level_${level}/${stageFile}`);\r\n          if (!stageResponse.ok) {\r\n            console.warn(`파일 ${stageFile} 로드 실패: ${stageResponse.status}`);\r\n            continue;\r\n          }\r\n\r\n          const stageData = await stageResponse.json();\r\n          \r\n          // 안전 검사\r\n          if (!stageData || !Array.isArray(stageData.sentences)) {\r\n            console.warn(`파일 ${stageFile}의 데이터 구조가 올바르지 않습니다.`);\r\n            continue;\r\n          }\r\n          \r\n          // 문장들에서 단어 추출\r\n          for (const sentence of stageData.sentences) {\r\n            if (!sentence || !sentence.en || typeof sentence.en !== 'string') {\r\n              continue;\r\n            }\r\n\r\n            const extractedWords = this.extractWordsFromSentence(sentence.en);\r\n            \r\n            for (const { word, category } of extractedWords) {\r\n              if (!word || word.length < 2) continue; // 너무 짧은 단어 제외\r\n              \r\n              // 빈도수 증가\r\n              wordFrequency.set(word, (wordFrequency.get(word) || 0) + 1);\r\n              \r\n              // 카테고리 저장 (첫 번째로 발견된 카테고리를 사용)\r\n              if (!wordCategories.has(word)) {\r\n                wordCategories.set(word, category);\r\n              }\r\n              \r\n              // 처음 등장 위치 기록\r\n              if (!wordFirstAppeared.has(word)) {\r\n                wordFirstAppeared.set(word, stageData.stage_id || `Lv${level}-Unknown`);\r\n              }\r\n              \r\n              // 예문 추가 (최대 3개까지)\r\n              if (!wordExamples.has(word)) {\r\n                wordExamples.set(word, []);\r\n              }\r\n              \r\n              const examples = wordExamples.get(word)!;\r\n              if (examples.length < 3 && sentence.kr) {\r\n                examples.push({\r\n                  sentence: sentence.en,\r\n                  translation: sentence.kr,\r\n                  stageId: stageData.stage_id || `Lv${level}-Unknown`\r\n                });\r\n              }\r\n            }\r\n          }\r\n        } catch (error) {\r\n          console.warn(`스테이지 파일 ${stageFile} 처리 중 오류:`, error);\r\n        }\r\n      }\r\n\r\n      // VocabularyWord 객체 생성\r\n      const vocabularyWords: VocabularyWord[] = Array.from(wordFrequency.entries()).map(([word, frequency]) => ({\r\n        id: `${level}_${word}`,\r\n        word,\r\n        translation: this.getKoreanTranslation(word), // 간단한 번역 (실제로는 번역 API 또는 사전 필요)\r\n        level,\r\n        category: wordCategories.get(word) || 'other',\r\n        difficulty: this.determineDifficulty(word, level, frequency),\r\n        frequency,\r\n        examples: wordExamples.get(word) || [],\r\n        firstAppeared: wordFirstAppeared.get(word) || `Lv${level}-Unknown`\r\n      }));\r\n\r\n      // 빈도순으로 정렬\r\n      vocabularyWords.sort((a, b) => b.frequency - a.frequency);\r\n\r\n      // 캐시에 저장\r\n      this.vocabularyCache.set(cacheKey, vocabularyWords);\r\n      \r\n      console.log(`✅ Level ${level} 단어 ${vocabularyWords.length}개 추출 완료`);\r\n      return vocabularyWords;\r\n    } catch (error) {\r\n      console.error(`Level ${level} 단어 추출 오류:`, error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 레벨별 스테이지 파일 목록 가져오기 (실제 존재하는 파일 기준)\r\n   */\r\n  private async getStageFilesForLevel(level: number): Promise<string[]> {\r\n    const files: string[] = [];\r\n    \r\n    // 실제 존재하는 파일들을 기준으로 하드코딩\r\n    if (level === 1) {\r\n      files.push(\r\n        'Lv1-P1-S01_bank.json',\r\n        'Lv1-P1-S02_bank.json',\r\n        'Lv1-P1-S03_bank.json',\r\n        'Lv1-P1-S04_bank.json',\r\n        'Lv1-P2-S05_bank.json',\r\n        'Lv1-P2-S06_bank.json',\r\n        'Lv1-P2-S07_bank.json',\r\n        'Lv1-P2-S08_bank.json',\r\n        'Lv1-P3-S09_bank.json',\r\n        'Lv1-P3-S10_bank.json',\r\n        'Lv1-P3-S11_bank.json',\r\n        'Lv1-P3-S12_bank.json',\r\n        'Lv1-P4-S13_bank.json',\r\n        'Lv1-P4-S14_bank.json',\r\n        'Lv1-P4-S15_bank.json',\r\n        'Lv1-P4-S16_bank.json'\r\n      );\r\n    } else if (level === 2) {\r\n      files.push(\r\n        'Lv2-P1-S01_bank.json',\r\n        'Lv2-P1-S02_bank.json',\r\n        'Lv2-P1-S03_bank.json',\r\n        'Lv2-P1-S04_bank.json',\r\n        'Lv2-P2-S05_bank.json',\r\n        'Lv2-P2-S06_bank.json',\r\n        'Lv2-P2-S07_bank.json',\r\n        'Lv2-P2-S08_bank.json',\r\n        'Lv2-P3-S09_bank.json',\r\n        'Lv2-P3-S10_bank.json',\r\n        'Lv2-P3-S11_bank.json',\r\n        'Lv2-P3-S12_bank.json',\r\n        'Lv2-P4-S13_bank.json',\r\n        'Lv2-P4-S14_bank.json',\r\n        'Lv2-P4-S15_bank.json',\r\n        'Lv2-P4-S16_bank.json',\r\n        'Lv2-P5-S17_bank.json',\r\n        'Lv2-P5-S18_bank.json',\r\n        'Lv2-P5-S19_bank.json',\r\n        'Lv2-P5-S20_bank.json'\r\n      );\r\n    }\r\n    // Level 3 이상은 일부만 추가 (실제 파일 기준)\r\n    else if (level === 3) {\r\n      files.push(\r\n        'Lv3-P1-S02_bank.json',\r\n        'Lv3-P1-S03_bank.json',\r\n        'Lv3-P2-S07_bank.json',\r\n        'Lv3-P2-S08_bank.json',\r\n        'Lv3-P2-S10_bank.json'\r\n      );\r\n    }\r\n    \r\n    return files;\r\n  }\r\n\r\n  /**\r\n   * 간단한 영-한 번역 (실제로는 번역 사전이나 API 필요)\r\n   */\r\n  private getKoreanTranslation(word: string): string {\r\n    const translations: Record<string, string> = {\r\n      // 대명사\r\n      'i': '나', 'you': '너/당신', 'he': '그', 'she': '그녀', 'it': '그것',\r\n      'we': '우리', 'they': '그들',\r\n      \r\n      // Be 동사\r\n      'am': '~이다', 'is': '~이다', 'are': '~이다',\r\n      \r\n      // 형용사\r\n      'happy': '행복한', 'sad': '슬픈', 'big': '큰', 'small': '작은',\r\n      'good': '좋은', 'bad': '나쁜', 'new': '새로운', 'old': '오래된',\r\n      'young': '젊은', 'tall': '키 큰', 'short': '짧은', 'smart': '똑똑한',\r\n      'kind': '친절한', 'pretty': '예쁜', 'tired': '피곤한', 'strong': '강한',\r\n      'quiet': '조용한', 'brave': '용감한', 'funny': '재미있는',\r\n      'honest': '정직한', 'nice': '좋은', 'fast': '빠른', 'safe': '안전한',\r\n      'normal': '정상적인', 'special': '특별한', 'important': '중요한',\r\n      \r\n      // 직업\r\n      'student': '학생', 'teacher': '선생님', 'doctor': '의사',\r\n      'cook': '요리사', 'driver': '운전자', 'farmer': '농부',\r\n      'writer': '작가', 'singer': '가수', 'painter': '화가',\r\n      'actor': '배우', 'scientist': '과학자',\r\n      \r\n      // 명사\r\n      'friend': '친구', 'book': '책', 'pencil': '연필', 'computer': '컴퓨터',\r\n      'family': '가족', 'chair': '의자', 'team': '팀', 'ball': '공',\r\n      \r\n      // 동사\r\n      'eating': '먹는', 'studying': '공부하는', 'playing': '놀고 있는',\r\n      'working': '일하는', 'reading': '읽는', 'running': '뛰는',\r\n      \r\n      // 시간/장소\r\n      'now': '지금', 'today': '오늘', 'park': '공원', 'lunch': '점심'\r\n    };\r\n    \r\n    return translations[word.toLowerCase()] || word; // 번역이 없으면 원문 반환\r\n  }\r\n\r\n  /**\r\n   * 사용자의 학습 진도에 맞는 단어장 가져오기\r\n   */\r\n  async getVocabularyForUser(userLevel: number, userStage: number | 'ALL'): Promise<VocabularyWord[]> {\r\n    const allWords: VocabularyWord[] = [];\r\n    \r\n    // 사용자 레벨까지의 모든 단어 수집\r\n    for (let level = 1; level <= userLevel; level++) {\r\n      const levelWords = await this.extractVocabularyFromLevel(level);\r\n      allWords.push(...levelWords);\r\n    }\r\n    \r\n    // 중복 제거 (같은 단어가 여러 레벨에서 나올 수 있음)\r\n    const uniqueWords = new Map<string, VocabularyWord>();\r\n    for (const word of allWords) {\r\n      if (!uniqueWords.has(word.word) || uniqueWords.get(word.word)!.level > word.level) {\r\n        uniqueWords.set(word.word, word);\r\n      }\r\n    }\r\n    \r\n    return Array.from(uniqueWords.values()).sort((a, b) => b.frequency - a.frequency);\r\n  }\r\n\r\n  /**\r\n   * 단어 학습 통계 계산\r\n   */\r\n  calculateVocabularyStats(vocabularyWords: VocabularyWord[], userProgress: UserVocabularyProgress[]): VocabularyStats {\r\n    const progressMap = new Map<string, UserVocabularyProgress>();\r\n    userProgress.forEach(p => progressMap.set(p.wordId, p));\r\n    \r\n    let knownWords = 0;\r\n    let learningWords = 0;\r\n    let reviewWords = 0;\r\n    let newWords = 0;\r\n    \r\n    vocabularyWords.forEach(word => {\r\n      const progress = progressMap.get(word.id);\r\n      if (!progress) {\r\n        newWords++;\r\n      } else {\r\n        switch (progress.status) {\r\n          case 'known': knownWords++; break;\r\n          case 'learning': learningWords++; break;\r\n          case 'review': reviewWords++; break;\r\n          case 'unknown': newWords++; break;\r\n        }\r\n      }\r\n    });\r\n    \r\n    return {\r\n      totalWords: vocabularyWords.length,\r\n      knownWords,\r\n      learningWords,\r\n      reviewWords,\r\n      newWords,\r\n      completionRate: vocabularyWords.length > 0 ? Math.round((knownWords / vocabularyWords.length) * 100) : 0\r\n    };\r\n  }\r\n}\r\n\r\nexport const vocabularyService = new VocabularyService();\r\nexport default vocabularyService;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\webSpeechAPI.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\services\\writingMode.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'question' is defined but never used. Allowed unused args must match /^_/u.","line":220,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":220,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Writing 모드 - 키보드 입력, 문법/맞춤법 체크, 정확성 강화\r\n\r\nexport interface WritingFeedback {\r\n  isCorrect: boolean;\r\n  originalInput: string;\r\n  correctedText: string;\r\n  grammarErrors: GrammarError[];\r\n  spellingErrors: SpellingError[];\r\n  suggestions: WritingSuggestion[];\r\n  score: number; // 0-100\r\n  explanation: string;\r\n}\r\n\r\nexport interface GrammarError {\r\n  type: 'grammar' | 'punctuation' | 'structure' | 'tense' | 'article';\r\n  position: { start: number; end: number };\r\n  original: string;\r\n  corrected: string;\r\n  rule: string;\r\n  explanation: string;\r\n}\r\n\r\nexport interface SpellingError {\r\n  position: { start: number; end: number };\r\n  original: string;\r\n  suggestions: string[];\r\n  confidence: number;\r\n}\r\n\r\nexport interface WritingSuggestion {\r\n  type: 'alternative' | 'improvement' | 'style' | 'vocabulary';\r\n  original: string;\r\n  suggested: string;\r\n  reason: string;\r\n  priority: 'high' | 'medium' | 'low';\r\n}\r\n\r\nexport interface WritingSession {\r\n  sessionId: string;\r\n  userId: string;\r\n  questions: WritingQuestion[];\r\n  results: WritingResult[];\r\n  startTime: Date;\r\n  endTime?: Date;\r\n  totalScore: number;\r\n  accuracyRate: number;\r\n  commonMistakes: string[];\r\n}\r\n\r\nexport interface WritingQuestion {\r\n  id: string;\r\n  front_ko: string;\r\n  target_en: string;\r\n  level: number;\r\n  stage: number;\r\n  difficulty: 'easy' | 'medium' | 'hard';\r\n  grammarFocus: string[];\r\n  vocabularyFocus: string[];\r\n}\r\n\r\nexport interface WritingResult {\r\n  questionId: string;\r\n  userInput: string;\r\n  feedback: WritingFeedback;\r\n  timeSpent: number;\r\n  attemptsCount: number;\r\n  finalScore: number;\r\n}\r\n\r\nclass WritingModeService {\r\n  \r\n  /**\r\n   * 사용자 입력에 대한 상세 피드백 생성\r\n   */\r\n  async generateWritingFeedback(\r\n    userInput: string,\r\n    targetAnswer: string,\r\n    question: WritingQuestion\r\n  ): Promise<WritingFeedback> {\r\n    \r\n    try {\r\n      // 1. 기본 정확성 체크\r\n      const isCorrect = this.checkBasicCorrectness(userInput, targetAnswer);\r\n      \r\n      // 2. 문법 오류 검출\r\n      const grammarErrors = await this.detectGrammarErrors(userInput, targetAnswer);\r\n      \r\n      // 3. 맞춤법 오류 검출\r\n      const spellingErrors = await this.detectSpellingErrors(userInput);\r\n      \r\n      // 4. 개선 제안 생성\r\n      const suggestions = await this.generateSuggestions(userInput, targetAnswer, question);\r\n      \r\n      // 5. 점수 계산\r\n      const score = this.calculateWritingScore(userInput, targetAnswer, grammarErrors, spellingErrors);\r\n      \r\n      // 6. 상세 설명 생성\r\n      const explanation = this.generateExplanation(userInput, targetAnswer, grammarErrors, suggestions);\r\n      \r\n      return {\r\n        isCorrect,\r\n        originalInput: userInput,\r\n        correctedText: this.generateCorrectedText(userInput, grammarErrors, spellingErrors),\r\n        grammarErrors,\r\n        spellingErrors,\r\n        suggestions,\r\n        score,\r\n        explanation\r\n      };\r\n      \r\n    } catch (error) {\r\n      console.error('Writing 피드백 생성 실패:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * 문법 오류 검출 (룰 기반 + AI 보조)\r\n   */\r\n  private async detectGrammarErrors(userInput: string, _targetAnswer: string): Promise<GrammarError[]> {\r\n    const errors: GrammarError[] = [];\r\n    \r\n    // 기본적인 문법 룰 체크\r\n    const rules = [\r\n      // be동사 오류\r\n      {\r\n        pattern: /\\b(I|You|We|They)\\s+(is)\\b/gi,\r\n        type: 'grammar' as const,\r\n        rule: 'Subject-Verb Agreement',\r\n        fix: (match: string) => match.replace(/is/gi, 'are')\r\n      },\r\n      // 단수/복수 오류\r\n      {\r\n        pattern: /\\b(a|an)\\s+(\\w+s)\\b/gi,\r\n        type: 'grammar' as const,\r\n        rule: 'Article-Noun Agreement',\r\n        fix: (match: string) => match.replace(/s$/, '')\r\n      },\r\n      // 시제 오류 (간단한 예시)\r\n      {\r\n        pattern: /\\byesterday\\s+.*\\b(will|going\\s+to)\\b/gi,\r\n        type: 'tense' as const,\r\n        rule: 'Past Time + Future Tense Mismatch',\r\n        fix: (match: string) => match.replace(/(will|going\\s+to)/gi, 'went')\r\n      },\r\n      // 관사 오류\r\n      {\r\n        pattern: /\\b(a)\\s+([aeiou])/gi,\r\n        type: 'article' as const,\r\n        rule: 'Article Before Vowel',\r\n        fix: (match: string) => match.replace(/^a\\s+/, 'an ')\r\n      }\r\n    ];\r\n    \r\n    rules.forEach(rule => {\r\n      let match;\r\n      while ((match = rule.pattern.exec(userInput)) !== null) {\r\n        const start = match.index;\r\n        const end = start + match[0].length;\r\n        \r\n        errors.push({\r\n          type: rule.type,\r\n          position: { start, end },\r\n          original: match[0],\r\n          corrected: rule.fix(match[0]),\r\n          rule: rule.rule,\r\n          explanation: this.getGrammarExplanation(rule.rule)\r\n        });\r\n      }\r\n    });\r\n    \r\n    return errors;\r\n  }\r\n  \r\n  /**\r\n   * 맞춤법 오류 검출\r\n   */\r\n  private async detectSpellingErrors(userInput: string): Promise<SpellingError[]> {\r\n    const errors: SpellingError[] = [];\r\n    \r\n    // 간단한 맞춤법 사전 (실제로는 더 큰 사전 사용)\r\n    const commonMisspellings: Record<string, string[]> = {\r\n      'recieve': ['receive'],\r\n      'seperate': ['separate'],\r\n      'occurence': ['occurrence'],\r\n      'neccessary': ['necessary'],\r\n      'beleive': ['believe'],\r\n      'achive': ['achieve'],\r\n      'begining': ['beginning'],\r\n      'definately': ['definitely'],\r\n      'intresting': ['interesting'],\r\n      'exersise': ['exercise']\r\n    };\r\n    \r\n    const words = userInput.toLowerCase().match(/\\b\\w+\\b/g) || [];\r\n    \r\n    words.forEach((word, _index) => {\r\n      if (commonMisspellings[word]) {\r\n        const start = userInput.toLowerCase().indexOf(word);\r\n        const end = start + word.length;\r\n        \r\n        errors.push({\r\n          position: { start, end },\r\n          original: word,\r\n          suggestions: commonMisspellings[word],\r\n          confidence: 0.8\r\n        });\r\n      }\r\n    });\r\n    \r\n    return errors;\r\n  }\r\n  \r\n  /**\r\n   * 개선 제안 생성\r\n   */\r\n  private async generateSuggestions(\r\n    userInput: string,\r\n    targetAnswer: string,\r\n    question: WritingQuestion\r\n  ): Promise<WritingSuggestion[]> {\r\n    \r\n    const suggestions: WritingSuggestion[] = [];\r\n    \r\n    // 대안 표현 제안\r\n    if (userInput.toLowerCase() !== targetAnswer.toLowerCase()) {\r\n      suggestions.push({\r\n        type: 'alternative',\r\n        original: userInput,\r\n        suggested: targetAnswer,\r\n        reason: '더 자연스러운 영어 표현입니다',\r\n        priority: 'high'\r\n      });\r\n    }\r\n    \r\n    // 어휘 개선 제안\r\n    const basicToAdvanced: Record<string, string> = {\r\n      'good': 'excellent, outstanding, remarkable',\r\n      'bad': 'terrible, awful, disappointing',\r\n      'big': 'huge, enormous, massive',\r\n      'small': 'tiny, miniature, compact',\r\n      'very': 'extremely, incredibly, remarkably',\r\n      'get': 'obtain, acquire, receive',\r\n      'make': 'create, produce, generate',\r\n      'do': 'perform, execute, accomplish'\r\n    };\r\n    \r\n    Object.entries(basicToAdvanced).forEach(([basic, advanced]) => {\r\n      if (userInput.toLowerCase().includes(basic.toLowerCase())) {\r\n        suggestions.push({\r\n          type: 'vocabulary',\r\n          original: basic,\r\n          suggested: advanced,\r\n          reason: '더 고급 어휘를 사용해보세요',\r\n          priority: 'medium'\r\n        });\r\n      }\r\n    });\r\n    \r\n    return suggestions;\r\n  }\r\n  \r\n  /**\r\n   * Writing 점수 계산\r\n   */\r\n  private calculateWritingScore(\r\n    userInput: string,\r\n    targetAnswer: string,\r\n    grammarErrors: GrammarError[],\r\n    spellingErrors: SpellingError[]\r\n  ): number {\r\n    \r\n    let score = 100;\r\n    \r\n    // 문법 오류 감점\r\n    score -= grammarErrors.length * 15;\r\n    \r\n    // 맞춤법 오류 감점\r\n    score -= spellingErrors.length * 10;\r\n    \r\n    // 정확도 보너스/감점\r\n    const similarity = this.calculateSimilarity(userInput, targetAnswer);\r\n    if (similarity >= 0.9) score += 10;\r\n    else if (similarity < 0.5) score -= 20;\r\n    \r\n    // 길이 차이 감점\r\n    const lengthDiff = Math.abs(userInput.length - targetAnswer.length) / targetAnswer.length;\r\n    if (lengthDiff > 0.5) score -= 10;\r\n    \r\n    return Math.max(0, Math.min(100, Math.round(score)));\r\n  }\r\n  \r\n  /**\r\n   * 교정된 텍스트 생성\r\n   */\r\n  private generateCorrectedText(\r\n    userInput: string,\r\n    grammarErrors: GrammarError[],\r\n    spellingErrors: SpellingError[]\r\n  ): string {\r\n    \r\n    let corrected = userInput;\r\n    \r\n    // 문법 오류부터 수정 (뒤에서부터 수정하여 인덱스 변화 방지)\r\n    [...grammarErrors]\r\n      .sort((a, b) => b.position.start - a.position.start)\r\n      .forEach(error => {\r\n        corrected = corrected.substring(0, error.position.start) +\r\n                   error.corrected +\r\n                   corrected.substring(error.position.end);\r\n      });\r\n    \r\n    // 맞춤법 오류 수정\r\n    [...spellingErrors]\r\n      .sort((a, b) => b.position.start - a.position.start)\r\n      .forEach(error => {\r\n        if (error.suggestions.length > 0) {\r\n          corrected = corrected.substring(0, error.position.start) +\r\n                     error.suggestions[0] +\r\n                     corrected.substring(error.position.end);\r\n        }\r\n      });\r\n    \r\n    return corrected;\r\n  }\r\n  \r\n  /**\r\n   * 상세 설명 생성\r\n   */\r\n  private generateExplanation(\r\n    userInput: string,\r\n    targetAnswer: string,\r\n    grammarErrors: GrammarError[],\r\n    suggestions: WritingSuggestion[]\r\n  ): string {\r\n    \r\n    let explanation = '';\r\n    \r\n    if (grammarErrors.length > 0) {\r\n      explanation += '📝 **문법 개선점:**\\n';\r\n      grammarErrors.forEach((error, index) => {\r\n        explanation += `${index + 1}. ${error.rule}: \"${error.original}\" → \"${error.corrected}\"\\n   ${error.explanation}\\n\\n`;\r\n      });\r\n    }\r\n    \r\n    if (suggestions.length > 0) {\r\n      explanation += '💡 **개선 제안:**\\n';\r\n      suggestions.slice(0, 3).forEach((suggestion, index) => {\r\n        explanation += `${index + 1}. ${suggestion.reason}\\n   \"${suggestion.original}\" → \"${suggestion.suggested}\"\\n\\n`;\r\n      });\r\n    }\r\n    \r\n    if (userInput.trim().toLowerCase() === targetAnswer.trim().toLowerCase()) {\r\n      explanation += '✅ **완벽합니다!** 문법과 맞춤법이 모두 정확합니다.';\r\n    }\r\n    \r\n    return explanation || '좋은 시도입니다! 계속 연습하세요.';\r\n  }\r\n  \r\n  /**\r\n   * 헬퍼 메서드들\r\n   */\r\n  private checkBasicCorrectness(userInput: string, targetAnswer: string): boolean {\r\n    const normalize = (str: string) => str.toLowerCase().trim().replace(/[.,!?]/g, '');\r\n    return normalize(userInput) === normalize(targetAnswer);\r\n  }\r\n  \r\n  private calculateSimilarity(str1: string, str2: string): number {\r\n    const longer = str1.length > str2.length ? str1 : str2;\r\n    const shorter = str1.length > str2.length ? str2 : str1;\r\n    \r\n    if (longer.length === 0) return 1.0;\r\n    \r\n    const editDistance = this.levenshteinDistance(longer, shorter);\r\n    return (longer.length - editDistance) / longer.length;\r\n  }\r\n  \r\n  private levenshteinDistance(str1: string, str2: string): number {\r\n    const matrix = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));\r\n    \r\n    for (let i = 0; i <= str1.length; i++) matrix[0][i] = i;\r\n    for (let j = 0; j <= str2.length; j++) matrix[j][0] = j;\r\n    \r\n    for (let j = 1; j <= str2.length; j++) {\r\n      for (let i = 1; i <= str1.length; i++) {\r\n        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;\r\n        matrix[j][i] = Math.min(\r\n          matrix[j][i - 1] + 1,\r\n          matrix[j - 1][i] + 1,\r\n          matrix[j - 1][i - 1] + indicator\r\n        );\r\n      }\r\n    }\r\n    \r\n    return matrix[str2.length][str1.length];\r\n  }\r\n  \r\n  private getGrammarExplanation(rule: string): string {\r\n    const explanations: Record<string, string> = {\r\n      'Subject-Verb Agreement': '주어와 동사의 수가 일치해야 합니다. I/You/We/They는 are을 사용합니다.',\r\n      'Article-Noun Agreement': '부정관사 a/an 뒤에는 단수명사가 와야 합니다.',\r\n      'Past Time + Future Tense Mismatch': '과거 시간 표현과 함께 미래 시제를 사용할 수 없습니다.',\r\n      'Article Before Vowel': '모음으로 시작하는 단어 앞에는 \"an\"을 사용합니다.'\r\n    };\r\n    \r\n    return explanations[rule] || '문법 규칙을 확인해보세요.';\r\n  }\r\n  \r\n  /**\r\n   * 레벨별 맞춤 피드백 생성\r\n   */\r\n  async generateLevelSpecificFeedback(\r\n    feedback: WritingFeedback,\r\n    level: number\r\n  ): Promise<string> {\r\n    \r\n    if (level <= 2) {\r\n      return '기초 단계입니다. 맞춤법과 기본 문법에 집중하세요.';\r\n    } else if (level <= 4) {\r\n      return '중급 단계입니다. 문법 정확성과 자연스러운 표현을 연습하세요.';\r\n    } else {\r\n      return '고급 단계입니다. 다양한 표현과 고급 어휘 사용에 도전하세요.';\r\n    }\r\n  }\r\n}\r\n\r\nexport const writingModeService = new WritingModeService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\state\\AudioFlowStateMachine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'data' is defined but never used. Allowed unused args must match /^_/u.","line":148,"column":75,"nodeType":null,"messageId":"unusedVar","endLine":148,"endColumn":79}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * AudioFlowStateMachine - 메인 상태 머신\r\n * 목적: 오디오 플로우 상태를 체계적으로 관리하고 전환을 제어\r\n */\r\n\r\nimport { BaseFlowState } from './BaseFlowState';\r\nimport type { \r\n  FlowState, \r\n  FlowAction, \r\n  ActionResult, \r\n  StateDisplayInfo, \r\n  StateMachineContext, \r\n  FlowCallbacks,\r\n  StateTransition \r\n} from './types';\r\n\r\n// 구체 상태 클래스들 import (Phase 2에서 구현)\r\nimport { IdleState } from './states/IdleState';\r\nimport { TTSState } from './states/TTSState';\r\nimport { BeepState } from './states/BeepState';\r\nimport { RecordingState } from './states/RecordingState';\r\nimport { ProcessingState } from './states/ProcessingState';\r\nimport { TimeoutState } from './states/TimeoutState';\r\n\r\nexport class AudioFlowStateMachine {\r\n  private currentState: BaseFlowState;\r\n  private context: StateMachineContext;\r\n  private callbacks: FlowCallbacks;\r\n  private states: Map<FlowState, BaseFlowState>;\r\n  private transitionMap: Map<string, StateTransition[]>;\r\n\r\n  constructor(callbacks: FlowCallbacks, recordingDuration: number = 10) {\r\n    this.callbacks = callbacks;\r\n    this.context = {\r\n      remainingTime: 0,\r\n      isPaused: false,\r\n      recordingDuration,\r\n    };\r\n\r\n    // 상태 인스턴스들 초기화\r\n    this.states = new Map();\r\n    this.initializeStates();\r\n    \r\n    // 상태 전환 규칙 초기화\r\n    this.transitionMap = new Map();\r\n    this.initializeTransitions();\r\n\r\n    // 초기 상태 설정\r\n    this.currentState = this.states.get('idle')!;\r\n  }\r\n\r\n  private initializeStates(): void {\r\n    const stateClasses = [\r\n      IdleState,\r\n      TTSState,\r\n      BeepState,\r\n      RecordingState,\r\n      ProcessingState,\r\n      TimeoutState,\r\n    ];\r\n\r\n    stateClasses.forEach(StateClass => {\r\n      const stateInstance = new StateClass(this.context, this.callbacks);\r\n      this.states.set(stateInstance.getStateName(), stateInstance);\r\n    });\r\n  }\r\n\r\n  private initializeTransitions(): void {\r\n    const transitions: StateTransition[] = [\r\n      // 정상 플로우\r\n      { from: 'idle', to: 'tts', action: 'start' },\r\n      { from: 'tts', to: 'beep', action: 'complete' },\r\n      { from: 'beep', to: 'recording', action: 'complete' },\r\n      { from: 'recording', to: 'processing', action: 'complete' },\r\n      { from: 'processing', to: 'idle', action: 'complete' },\r\n      \r\n      // 타임아웃 플로우\r\n      { from: 'recording', to: 'timeout', action: 'timeout' },\r\n      { from: 'timeout', to: 'idle', action: 'complete' },\r\n      \r\n      // 중지 플로우\r\n      { from: 'tts', to: 'idle', action: 'stop' },\r\n      { from: 'beep', to: 'idle', action: 'stop' },\r\n      { from: 'recording', to: 'idle', action: 'stop' },\r\n      { from: 'timeout', to: 'idle', action: 'stop' },\r\n    ];\r\n\r\n    transitions.forEach(transition => {\r\n      const key = `${transition.from}-${transition.action}`;\r\n      const existing = this.transitionMap.get(key) || [];\r\n      existing.push(transition);\r\n      this.transitionMap.set(key, existing);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * 현재 상태 반환\r\n   */\r\n  public getCurrentState(): FlowState {\r\n    return this.currentState.getStateName();\r\n  }\r\n\r\n  /**\r\n   * 컨텍스트 정보 반환\r\n   */\r\n  public getContext(): StateMachineContext {\r\n    return { ...this.context };\r\n  }\r\n\r\n  /**\r\n   * 상태 표시 정보 반환\r\n   */\r\n  public getDisplayInfo(): StateDisplayInfo {\r\n    return this.currentState.getDisplayInfo();\r\n  }\r\n\r\n  /**\r\n   * 허용된 액션 목록 반환\r\n   */\r\n  public getAllowedActions(): FlowAction[] {\r\n    return this.currentState.getAllowedActions();\r\n  }\r\n\r\n  /**\r\n   * 액션 실행\r\n   */\r\n  public async executeAction(action: FlowAction, data?: any): Promise<ActionResult> {\r\n    console.log(`[StateMachine] Executing action '${action}' in state '${this.getCurrentState()}'`);\r\n    \r\n    try {\r\n      const result = this.currentState.handleAction(action);\r\n      \r\n      if (result.success && result.newState && result.newState !== this.getCurrentState()) {\r\n        await this.transitionTo(result.newState, action, data);\r\n      }\r\n      \r\n      return result;\r\n    } catch (error) {\r\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\r\n      this.callbacks.onError(`Action execution failed: ${errorMessage}`);\r\n      return { success: false, error: errorMessage };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 직접 상태 전환 (내부용)\r\n   */\r\n  public async transitionTo(newStateName: FlowState, action?: FlowAction, data?: any): Promise<void> {\r\n    const currentStateName = this.getCurrentState();\r\n    \r\n    console.log(`[StateMachine] Transitioning: ${currentStateName} → ${newStateName}`);\r\n    \r\n    // 전환 가능성 검증\r\n    if (action && !this.isTransitionAllowed(currentStateName, newStateName, action)) {\r\n      throw new Error(\r\n        `Transition from '${currentStateName}' to '${newStateName}' with action '${action}' is not allowed`\r\n      );\r\n    }\r\n\r\n    const newState = this.states.get(newStateName);\r\n    if (!newState) {\r\n      throw new Error(`State '${newStateName}' not found`);\r\n    }\r\n\r\n    // 현재 상태 종료\r\n    await this.currentState.exit();\r\n    \r\n    // 새 상태로 전환\r\n    this.currentState = newState;\r\n    \r\n    // 새 상태 진입\r\n    await this.currentState.enter();\r\n    \r\n    console.log(`[StateMachine] Transition completed: ${newStateName}`);\r\n  }\r\n\r\n  /**\r\n   * 전환 가능성 검증\r\n   */\r\n  private isTransitionAllowed(from: FlowState, to: FlowState, action: FlowAction): boolean {\r\n    const key = `${from}-${action}`;\r\n    const transitions = this.transitionMap.get(key) || [];\r\n    \r\n    return transitions.some(transition => \r\n      transition.to === to && \r\n      (!transition.condition || transition.condition())\r\n    );\r\n  }\r\n\r\n  /**\r\n   * 플로우 시작 (외부 인터페이스)\r\n   */\r\n  public async startFlow(text: string): Promise<ActionResult> {\r\n    this.context.currentText = text;\r\n    return this.executeAction('start');\r\n  }\r\n\r\n  /**\r\n   * 일시정지\r\n   */\r\n  public pauseFlow(): ActionResult {\r\n    if (this.context.isPaused) {\r\n      return { success: false, error: 'Already paused' };\r\n    }\r\n    \r\n    const result = this.currentState.handleAction('pause');\r\n    if (result.success) {\r\n      this.context.isPaused = true;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 재개\r\n   */\r\n  public resumeFlow(): ActionResult {\r\n    if (!this.context.isPaused) {\r\n      return { success: false, error: 'Not paused' };\r\n    }\r\n    \r\n    const result = this.currentState.handleAction('resume');\r\n    if (result.success) {\r\n      this.context.isPaused = false;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 중지\r\n   */\r\n  public stopFlow(): ActionResult {\r\n    const result = this.currentState.handleAction('stop');\r\n    if (result.success) {\r\n      this.context.isPaused = false;\r\n      this.context.remainingTime = 0;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * 정답 재생\r\n   */\r\n  public async playAnswerAndNext(answerText?: string): Promise<ActionResult> {\r\n    this.context.answerText = answerText;\r\n    return this.executeAction('complete');\r\n  }\r\n\r\n  /**\r\n   * 컨텍스트 업데이트\r\n   */\r\n  public updateContext(updates: Partial<StateMachineContext>): void {\r\n    this.context = { ...this.context, ...updates };\r\n  }\r\n\r\n  /**\r\n   * 정리\r\n   */\r\n  public async cleanup(): Promise<void> {\r\n    console.log('[StateMachine] Cleaning up...');\r\n    \r\n    try {\r\n      await this.currentState.exit();\r\n    } catch (error) {\r\n      console.warn('[StateMachine] Error during cleanup:', error);\r\n    }\r\n    \r\n    // 모든 상태 정리\r\n    this.states.clear();\r\n    this.transitionMap.clear();\r\n  }\r\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\state\\BaseFlowState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\state\\states\\BeepState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\state\\states\\IdleState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\state\\states\\ProcessingState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\state\\states\\RecordingState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\state\\states\\TTSState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\state\\states\\TimeoutState.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\state\\types.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\store\\useAppStore.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":138,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":138,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":145,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":145,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":175,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":175,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":265,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":265,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\r\nimport { persist } from 'zustand/middleware';\r\nimport type { AppSettings, StudyState, DrillCard, StudySession, FeedbackResponse } from '@/types';\r\n\r\nexport type LearningMode = 'writing' | 'speaking';\r\n\r\nexport type ThemeMode = 'default' | 'personal';\r\n\r\nexport interface PersonalTheme {\r\n  primary: string;    // #4A90E2 (차분한 블루)\r\n  secondary: string;  // #7B68EE (미디엄 퍼플)\r\n  accent: string;     // #FF8A80 (따뜻한 코랄)\r\n  base: string;       // #F5F7FA (부드러운 화이트)\r\n}\r\n\r\ninterface AppStore {\r\n  // Settings\r\n  settings: AppSettings;\r\n  updateSettings: (settings: Partial<AppSettings>) => void;\r\n\r\n  // Global Learning Mode\r\n  learningMode: LearningMode;\r\n  setLearningMode: (mode: LearningMode) => void;\r\n  \r\n  // Speaking Stage (1단계 3초, 2단계 2초, 3단계 1초)\r\n  speakingStage: 1 | 2 | 3;\r\n  setSpeakingStage: (stage: 1 | 2 | 3) => void;\r\n  \r\n  // Stage Progress for 3-step system\r\n  stageProgress: Record<string, boolean[]>; // key: \"level-stage\" => [1단계완료, 2단계완료, 3단계완료]\r\n  updateStageProgress: (level: number, stage: number, speakingStage: 1 | 2 | 3, completed: boolean) => void;\r\n  getStageProgress: (level: number, stage: number) => boolean[];\r\n\r\n  // Theme System\r\n  themeMode: ThemeMode;\r\n  personalTheme: PersonalTheme;\r\n  setThemeMode: (mode: ThemeMode) => void;\r\n  setPersonalTheme: (theme: Partial<PersonalTheme>) => void;\r\n\r\n  // User state\r\n  user: {\r\n    id: string | null;\r\n    level: number;\r\n    stage: number | 'ALL';\r\n    isAuthenticated: boolean;\r\n  };\r\n  setUser: (user: Partial<AppStore['user']>) => void;\r\n  setUserLevel: (level: number) => void;\r\n  setUserStage: (stage: number | 'ALL') => void;\r\n\r\n  // Stage selection state\r\n  stageSelection: {\r\n    selectedLevel: number | null;\r\n    isStageModalOpen: boolean;\r\n  };\r\n  setSelectedLevel: (level: number | null) => void;\r\n  setStageModalOpen: (isOpen: boolean) => void;\r\n  selectLevelAndStage: (level: number, stage: number | 'ALL') => void;\r\n\r\n  // Study session state\r\n  study: StudyState;\r\n  setCurrentSession: (session: StudySession | null) => void;\r\n  setCurrentCard: (card: DrillCard | null, index: number) => void;\r\n  setCards: (cards: DrillCard[]) => void;\r\n  setRecording: (isRecording: boolean) => void;\r\n  setProcessing: (isProcessing: boolean) => void;\r\n  setFeedback: (feedback: FeedbackResponse | null) => void;\r\n  resetStudyState: () => void;\r\n\r\n  // UI state\r\n  ui: {\r\n    isLoading: boolean;\r\n    error: string | null;\r\n    notification: string | null;\r\n  };\r\n  setLoading: (isLoading: boolean) => void;\r\n  setError: (error: string | null) => void;\r\n  setNotification: (notification: string | null) => void;\r\n  clearError: () => void;\r\n  clearNotification: () => void;\r\n}\r\n\r\nconst initialSettings: AppSettings = {\r\n  language: 'ko',\r\n  sttEngine: 'browser',\r\n  ttsEnabled: true,\r\n  volume: 1.0,\r\n};\r\n\r\nconst initialStudyState: StudyState = {\r\n  currentSession: null,\r\n  currentCard: null,\r\n  currentIndex: 0,\r\n  cards: [],\r\n  isRecording: false,\r\n  isProcessing: false,\r\n  feedback: null,\r\n};\r\n\r\nconst initialUserState = {\r\n  id: null,\r\n  level: 1,\r\n  stage: 1,\r\n  isAuthenticated: false,\r\n};\r\n\r\nconst initialStageSelectionState = {\r\n  selectedLevel: null,\r\n  isStageModalOpen: false,\r\n};\r\n\r\nconst initialUIState = {\r\n  isLoading: false,\r\n  error: null,\r\n  notification: null,\r\n};\r\n\r\nconst initialPersonalTheme: PersonalTheme = {\r\n  primary: '#6b7280',    // 회색 (기본 테마와 동일)\r\n  secondary: '#ffffff',  // 흰색 (기본 테마와 동일)\r\n  accent: '#4b5563',     // 어두운 회색 (기본 테마와 동일)\r\n  base: '#f9fafb',       // 연한 회색 배경 (기본 테마와 동일)\r\n};\r\n\r\nexport const useAppStore = create<AppStore>()(\r\n  persist(\r\n    (set, get) => ({\r\n      // Settings\r\n      settings: initialSettings,\r\n      updateSettings: (newSettings) =>\r\n        set((state) => ({\r\n          settings: { ...state.settings, ...newSettings },\r\n        })),\r\n\r\n      // Global Learning Mode\r\n      learningMode: 'speaking', // 기본값은 기존 방식(speaking)\r\n      setLearningMode: (mode) =>\r\n        set((state) => ({\r\n          learningMode: mode,\r\n        })),\r\n      \r\n      // Speaking Stage\r\n      speakingStage: 1, // 기본값: 1단계 (3초)\r\n      setSpeakingStage: (stage) =>\r\n        set((state) => ({\r\n          speakingStage: stage,\r\n        })),\r\n      \r\n      // Stage Progress\r\n      stageProgress: {},\r\n      updateStageProgress: (level, stage, speakingStage, completed) =>\r\n        set((state) => {\r\n          const key = `${level}-${stage}`;\r\n          const currentProgress = state.stageProgress[key] || [false, false, false];\r\n          const newProgress = [...currentProgress];\r\n          newProgress[speakingStage - 1] = completed; // 0-based index\r\n          \r\n          return {\r\n            stageProgress: {\r\n              ...state.stageProgress,\r\n              [key]: newProgress\r\n            }\r\n          };\r\n        }),\r\n      getStageProgress: (level, stage) => {\r\n        const state = get();\r\n        const key = `${level}-${stage}`;\r\n        return state.stageProgress[key] || [false, false, false];\r\n      },\r\n\r\n      // Theme System\r\n      themeMode: 'default', // 기본값: 깔끔한 테마\r\n      personalTheme: initialPersonalTheme,\r\n      setThemeMode: (mode) =>\r\n        set((state) => ({\r\n          themeMode: mode,\r\n        })),\r\n      setPersonalTheme: (theme) =>\r\n        set((state) => ({\r\n          personalTheme: { ...state.personalTheme, ...theme },\r\n        })),\r\n\r\n      // User\r\n      user: initialUserState,\r\n      setUser: (userData) =>\r\n        set((state) => ({\r\n          user: { ...state.user, ...userData },\r\n        })),\r\n      \r\n      setUserLevel: (level) =>\r\n        set((state) => ({\r\n          user: { ...state.user, level },\r\n        })),\r\n      \r\n      setUserStage: (stage) =>\r\n        set((state) => ({\r\n          user: { ...state.user, stage },\r\n        })),\r\n\r\n      // Stage selection\r\n      stageSelection: initialStageSelectionState,\r\n      \r\n      setSelectedLevel: (level) =>\r\n        set((state) => ({\r\n          stageSelection: { ...state.stageSelection, selectedLevel: level },\r\n        })),\r\n\r\n      setStageModalOpen: (isOpen) =>\r\n        set((state) => ({\r\n          stageSelection: { ...state.stageSelection, isStageModalOpen: isOpen },\r\n        })),\r\n\r\n      selectLevelAndStage: (level, stage) =>\r\n        set((state) => ({\r\n          user: { \r\n            ...state.user, \r\n            level, \r\n            stage \r\n          },\r\n          stageSelection: { \r\n            selectedLevel: null, \r\n            isStageModalOpen: false \r\n          },\r\n        })),\r\n\r\n      // Study session\r\n      study: initialStudyState,\r\n      \r\n      setCurrentSession: (session) =>\r\n        set((state) => ({\r\n          study: { ...state.study, currentSession: session },\r\n        })),\r\n\r\n      setCurrentCard: (card, index) =>\r\n        set((state) => ({\r\n          study: { \r\n            ...state.study, \r\n            currentCard: card, \r\n            currentIndex: index,\r\n            feedback: null, // Clear previous feedback\r\n          },\r\n        })),\r\n\r\n      setCards: (cards) =>\r\n        set((state) => ({\r\n          study: { ...state.study, cards },\r\n        })),\r\n\r\n      setRecording: (isRecording) =>\r\n        set((state) => ({\r\n          study: { ...state.study, isRecording },\r\n        })),\r\n\r\n      setProcessing: (isProcessing) =>\r\n        set((state) => ({\r\n          study: { ...state.study, isProcessing },\r\n        })),\r\n\r\n      setFeedback: (feedback) =>\r\n        set((state) => ({\r\n          study: { ...state.study, feedback },\r\n        })),\r\n\r\n      resetStudyState: () =>\r\n        set((state) => ({\r\n          study: initialStudyState,\r\n        })),\r\n\r\n      // UI state\r\n      ui: initialUIState,\r\n\r\n      setLoading: (isLoading) =>\r\n        set((state) => ({\r\n          ui: { ...state.ui, isLoading },\r\n        })),\r\n\r\n      setError: (error) =>\r\n        set((state) => ({\r\n          ui: { ...state.ui, error },\r\n        })),\r\n\r\n      setNotification: (notification) =>\r\n        set((state) => ({\r\n          ui: { ...state.ui, notification },\r\n        })),\r\n\r\n      clearError: () =>\r\n        set((state) => ({\r\n          ui: { ...state.ui, error: null },\r\n        })),\r\n\r\n      clearNotification: () =>\r\n        set((state) => ({\r\n          ui: { ...state.ui, notification: null },\r\n        })),\r\n    }),\r\n    {\r\n      name: 'dasi-english-store',\r\n      // Only persist settings, user data, learning mode, and stage progress\r\n      partialize: (state) => ({\r\n        settings: state.settings,\r\n        user: state.user,\r\n        learningMode: state.learningMode,\r\n        speakingStage: state.speakingStage,\r\n        stageProgress: state.stageProgress,\r\n      }),\r\n    }\r\n  )\r\n);\r\n\r\n// Selectors for easier access\r\nexport const useSettings = () => useAppStore((state) => state.settings);\r\nexport const useUser = () => useAppStore((state) => state.user);\r\nexport const useStudy = () => useAppStore((state) => ({\r\n  ...state.study,\r\n  cards: state.study.cards || [],\r\n}));\r\nexport const useUI = () => useAppStore((state) => state.ui);\r\nexport const useLearningMode = () => useAppStore((state) => ({\r\n  mode: state.learningMode,\r\n  setLearningMode: state.setLearningMode,\r\n}));\r\n\r\nexport const useSpeakingStage = () => useAppStore((state) => ({\r\n  stage: state.speakingStage,\r\n  setSpeakingStage: state.setSpeakingStage,\r\n}));\r\n\r\nexport const useStageSelection = () => useAppStore((state) => ({\r\n  stageSelection: state.stageSelection,\r\n  setSelectedLevel: state.setSelectedLevel,\r\n  setStageModalOpen: state.setStageModalOpen,\r\n  selectLevelAndStage: state.selectLevelAndStage,\r\n}));\r\n\r\nexport const useTheme = () => useAppStore((state) => ({\r\n  themeMode: state.themeMode,\r\n  personalTheme: state.personalTheme,\r\n  setThemeMode: state.setThemeMode,\r\n  setPersonalTheme: state.setPersonalTheme,\r\n}));\r\n\r\nexport const useStageProgress = () => useAppStore((state) => ({\r\n  stageProgress: state.stageProgress,\r\n  updateStageProgress: state.updateStageProgress,\r\n  getStageProgress: state.getStageProgress,\r\n}));","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\types\\core.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\types\\global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\types\\interview.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\types\\pattern-training.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\types\\services.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\utils\\answerNormalization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\utils\\errorHandling.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\utils\\index.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":40,"column":44,"nodeType":null,"messageId":"unusedVar","endLine":40,"endColumn":51}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @fileoverview 유틸리티 모듈의 중앙 집중식 익스포트\n * @description 기본 유틸리티 함수들\n * @author DaSiStart Team\n * @version 1.0.0\n */\n\n// 로그 카테고리 타입\nexport type LogCategory = 'PERFORMANCE' | 'API' | 'AUDIO' | 'SRS' | 'PLUGIN' | 'GENERAL';\n\n// 개별 로깅 함수들 (플러그인 시스템에서 사용)\nexport const logInfo = (message: string, category?: LogCategory) =>\n  console.log(`[INFO]${category ? `[${category}]` : ''} ${message}`);\n\nexport const logWarn = (message: string, category?: LogCategory) =>\n  console.warn(`[WARN]${category ? `[${category}]` : ''} ${message}`);\n\nexport const logError = (message: string, category?: LogCategory) =>\n  console.error(`[ERROR]${category ? `[${category}]` : ''} ${message}`);\n\nexport const logDebug = (message: string, category?: LogCategory) =>\n  console.debug(`[DEBUG]${category ? `[${category}]` : ''} ${message}`);\n\n// 기본 로깅 함수 (레거시 호환성)\nexport const logger = {\n  info: logInfo,\n  warn: logWarn,\n  error: logError,\n  debug: logDebug\n};\n\n// 기본 에러 핸들러\nexport const errorHandler = {\n  handle: (error: any, context?: string) => {\n    console.error(`Error${context ? ` in ${context}` : ''}:`, error);\n  }\n};\n\n// API 에러 핸들링 함수\nexport const handleApiError = (error: any, context?: any) => {\n  const errorMessage = error?.response?.data?.message || error?.message || 'API Error';\n  logger.error(`API Error: ${errorMessage}`, 'API');\n  return {\n    success: false,\n    error: errorMessage,\n    timestamp: Date.now()\n  };\n};\n\n// 기본 성능 모니터\nexport const performanceMonitor = {\n  start: (label: string) => console.time(label),\n  end: (label: string) => console.timeEnd(label),\n  mark: (label: string) => logger.debug(`Performance mark: ${label}`)\n};\n\n// 로그 카테고리 상수\nexport const LogCategory = {\n  AUDIO: 'AUDIO',\n  API: 'API',\n  PERFORMANCE: 'PERFORMANCE',\n  USER_INTERACTION: 'USER_INTERACTION',\n  ERROR: 'ERROR'\n} as const;\n\n// 에러 타입 상수\nexport const ErrorType = {\n  API_CONNECTION: 'API_CONNECTION',\n  API_TIMEOUT: 'API_TIMEOUT',\n  API_UNAUTHORIZED: 'API_UNAUTHORIZED',\n  SPEECH_PERMISSION_DENIED: 'SPEECH_PERMISSION_DENIED',\n  SPEECH_NOT_SUPPORTED: 'SPEECH_NOT_SUPPORTED',\n  BROWSER_NOT_SUPPORTED: 'BROWSER_NOT_SUPPORTED'\n} as const;\n\n// DaSi 모니터링 클래스 (간소화)\nexport class DaSiStartMonitoring {\n  private static instance: DaSiStartMonitoring | null = null;\n  private isInitialized = false;\n\n  private constructor() {\n    this.setupSystemInfo();\n    this.startPerformanceMonitoring();\n  }\n\n  static getInstance(): DaSiStartMonitoring {\n    if (!DaSiStartMonitoring.instance) {\n      DaSiStartMonitoring.instance = new DaSiStartMonitoring();\n    }\n    return DaSiStartMonitoring.instance;\n  }\n\n  private setupSystemInfo(): void {\n    try {\n      logger.info('DaSi monitoring system initialized', LogCategory.PERFORMANCE);\n      this.isInitialized = true;\n    } catch (error) {\n      console.error('Failed to setup system info:', error);\n    }\n  }\n\n  private startPerformanceMonitoring(): void {\n    try {\n      performanceMonitor.start('DaSi-Session');\n      logger.info('Performance monitoring started', LogCategory.PERFORMANCE);\n    } catch (error) {\n      console.error('Failed to start performance monitoring:', error);\n    }\n  }\n\n  public logUserAction(action: string, details?: any): void {\n    logger.info(`User action: ${action}`, LogCategory.USER_INTERACTION);\n    if (details) {\n      logger.debug(`Action details: ${JSON.stringify(details)}`, LogCategory.USER_INTERACTION);\n    }\n  }\n\n  public reportError(error: any, context?: string): void {\n    errorHandler.handle(error, context);\n    logger.error(`Error reported: ${error.message || error}`, LogCategory.ERROR);\n  }\n}\n\n// 자동 초기화\nsetTimeout(() => {\n  try {\n    DaSiStartMonitoring.getInstance();\n  } catch (error) {\n    console.warn('DaSi monitoring initialization failed:', error);\n  }\n}, 100);\n\n// 기본 익스포트\nexport default {\n  logger,\n  errorHandler,\n  performanceMonitor,\n  LogCategory,\n  ErrorType,\n  DaSiStartMonitoring\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\utils\\loggingUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\utils\\performanceUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\utils\\speakingStageUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\utils\\speechUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\utils\\stageFocusDefaults.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\kimdaesoo\\source\\claude\\DaSi_eng\\web_app\\src\\utils\\urlParams.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
